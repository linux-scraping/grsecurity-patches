diff -urNp linux-2.4.37.7/arch/alpha/config.in linux-2.4.37.7/arch/alpha/config.in
--- linux-2.4.37.7/arch/alpha/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/alpha/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -468,3 +468,12 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
+
diff -urNp linux-2.4.37.7/arch/alpha/kernel/osf_sys.c linux-2.4.37.7/arch/alpha/kernel/osf_sys.c
--- linux-2.4.37.7/arch/alpha/kernel/osf_sys.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/alpha/kernel/osf_sys.c	2009-11-10 19:30:27.000000000 -0500
@@ -1357,6 +1357,10 @@ arch_get_unmapped_area(struct file *filp
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != -ENOMEM)
@@ -1364,8 +1368,15 @@ arch_get_unmapped_area(struct file *filp
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+
+	addr = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		addr += current->mm->delta_mmap;
+#endif
+
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 	if (addr != -ENOMEM)
 		return addr;
 
diff -urNp linux-2.4.37.7/arch/alpha/kernel/ptrace.c linux-2.4.37.7/arch/alpha/kernel/ptrace.c
--- linux-2.4.37.7/arch/alpha/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/alpha/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -13,6 +13,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/slab.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -275,6 +276,10 @@ sys_ptrace(long request, long pid, long 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out_notsk;
+
+	if(gr_handle_ptrace(child, request))
+		goto out;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out;
diff -urNp linux-2.4.37.7/arch/alpha/kernel/setup.c linux-2.4.37.7/arch/alpha/kernel/setup.c
--- linux-2.4.37.7/arch/alpha/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/alpha/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -1208,7 +1208,7 @@ c_stop(struct seq_file *f, void *v)
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/alpha/mm/fault.c linux-2.4.37.7/arch/alpha/mm/fault.c
--- linux-2.4.37.7/arch/alpha/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/alpha/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -53,6 +53,123 @@ __load_new_mm_context(struct mm_struct *
 	__reload_thread(&current->thread);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long*)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -133,8 +250,29 @@ do_page_fault(unsigned long address, uns
 good_area:
 	info.si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)rdusp());
+			do_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -urNp linux-2.4.37.7/arch/arm/config.in linux-2.4.37.7/arch/arm/config.in
--- linux-2.4.37.7/arch/arm/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/arm/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -736,3 +736,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/arm/kernel/setup.c linux-2.4.37.7/arch/arm/kernel/setup.c
--- linux-2.4.37.7/arch/arm/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/arm/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -611,7 +611,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start	= c_start,
 	.next	= c_next,
 	.stop	= c_stop,
diff -urNp linux-2.4.37.7/arch/cris/config.in linux-2.4.37.7/arch/cris/config.in
--- linux-2.4.37.7/arch/cris/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -276,3 +276,12 @@ int 'Kernel messages buffer length shift
 source crypto/Config.in
 source lib/Config.in
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urNp linux-2.4.37.7/arch/cris/drivers/ds1302.c linux-2.4.37.7/arch/cris/drivers/ds1302.c
--- linux-2.4.37.7/arch/cris/drivers/ds1302.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/ds1302.c	2009-11-10 19:30:27.000000000 -0500
@@ -473,7 +473,7 @@ print_rtc_status(void) 
 
 /* The various file operations we support. */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
         owner:          THIS_MODULE,
         ioctl:          rtc_ioctl,	
 }; 
diff -urNp linux-2.4.37.7/arch/cris/drivers/examples/kiobuftest.c linux-2.4.37.7/arch/cris/drivers/examples/kiobuftest.c
--- linux-2.4.37.7/arch/cris/drivers/examples/kiobuftest.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/examples/kiobuftest.c	2009-11-10 19:30:27.000000000 -0500
@@ -78,7 +78,7 @@ kiobuf_read(struct file *filp, char *buf
 }
 
 
-static struct file_operations kiobuf_fops = {
+static const struct file_operations kiobuf_fops = {
 	owner:    THIS_MODULE,
 	read:     kiobuf_read
 };
diff -urNp linux-2.4.37.7/arch/cris/drivers/gpio.c linux-2.4.37.7/arch/cris/drivers/gpio.c
--- linux-2.4.37.7/arch/cris/drivers/gpio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/gpio.c	2009-11-10 19:30:27.000000000 -0500
@@ -779,7 +779,7 @@ gpio_leds_ioctl(unsigned int cmd, unsign
 	return 0;
 }
 
-struct file_operations gpio_fops = {
+const struct file_operations gpio_fops = {
 	owner:       THIS_MODULE,
 	poll:        gpio_poll,
 	ioctl:       gpio_ioctl,
diff -urNp linux-2.4.37.7/arch/cris/drivers/i2c.c linux-2.4.37.7/arch/cris/drivers/i2c.c
--- linux-2.4.37.7/arch/cris/drivers/i2c.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/i2c.c	2009-11-10 19:30:27.000000000 -0500
@@ -681,7 +681,7 @@ i2c_ioctl(struct inode *inode, struct fi
 	return 0;
 }
 
-static struct file_operations i2c_fops = {
+static const struct file_operations i2c_fops = {
 	owner:    THIS_MODULE,
 	ioctl:    i2c_ioctl,
 	open:     i2c_open,
diff -urNp linux-2.4.37.7/arch/cris/drivers/pcf8563.c linux-2.4.37.7/arch/cris/drivers/pcf8563.c
--- linux-2.4.37.7/arch/cris/drivers/pcf8563.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/pcf8563.c	2009-11-10 19:30:27.000000000 -0500
@@ -51,7 +51,7 @@ int pcf8563_ioctl(struct inode *, struct
 int pcf8563_open(struct inode *, struct file *);
 int pcf8563_release(struct inode *, struct file *);
 
-static struct file_operations pcf8563_fops = {
+static const struct file_operations pcf8563_fops = {
 	owner: THIS_MODULE,
 	ioctl: pcf8563_ioctl,
 	open: pcf8563_open,
diff -urNp linux-2.4.37.7/arch/cris/drivers/sync_serial.c linux-2.4.37.7/arch/cris/drivers/sync_serial.c
--- linux-2.4.37.7/arch/cris/drivers/sync_serial.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/sync_serial.c	2009-11-10 19:30:27.000000000 -0500
@@ -214,7 +214,7 @@ static unsigned gen_config_ii_shadow = 0
 
 #define NUMBER_OF_PORTS (sizeof(ports)/sizeof(sync_port))
 
-static struct file_operations sync_serial_fops = {
+static const struct file_operations sync_serial_fops = {
 	.owner   = THIS_MODULE,
 	.write   = sync_serial_write,
 	.read    = sync_serial_read,
diff -urNp linux-2.4.37.7/arch/cris/drivers/virtex.c linux-2.4.37.7/arch/cris/drivers/virtex.c
--- linux-2.4.37.7/arch/cris/drivers/virtex.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/drivers/virtex.c	2009-11-10 19:30:27.000000000 -0500
@@ -372,7 +372,7 @@ virtex_ioctl(struct inode *inode, struct
 return 0;
 }
 
-static struct file_operations virtex_fops = {
+static const struct file_operations virtex_fops = {
 	owner:    THIS_MODULE,
 	ioctl:    virtex_ioctl,
 	open:     virtex_open,
diff -urNp linux-2.4.37.7/arch/cris/kernel/setup.c linux-2.4.37.7/arch/cris/kernel/setup.c
--- linux-2.4.37.7/arch/cris/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/cris/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -283,7 +283,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:  c_start,
 	next:   c_next,
 	stop:   c_stop,
diff -urNp linux-2.4.37.7/arch/i386/boot/bootsect.S linux-2.4.37.7/arch/i386/boot/bootsect.S
--- linux-2.4.37.7/arch/i386/boot/bootsect.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/boot/bootsect.S	2009-11-10 19:30:27.000000000 -0500
@@ -237,7 +237,7 @@ rp_read:
 #ifdef __BIG_KERNEL__
 					# look in setup.S for bootsect_kludge
 	bootsect_kludge = 0x220		# 0x200 + 0x20 which is the size of the
-	lcall	bootsect_kludge		# bootsector + bootsect_kludge offset
+	lcall	*bootsect_kludge	# bootsector + bootsect_kludge offset
 #else
 	movw	%es, %ax
 	subw	$SYSSEG, %ax
diff -urNp linux-2.4.37.7/arch/i386/boot/compressed/head.S linux-2.4.37.7/arch/i386/boot/compressed/head.S
--- linux-2.4.37.7/arch/i386/boot/compressed/head.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/boot/compressed/head.S	2009-11-10 19:30:27.000000000 -0500
@@ -38,11 +38,13 @@ startup_32:
 	movl %eax,%gs
 
 	lss SYMBOL_NAME(stack_start),%esp
+	movl 0x000000,%ecx
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000	# loop forever if it isn't
 	cmpl %eax,0x100000
 	je 1b
+	movl %ecx,0x000000
 
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
diff -urNp linux-2.4.37.7/arch/i386/boot/setup.S linux-2.4.37.7/arch/i386/boot/setup.S
--- linux-2.4.37.7/arch/i386/boot/setup.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/boot/setup.S	2009-11-10 19:30:27.000000000 -0500
@@ -637,7 +637,7 @@ edd_done:
 	cmpw	$0, %cs:realmode_swtch
 	jz	rmodeswtch_normal
 
-	lcall	%cs:realmode_swtch
+	lcall	*%cs:realmode_swtch
 
 	jmp	rmodeswtch_end
 
diff -urNp linux-2.4.37.7/arch/i386/config.in linux-2.4.37.7/arch/i386/config.in
--- linux-2.4.37.7/arch/i386/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -103,6 +103,7 @@ if [ "$CONFIG_M586MMX" = "y" ]; then
 fi
 if [ "$CONFIG_M686" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    bool 'PGE extensions (not for Cyrix/Transmeta)' CONFIG_X86_PGE
@@ -112,6 +113,7 @@ if [ "$CONFIG_M686" = "y" ]; then
 fi
 if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_PGE y
@@ -120,6 +122,7 @@ if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
 fi
 if [ "$CONFIG_MPENTIUM4" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 7
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_PGE y
@@ -139,6 +142,7 @@ if [ "$CONFIG_MK8" = "y" ]; then
 fi
 if [ "$CONFIG_MK7" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 6
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_USE_3DNOW y
@@ -505,3 +509,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/i386/kernel/acpi.c linux-2.4.37.7/arch/i386/kernel/acpi.c
--- linux-2.4.37.7/arch/i386/kernel/acpi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/acpi.c	2009-11-10 19:30:27.000000000 -0500
@@ -370,7 +370,7 @@ acpi_scan_rsdp (
 	 * RSDP signature.
 	 */
 	for (offset = 0; offset < length; offset += 16) {
-		if (strncmp((char *) (start + offset), "RSD PTR ", sig_len))
+		if (strncmp((char *) (phys_to_virt(start) + offset), "RSD PTR ", sig_len))
 			continue;
 		return (start + offset);
 	}
@@ -708,7 +708,7 @@ static void acpi_create_identity_pmd (vo
 	saved_pmd = *pmd;
 
 	/* set the new one */
-	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(ptep)));
+	set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(ptep)));
 
 	/* flush the TLB */
 	local_flush_tlb();
diff -urNp linux-2.4.37.7/arch/i386/kernel/apm.c linux-2.4.37.7/arch/i386/kernel/apm.c
--- linux-2.4.37.7/arch/i386/kernel/apm.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/apm.c	2009-11-10 19:30:27.000000000 -0500
@@ -223,7 +223,7 @@
 #include <linux/sysrq.h>
 
 extern unsigned long get_cmos_time(void);
-extern void machine_real_restart(unsigned char *, int);
+extern void machine_real_restart(const unsigned char *, unsigned int);
 
 #if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)
 extern int (*console_blank_hook)(int);
@@ -614,7 +614,7 @@ static u8 apm_bios_call(u32 func, u32 eb
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall %%cs:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
+		"lcall *%%ss:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
 		"setc %%al\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
@@ -666,7 +666,7 @@ static u8 apm_bios_call_simple(u32 func,
 		__asm__ __volatile__(APM_DO_ZERO_SEGS
 			"pushl %%edi\n\t"
 			"pushl %%ebp\n\t"
-			"lcall %%cs:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
+			"lcall *%%ss:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
 			"setc %%bl\n\t"
 			"popl %%ebp\n\t"
 			"popl %%edi\n\t"
@@ -924,7 +924,7 @@ recalc:
  
 static void apm_power_off(void)
 {
-	unsigned char	po_bios_call[] = {
+	const unsigned char	po_bios_call[] = {
 		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
 		0x8e, 0xd0,		/* movw  ax,ss       */
 		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
@@ -1883,7 +1883,7 @@ static int __init apm_setup(char *str)
 __setup("apm=", apm_setup);
 #endif
 
-static struct file_operations apm_bios_fops = {
+static const struct file_operations apm_bios_fops = {
 	owner:		THIS_MODULE,
 	read:		do_read,
 	poll:		do_poll,
@@ -1985,6 +1985,12 @@ static int __init apm_init(void)
 		 __va((unsigned long)0x40 << 4));
 	_set_limit((char *)&gdt[APM_40 >> 3], 4095 - (0x40 << 4));
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	set_base(gdt2[APM_40 >> 3],
+		__va((unsigned long)0x40 << 4));
+	_set_limit((char *)&gdt2[APM_40 >> 3], 4095 - (0x40 << 4));
+#endif
+
 	apm_bios_entry.offset = apm_info.bios.offset;
 	apm_bios_entry.segment = APM_CS;
 	set_base(gdt[APM_CS >> 3],
@@ -1993,6 +1999,16 @@ static int __init apm_init(void)
 		 __va((unsigned long)apm_info.bios.cseg_16 << 4));
 	set_base(gdt[APM_DS >> 3],
 		 __va((unsigned long)apm_info.bios.dseg << 4));
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	set_base(gdt2[APM_CS >> 3],
+		 __va((unsigned long)apm_info.bios.cseg << 4));
+	set_base(gdt2[APM_CS_16 >> 3],
+		 __va((unsigned long)apm_info.bios.cseg_16 << 4));
+	set_base(gdt2[APM_DS >> 3],
+		 __va((unsigned long)apm_info.bios.dseg << 4));
+#endif
+
 #ifndef APM_RELAX_SEGMENTS
 	if (apm_info.bios.version == 0x100) {
 #endif
@@ -2002,6 +2018,13 @@ static int __init apm_init(void)
 		_set_limit((char *)&gdt[APM_CS_16 >> 3], 64 * 1024 - 1);
 		/* For the DEC Hinote Ultra CT475 (and others?) */
 		_set_limit((char *)&gdt[APM_DS >> 3], 64 * 1024 - 1);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_set_limit((char *)&gdt2[APM_CS >> 3], 64 * 1024 - 1);
+		_set_limit((char *)&gdt2[APM_CS_16 >> 3], 64 * 1024 - 1);
+		_set_limit((char *)&gdt2[APM_DS >> 3], 64 * 1024 - 1);
+#endif
+
 #ifndef APM_RELAX_SEGMENTS
 	} else {
 		_set_limit((char *)&gdt[APM_CS >> 3],
@@ -2010,6 +2033,16 @@ static int __init apm_init(void)
 			(apm_info.bios.cseg_16_len - 1) & 0xffff);
 		_set_limit((char *)&gdt[APM_DS >> 3],
 			(apm_info.bios.dseg_len - 1) & 0xffff);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_set_limit((char *)&gdt2[APM_CS >> 3],
+			(apm_info.bios.cseg_len - 1) & 0xffff);
+		_set_limit((char *)&gdt2[APM_CS_16 >> 3],
+			(apm_info.bios.cseg_16_len - 1) & 0xffff);
+		_set_limit((char *)&gdt2[APM_DS >> 3],
+			(apm_info.bios.dseg_len - 1) & 0xffff);
+#endif
+
 	}
 #endif
 
diff -urNp linux-2.4.37.7/arch/i386/kernel/cpuid.c linux-2.4.37.7/arch/i386/kernel/cpuid.c
--- linux-2.4.37.7/arch/i386/kernel/cpuid.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/cpuid.c	2009-11-10 19:30:27.000000000 -0500
@@ -133,7 +133,7 @@ static int cpuid_open(struct inode *inod
 /*
  * File operations we support
  */
-static struct file_operations cpuid_fops = {
+static const struct file_operations cpuid_fops = {
   owner:	THIS_MODULE,
   llseek:	cpuid_seek,
   read:		cpuid_read,
diff -urNp linux-2.4.37.7/arch/i386/kernel/entry.S linux-2.4.37.7/arch/i386/kernel/entry.S
--- linux-2.4.37.7/arch/i386/kernel/entry.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/entry.S	2009-11-10 19:30:27.000000000 -0500
@@ -84,7 +84,7 @@ processor	= 52
 ENOSYS = 38
 
 
-#define SAVE_ALL \
+#define __SAVE_ALL \
 	cld; \
 	pushl %es; \
 	pushl %ds; \
@@ -99,6 +99,18 @@ ENOSYS = 38
 	movl %edx,%ds; \
 	movl %edx,%es;
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL \
+	movl %cr0,%edx; \
+	movl %edx,%ebp; \
+	orl $0x10000,%edx; \
+	xorl %edx,%ebp; \
+	movl %edx,%cr0;
+#else
+#define SAVE_ALL __SAVE_ALL
+#endif
+
 #define RESTORE_ALL	\
 	popl %ebx;	\
 	popl %ecx;	\
@@ -209,6 +221,17 @@ ENTRY(system_call)
 	jae badsys
 	call *SYMBOL_NAME(sys_call_table)(,%eax,4)
 	movl %eax,EAX(%esp)		# save the return value
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	cli				# need_resched and signals atomic test
+	cmpl $0,need_resched(%ebx)
+	jne reschedule
+	cmpl $0,sigpending(%ebx)
+	jne signal_return
+	call SYMBOL_NAME(pax_randomize_kstack)
+	jmp restore_all
+#endif
+
 ENTRY(ret_from_sys_call)
 	cli				# need_resched and signals atomic test
 	cmpl $0,need_resched(%ebx)
@@ -260,6 +283,13 @@ ret_from_exception:
 	movb CS(%esp),%al
 	testl $(VM_MASK | 3),%eax	# return to VM86 mode or non-supervisor?
 	jne ret_from_sys_call
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0, %edx
+	xorl %ebp, %edx
+	movl %edx, %cr0
+#endif
+
 	jmp restore_all
 
 	ALIGN
@@ -283,6 +313,15 @@ error_code:
 	pushl %ecx
 	pushl %ebx
 	cld
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0,%edx
+	movl %edx,%ebp
+	orl $0x10000,%edx
+	xorl %edx,%ebp
+	movl %edx,%cr0
+#endif
+
 	movl %es,%ecx
 	movl ORIG_EAX(%esp), %esi	# get the error code
 	movl ES(%esp), %edi		# get the function address
@@ -337,6 +376,13 @@ ENTRY(nmi)
 	pushl %edx
 	call SYMBOL_NAME(do_nmi)
 	addl $8,%esp
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0, %edx
+	xorl %ebp, %edx
+	movl %edx, %cr0
+#endif
+
 	RESTORE_ALL
 
 ENTRY(int3)
@@ -389,8 +435,77 @@ ENTRY(alignment_check)
 	jmp error_code
 
 ENTRY(page_fault)
+#ifdef CONFIG_PAX_PAGEEXEC
+	ALIGN
+	pushl $ SYMBOL_NAME(pax_do_page_fault)
+#else
 	pushl $ SYMBOL_NAME(do_page_fault)
+#endif
+
+#ifndef CONFIG_PAX_EMUTRAMP
 	jmp error_code
+#else
+	pushl %ds
+	pushl %eax
+	xorl %eax,%eax
+	pushl %ebp
+	pushl %edi
+	pushl %esi
+	pushl %edx
+	decl %eax			# eax = -1
+	pushl %ecx
+	pushl %ebx
+	cld
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0,%edx
+	movl %edx,%ebp
+	orl $0x10000,%edx
+	xorl %edx,%ebp
+	movl %edx,%cr0
+#endif
+
+	movl %es,%ecx
+	movl ORIG_EAX(%esp), %esi	# get the error code
+	movl ES(%esp), %edi		# get the function address
+	movl %eax, ORIG_EAX(%esp)
+	movl %ecx, ES(%esp)
+	movl %esp,%edx
+	pushl %esi			# push the error code
+	pushl %edx			# push the pt_regs pointer
+	movl $(__KERNEL_DS),%edx
+	movl %edx,%ds
+	movl %edx,%es
+	GET_CURRENT(%ebx)
+	call *%edi
+	addl $8,%esp
+	decl %eax
+	jnz ret_from_exception
+
+	popl %ebx
+	popl %ecx
+	popl %edx
+	popl %esi
+	popl %edi
+	popl %ebp
+	popl %eax
+1:	popl %ds;
+2:	popl %es;
+	addl $4,%esp;
+	jmp system_call
+
+.section .fixup,"ax";
+3:	movl $0,(%esp);
+	jmp 1b;
+4:	movl $0,(%esp);
+	jmp 2b;
+.previous;
+.section __ex_table,"a";
+	.align 4;
+	.long 1b,3b;
+	.long 2b,4b;
+.previous
+#endif
 
 ENTRY(machine_check)
 	pushl $0
@@ -402,7 +517,7 @@ ENTRY(spurious_interrupt_bug)
 	pushl $ SYMBOL_NAME(do_spurious_interrupt_bug)
 	jmp error_code
 
-.data
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* 0  -  old "setup()" system call*/
 	.long SYMBOL_NAME(sys_exit)
diff -urNp linux-2.4.37.7/arch/i386/kernel/head.S linux-2.4.37.7/arch/i386/kernel/head.S
--- linux-2.4.37.7/arch/i386/kernel/head.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/head.S	2009-11-10 19:30:27.000000000 -0500
@@ -36,11 +36,23 @@
 #define X86_CAPABILITY	CPU_PARAMS+12
 #define X86_VENDOR_ID	CPU_PARAMS+36	/* tied to NCAPINTS in cpufeature.h */
 
+#ifdef CONFIG_PAX_KERNEXEC
+/* PaX: fill first page in .text with int3 to catch NULL derefs in kernel mode */
+.fill 4096,1,0xcc
+#endif
+
+/*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
+
 /*
  * swapper_pg_dir is the main page directory, address 0x00101000
  *
  * On entry, %esi points to the real-mode code as a 32-bit pointer.
  */
+.global startup_32
 startup_32:
 /*
  * Set segments to known values
@@ -51,9 +63,88 @@ startup_32:
 	movl %eax,%es
 	movl %eax,%fs
 	movl %eax,%gs
+	movl %eax,%ss
+
 #ifdef CONFIG_SMP
 	orw %bx,%bx
-	jz 1f
+	jnz 1f
+#endif
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	/* check for VMware */
+	movl $0x564d5868,%eax
+	xorl %ebx,%ebx
+	movl $0xa,%ecx
+	movl $0x5658,%edx
+	in (%dx),%eax
+	cmpl $0x564d5868,%ebx
+	jz 2f
+
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c09700),%eax
+	movl %eax,(SYMBOL_NAME(gdt_table) - __PAGE_OFFSET + __KERNEL_DS + 4)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	movl %eax,(SYMBOL_NAME(gdt_table2) - __PAGE_OFFSET + __KERNEL_DS + 4)
+#endif
+
+2:
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $__KERNEL_TEXT_OFFSET,%eax
+	movw %ax,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 2 - __PAGE_OFFSET)
+	rorl $16,%eax
+	movb %al,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 4 - __PAGE_OFFSET)
+	movb %ah,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 7 - __PAGE_OFFSET)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	movb %al,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 4 - __PAGE_OFFSET)
+	movb %ah,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 7 - __PAGE_OFFSET)
+	rorl $16,%eax
+	movw %ax,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 2 - __PAGE_OFFSET)
+#endif
+
+#endif
+
+/*
+ * Clear BSS first so that there are no surprises...
+ * No need to cld as DF is already clear from cld above...
+ */
+	xorl %eax,%eax
+	movl $ SYMBOL_NAME(__bss_start) - __PAGE_OFFSET,%edi
+	movl $ SYMBOL_NAME(__bss_end) - __PAGE_OFFSET,%ecx
+	subl %edi,%ecx
+	rep
+	stosb
+/*
+ * Copy bootup parameters out of the way. First 2kB of
+ * _empty_zero_page is for boot parameters, second 2kB
+ * is for the command line.
+ *
+ * Note: %esi still has the pointer to the real-mode data.
+ */
+	movl $ SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET,%edi
+	movl $512,%ecx
+	cld
+	rep
+	movsl
+	xorl %eax,%eax
+	movl $512,%ecx
+	rep
+	stosl
+	movl SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET + NEW_CL_POINTER,%esi
+	andl %esi,%esi
+	jnz 2f			# New command line protocol
+	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
+	jne 1f
+	movzwl OLD_CL_OFFSET,%esi
+	addl $(OLD_CL_BASE_ADDR),%esi
+2:
+	movl $ SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET + 2048,%edi
+	movl $512,%ecx
+	rep
+	movsl
+1:
 
 /*
  *	New page tables may be in 4Mbyte page mode and may
@@ -71,22 +162,28 @@ startup_32:
  */
 #define cr4_bits mmu_cr4_features-__PAGE_OFFSET
 	cmpl $0,cr4_bits
-	je 3f
+	je 1f
 	movl %cr4,%eax		# Turn on paging options (PSE,PAE,..)
 	orl cr4_bits,%eax
 	movl %eax,%cr4
-	jmp 3f
 1:
+
+#ifdef CONFIG_SMP
+	orw  %bx,%bx
+	jnz 3f
 #endif
+
 /*
  * Initialize page tables
  */
 	movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */
-	movl $007,%eax		/* "007" doesn't mean with right to kill, but
-				   PRESENT+RW+USER */
+	movl $0x63,%eax		/* "0x63" is PRESENT+RW+ACCESSED+DIRTY */
 2:	stosl
+#ifdef CONFIG_X86_PAE
+	addl $4,%edi
+#endif
 	add $0x1000,%eax
-	cmp $empty_zero_page-__PAGE_OFFSET,%edi
+	cmp $0x01000063,%eax
 	jne 2b
 
 /*
@@ -100,37 +197,16 @@ startup_32:
 	movl %eax,%cr0		/* ..and set paging (PG) bit */
 	jmp 1f			/* flush the prefetch-queue */
 1:
-	movl $1f,%eax
-	jmp *%eax		/* make sure eip is relocated */
-1:
+	lgdt gdt_descr
+	ljmp $__KERNEL_CS,$1f
+1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
+	movl %eax,%ds		# after changing gdt.
+	movl %eax,%es
+	movl %eax,%fs
+	movl %eax,%gs
 	/* Set up the stack pointer */
 	lss stack_start,%esp
 
-#ifdef CONFIG_SMP
-	orw  %bx,%bx
-	jz  1f				/* Initial CPU cleans BSS */
-	pushl $0
-	popfl
-	jmp checkCPUtype
-1:
-#endif /* CONFIG_SMP */
-
-/*
- * Clear BSS first so that there are no surprises...
- * No need to cld as DF is already clear from cld above...
- */
-	xorl %eax,%eax
-	movl $ SYMBOL_NAME(__bss_start),%edi
-	movl $ SYMBOL_NAME(_end),%ecx
-	subl %edi,%ecx
-	rep
-	stosb
-
-/*
- * start system 32-bit setup. We need to re-do some of the things done
- * in 16-bit mode for the "real" operations.
- */
-	call setup_idt
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
  * confuse the debugger if this code is traced.
@@ -138,35 +214,18 @@ startup_32:
  */
 	pushl $0
 	popfl
+
+#ifdef CONFIG_SMP
+	orw  %bx,%bx
+	jnz checkCPUtype
+#endif /* CONFIG_SMP */
+
 /*
- * Copy bootup parameters out of the way. First 2kB of
- * _empty_zero_page is for boot parameters, second 2kB
- * is for the command line.
- *
- * Note: %esi still has the pointer to the real-mode data.
+ * start system 32-bit setup. We need to re-do some of the things done
+ * in 16-bit mode for the "real" operations.
  */
-	movl $ SYMBOL_NAME(empty_zero_page),%edi
-	movl $512,%ecx
-	cld
-	rep
-	movsl
-	xorl %eax,%eax
-	movl $512,%ecx
-	rep
-	stosl
-	movl SYMBOL_NAME(empty_zero_page)+NEW_CL_POINTER,%esi
-	andl %esi,%esi
-	jnz 2f			# New command line protocol
-	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
-	jne 1f
-	movzwl OLD_CL_OFFSET,%esi
-	addl $(OLD_CL_BASE_ADDR),%esi
-2:
-	movl $ SYMBOL_NAME(empty_zero_page)+2048,%edi
-	movl $512,%ecx
-	rep
-	movsl
-1:
+	call setup_idt
+
 checkCPUtype:
 
 	movl $-1,X86_CPUID		#  -1 for no CPUID initially
@@ -241,20 +300,7 @@ is386:	pushl %ecx		# restore original EF
 2:	movl %eax,%cr0
 	call check_x87
 	incb ready
-	lgdt gdt_descr
 	lidt idt_descr
-	ljmp $(__KERNEL_CS),$1f
-1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
-	movl %eax,%ds		# after changing gdt.
-	movl %eax,%es
-	movl %eax,%fs
-	movl %eax,%gs
-#ifdef CONFIG_SMP
-	movl $(__KERNEL_DS), %eax
-	movl %eax,%ss		# Reload the stack pointer (segment only)
-#else
-	lss stack_start,%esp	# Load processor stack
-#endif
 	xorl %eax,%eax
 	lldt %ax
 	cld			# gcc2 wants the direction flag cleared at all times
@@ -272,8 +318,6 @@ L6:
 	jmp L6			# main should never return here, but
 				# just in case, we know what happens.
 
-ready:	.byte 0
-
 /*
  * We depend on ET to be correct. This checks for 287/387.
  */
@@ -319,13 +363,6 @@ rp_sidt:
 	jne rp_sidt
 	ret
 
-ENTRY(stack_start)
-	.long SYMBOL_NAME(init_task_union)+8192
-	.long __KERNEL_DS
-
-/* This is the default interrupt "handler" :-) */
-int_msg:
-	.asciz "Unknown interrupt, stack: %p %p %p %p\n"
 	ALIGN
 ignore_int:
 	cld
@@ -341,6 +378,18 @@ ignore_int:
 1:	hlt
 	jmp 1b
 
+.data
+ready:	.byte 0
+
+ENTRY(stack_start)
+	.long SYMBOL_NAME(init_task_union)+8192-8
+	.long __KERNEL_DS
+
+.section .rodata,"a"
+/* This is the default interrupt "handler" :-) */
+int_msg:
+	.asciz "Unknown interrupt, stack: %p %p %p %p\n"
+
 /*
  * The interrupt descriptor table has room for 256 idt's,
  * the global descriptor table is dependent on the number
@@ -360,60 +409,134 @@ idt_descr:
 SYMBOL_NAME(idt):
 	.long SYMBOL_NAME(idt_table)
 
+.globl SYMBOL_NAME(boot_gdt_table)
+boot_gdt_table:
+	.fill __KERNEL_CS,1,0
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+
 	.word 0
 gdt_descr:
 	.word GDT_ENTRIES*8-1
 SYMBOL_NAME(gdt):
 	.long SYMBOL_NAME(gdt_table)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+.globl SYMBOL_NAME(gdt2)
+	.word 0
+gdt_descr2:
+	.word GDT_ENTRIES*8-1
+SYMBOL_NAME(gdt2):
+	.long SYMBOL_NAME(gdt_table2)
+#endif
+
 /*
- * This is initialized to create an identity-mapping at 0-8M (for bootup
- * purposes) and another mapping of the 0-8M area at virtual address
+ * This is initialized to create an identity-mapping at 0-16M (for bootup
+ * purposes) and another mapping of the 0-16M area at virtual address
  * PAGE_OFFSET.
  */
-.org 0x1000
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
-	.long 0x00102007
-	.long 0x00103007
-	.fill BOOT_USER_PGD_PTRS-2,4,0
-	/* default: 766 entries */
-	.long 0x00102007
-	.long 0x00103007
-	/* default: 254 entries */
-	.fill BOOT_KERNEL_PGD_PTRS-2,4,0
+#ifdef CONFIG_X86_PAE
+	.long swapper_pm_dir-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*8-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*16-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*24-__PAGE_OFFSET+1
+	.long 0
+#else
+	.long pg0-__PAGE_OFFSET+63
+	.long pg0+1024*4-__PAGE_OFFSET+63
+	.long pg0+1024*8-__PAGE_OFFSET+63
+	.long pg0+1024*12-__PAGE_OFFSET+63
+	.fill BOOT_USER_PGD_PTRS-4,4,0
+	/* default: 764 entries */
+	.long pg0-__PAGE_OFFSET+67
+	.long pg0+1024*4-__PAGE_OFFSET+63
+	.long pg0+1024*8-__PAGE_OFFSET+63
+	.long pg0+1024*12-__PAGE_OFFSET+63
+	/* default: 252 entries */
+	.fill BOOT_KERNEL_PGD_PTRS-4,4,0
+#endif
+
+#ifdef CONFIG_X86_PAE
+.section .swapper_pm_dir,"a",@progbits
+ENTRY(swapper_pm_dir)
+	.long pg0-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*8-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*16-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*24-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*32-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*40-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*48-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*56-__PAGE_OFFSET+63
+	.long 0
+	.fill BOOT_USER_PMD_PTRS-8,8,0
+	/* default: 1024+512-4 entries */
+	.long pg0-__PAGE_OFFSET+67
+	.long 0
+	.long pg0+512*8-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*16-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*24-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*32-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*40-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*48-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*56-__PAGE_OFFSET+63
+	.long 0
+	/* default: 512-4 entries */
+	.fill BOOT_KERNEL_PMD_PTRS-8,8,0
+#endif
 
 /*
- * The page tables are initialized to only 8MB here - the final page
+ * The page tables are initialized to only 16MB here - the final page
  * tables are set up later depending on memory size.
  */
-.org 0x2000
+.section .pg0,"a",@progbits
 ENTRY(pg0)
+	.fill 1024*4,4,0
 
-.org 0x3000
-ENTRY(pg1)
+#ifdef CONFIG_X86_PAE
+	.fill 1024*4,4,0
+#endif
 
 /*
  * empty_zero_page must immediately follow the page tables ! (The
  * initialization loop counts until empty_zero_page)
  */
-
-.org 0x4000
+.section .empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
-
-.org 0x5000
+	.fill 1024,4,0
 
 /*
- * Real beginning of normal "text" segment
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
  */
-ENTRY(stext)
-ENTRY(_stext)
+.section .idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
 
 /*
  * This starts the data section. Note that the above is all
  * in the text section because it has alignment requirements
  * that we cannot fulfill any other way.
  */
-.data
+.section .rodata,"a",@progbits
 
 ALIGN
 /*
@@ -425,18 +548,39 @@ ALIGN
 ENTRY(gdt_table)
 	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x0000000000000000	/* not used */
-	.quad 0x00cf9a000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
-	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
-	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
-	.quad 0x0000000000000000	/* not used */
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x23 user   4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x2b user   4GB data at 0x00000000 */
+	.quad 0x0000000000000000	/* PCIBIOS_CS */
+	.quad 0x0000000000000000	/* PCIBIOS_DS */
+	/*
+	 * The APM segments have byte granularity and their bases
+	 * and limits are set at run time.
+	 */
+	.quad 0x0040930000000000	/* 0x40 APM set up for bad BIOS's */
+	.quad 0x00409b0000000000	/* 0x48 APM CS    code */
+	.quad 0x00009b0000000000	/* 0x50 APM CS 16 code (16 bit) */
+	.quad 0x0040930000000000	/* 0x58 APM DS    data */
+	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+ENTRY(gdt_table2)
+	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x0000000000000000	/* not used */
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+	.quad 0x60c5fb000000ffff	/* 0x23 user 1.5GB code at 0x60000000 */
+	.quad 0x00cff3000000ffff	/* 0x2b user   4GB data at 0x00000000 */
+	.quad 0x0000000000000000	/* PCIBIOS_CS */
+	.quad 0x0000000000000000	/* PCIBIOS_DS */
 	/*
 	 * The APM segments have byte granularity and their bases
 	 * and limits are set at run time.
 	 */
-	.quad 0x0040920000000000	/* 0x40 APM set up for bad BIOS's */
-	.quad 0x00409a0000000000	/* 0x48 APM CS    code */
-	.quad 0x00009a0000000000	/* 0x50 APM CS 16 code (16 bit) */
-	.quad 0x0040920000000000	/* 0x58 APM DS    data */
+	.quad 0x0040930000000000	/* 0x40 APM set up for bad BIOS's */
+	.quad 0x00409b0000000000	/* 0x48 APM CS    code */
+	.quad 0x00009b0000000000	/* 0x50 APM CS 16 code (16 bit) */
+	.quad 0x0040930000000000	/* 0x58 APM DS    data */
 	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
+#endif
diff -urNp linux-2.4.37.7/arch/i386/kernel/i386_ksyms.c linux-2.4.37.7/arch/i386/kernel/i386_ksyms.c
--- linux-2.4.37.7/arch/i386/kernel/i386_ksyms.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/i386_ksyms.c	2009-11-10 19:30:27.000000000 -0500
@@ -34,7 +34,7 @@ extern void dump_thread(struct pt_regs *
 extern spinlock_t rtc_lock;
 
 #if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
-extern void machine_real_restart(unsigned char *, int);
+extern void machine_real_restart(const unsigned char *, unsigned int);
 EXPORT_SYMBOL(machine_real_restart);
 extern void default_idle(void);
 EXPORT_SYMBOL(default_idle);
@@ -74,6 +74,11 @@ EXPORT_SYMBOL(pm_power_off);
 EXPORT_SYMBOL(get_cmos_time);
 EXPORT_SYMBOL(apm_info);
 EXPORT_SYMBOL(gdt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+EXPORT_SYMBOL(gdt2);
+#endif
+
 EXPORT_SYMBOL(empty_zero_page);
 
 #ifdef CONFIG_DEBUG_IOVIRT
@@ -86,6 +91,8 @@ EXPORT_SYMBOL_NOVERS(__down_failed_trylo
 EXPORT_SYMBOL_NOVERS(__up_wakeup);
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_generic);
+EXPORT_SYMBOL(csum_partial_copy_generic_to_user);
+EXPORT_SYMBOL(csum_partial_copy_generic_from_user);
 /* Delay loops */
 EXPORT_SYMBOL(__ndelay);
 EXPORT_SYMBOL(__udelay);
diff -urNp linux-2.4.37.7/arch/i386/kernel/i8259.c linux-2.4.37.7/arch/i386/kernel/i8259.c
--- linux-2.4.37.7/arch/i386/kernel/i8259.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/i8259.c	2009-11-10 19:30:27.000000000 -0500
@@ -107,7 +107,8 @@ BUILD_SMP_INTERRUPT(spurious_interrupt,S
 	IRQ(x,8), IRQ(x,9), IRQ(x,a), IRQ(x,b), \
 	IRQ(x,c), IRQ(x,d), IRQ(x,e), IRQ(x,f)
 
-void (*interrupt[NR_IRQS])(void) = {
+typedef void (*interrupt_t)(void);
+const interrupt_t interrupt[NR_IRQS] = {
 	IRQLIST_16(0x0),
 
 #ifdef CONFIG_X86_IO_APIC
diff -urNp linux-2.4.37.7/arch/i386/kernel/init_task.c linux-2.4.37.7/arch/i386/kernel/init_task.c
--- linux-2.4.37.7/arch/i386/kernel/init_task.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/init_task.c	2009-11-10 19:30:27.000000000 -0500
@@ -29,5 +29,9 @@ union task_union init_task_union 
  * section. Since TSS's are completely CPU-local, we want them
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */ 
-struct tss_struct init_tss[NR_CPUS] __cacheline_aligned = { [0 ... NR_CPUS-1] = INIT_TSS };
 
+#ifdef CONFIG_PAX_KERNEXEC
+struct tss_struct init_tss[NR_CPUS] __attribute__((__aligned__(SMP_CACHE_BYTES), __section__(".rodata"))) = { [0 ... NR_CPUS-1] = INIT_TSS };
+#else
+struct tss_struct init_tss[NR_CPUS] __cacheline_aligned = { [0 ... NR_CPUS-1] = INIT_TSS };
+#endif
diff -urNp linux-2.4.37.7/arch/i386/kernel/io_apic.c linux-2.4.37.7/arch/i386/kernel/io_apic.c
--- linux-2.4.37.7/arch/i386/kernel/io_apic.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/io_apic.c	2009-11-10 19:30:27.000000000 -0500
@@ -620,7 +620,8 @@ next:
 	return current_vector;
 }
 
-extern void (*interrupt[NR_IRQS])(void);
+typedef void (*interrupt_t)(void);
+extern const interrupt_t interrupt[NR_IRQS];
 static struct hw_interrupt_type ioapic_level_irq_type;
 static struct hw_interrupt_type ioapic_edge_irq_type;
 
diff -urNp linux-2.4.37.7/arch/i386/kernel/ioport.c linux-2.4.37.7/arch/i386/kernel/ioport.c
--- linux-2.4.37.7/arch/i386/kernel/ioport.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/ioport.c	2009-11-10 19:30:27.000000000 -0500
@@ -14,6 +14,8 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
+#include <linux/grsecurity.h>
+#include <asm/desc.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
@@ -57,10 +59,22 @@ asmlinkage int sys_ioperm(unsigned long 
 	struct thread_struct * t = &current->thread;
 	struct tss_struct * tss = init_tss + smp_processor_id();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
+#ifdef CONFIG_GRKERNSEC_IO
+	if (turn_on) {
+		gr_handle_ioperm();
+#else
 	if (turn_on && !capable(CAP_SYS_RAWIO))
+#endif
 		return -EPERM;
+#ifdef CONFIG_GRKERNSEC_IO
+	}
+#endif
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -78,6 +92,11 @@ asmlinkage int sys_ioperm(unsigned long 
 	 * do it in the per-thread copy and in the TSS ...
 	 */
 	set_bitmap(t->io_bitmap, from, num, !turn_on);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	if (tss->bitmap == IO_BITMAP_OFFSET) { /* already active? */
 		set_bitmap(tss->io_bitmap, from, num, !turn_on);
 	} else {
@@ -85,6 +104,10 @@ asmlinkage int sys_ioperm(unsigned long 
 		tss->bitmap = IO_BITMAP_OFFSET; /* Activate it in the TSS */
 	}
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	return 0;
 }
 
@@ -109,8 +132,13 @@ asmlinkage int sys_iopl(unsigned long un
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
+#ifdef CONFIG_GRKERNSEC_IO
+		gr_handle_iopl();
+		return -EPERM;
+#else
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
+#endif
 	}
 	regs->eflags = (regs->eflags & 0xffffcfff) | (level << 12);
 	return 0;
diff -urNp linux-2.4.37.7/arch/i386/kernel/ldt.c linux-2.4.37.7/arch/i386/kernel/ldt.c
--- linux-2.4.37.7/arch/i386/kernel/ldt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/ldt.c	2009-11-10 19:30:27.000000000 -0500
@@ -151,7 +151,7 @@ static int read_default_ldt(void * ptr, 
 {
 	int err;
 	unsigned long size;
-	void *address;
+	const void *address;
 
 	err = 0;
 	address = &default_ldt[0];
@@ -214,6 +214,13 @@ static int write_ldt(void * ptr, unsigne
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & 2)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	entry_1 = ((ldt_info.base_addr & 0x0000ffff) << 16) |
 		  (ldt_info.limit & 0x0ffff);
 	entry_2 = (ldt_info.base_addr & 0xff000000) |
@@ -224,7 +231,7 @@ static int write_ldt(void * ptr, unsigne
 		  ((ldt_info.seg_not_present ^ 1) << 15) |
 		  (ldt_info.seg_32bit << 22) |
 		  (ldt_info.limit_in_pages << 23) |
-		  0x7000;
+		  0x7100;
 	if (!oldmode)
 		entry_2 |= (ldt_info.useable << 20);
 
diff -urNp linux-2.4.37.7/arch/i386/kernel/microcode.c linux-2.4.37.7/arch/i386/kernel/microcode.c
--- linux-2.4.37.7/arch/i386/kernel/microcode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/microcode.c	2009-11-10 19:30:27.000000000 -0500
@@ -474,7 +474,7 @@ static int microcode_ioctl (struct inode
 }
 
 /* shared between misc device and devfs regular file */
-static struct file_operations microcode_fops = {
+static const struct file_operations microcode_fops = {
 	.owner		= THIS_MODULE,
 	.write		= microcode_write,
 	.ioctl		= microcode_ioctl,
diff -urNp linux-2.4.37.7/arch/i386/kernel/mpparse.c linux-2.4.37.7/arch/i386/kernel/mpparse.c
--- linux-2.4.37.7/arch/i386/kernel/mpparse.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/mpparse.c	2009-11-10 19:30:27.000000000 -0500
@@ -833,7 +833,7 @@ void __init get_smp_config (void)
 		 * Read the physical hardware table.  Anything here will
 		 * override the defaults.
 		 */
-		if (!smp_read_mpc((void *)mpf->mpf_physptr)) {
+		if (!smp_read_mpc(phys_to_virt(mpf->mpf_physptr))) {
 			smp_found_config = 0;
 			printk(KERN_ERR "BIOS bug, MP table errors detected!...\n");
 			printk(KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
diff -urNp linux-2.4.37.7/arch/i386/kernel/msr.c linux-2.4.37.7/arch/i386/kernel/msr.c
--- linux-2.4.37.7/arch/i386/kernel/msr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/msr.c	2009-11-10 19:30:27.000000000 -0500
@@ -240,7 +240,7 @@ static int msr_open(struct inode *inode,
 /*
  * File operations we support
  */
-static struct file_operations msr_fops = {
+static const struct file_operations msr_fops = {
   owner:	THIS_MODULE,
   llseek:	msr_seek,
   read:		msr_read,
diff -urNp linux-2.4.37.7/arch/i386/kernel/mtrr.c linux-2.4.37.7/arch/i386/kernel/mtrr.c
--- linux-2.4.37.7/arch/i386/kernel/mtrr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/mtrr.c	2009-11-10 19:30:27.000000000 -0500
@@ -1675,7 +1675,7 @@ static ssize_t mtrr_write (struct file *
     char line[LINE_SIZE];
 
     if (!len) return -EINVAL;
-    if ( !suser () ) return -EPERM;
+    if ( !capable(CAP_SYS_ADMIN) ) return -EPERM;
     /*  Can't seek (pwrite) on this device  */
     if (ppos != &file->f_pos) return -ESPIPE;
     memset (line, 0, LINE_SIZE);
diff -urNp linux-2.4.37.7/arch/i386/kernel/pci-pc.c linux-2.4.37.7/arch/i386/kernel/pci-pc.c
--- linux-2.4.37.7/arch/i386/kernel/pci-pc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/pci-pc.c	2009-11-10 19:30:27.000000000 -0500
@@ -17,6 +17,7 @@
 #include <asm/io.h>
 #include <asm/smp.h>
 #include <asm/smpboot.h>
+#include <asm/desc.h>
 
 #include "pci-i386.h"
 
@@ -575,11 +576,10 @@ union bios32 {
  * we'll make pcibios_present() take a memory start parameter and store
  * the array there.
  */
-
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} bios32_indirect = { 0, __KERNEL_CS };
+} bios32_indirect = { 0, __PCIBIOS_CS };
 
 /*
  * Returns the entry point for the given service, NULL on error
@@ -593,34 +593,122 @@ static unsigned long bios32_service(unsi
 	unsigned long entry;		/* %edx */
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	__save_flags(flags); __cli();
-	__asm__("lcall (%%edi); cld"
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	gdt_table[6].a = 0x0000FFFFUL;
+	gdt_table[6].b = 0x00CF9B00UL;
+	gdt_table[7].a = 0x0000FFFFUL;
+	gdt_table[7].b = 0x00CF9300UL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[6].a = 0x0000FFFFUL;
+	gdt_table2[6].b = 0x00CF9B00UL;
+	gdt_table2[7].a = 0x0000FFFFUL;
+	gdt_table2[7].b = 0x00CF9300UL;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	__asm__("movw %w7, %%ds; lcall *(%%edi); push %%ss; pop %%ds; cld"
 		: "=a" (return_code),
 		  "=b" (address),
 		  "=c" (length),
 		  "=d" (entry)
 		: "0" (service),
 		  "1" (0),
-		  "D" (&bios32_indirect));
+		  "D" (&bios32_indirect),
+		  "r" (__PCIBIOS_DS)
+		: "memory");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	gdt_table[6].a = 0;
+	gdt_table[6].b = 0;
+	gdt_table[7].a = 0;
+	gdt_table[7].b = 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[6].a = 0;
+	gdt_table2[6].b = 0;
+	gdt_table2[7].a = 0;
+	gdt_table2[7].b = 0;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	__restore_flags(flags);
 
 	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
-				service, return_code);
+	case 0: {
+		unsigned long a, b1, b2;
+		unsigned char flags;
+
+		printk(KERN_INFO "bios32_service: base:%08lx length:%08lx entry:%08lx\n", address, length, entry);
+		if (address >= 0xFFFF0 || length >= 0xFFFF0 - address || length <= entry) {
+			printk(KERN_WARNING "bios32_service: not valid\n");
 			return 0;
+		}
+		address = address + PAGE_OFFSET;
+		length += 16UL; /* some BIOSs underreport this... */
+		flags = 4;
+		if (length >= 64*1024*1024) {
+			length >>= PAGE_SHIFT;
+			flags |= 8;
+		}
+		a = (length & 0xFFFFUL) | ((address & 0xFFFFUL) << 16);
+		b1 = (address & 0xFF000000UL) | ((address & 0x00FF0000UL) >> 16) | (length & 0xF0000UL) | (flags << 20) | 0x9B00UL;
+		b2 = (address & 0xFF000000UL) | ((address & 0x00FF0000UL) >> 16) | (length & 0xF0000UL) | (flags << 20) | 0x9300UL;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_open_kernel(cr0);
+#endif
+
+		gdt_table[6].a = a;
+		gdt_table[6].b = b1;
+		gdt_table[7].a = a;
+		gdt_table[7].b = b2;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		gdt_table2[6].a = a;
+		gdt_table2[6].b = b1;
+		gdt_table2[7].a = a;
+		gdt_table2[7].b = b2;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+
+		return entry;
+	}
+	case 0x80:	/* Not present */
+		printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
+		return 0;
+	default: /* Shouldn't happen */
+		printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
+			service, return_code);
+		return 0;
 	}
 }
 
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} pci_indirect = { 0, __KERNEL_CS };
+} pci_indirect = { 0, __PCIBIOS_CS };
 
 static int pci_bios_present;
 
@@ -631,11 +719,13 @@ static int __devinit check_pcibios(void)
 	unsigned long flags, pcibios_entry;
 
 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry + PAGE_OFFSET;
+		pci_indirect.address = pcibios_entry;
 
 		__save_flags(flags); __cli();
-		__asm__(
-			"lcall (%%edi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%edi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -644,7 +734,8 @@ static int __devinit check_pcibios(void)
 			  "=b" (ebx),
 			  "=c" (ecx)
 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
+			  "D" (&pci_indirect),
+			  "r" (__PCIBIOS_DS)
 			: "memory");
 		__restore_flags(flags);
 
@@ -680,7 +771,10 @@ static int __devinit pci_bios_find_devic
 	unsigned short bx;
 	unsigned short ret;
 
-	__asm__("lcall (%%edi); cld\n\t"
+	__asm__("movw %w7, %%ds\n\t"
+		"lcall *%%ss:(%%edi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n\t"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -690,7 +784,8 @@ static int __devinit pci_bios_find_devic
 		  "c" (device_id),
 		  "d" (vendor),
 		  "S" ((int) index),
-		  "D" (&pci_indirect));
+		  "D" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	*bus = (bx >> 8) & 0xff;
 	*device_fn = bx & 0xff;
 	return (int) (ret & 0xff00) >> 8;
@@ -709,7 +804,10 @@ static int pci_bios_read (int seg, int b
 
 	switch (len) {
 	case 1:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -718,10 +816,14 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_BYTE),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -730,10 +832,14 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_WORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -742,7 +848,8 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_DWORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -764,7 +871,10 @@ static int pci_bios_write (int seg, int 
 
 	switch (len) {
 	case 1:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -773,10 +883,14 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -785,10 +899,14 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -797,7 +915,8 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -1009,10 +1128,13 @@ struct irq_routing_table * __devinit pci
 
 	DBG("PCI: Fetching IRQ routing table... ");
 	__asm__("push %%es\n\t"
+		"movw %w8, %%ds\n\t"
 		"push %%ds\n\t"
 		"pop  %%es\n\t"
-		"lcall (%%esi); cld\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
 		"pop %%es\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -1023,7 +1145,8 @@ struct irq_routing_table * __devinit pci
 		  "1" (0),
 		  "D" ((long) &opt),
 		  "S" (&pci_indirect),
-		  "m" (opt)
+		  "m" (opt),
+		  "r" (__PCIBIOS_DS)
 		: "memory");
 	DBG("OK  ret=%d, size=%d, map=%x\n", ret, opt.size, map);
 	if (ret & 0xff00)
@@ -1047,7 +1170,10 @@ int pcibios_set_irq_routing(struct pci_d
 {
 	int ret;
 
-	__asm__("lcall (%%esi); cld\n\t"
+	__asm__("movw %w5, %%ds\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -1055,7 +1181,8 @@ int pcibios_set_irq_routing(struct pci_d
 		: "0" (PCIBIOS_SET_PCI_HW_INT),
 		  "b" ((dev->bus->number << 8) | dev->devfn),
 		  "c" ((irq << 8) | (pin + 10)),
-		  "S" (&pci_indirect));
+		  "S" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	return !(ret & 0xff00);
 }
 
diff -urNp linux-2.4.37.7/arch/i386/kernel/process.c linux-2.4.37.7/arch/i386/kernel/process.c
--- linux-2.4.37.7/arch/i386/kernel/process.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/process.c	2009-11-10 19:30:27.000000000 -0500
@@ -153,7 +153,7 @@ static int __init idle_setup (char *str)
 
 __setup("idle=", idle_setup);
 
-static int reboot_mode;
+static unsigned short reboot_mode;
 int reboot_thru_bios;
 
 #ifdef CONFIG_SMP
@@ -209,18 +209,18 @@ __setup("reboot=", reboot_setup);
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
 
-static unsigned long long
+static const unsigned long long
 real_mode_gdt_entries [3] =
 {
 	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009a000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000092000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	0x00009b000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
+	0x000093000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
-static struct
+static const struct
 {
 	unsigned short       size __attribute__ ((packed));
-	unsigned long long * base __attribute__ ((packed));
+	const unsigned long long * base __attribute__ ((packed));
 }
 real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, real_mode_gdt_entries },
 real_mode_idt = { 0x3ff, 0 },
@@ -245,7 +245,7 @@ no_idt = { 0, 0 };
    More could be done here to set up the registers as if a CPU reset had
    occurred; hopefully real BIOSs don't assume much. */
 
-static unsigned char real_mode_switch [] =
+static const unsigned char real_mode_switch [] =
 {
 	0x66, 0x0f, 0x20, 0xc0,			/*    movl  %cr0,%eax        */
 	0x66, 0x83, 0xe0, 0x11,			/*    andl  $0x00000011,%eax */
@@ -259,7 +259,7 @@ static unsigned char real_mode_switch []
 	0x24, 0x10,				/* f: andb  $0x10,al         */
 	0x66, 0x0f, 0x22, 0xc0			/*    movl  %eax,%cr0        */
 };
-static unsigned char jump_to_bios [] =
+static const unsigned char jump_to_bios [] =
 {
 	0xea, 0x00, 0x00, 0xff, 0xff		/*    ljmp  $0xffff,$0x0000  */
 };
@@ -278,10 +278,14 @@ static inline void kb_wait(void)
  * specified by the code and length parameters.
  * We assume that length will aways be less that 100!
  */
-void machine_real_restart(unsigned char *code, int length)
+void machine_real_restart(const unsigned char *code, unsigned int length)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	cli();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -302,9 +306,17 @@ void machine_real_restart(unsigned char 
 	   from the kernel segment.  This assumes the kernel segment starts at
 	   virtual address PAGE_OFFSET. */
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	memcpy (swapper_pg_dir, swapper_pg_dir + USER_PGD_PTRS,
 		sizeof (swapper_pg_dir [0]) * KERNEL_PGD_PTRS);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/* Make sure the first page is mapped to the start of physical memory.
 	   It is normally not mapped, to trap kernel NULL pointer dereferences. */
 
@@ -321,7 +333,7 @@ void machine_real_restart(unsigned char 
 	   REBOOT.COM programs, and the previous reset routine did this
 	   too. */
 
-	*((unsigned short *)0x472) = reboot_mode;
+	__put_user(reboot_mode, (unsigned short *)0x472);
 
 	/* For the switch to real mode, copy some code to low memory.  It has
 	   to be in the first 64k because it is running in 16-bit mode, and it
@@ -329,9 +341,9 @@ void machine_real_restart(unsigned char 
 	   off paging.  Copy it near the end of the first page, out of the way
 	   of BIOS variables. */
 
-	memcpy ((void *) (0x1000 - sizeof (real_mode_switch) - 100),
+	__copy_to_user ((void *) (0x1000 - sizeof (real_mode_switch) - 100),
 		real_mode_switch, sizeof (real_mode_switch));
-	memcpy ((void *) (0x1000 - 100), code, length);
+	__copy_to_user ((void *) (0x1000 - 100), code, length);
 
 	/* Set up the IDT for real mode. */
 
@@ -414,7 +426,7 @@ void machine_restart(char * __unused)
 
 	if(!reboot_thru_bios) {
 		/* rebooting needs to touch the page at absolute addr 0 */
-		*((unsigned short *)__va(0x472)) = reboot_mode;
+		__put_user(reboot_mode, (unsigned short *)0x472);
 		for (;;) {
 			int i;
 			for (i=0; i<100; i++) {
@@ -552,7 +564,7 @@ int copy_thread(int nr, unsigned long cl
 {
 	struct pt_regs * childregs;
 
-	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p)) - 1;
+	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p - sizeof(unsigned long))) - 1;
 	struct_cpy(childregs, regs);
 	childregs->eax = 0;
 	childregs->esp = esp;
@@ -613,6 +625,19 @@ void dump_thread(struct pt_regs * regs, 
 	dump->u_fpvalid = dump_fpu (regs, &dump->i387);
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+void pax_switch_segments(struct task_struct * tsk)
+{
+	if (!tsk->mm)
+		return;
+
+	if (tsk->mm->pax_flags & MF_PAX_SEGMEXEC)
+		__asm__ __volatile__("lgdt %0": "=m" (gdt_descr2));
+	else
+		__asm__ __volatile__("lgdt %0": "=m" (gdt_descr));
+}
+#endif
+
 /*
  * This special macro can be used to load a debugging register
  */
@@ -650,12 +675,15 @@ void fastcall __switch_to(struct task_st
 				 *next = &next_p->thread;
 	struct tss_struct *tss = init_tss + smp_processor_id();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	unlazy_fpu(prev_p);
 
-	/*
-	 * Reload esp0, LDT and the page table pointer:
-	 */
-	tss->esp0 = next->esp0;
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_switch_segments(next_p);
+#endif
 
 	/*
 	 * Save away %fs and %gs. No need to save %es and %ds, as
@@ -683,6 +711,15 @@ void fastcall __switch_to(struct task_st
 		loaddebug(next, 7);
 	}
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	/*
+	 * Reload esp0, LDT and the page table pointer:
+	 */
+	tss->esp0 = next->esp0;
+
 	if (prev->ioperm || next->ioperm) {
 		if (next->ioperm) {
 			/*
@@ -705,6 +742,11 @@ void fastcall __switch_to(struct task_st
 			 */
 			tss->bitmap = INVALID_IO_BITMAP_OFFSET;
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 asmlinkage int sys_fork(struct pt_regs regs)
@@ -792,3 +834,44 @@ unsigned long get_wchan(struct task_stru
 }
 #undef last_sched
 #undef first_sched
+
+#ifdef CONFIG_PAX_RANDKSTACK
+asmlinkage void pax_randomize_kstack(void)
+{
+	struct tss_struct *tss;
+	unsigned long time;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (!pax_aslr)
+		return;
+#endif
+
+	tss = init_tss + smp_processor_id();
+	rdtscl(time);
+
+	/* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x1EUL;
+	time <<= 2;
+#else
+	time &= 0xFUL;
+	time <<= 3;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	tss->esp0 ^= time;
+	current->thread.esp0 = tss->esp0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+}
+#endif
diff -urNp linux-2.4.37.7/arch/i386/kernel/ptrace.c linux-2.4.37.7/arch/i386/kernel/ptrace.c
--- linux-2.4.37.7/arch/i386/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -177,6 +178,9 @@ asmlinkage int sys_ptrace(long request, 
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if(gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
@@ -256,6 +260,17 @@ asmlinkage int sys_ptrace(long request, 
 			  if(addr < (long) &dummy->u_debugreg[4] &&
 			     ((unsigned long) data) >= TASK_SIZE-3) break;
 			  
+#ifdef CONFIG_GRKERNSEC
+			  if(addr >= (long) &dummy->u_debugreg[0] &&
+			     addr <= (long) &dummy->u_debugreg[3]){
+				  long reg   = (addr - (long) &dummy->u_debugreg[0]) >> 2;
+				  long type  = (child->thread.debugreg[7] >> (DR_CONTROL_SHIFT + 4*reg)) & 3;
+				  long align = (child->thread.debugreg[7] >> (DR_CONTROL_SHIFT + 2 + 4*reg)) & 3;
+				  if((type & 1) && (data & align))
+					break;
+			  }
+#endif
+
 			  if(addr == (long) &dummy->u_debugreg[7]) {
 				  data &= ~DR_CONTROL_RESERVED;
 				  for(i=0; i<4; i++)
diff -urNp linux-2.4.37.7/arch/i386/kernel/setup.c linux-2.4.37.7/arch/i386/kernel/setup.c
--- linux-2.4.37.7/arch/i386/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -129,7 +129,11 @@
 char ignore_irq13;		/* set if exception 16 works */
 struct cpuinfo_x86 boot_cpu_data = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
 
+#ifdef CONFIG_X86_PAE
+unsigned long mmu_cr4_features = X86_CR4_PAE;
+#else
 unsigned long mmu_cr4_features;
+#endif
 EXPORT_SYMBOL(mmu_cr4_features);
 
 /*
@@ -170,7 +174,7 @@ unsigned char aux_device_present;
 extern void mcheck_init(struct cpuinfo_x86 *c);
 extern void dmi_scan_machine(void);
 extern int root_mountflags;
-extern char _text, _etext, _edata, _end;
+extern char _text, _etext, _data, _edata, _end;
 
 static int have_cpuid_p(void) __init;
 
@@ -1209,14 +1213,14 @@ void __init setup_arch(char **cmdline_p)
 
 	if (!MOUNT_ROOT_RDONLY)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) &_text;
-	init_mm.end_code = (unsigned long) &_etext;
+	init_mm.start_code = (unsigned long) &_text + __KERNEL_TEXT_OFFSET;
+	init_mm.end_code = (unsigned long) &_etext + __KERNEL_TEXT_OFFSET;
 	init_mm.end_data = (unsigned long) &_edata;
 	init_mm.brk = (unsigned long) &_end;
 
-	code_resource.start = virt_to_bus(&_text);
-	code_resource.end = virt_to_bus(&_etext)-1;
-	data_resource.start = virt_to_bus(&_etext);
+	code_resource.start = virt_to_bus(&_text + __KERNEL_TEXT_OFFSET);
+	code_resource.end = virt_to_bus(&_etext + __KERNEL_TEXT_OFFSET)-1;
+	data_resource.start = virt_to_bus(&_data);
 	data_resource.end = virt_to_bus(&_edata)-1;
 
 	parse_cmdline_early(cmdline_p);
@@ -3164,7 +3168,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
@@ -3184,6 +3188,10 @@ void __init cpu_init (void)
 	int nr = smp_processor_id();
 	struct tss_struct * t = &init_tss[nr];
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (test_and_set_bit(nr, &cpu_initialized)) {
 		printk(KERN_WARNING "CPU#%d already initialized!\n", nr);
 		for (;;) __sti();
@@ -3218,10 +3226,19 @@ void __init cpu_init (void)
 		BUG();
 	enter_lazy_tlb(&init_mm, current, nr);
 
-	t->esp0 = current->thread.esp0;
 	set_tss_desc(nr,t);
-	gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	t->esp0 = current->thread.esp0;
 	load_TR(nr);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	load_LDT(&init_mm.context);
 
 	/*
@@ -3288,7 +3305,53 @@ int __init ppro_with_ram_bug(void)
 	printk(KERN_INFO "Your Pentium Pro seems ok.\n");
 	return 0;
 }
-	
+
+static int current_ypos = 25, current_xpos;
+#define VGABASE (0xb8000)
+#define VGAXY(x, y) (VGABASE + 2 * (x + y * SCREEN_INFO.orig_video_cols))
+
+static void early_vga_write(const char *str, int n)
+{
+	char c;
+	int  i, k, j;
+
+	while ((c = *str++) != '\0' && n-- > 0) {
+		if (current_ypos >= SCREEN_INFO.orig_video_lines) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < SCREEN_INFO.orig_video_lines; k++, j++) {
+				for (i = 0; i < SCREEN_INFO.orig_video_cols; i++) {
+					isa_writew(isa_readw(VGAXY(i, k)), VGAXY(i, j));
+				}
+			}
+			for (i = 0; i < SCREEN_INFO.orig_video_cols; i++)
+				isa_writew(0x720, VGAXY(i, j));
+			current_ypos = SCREEN_INFO.orig_video_lines-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			isa_writew((0x700 | (unsigned short) c), VGAXY(current_xpos, current_ypos));
+			if (++current_xpos >= SCREEN_INFO.orig_video_cols) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+asmlinkage void __init early_printk(const char *fmt, ...)
+{
+	char buf[512];
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vsnprintf(buf, 512, fmt, ap);
+	early_vga_write(buf, n);
+	va_end(ap);
+}
+
 /*
  * Local Variables:
  * mode:c
diff -urNp linux-2.4.37.7/arch/i386/kernel/sys_i386.c linux-2.4.37.7/arch/i386/kernel/sys_i386.c
--- linux-2.4.37.7/arch/i386/kernel/sys_i386.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/sys_i386.c	2009-11-10 19:30:27.000000000 -0500
@@ -48,6 +48,11 @@ static inline long do_mmap2(
 	int error = -EBADF;
 	struct file * file = NULL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR)
+		return -EINVAL;
+#endif
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
diff -urNp linux-2.4.37.7/arch/i386/kernel/trampoline.S linux-2.4.37.7/arch/i386/kernel/trampoline.S
--- linux-2.4.37.7/arch/i386/kernel/trampoline.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/trampoline.S	2009-11-10 19:30:27.000000000 -0500
@@ -54,7 +54,7 @@ r_base = .
 	lmsw	%ax		# into protected mode
 	jmp	flush_instr
 flush_instr:
-	ljmpl	$__KERNEL_CS, $0x00100000
+	ljmpl	$__KERNEL_CS, $SYMBOL_NAME(startup_32) + __KERNEL_TEXT_OFFSET - __PAGE_OFFSET
 			# jump to startup_32 in arch/i386/kernel/head.S
 
 idt_48:
@@ -62,8 +62,8 @@ idt_48:
 	.word	0, 0			# idt base = 0L
 
 gdt_48:
-	.word	0x0800			# gdt limit = 2048, 256 GDT entries
-	.long	gdt_table-__PAGE_OFFSET	# gdt base = gdt (first SMP CPU)
+	.word	__KERNEL_DS+7			# gdt limit = just the minimum
+	.long	boot_gdt_table-__PAGE_OFFSET	# gdt base = boot_gdt (first SMP CPU)
 
 .globl SYMBOL_NAME(trampoline_end)
 SYMBOL_NAME_LABEL(trampoline_end)
diff -urNp linux-2.4.37.7/arch/i386/kernel/traps.c linux-2.4.37.7/arch/i386/kernel/traps.c
--- linux-2.4.37.7/arch/i386/kernel/traps.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/traps.c	2009-11-10 19:30:27.000000000 -0500
@@ -54,15 +54,10 @@ asmlinkage int system_call(void);
 asmlinkage void lcall7(void);
 asmlinkage void lcall27(void);
 
-struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
+const struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
 		{ 0, 0 }, { 0, 0 } };
 
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.. We have a special link segment
- * for this.
- */
-struct desc_struct idt_table[256] __attribute__((__section__(".data.idt"))) = { {0, 0}, };
+extern struct desc_struct idt_table[256];
 
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
@@ -87,6 +82,7 @@ asmlinkage void machine_check(void);
 
 int kstack_depth_to_print = 24;
 
+extern char _text, _sinittext, _einittext;
 
 /*
  * If the address is either in the .text section of the
@@ -104,6 +100,10 @@ static inline int kernel_text_address(un
 	int retval = 0;
 	struct module *mod;
 
+	if (addr >= (unsigned long) &_sinittext &&
+	    addr <= (unsigned long) &_einittext)
+		return 1;
+
 	if (addr >= (unsigned long) &_stext &&
 	    addr <= (unsigned long) &_etext)
 		return 1;
@@ -125,8 +125,15 @@ static inline int kernel_text_address(un
 
 static inline int kernel_text_address(unsigned long addr)
 {
-	return (addr >= (unsigned long) &_stext &&
-		addr <= (unsigned long) &_etext);
+	if (addr >= (unsigned long) &_sinittext &&
+	    addr <= (unsigned long) &_einittext)
+		return 1;
+
+	if (addr >= (unsigned long) &_stext &&
+	    addr <= (unsigned long) &_etext)
+		return 1;
+
+	return 0;
 }
 
 #endif
@@ -228,13 +235,13 @@ void show_registers(struct pt_regs *regs
 		show_stack((unsigned long*)esp);
 
 		printk("\nCode: ");
-		if(regs->eip < PAGE_OFFSET)
+		if(regs->eip + __KERNEL_TEXT_OFFSET < PAGE_OFFSET)
 			goto bad;
 
 		for(i=0;i<20;i++)
 		{
 			unsigned char c;
-			if(__get_user(c, &((unsigned char*)regs->eip)[i])) {
+			if(__get_user(c, &((unsigned char*)regs->eip)[i+__KERNEL_TEXT_OFFSET])) {
 bad:
 				printk(" Bad EIP value.");
 				break;
@@ -256,7 +263,7 @@ static void handle_BUG(struct pt_regs *r
 	if (regs->xcs & 3)
 		goto no_bug;		/* Not in kernel */
 
-	eip = regs->eip;
+	eip = regs->eip + __KERNEL_TEXT_OFFSET;
 
 	if (eip < PAGE_OFFSET)
 		goto no_bug;
@@ -264,10 +271,11 @@ static void handle_BUG(struct pt_regs *r
 		goto no_bug;
 	if (ud2 != 0x0b0f)
 		goto no_bug;
-	if (__get_user(line, (unsigned short *)(eip + 2)))
+	if (__get_user(line, (unsigned short *)(eip + 7)))
 		goto bug;
-	if (__get_user(file, (char **)(eip + 4)) ||
-		(unsigned long)file < PAGE_OFFSET || __get_user(c, file))
+	if (__get_user(file, (char **)(eip + 3)) || file < &_text + __KERNEL_TEXT_OFFSET)
+		goto bug;
+	if (__get_user(c, file))
 		file = "<bad filename>";
 
 	printk("kernel BUG at %s:%d!\n", file, line);
@@ -422,6 +430,13 @@ gp_in_kernel:
 			regs->eip = fixup;
 			return;
 		}
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if ((regs->xcs & 0xFFFF) == __KERNEL_CS)
+			die("PAX: suspicious general protection fault", regs, error_code);
+		else
+#endif
+
 		die("general protection fault", regs, error_code);
 	}
 }
@@ -527,13 +542,12 @@ asmlinkage void do_debug(struct pt_regs 
 {
 	unsigned int condition;
 	struct task_struct *tsk = current;
-	unsigned long eip = regs->eip;
 	siginfo_t info;
 
 	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
 
 	/* If the user set TF, it's simplest to clear it right away. */
-	if ((eip >=PAGE_OFFSET) && (regs->eflags & TF_MASK))
+	if (!(regs->xcs & 3) && (regs->eflags & TF_MASK) && !(regs->eflags & VM_MASK))
 		goto clear_TF;
 
 	/* Mask out spurious debug traps due to lazy DR7 setting */
@@ -778,6 +792,8 @@ asmlinkage void math_emulate(long arg)
 #ifndef CONFIG_X86_F00F_WORKS_OK
 void __init trap_init_f00f_bug(void)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	/*
 	 * "idt" is magic - it overlaps the idt_descr
 	 * variable so that updating idt will automatically
@@ -787,12 +803,17 @@ void __init trap_init_f00f_bug(void)
 	idt = (struct desc_struct *)__fix_to_virt(FIX_F00F);
 
 	__asm__ __volatile__("lidt %0": "=m" (idt_descr));
+#endif
+
 }
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
 #define _set_gate(gate_addr,type,dpl,addr) \
 do { \
   int __d0, __d1; \
+  unsigned long cr0; \
+  pax_open_kernel(cr0); \
   __asm__ __volatile__ ("movw %%dx,%%ax\n\t" \
 	"movw %4,%%dx\n\t" \
 	"movl %%eax,%0\n\t" \
@@ -801,8 +822,22 @@ do { \
 	 "=m" (*(1+(long *) (gate_addr))), "=&a" (__d0), "=&d" (__d1) \
 	:"i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
 	 "3" ((char *) (addr)),"2" (__KERNEL_CS << 16)); \
+  pax_close_kernel(cr0); \
 } while (0)
-
+#else
+#define _set_gate(gate_addr,type,dpl,addr) \
+do { \
+  int __d0, __d1; \
+  __asm__ __volatile__ ("movw %%dx,%%ax\n\t" \
+	"movw %4,%%dx\n\t" \
+	"movl %%eax,%0\n\t" \
+	"movl %%edx,%1" \
+	:"=m" (*((long *) (gate_addr))), \
+	 "=m" (*(1+(long *) (gate_addr))), "=&a" (__d0), "=&d" (__d1) \
+	:"i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
+	 "3" ((char *) (addr)),"2" (__KERNEL_CS << 16)); \
+} while (0)
+#endif
 
 /*
  * This needs to use 'idt_table' rather than 'idt', and
@@ -810,26 +845,42 @@ do { \
  * Pentium F0 0F bugfix can have resulted in the mapped
  * IDT being write-protected.
  */
-void set_intr_gate(unsigned int n, void *addr)
+void set_intr_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,14,0,addr);
 }
 
-static void __init set_trap_gate(unsigned int n, void *addr)
+static void __init set_trap_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,15,0,addr);
 }
 
-static void __init set_system_gate(unsigned int n, void *addr)
+static void __init set_system_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,15,3,addr);
 }
 
-static void __init set_call_gate(void *a, void *addr)
+static void __init set_call_gate(const void *a, const void *addr)
 {
 	_set_gate(a,12,3,addr);
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define _set_seg_desc(gate_addr,type,dpl,base,limit) \
+do {\
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*((gate_addr)+1) = ((base) & 0xff000000) | \
+		(((base) & 0x00ff0000)>>16) | \
+		((limit) & 0xf0000) | \
+		((dpl)<<13) | \
+		(0x00408000) | \
+		((type)<<8); \
+	*(gate_addr) = (((base) & 0x0000ffff)<<16) | \
+		((limit) & 0x0ffff); \
+	pax_close_kernel(cr0); \
+} while (0)
+#else
 #define _set_seg_desc(gate_addr,type,dpl,base,limit) {\
 	*((gate_addr)+1) = ((base) & 0xff000000) | \
 		(((base) & 0x00ff0000)>>16) | \
@@ -839,7 +890,25 @@ static void __init set_call_gate(void *a
 		((type)<<8); \
 	*(gate_addr) = (((base) & 0x0000ffff)<<16) | \
 		((limit) & 0x0ffff); }
+#endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define _set_tssldt_desc(n,addr,limit,type) \
+do { \
+  unsigned long cr0; \
+  pax_open_kernel(cr0); \
+  __asm__ __volatile__ ("movw %w3,0(%2)\n\t" \
+	"movw %%ax,2(%2)\n\t" \
+	"rorl $16,%%eax\n\t" \
+	"movb %%al,4(%2)\n\t" \
+	"movb %4,5(%2)\n\t" \
+	"movb $0,6(%2)\n\t" \
+	"movb %%ah,7(%2)\n\t" \
+	"rorl $16,%%eax" \
+	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type)); \
+  pax_close_kernel(cr0); \
+} while (0)
+#else
 #define _set_tssldt_desc(n,addr,limit,type) \
 __asm__ __volatile__ ("movw %w3,0(%2)\n\t" \
 	"movw %%ax,2(%2)\n\t" \
@@ -850,15 +919,26 @@ __asm__ __volatile__ ("movw %w3,0(%2)\n\
 	"movb %%ah,7(%2)\n\t" \
 	"rorl $16,%%eax" \
 	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type))
+#endif
 
-void set_tss_desc(unsigned int n, void *addr)
+void set_tss_desc(unsigned int n, const void *addr)
 {
 	_set_tssldt_desc(gdt_table+__TSS(n), (int)addr, 235, 0x89);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	_set_tssldt_desc(gdt_table2+__TSS(n), (int)addr, 235, 0x89);
+#endif
+
 }
 
-void set_ldt_desc(unsigned int n, void *addr, unsigned int size)
+void set_ldt_desc(unsigned int n, const void *addr, unsigned int size)
 {
 	_set_tssldt_desc(gdt_table+__LDT(n), (int)addr, ((size << 3)-1), 0x82);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	_set_tssldt_desc(gdt_table2+__LDT(n), (int)addr, ((size << 3)-1), 0x82);
+#endif
+
 }
 
 #ifdef CONFIG_X86_VISWS_APIC
diff -urNp linux-2.4.37.7/arch/i386/kernel/vm86.c linux-2.4.37.7/arch/i386/kernel/vm86.c
--- linux-2.4.37.7/arch/i386/kernel/vm86.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/kernel/vm86.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,6 +44,7 @@
 #include <asm/pgalloc.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/desc.h>
 
 /*
  * Known problems:
@@ -97,6 +98,10 @@ struct pt_regs * fastcall save_v86_state
 	struct pt_regs *ret;
 	unsigned long tmp;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (!current->thread.vm86_info) {
 		printk("no vm86_info: BAD\n");
 		do_exit(SIGSEGV);
@@ -111,7 +116,17 @@ struct pt_regs * fastcall save_v86_state
 		do_exit(SIGSEGV);
 	}
 	tss = init_tss + smp_processor_id();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	tss->esp0 = current->thread.esp0 = current->thread.saved_esp0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	current->thread.saved_esp0 = 0;
 	ret = KVM86->regs32;
 	return ret;
@@ -237,6 +252,11 @@ out:
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk)
 {
 	struct tss_struct *tss;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr3;
+#endif
+
 /*
  * make sure the vm86() system call doesn't try to do anything silly
  */
@@ -278,8 +298,17 @@ static void do_sys_vm86(struct kernel_vm
 	info->regs32->eax = 0;
 	tsk->thread.saved_esp0 = tsk->thread.esp0;
 	tss = init_tss + smp_processor_id();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr3);
+#endif
+
 	tss->esp0 = tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr3);
+#endif
+
 	tsk->thread.screen_bitmap = info->screen_bitmap;
 	if (info->flags & VM86_SCREEN_BITMAP)
 		mark_screen_rdonly(tsk);
diff -urNp linux-2.4.37.7/arch/i386/lib/checksum.S linux-2.4.37.7/arch/i386/lib/checksum.S
--- linux-2.4.37.7/arch/i386/lib/checksum.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/lib/checksum.S	2009-11-10 19:30:27.000000000 -0500
@@ -27,7 +27,8 @@
 
 #include <linux/config.h>
 #include <asm/errno.h>
-				
+#include <asm/segment.h>
+
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
  */
@@ -281,12 +282,23 @@ unsigned int csum_partial_copy_generic (
 
 .align 4
 .globl csum_partial_copy_generic
-				
+.globl csum_partial_copy_generic_to_user
+.globl csum_partial_copy_generic_from_user
+
 #ifndef CONFIG_X86_USE_PPRO_CHECKSUM
 
 #define ARGBASE 16		
 #define FP		12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	subl  $4,%esp	
 	pushl %edi
@@ -305,7 +317,7 @@ csum_partial_copy_generic:
 	jmp 4f
 SRC(1:	movw (%esi), %bx	)
 	addl $2, %esi
-DST(	movw %bx, (%edi)	)
+DST(	movw %bx, %es:(%edi)	)
 	addl $2, %edi
 	addw %bx, %ax	
 	adcl $0, %eax
@@ -317,30 +329,30 @@ DST(	movw %bx, (%edi)	)
 SRC(1:	movl (%esi), %ebx	)
 SRC(	movl 4(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 4(%edi)	)
+DST(	movl %edx, %es:4(%edi)	)
 
 SRC(	movl 8(%esi), %ebx	)
 SRC(	movl 12(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 8(%edi)	)
+DST(	movl %ebx, %es:8(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 12(%edi)	)
+DST(	movl %edx, %es:12(%edi)	)
 
 SRC(	movl 16(%esi), %ebx 	)
 SRC(	movl 20(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 16(%edi)	)
+DST(	movl %ebx, %es:16(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 20(%edi)	)
+DST(	movl %edx, %es:20(%edi)	)
 
 SRC(	movl 24(%esi), %ebx	)
 SRC(	movl 28(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 24(%edi)	)
+DST(	movl %ebx, %es:24(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 28(%edi)	)
+DST(	movl %edx, %es:28(%edi)	)
 
 	lea 32(%esi), %esi
 	lea 32(%edi), %edi
@@ -354,7 +366,7 @@ DST(	movl %edx, 28(%edi)	)
 	shrl $2, %edx			# This clears CF
 SRC(3:	movl (%esi), %ebx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	lea 4(%esi), %esi
 	lea 4(%edi), %edi
 	dec %edx
@@ -366,12 +378,12 @@ DST(	movl %ebx, (%edi)	)
 	jb 5f
 SRC(	movw (%esi), %cx	)
 	leal 2(%esi), %esi
-DST(	movw %cx, (%edi)	)
+DST(	movw %cx, %es:(%edi)	)
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%ecx
 SRC(5:	movb (%esi), %cl	)
-DST(	movb %cl, (%edi)	)
+DST(	movb %cl, %es:(%edi)	)
 6:	addl %ecx, %eax
 	adcl $0, %eax
 7:
@@ -382,7 +394,7 @@ DST(	movb %cl, (%edi)	)
 
 6001:
 	movl ARGBASE+20(%esp), %ebx	# src_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 
 	# zero the complete destination - computing the rest
 	# is too much work 
@@ -395,11 +407,15 @@ DST(	movb %cl, (%edi)	)
 
 6002:
 	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT,(%ebx)
+	movl $-EFAULT,%ss:(%ebx)
 	jmp 5000b
 
 .previous
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %ebx
 	popl %esi
 	popl %edi
@@ -411,17 +427,28 @@ DST(	movb %cl, (%edi)	)
 /* Version for PentiumII/PPro */
 
 #define ROUND1(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	addl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	; 
+	DST(movl %ebx, %es:x(%edi));
 
 #define ROUND(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	adcl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	;
+	DST(movl %ebx, %es:x(%edi));
 
 #define ARGBASE 12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	pushl %ebx
 	pushl %edi
@@ -440,7 +467,7 @@ csum_partial_copy_generic:
 	subl %ebx, %edi  
 	lea  -1(%esi),%edx
 	andl $-32,%edx
-	lea 3f(%ebx,%ebx), %ebx
+	lea 3f(%ebx,%ebx,2), %ebx
 	testl %esi, %esi 
 	jmp *%ebx
 1:	addl $64,%esi
@@ -461,19 +488,19 @@ csum_partial_copy_generic:
 	jb 5f
 SRC(	movw (%esi), %dx         )
 	leal 2(%esi), %esi
-DST(	movw %dx, (%edi)         )
+DST(	movw %dx, %es:(%edi)     )
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%edx
 5:
 SRC(	movb (%esi), %dl         )
-DST(	movb %dl, (%edi)         )
+DST(	movb %dl, %es:(%edi)     )
 6:	addl %edx, %eax
 	adcl $0, %eax
 7:
 .section .fixup, "ax"
 6001:	movl	ARGBASE+20(%esp), %ebx	# src_err_ptr	
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	# zero the complete destination (computing the rest is too much work)
 	movl ARGBASE+8(%esp),%edi	# dst
 	movl ARGBASE+12(%esp),%ecx	# len
@@ -481,10 +508,14 @@ DST(	movb %dl, (%edi)         )
 	rep; stosb
 	jmp 7b
 6002:	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	jmp  7b			
 .previous				
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %esi
 	popl %edi
 	popl %ebx
diff -urNp linux-2.4.37.7/arch/i386/lib/getuser.S linux-2.4.37.7/arch/i386/lib/getuser.S
--- linux-2.4.37.7/arch/i386/lib/getuser.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/lib/getuser.S	2009-11-10 19:30:27.000000000 -0500
@@ -9,6 +9,8 @@
  * return value.
  */
 
+#include <asm/segment.h>
+
 /*
  * __get_user_X
  *
@@ -31,7 +33,11 @@ __get_user_1:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movzbl (%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
@@ -44,7 +50,11 @@ __get_user_2:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movzwl -1(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
@@ -57,11 +67,17 @@ __get_user_4:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl -3(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
 bad_get_user:
+	pushl %ss
+	pop %ds
 	xorl %edx,%edx
 	movl $-14,%eax
 	ret
diff -urNp linux-2.4.37.7/arch/i386/lib/mmx.c linux-2.4.37.7/arch/i386/lib/mmx.c
--- linux-2.4.37.7/arch/i386/lib/mmx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/lib/mmx.c	2009-11-10 19:30:27.000000000 -0500
@@ -30,6 +30,7 @@ void *_mmx_memcpy(void *to, const void *
 {
 	void *p;
 	int i;
+	unsigned long cr0;
 
 	if (in_interrupt())
 		return __memcpy(to, from, len);
@@ -40,52 +41,80 @@ void *_mmx_memcpy(void *to, const void *
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"		/* This set is 28 bytes */
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"		/* This set is 28 bytes */
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 		
 	
 	for(; i>5; i--)
 	{
 		__asm__ __volatile__ (
-		"1:  prefetch 320(%0)\n"
-		"2:  movq (%0), %%mm0\n"
-		"  movq 8(%0), %%mm1\n"
-		"  movq 16(%0), %%mm2\n"
-		"  movq 24(%0), %%mm3\n"
-		"  movq %%mm0, (%1)\n"
-		"  movq %%mm1, 8(%1)\n"
-		"  movq %%mm2, 16(%1)\n"
-		"  movq %%mm3, 24(%1)\n"
-		"  movq 32(%0), %%mm0\n"
-		"  movq 40(%0), %%mm1\n"
-		"  movq 48(%0), %%mm2\n"
-		"  movq 56(%0), %%mm3\n"
-		"  movq %%mm0, 32(%1)\n"
-		"  movq %%mm1, 40(%1)\n"
-		"  movq %%mm2, 48(%1)\n"
-		"  movq %%mm3, 56(%1)\n"
+		"1:  prefetch 320(%1)\n"
+		"2:  movq (%1), %%mm0\n"
+		"  movq 8(%1), %%mm1\n"
+		"  movq 16(%1), %%mm2\n"
+		"  movq 24(%1), %%mm3\n"
+		"  movq %%mm0, (%2)\n"
+		"  movq %%mm1, 8(%2)\n"
+		"  movq %%mm2, 16(%2)\n"
+		"  movq %%mm3, 24(%2)\n"
+		"  movq 32(%1), %%mm0\n"
+		"  movq 40(%1), %%mm1\n"
+		"  movq 48(%1), %%mm2\n"
+		"  movq 56(%1), %%mm3\n"
+		"  movq %%mm0, 32(%2)\n"
+		"  movq %%mm1, 40(%2)\n"
+		"  movq %%mm2, 48(%2)\n"
+		"  movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -164,6 +193,7 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
@@ -171,51 +201,79 @@ static void fast_copy_page(void *to, voi
 	 * but that is for later. -AV
 	 */
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 
 	for(i=0; i<(4096-320)/64; i++)
 	{
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movntq %%mm0, (%1)\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movntq %%mm1, 8(%1)\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movntq %%mm2, 16(%1)\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movntq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm4\n"
-		"   movntq %%mm4, 32(%1)\n"
-		"   movq 40(%0), %%mm5\n"
-		"   movntq %%mm5, 40(%1)\n"
-		"   movq 48(%0), %%mm6\n"
-		"   movntq %%mm6, 48(%1)\n"
-		"   movq 56(%0), %%mm7\n"
-		"   movntq %%mm7, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movntq %%mm0, (%2)\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movntq %%mm1, 8(%2)\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movntq %%mm2, 16(%2)\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movntq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm4\n"
+		"   movntq %%mm4, 32(%2)\n"
+		"   movq 40(%1), %%mm5\n"
+		"   movntq %%mm5, 40(%2)\n"
+		"   movq 48(%1), %%mm6\n"
+		"   movntq %%mm6, 48(%2)\n"
+		"   movq 56(%1), %%mm7\n"
+		"   movntq %%mm7, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -296,56 +354,84 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
-	
-	
+	unsigned long cr0;
+
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 
 	for(i=0; i<4096/64; i++)
 	{
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movq %%mm0, (%1)\n"
-		"   movq %%mm1, 8(%1)\n"
-		"   movq %%mm2, 16(%1)\n"
-		"   movq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm0\n"
-		"   movq 40(%0), %%mm1\n"
-		"   movq 48(%0), %%mm2\n"
-		"   movq 56(%0), %%mm3\n"
-		"   movq %%mm0, 32(%1)\n"
-		"   movq %%mm1, 40(%1)\n"
-		"   movq %%mm2, 48(%1)\n"
-		"   movq %%mm3, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movq %%mm0, (%2)\n"
+		"   movq %%mm1, 8(%2)\n"
+		"   movq %%mm2, 16(%2)\n"
+		"   movq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm0\n"
+		"   movq 40(%1), %%mm1\n"
+		"   movq 48(%1), %%mm2\n"
+		"   movq 56(%1), %%mm3\n"
+		"   movq %%mm0, 32(%2)\n"
+		"   movq %%mm1, 40(%2)\n"
+		"   movq %%mm2, 48(%2)\n"
+		"   movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
diff -urNp linux-2.4.37.7/arch/i386/lib/usercopy.c linux-2.4.37.7/arch/i386/lib/usercopy.c
--- linux-2.4.37.7/arch/i386/lib/usercopy.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/lib/usercopy.c	2009-11-10 19:30:27.000000000 -0500
@@ -8,6 +8,7 @@
 #include <linux/config.h>
 #include <asm/uaccess.h>
 #include <asm/mmx.h>
+#include <asm/segment.h>
 
 #ifdef CONFIG_X86_USE_3DNOW_AND_WORKS
 
@@ -75,6 +76,11 @@ __generic_copy_from_user(void *to, const
 do {									   \
 	int __d0, __d1, __d2;						   \
 	__asm__ __volatile__(						   \
+		"	movw %w0,%%ds\n"				   \
+		:							   \
+		: "r"(__USER_DS)					   \
+		: "memory");						   \
+	__asm__ __volatile__(						   \
 		"	testl %1,%1\n"					   \
 		"	jz 2f\n"					   \
 		"0:	lodsb\n"					   \
@@ -85,6 +91,8 @@ do {									   \
 		"	jnz 0b\n"					   \
 		"1:	subl %1,%0\n"					   \
 		"2:\n"							   \
+		"	pushl %%ss\n"					   \
+		"	popl %%ds\n"					   \
 		".section .fixup,\"ax\"\n"				   \
 		"3:	movl %5,%0\n"					   \
 		"	jmp 2b\n"					   \
@@ -163,10 +171,13 @@ strncpy_from_user(char *dst, const char 
 do {									\
 	int __d0;							\
   	__asm__ __volatile__(						\
+		"	movw %w6,%%es\n"				\
 		"0:	rep; stosl\n"					\
 		"	movl %2,%0\n"					\
 		"1:	rep; stosb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%es\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%2,%0,4),%0\n"				\
 		"	jmp 2b\n"					\
@@ -177,7 +188,8 @@ do {									\
 		"	.long 1b,2b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0)				\
-		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0));	\
+		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0),	\
+		  "r"(__USER_DS));					\
 } while (0)
 
 /**
@@ -233,6 +245,7 @@ long strnlen_user(const char *s, long n)
 	unsigned long res, tmp;
 
 	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
 		"	testl %0, %0\n"
 		"	jz 3f\n"
 		"	andl %0,%%ecx\n"
@@ -241,6 +254,8 @@ long strnlen_user(const char *s, long n)
 		"	subl %%ecx,%0\n"
 		"	addl %0,%%eax\n"
 		"1:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
 		".section .fixup,\"ax\"\n"
 		"2:	xorl %%eax,%%eax\n"
 		"	jmp 1b\n"
@@ -252,7 +267,7 @@ long strnlen_user(const char *s, long n)
 		"	.long 0b,2b\n"
 		".previous"
 		:"=r" (n), "=D" (s), "=a" (res), "=c" (tmp)
-		:"0" (n), "1" (s), "2" (0), "3" (mask)
+		:"0" (n), "1" (s), "2" (0), "3" (mask), "r" (__USER_DS)
 		:"cc");
 	return res & mask;
 }
diff -urNp linux-2.4.37.7/arch/i386/Makefile linux-2.4.37.7/arch/i386/Makefile
--- linux-2.4.37.7/arch/i386/Makefile	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/Makefile	2009-11-10 19:30:27.000000000 -0500
@@ -123,6 +123,9 @@ arch/i386/mm: dummy
 
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
 
+arch/i386/vmlinux.lds: arch/i386/vmlinux.lds.S FORCE
+	$(CPP) -C -P -I$(HPATH) -D__KERNEL__ -imacros $(HPATH)/linux/config.h -imacros $(HPATH)/asm-i386/segment.h -imacros $(HPATH)/asm-i386/page.h -Ui386 arch/i386/vmlinux.lds.S >arch/i386/vmlinux.lds
+
 vmlinux: arch/i386/vmlinux.lds
 
 FORCE: ;
@@ -159,6 +162,7 @@ archclean:
 	@$(MAKEBOOT) clean
 
 archmrproper:
+	rm -f arch/i386/vmlinux.lds
 
 archdep:
 	@$(MAKEBOOT) dep
diff -urNp linux-2.4.37.7/arch/i386/mm/fault.c linux-2.4.37.7/arch/i386/mm/fault.c
--- linux-2.4.37.7/arch/i386/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -19,6 +19,8 @@
 #include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/unistd.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -78,6 +80,12 @@ good_area:
 check_stack:
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < start - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, start) == 0)
 		goto good_area;
 
@@ -125,7 +133,10 @@ void bust_spinlocks(int yes)
 }
 
 asmlinkage void do_invalid_op(struct pt_regs *, unsigned long);
-extern unsigned long idt;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -137,23 +148,31 @@ extern unsigned long idt;
  *	bit 1 == 0 means read, 1 means write
  *	bit 2 == 0 means kernel, 1 means user-mode
  */
-asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+static int do_page_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+#else
+asmlinkage int do_page_fault(struct pt_regs *regs, unsigned long error_code)
+#endif
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
+#ifndef CONFIG_PAX_PAGEEXEC
 	unsigned long address;
-	unsigned long page;
+#endif
 	unsigned long fixup;
 	int write;
 	siginfo_t info;
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
 
 	/* It's safe to allow irq's after cr2 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
 		local_irq_enable();
+#endif
 
 	tsk = current;
 
@@ -202,6 +221,12 @@ asmlinkage void do_page_fault(struct pt_
 		if (address + 32 < regs->esp)
 			goto bad_area;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < address - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, address))
 		goto bad_area;
 /*
@@ -258,7 +283,7 @@ good_area:
 			tsk->thread.screen_bitmap |= 1 << bit;
 	}
 	up_read(&mm->mmap_sem);
-	return;
+	return 0;
 
 /*
  * Something tried to access memory that isn't in our memory map..
@@ -267,6 +292,38 @@ good_area:
 bad_area:
 	up_read(&mm->mmap_sem);
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if ((error_code & 4) && !(regs->eflags & X86_EFLAGS_VM)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(error_code & 3) && (regs->eip == address)) {
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && !(error_code & 3) && (regs->eip + SEGMEXEC_TASK_SIZE == address)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 4:
+				return 0;
+
+			case 3:
+			case 2:
+				return 1;
+			}
+#endif
+
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+	}
+#endif
+
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
 		tsk->thread.cr2 = address;
@@ -278,7 +335,7 @@ bad_area:
 		/* info.si_code has been set above */
 		info.si_addr = (void *)address;
 		force_sig_info(SIGSEGV, &info, tsk);
-		return;
+		return 0;
 	}
 
 	/*
@@ -287,11 +344,11 @@ bad_area:
 	if (boot_cpu_data.f00f_bug) {
 		unsigned long nr;
 		
-		nr = (address - idt) >> 3;
+		nr = (address - (unsigned long)idt) >> 3;
 
 		if (nr == 6) {
 			do_invalid_op(regs, 0);
-			return;
+			return 0;
 		}
 	}
 
@@ -299,7 +356,7 @@ no_context:
 	/* Are we prepared to handle this kernel fault?  */
 	if ((fixup = search_exception_table(regs->eip)) != 0) {
 		regs->eip = fixup;
-		return;
+		return 0;
 	}
 
 /*
@@ -311,19 +368,41 @@ no_context:
 
 	if (address < PAGE_SIZE)
 		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	else if (init_mm.start_code <= address && address < init_mm.end_code) {
+		if (tsk->curr_ip)
+			printk(KERN_ERR "PAX: From %u.%u.%u.%u: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+					 NIPQUAD(tsk->curr_ip), tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+		else
+			printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+					 tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+	}
+#endif
+
 	else
 		printk(KERN_ALERT "Unable to handle kernel paging request");
 	printk(" at virtual address %08lx\n",address);
 	printk(" printing eip:\n");
 	printk("%08lx\n", regs->eip);
-	asm("movl %%cr3,%0":"=r" (page));
-	page = ((unsigned long *) __va(page))[address >> 22];
-	printk(KERN_ALERT "*pde = %08lx\n", page);
-	if (page & 1) {
-		page &= PAGE_MASK;
-		address &= 0x003ff000;
-		page = ((unsigned long *) __va(page))[address >> PAGE_SHIFT];
-		printk(KERN_ALERT "*pte = %08lx\n", page);
+	{
+		unsigned long index = pgd_index(address);
+		unsigned long pgd_paddr;
+		pgd_t *pgd;
+		pmd_t *pmd;
+		pte_t *pte;
+
+		asm("movl %%cr3,%0":"=r" (pgd_paddr));
+		pgd = index + (pgd_t *)__va(pgd_paddr);
+		printk(KERN_ALERT "*pgd = %*llx\n", sizeof(*pgd), (unsigned long long)pgd_val(*pgd));
+		if (pgd_present(*pgd)) {
+			pmd = pmd_offset(pgd, address);
+			printk(KERN_ALERT "*pmd = %*llx\n", sizeof(*pmd), (unsigned long long)pmd_val(*pmd));
+			if (pmd_present(*pmd) && !(pmd_val(*pmd) & _PAGE_PSE)) {
+				pte = pte_offset(pmd, address);
+				printk(KERN_ALERT "*pte = %*llx\n", sizeof(*pte), (unsigned long long)pte_val(*pte));
+			}
+		}
 	}
 	die("Oops", regs, error_code);
 	bust_spinlocks(0);
@@ -363,7 +442,7 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!(error_code & 4))
 		goto no_context;
-	return;
+	return 0;
 
 vmalloc_fault:
 	{
@@ -396,6 +475,333 @@ vmalloc_fault:
 		pte_k = pte_offset(pmd_k, address);
 		if (!pte_present(*pte_k))
 			goto no_context;
-		return;
+		return 0;
 	}
 }
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/* PaX: called with the page_table_lock spinlock held */
+static inline pte_t * pax_get_pte(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd_present(*pgd))
+		return NULL;
+	pmd = pmd_offset(pgd, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	return pte_offset(pmd, address);
+}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+/*
+ * PaX: decide what to do with offenders (regs->eip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when sigreturn trampoline was detected
+ *         3 when rt_sigreturn trampoline was detected
+ *         4 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	static const unsigned char trans[8] = {
+		offsetof(struct pt_regs, eax) / 4,
+		offsetof(struct pt_regs, ecx) / 4,
+		offsetof(struct pt_regs, edx) / 4,
+		offsetof(struct pt_regs, ebx) / 4,
+		offsetof(struct pt_regs, esp) / 4,
+		offsetof(struct pt_regs, ebp) / 4,
+		offsetof(struct pt_regs, esi) / 4,
+		offsetof(struct pt_regs, edi) / 4,
+	};
+	int err;
+
+	if (regs->eflags & X86_EFLAGS_VM)
+		return 1;
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: sigreturn emulation */
+		unsigned char pop, mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = get_user(pop, (unsigned char *)(regs->eip));
+		err |= get_user(mov, (unsigned char *)(regs->eip + 1));
+		err |= get_user(nr, (unsigned long *)(regs->eip + 2));
+		err |= get_user(sys, (unsigned short *)(regs->eip + 6));
+
+		if (err)
+			break;
+
+		if (pop == 0x58 &&
+		    mov == 0xb8 &&
+		    nr == __NR_sigreturn &&
+		    sys == 0x80cd)
+		{
+
+#ifdef CONFIG_PAX_EMUSIGRT
+			int sig;
+			struct k_sigaction *ka;
+			__sighandler_t handler;
+
+			if (get_user(sig, (int *)regs->esp))
+				return 1;
+			if (sig < 1 || sig > _NSIG || sig == SIGKILL || sig == SIGSTOP)
+				return 1;
+			spin_lock_irq(&current->sigmask_lock);
+			ka = &current->sig->action[sig-1];
+			handler = ka->sa.sa_handler;
+			if (handler == SIG_DFL || handler == SIG_IGN) {
+				if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+					err = 1;
+			} else if (ka->sa.sa_flags & SA_SIGINFO)
+				err = 1;
+			spin_unlock_irq(&current->sigmask_lock);
+			if (err)
+				return 1;
+#endif
+
+			regs->esp += 4;
+			regs->eax = nr;
+			regs->eip += 8;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned char mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = get_user(mov, (unsigned char *)(regs->eip));
+		err |= get_user(nr, (unsigned long *)(regs->eip + 1));
+		err |= get_user(sys, (unsigned short *)(regs->eip + 5));
+
+		if (err)
+			break;
+
+		if (mov == 0xb8 &&
+		    nr == __NR_rt_sigreturn &&
+		    sys == 0x80cd)
+		{
+
+#ifdef CONFIG_PAX_EMUSIGRT
+			int sig;
+			struct k_sigaction *ka;
+			__sighandler_t handler;
+
+			if (get_user(sig, (int *)regs->esp))
+				return 1;
+			if (sig < 1 || sig > _NSIG || sig == SIGKILL || sig == SIGSTOP)
+				return 1;
+			spin_lock_irq(&current->sigmask_lock);
+			ka = &current->sig->action[sig-1];
+			handler = ka->sa.sa_handler;
+			if (handler == SIG_DFL || handler == SIG_IGN) {
+				if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+					err = 1;
+			} else if (!(ka->sa.sa_flags & SA_SIGINFO))
+				err = 1;
+			spin_unlock_irq(&current->sigmask_lock);
+			if (err)
+				return 1;
+#endif
+
+			regs->eax = nr;
+			regs->eip += 7;
+			return 3;
+		}
+	} while (0);
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(mov2, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(jmp, (unsigned short *)(regs->eip + 10));
+
+		if (err)
+			break;
+
+		if ((mov1 & 0xF8) == 0xB8 &&
+		    (mov2 & 0xF8) == 0xB8 &&
+		    (mov1 & 0x07) != (mov2 & 0x07) &&
+		    (jmp & 0xF8FF) == 0xE0FF &&
+		    (mov2 & 0x07) == ((jmp>>8) & 0x07))
+		{
+			((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+			((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+			regs->eip = addr2;
+			return 4;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9)
+		{
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 4;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char*)pc+i))
+			printk("?? ");
+		else
+			printk("%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-4: ");
+	for (i = -1; i < 20; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long*)sp+i))
+			printk("???????? ");
+		else
+			printk("%08lx ", c);
+	}
+	printk("\n");
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: handle the extra page faults or pass it down to the original handler
+ *
+ * returns 0 when nothing special was detected
+ *         1 when sigreturn trampoline (syscall) has to be emulated
+ */
+asmlinkage int pax_do_page_fault(struct pt_regs *regs, unsigned long error_code)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long address;
+	pte_t *pte;
+	unsigned char pte_mask;
+
+	__asm__("movl %%cr2,%0":"=r" (address));
+
+	/* It's safe to allow irq's after cr2 has been saved */
+	if (likely(regs->eflags & X86_EFLAGS_IF))
+		local_irq_enable();
+
+	if (unlikely((error_code & 5) != 5 ||
+		     address >= TASK_SIZE ||
+		     (regs->eflags & X86_EFLAGS_VM) ||
+		     !mm || !(mm->pax_flags & MF_PAX_PAGEEXEC)))
+		return do_page_fault(regs, error_code, address);
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & 2) && (regs->eip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		switch (pax_handle_fetch_fault(regs)) {
+		case 4:
+			return 0;
+
+		case 3:
+		case 2:
+			return 1;
+		}
+#endif
+
+		pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+		do_exit(SIGKILL);
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & 2) << (_PAGE_BIT_DIRTY-1));
+
+	spin_lock(&mm->page_table_lock);
+	pte = pax_get_pte(mm, address);
+	if (unlikely(!pte || !(pte_val(*pte) & _PAGE_PRESENT) || pte_exec(*pte))) {
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		return 0;
+	}
+
+	if (unlikely((error_code & 2) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		return 0;
+	}
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"movw %w4,%%es\n"
+#endif
+		"orb %2,(%1)\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg (%0)\n"
+#endif
+		"testb $0,%%es:(%0)\n"
+		"xorb %3,(%1)\n"
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"pushl %%ss\n"
+		"popl %%es\n"
+#endif
+		:
+		: "q" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER), "r" (__USER_DS)
+		: "memory", "cc");
+	spin_unlock(&mm->page_table_lock);
+	return 0;
+}
+#endif
diff -urNp linux-2.4.37.7/arch/i386/mm/init.c linux-2.4.37.7/arch/i386/mm/init.c
--- linux-2.4.37.7/arch/i386/mm/init.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/mm/init.c	2009-11-10 19:30:27.000000000 -0500
@@ -37,6 +37,7 @@
 #include <asm/e820.h>
 #include <asm/apic.h>
 #include <asm/tlb.h>
+#include <asm/desc.h>
 
 mmu_gather_t mmu_gathers[NR_CPUS];
 unsigned long highstart_pfn, highend_pfn;
@@ -122,7 +123,7 @@ void show_mem(void)
 
 /* References to section boundaries */
 
-extern char _text, _etext, _edata, __bss_start, _end;
+extern char _text, _etext, _data, _edata, __bss_start, _end;
 extern char __init_begin, __init_end;
 
 static inline void set_pte_phys (unsigned long vaddr,
@@ -178,17 +179,7 @@ static void __init fixrange_init (unsign
 	pgd = pgd_base + i;
 
 	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-#if CONFIG_X86_PAE
-		if (pgd_none(*pgd)) {
-			pmd = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-			set_pgd(pgd, __pgd(__pa(pmd) + 0x1));
-			if (pmd != pmd_offset(pgd, 0))
-				printk("PAE BUG #02!\n");
-		}
 		pmd = pmd_offset(pgd, vaddr);
-#else
-		pmd = (pmd_t *)pgd;
-#endif
 		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
 			if (pmd_none(*pmd)) {
 				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
@@ -217,25 +208,22 @@ static void __init pagetable_init (void)
 	end = (unsigned long)__va(max_low_pfn*PAGE_SIZE);
 
 	pgd_base = swapper_pg_dir;
-#if CONFIG_X86_PAE
-	for (i = 0; i < PTRS_PER_PGD; i++)
-		set_pgd(pgd_base + i, __pgd(1 + __pa(empty_zero_page)));
-#endif
 	i = __pgd_offset(PAGE_OFFSET);
 	pgd = pgd_base + i;
 
+	if (cpu_has_pse) {
+		set_in_cr4(X86_CR4_PSE);
+		boot_cpu_data.wp_works_ok = 1;
+
+		if (cpu_has_pge)
+			set_in_cr4(X86_CR4_PGE);
+	}
+
 	for (; i < PTRS_PER_PGD; pgd++, i++) {
 		vaddr = i*PGDIR_SIZE;
 		if (end && (vaddr >= end))
 			break;
-#if CONFIG_X86_PAE
-		pmd = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-		set_pgd(pgd, __pgd(__pa(pmd) + 0x1));
-#else
-		pmd = (pmd_t *)pgd;
-#endif
-		if (pmd != pmd_offset(pgd, 0))
-			BUG();
+		pmd = pmd_offset(pgd, PAGE_OFFSET);
 		for (j = 0; j < PTRS_PER_PMD; pmd++, j++) {
 			vaddr = i*PGDIR_SIZE + j*PMD_SIZE;
 			if (end && (vaddr >= end))
@@ -243,14 +231,16 @@ static void __init pagetable_init (void)
 			if (cpu_has_pse) {
 				unsigned long __pe;
 
-				set_in_cr4(X86_CR4_PSE);
-				boot_cpu_data.wp_works_ok = 1;
 				__pe = _KERNPG_TABLE + _PAGE_PSE + __pa(vaddr);
 				/* Make it "global" too if supported */
-				if (cpu_has_pge) {
-					set_in_cr4(X86_CR4_PGE);
+				if (cpu_has_pge)
 					__pe += _PAGE_GLOBAL;
-				}
+
+#ifdef CONFIG_PAX_KERNEXEC
+				if (__KERNEL_TEXT_OFFSET <= vaddr && vaddr < (unsigned long)&_data)
+					__pe &= ~_PAGE_RW;
+#endif
+
 				set_pmd(pmd, __pmd(__pe));
 				continue;
 			}
@@ -263,6 +253,13 @@ static void __init pagetable_init (void)
 					break;
 				*pte = mk_pte_phys(__pa(vaddr), PAGE_KERNEL);
 			}
+
+#ifdef CONFIG_PAX_KERNEXEC
+			if (__KERNEL_TEXT_OFFSET <= vaddr && vaddr < (unsigned long)&_data)
+				set_pmd(pmd, __pmd((_KERNPG_TABLE & ~_PAGE_RW) + __pa(pte_base)));
+			else
+#endif
+
 			set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte_base)));
 			if (pte_base != pte_offset(pmd, 0))
 				BUG();
@@ -289,17 +286,6 @@ static void __init pagetable_init (void)
 	pte = pte_offset(pmd, vaddr);
 	pkmap_page_table = pte;
 #endif
-
-#if CONFIG_X86_PAE
-	/*
-	 * Add low memory identity-mappings - SMP needs it when
-	 * starting up on an AP from real-mode. In the non-PAE
-	 * case we already have these mappings through head.S.
-	 * All user-space mappings are explicitly cleared after
-	 * SMP startup.
-	 */
-	pgd_base[0] = pgd_base[USER_PTRS_PER_PGD];
-#endif
 }
 
 void __init zap_low_mappings (void)
@@ -312,7 +298,7 @@ void __init zap_low_mappings (void)
 	 * us, because pgd_clear() is a no-op on i386.
 	 */
 	for (i = 0; i < USER_PTRS_PER_PGD; i++)
-#if CONFIG_X86_PAE
+#ifdef CONFIG_X86_PAE
 		set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
 #else
 		set_pgd(swapper_pg_dir+i, __pgd(0));
@@ -353,16 +339,6 @@ void __init paging_init(void)
 	pagetable_init();
 
 	load_cr3(swapper_pg_dir);	
-
-#if CONFIG_X86_PAE
-	/*
-	 * We will bail out later - printk doesn't work right now so
-	 * the user would just see a hanging kernel.
-	 */
-	if (cpu_has_pae)
-		set_in_cr4(X86_CR4_PAE);
-#endif
-
 	__flush_tlb_all();
 
 #ifdef CONFIG_HIGHMEM
@@ -508,6 +484,10 @@ void __init mem_init(void)
 {
 	int codesize, reservedpages, datasize, initsize;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (!mem_map)
 		BUG();
 #ifdef CONFIG_HIGHMEM
@@ -524,12 +504,21 @@ void __init mem_init(void)
 	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
 
 	/* clear the zero-page */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	memset(empty_zero_page, 0, PAGE_SIZE);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	reservedpages = free_pages_init();
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_data;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	printk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init, %ldk highmem)\n",
@@ -542,10 +531,6 @@ void __init mem_init(void)
 		(unsigned long) (totalhigh_pages << (PAGE_SHIFT-10))
 	       );
 
-#if CONFIG_X86_PAE
-	if (!cpu_has_pae)
-		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
-#endif
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
 
@@ -589,6 +574,26 @@ void free_initmem(void)
 {
 	unsigned long addr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	/* PaX: limit KERNEL_CS to actual size */
+	unsigned long limit, cr0;
+
+	limit = (unsigned long)&_etext >> PAGE_SHIFT;
+
+	pax_open_kernel(cr0);
+
+	gdt_table[2].a = (gdt_table[2].a & 0xFFFF0000UL) | (limit & 0x0FFFFUL);
+	gdt_table[2].b = (gdt_table[2].b & 0xFFF0FFFFUL) | (limit & 0xF0000UL);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[2].a = (gdt_table2[2].a & 0xFFFF0000UL) | (limit & 0x0FFFFUL);
+	gdt_table2[2].b = (gdt_table2[2].b & 0xFFF0FFFFUL) | (limit & 0xF0000UL);
+#endif
+
+	pax_close_kernel(cr0);
+#endif
+
+	memset(&__init_begin, 0, &__init_end - &__init_begin);
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
diff -urNp linux-2.4.37.7/arch/i386/mm/ioremap.c linux-2.4.37.7/arch/i386/mm/ioremap.c
--- linux-2.4.37.7/arch/i386/mm/ioremap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/mm/ioremap.c	2009-11-10 19:30:27.000000000 -0500
@@ -49,7 +49,7 @@ static inline int remap_area_pmd(pmd_t *
 	if (address >= end)
 		BUG();
 	do {
-		pte_t * pte = pte_alloc(&init_mm, pmd, address);
+		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
 		if (!pte)
 			return -ENOMEM;
 		remap_area_pte(pte, address, end - address, address + phys_addr, flags);
diff -urNp linux-2.4.37.7/arch/i386/mm/pageattr.c linux-2.4.37.7/arch/i386/mm/pageattr.c
--- linux-2.4.37.7/arch/i386/mm/pageattr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/mm/pageattr.c	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <asm/desc.h>
 
 /* Should move most of this stuff into the appropiate includes */
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
@@ -63,7 +64,19 @@ static void flush_kernel_map(void * addr
 
 static void set_pmd_pte(pte_t *kpte, unsigned long address, pte_t pte) 
 { 
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte_atomic(kpte, pte); 	/* change init_mm */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 #ifndef CONFIG_X86_PAE
 	{
 		struct list_head *l;
diff -urNp linux-2.4.37.7/arch/i386/vmlinux.lds linux-2.4.37.7/arch/i386/vmlinux.lds
--- linux-2.4.37.7/arch/i386/vmlinux.lds	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/i386/vmlinux.lds	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-/* ld script to make i386 Linux kernel
- * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
- */
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
-OUTPUT_ARCH(i386)
-ENTRY(_start)
-SECTIONS
-{
-  . = 0xC0000000 + 0x100000;
-  _text = .;			/* Text and read-only data */
-  .text : {
-	*(.text)
-	*(.fixup)
-	*(.gnu.warning)
-	} = 0x9090
-
-  _etext = .;			/* End of text section */
-
-  .rodata : { *(.rodata) *(.rodata.*) }
-  .kstrtab : { *(.kstrtab) }
-
-  . = ALIGN(16);		/* Exception table */
-  __start___ex_table = .;
-  __ex_table : { *(__ex_table) }
-  __stop___ex_table = .;
-
-  __start___ksymtab = .;	/* Kernel symbol table */
-  __ksymtab : { *(__ksymtab) }
-  __stop___ksymtab = .;
-
-  .data : {			/* Data */
-	*(.data)
-	CONSTRUCTORS
-	}
-
-  _edata = .;			/* End of data section */
-
-  . = ALIGN(8192);		/* init_task */
-  .data.init_task : { *(.data.init_task) }
-
-  . = ALIGN(4096);		/* Init code and data */
-  __init_begin = .;
-  .text.init : { *(.text.init) }
-  .data.init : { *(.data.init) }
-  . = ALIGN(16);
-  __setup_start = .;
-  .setup.init : { *(.setup.init) }
-  __setup_end = .;
-  __initcall_start = .;
-  .initcall.init : { *(.initcall.init) }
-  __initcall_end = .;
-  . = ALIGN(4096);
-  __init_end = .;
-
-  . = ALIGN(4096);
-  .data.page_aligned : { *(.data.idt) }
-
-  . = ALIGN(32);
-  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
-
-  __bss_start = .;		/* BSS */
-  .bss : {
-	*(.bss)
-	}
-  _end = . ;
-
-  /* Sections to be discarded */
-  /DISCARD/ : {
-	*(.text.exit)
-	*(.data.exit)
-	*(.exitcall.exit)
-	}
-
-  /* Stabs debugging sections.  */
-  .stab 0 : { *(.stab) }
-  .stabstr 0 : { *(.stabstr) }
-  .stab.excl 0 : { *(.stab.excl) }
-  .stab.exclstr 0 : { *(.stab.exclstr) }
-  .stab.index 0 : { *(.stab.index) }
-  .stab.indexstr 0 : { *(.stab.indexstr) }
-  .comment 0 : { *(.comment) }
-}
diff -urNp linux-2.4.37.7/arch/i386/vmlinux.lds.S linux-2.4.37.7/arch/i386/vmlinux.lds.S
--- linux-2.4.37.7/arch/i386/vmlinux.lds.S	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/arch/i386/vmlinux.lds.S	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,140 @@
+/* ld script to make i386 Linux kernel
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
+ */
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+PHDRS {
+	initdata PT_LOAD FLAGS(6);	/* RW_ */
+	inittext PT_LOAD FLAGS(5);	/* R_E */
+	text     PT_LOAD FLAGS(5);	/* R_E */
+	rodata   PT_LOAD FLAGS(4);	/* R__ */
+	data     PT_LOAD FLAGS(6);	/* RW_ */
+}
+SECTIONS
+{
+  . = __PAGE_OFFSET + 0x100000;
+  .text.startup : {
+	BYTE(0xEA) /* jmp far */
+	LONG(startup_32 + __KERNEL_TEXT_OFFSET - __PAGE_OFFSET)
+	SHORT(__KERNEL_CS)
+	} :initdata
+
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .data.init : { *(.data.init) }
+  . = ALIGN(16);
+  __setup_start = .;
+  .setup.init : { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : { *(.initcall.init) }
+  __initcall_end = .;
+
+  _sinittext = . - __KERNEL_TEXT_OFFSET;
+
+#ifdef CONFIG_PAX_KERNEXEC
+  .text.init (. - __KERNEL_TEXT_OFFSET) : AT (_sinittext + __KERNEL_TEXT_OFFSET) {
+	*(.text.init)
+	_einittext = .;
+	. = ALIGN(4*1024*1024) - 1;
+	BYTE(0)
+	} :inittext
+  __init_end = . + __KERNEL_TEXT_OFFSET;
+
+/*
+ * PaX: this must be kept in synch with the KERNEL_CS base
+ * in the GDTs in arch/i386/kernel/head.S
+ */
+  _text = .;			/* Text and read-only data */
+  .text : AT (. + __KERNEL_TEXT_OFFSET) {
+#else
+  .text.init : { *(.text.init) } :inittext
+  _einittext = .;
+  . = ALIGN(4096);
+  __init_end = .;
+  _text = .;			/* Text and read-only data */
+  .text : {
+#endif
+
+	*(.text)
+	*(.fixup)
+	*(.gnu.warning)
+	} :text = 0x9090
+
+  _etext = .;			/* End of text section */
+
+  . = ALIGN(4096);
+  . += __KERNEL_TEXT_OFFSET;
+  .rodata.page_aligned : {
+	*(.empty_zero_page)
+	*(.pg0)
+
+#ifdef CONFIG_X86_PAE
+	*(.swapper_pm_dir)
+#endif
+
+	*(.swapper_pg_dir)
+	*(.idt)
+	} :rodata
+  .rodata : { *(.rodata) *(.rodata.*) }
+  .kstrtab : { *(.kstrtab) }
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : { *(__ksymtab) }
+  __stop___ksymtab = .;
+
+#ifdef CONFIG_PAX_KERNEXEC
+  . = ALIGN(4*1024*1024);
+#else
+  . = ALIGN(32);
+#endif
+
+  _data = .;
+  .data : {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	} :data
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  . = ALIGN(8192);
+  .data.init_task : { *(.data.init_task) }
+
+  . = ALIGN(4096);
+  .data.page_aligned : {
+	}
+
+  _edata = .;			/* End of data section */
+
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss)
+	}
+  __bss_end = . ;
+
+  _end = . ;
+
+  /* Sections to be discarded */
+  /DISCARD/ : {
+	*(.text.exit)
+	*(.data.exit)
+	*(.exitcall.exit)
+	}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -urNp linux-2.4.37.7/arch/ia64/config.in linux-2.4.37.7/arch/ia64/config.in
--- linux-2.4.37.7/arch/ia64/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -319,3 +319,12 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urNp linux-2.4.37.7/arch/ia64/hp/common/sba_iommu.c linux-2.4.37.7/arch/ia64/hp/common/sba_iommu.c
--- linux-2.4.37.7/arch/ia64/hp/common/sba_iommu.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/hp/common/sba_iommu.c	2009-11-10 19:30:27.000000000 -0500
@@ -1704,7 +1704,7 @@ ioc_show(struct seq_file *s, void *v)
 	return 0;
 }
 
-static struct seq_operations ioc_seq_ops = {
+static const struct seq_operations ioc_seq_ops = {
 	.start = ioc_start,
 	.next  = ioc_next,
 	.stop  = ioc_stop,
@@ -1717,7 +1717,7 @@ ioc_open(struct inode *inode, struct fil
 	return seq_open(file, &ioc_seq_ops);
 }
 
-static struct file_operations ioc_fops = {
+static const struct file_operations ioc_fops = {
 	.open    = ioc_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
diff -urNp linux-2.4.37.7/arch/ia64/ia32/binfmt_elf32.c linux-2.4.37.7/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.4.37.7/arch/ia64/ia32/binfmt_elf32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/ia32/binfmt_elf32.c	2009-11-10 19:30:27.000000000 -0500
@@ -53,6 +53,13 @@ static void elf32_set_personality (void)
 #undef SET_PERSONALITY
 #define SET_PERSONALITY(ex, ibcs2)	elf32_set_personality()
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
@@ -68,7 +75,7 @@ ia32_install_shared_page (struct vm_area
 	return pg;
 }
 
-static struct vm_operations_struct ia32_shared_page_vm_ops = {
+static const struct vm_operations_struct ia32_shared_page_vm_ops = {
 	.nopage =ia32_install_shared_page
 };
 
@@ -190,8 +197,15 @@ ia32_setup_arg_pages (struct linux_binpr
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = IA32_STACK_TOP;
-		mpnt->vm_page_prot = PAGE_COPY;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(current->mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(VM_STACK_FLAGS | VM_EXEC) & 0x7];
+		else
+#endif
+
+		mpnt->vm_page_prot = protection_map[VM_STACK_FLAGS & 0x7];
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
diff -urNp linux-2.4.37.7/arch/ia64/ia32/sys_ia32.c linux-2.4.37.7/arch/ia64/ia32/sys_ia32.c
--- linux-2.4.37.7/arch/ia64/ia32/sys_ia32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/ia32/sys_ia32.c	2009-11-10 19:30:27.000000000 -0500
@@ -538,7 +538,6 @@ sys32_mmap (struct mmap_arg_struct *arg)
 		return -EINVAL;
 
 	flags = a.flags;
-
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(a.fd);
diff -urNp linux-2.4.37.7/arch/ia64/kernel/efivars.c linux-2.4.37.7/arch/ia64/kernel/efivars.c
--- linux-2.4.37.7/arch/ia64/kernel/efivars.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/efivars.c	2009-11-10 19:30:27.000000000 -0500
@@ -412,7 +412,7 @@ out:
 }
 
 static struct proc_dir_entry *efi_systab_entry;
-static struct file_operations efi_systab_fops = {
+static const struct file_operations efi_systab_fops = {
 	.read = efi_systab_read,
 };
 
diff -urNp linux-2.4.37.7/arch/ia64/kernel/perfmon.c linux-2.4.37.7/arch/ia64/kernel/perfmon.c
--- linux-2.4.37.7/arch/ia64/kernel/perfmon.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/perfmon.c	2009-11-10 19:30:27.000000000 -0500
@@ -3261,7 +3261,7 @@ pfm_proc_show(struct seq_file *m, void *
 	return 0;
 }
  
-struct seq_operations pfm_seq_ops = {
+const struct seq_operations pfm_seq_ops = {
 	.start =	pfm_proc_start,
  	.next =		pfm_proc_next,
  	.stop =		pfm_proc_stop,
@@ -4500,7 +4500,7 @@ pfm_remove_alternate_syswide_subsystem(p
 	return 0;
 }
 
-static struct file_operations pfm_proc_fops = {
+static const struct file_operations pfm_proc_fops = {
 	.open		= pfm_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
diff -urNp linux-2.4.37.7/arch/ia64/kernel/ptrace.c linux-2.4.37.7/arch/ia64/kernel/ptrace.c
--- linux-2.4.37.7/arch/ia64/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -16,6 +16,7 @@
 #include <linux/ptrace.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1299,6 +1300,9 @@ sys_ptrace (long request, pid_t pid, uns
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urNp linux-2.4.37.7/arch/ia64/kernel/salinfo.c linux-2.4.37.7/arch/ia64/kernel/salinfo.c
--- linux-2.4.37.7/arch/ia64/kernel/salinfo.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/salinfo.c	2009-11-10 19:30:27.000000000 -0500
@@ -338,7 +338,7 @@ retry:
 	return size;
 }
 
-static struct file_operations salinfo_event_fops = {
+static const struct file_operations salinfo_event_fops = {
 	.open  = salinfo_event_open,
 	.read  = salinfo_event_read,
 };
@@ -558,7 +558,7 @@ salinfo_log_write(struct file *file, con
 	return count;
 }
 
-static struct file_operations salinfo_data_fops = {
+static const struct file_operations salinfo_data_fops = {
 	.open    = salinfo_log_open,
 	.release = salinfo_log_release,
 	.read    = salinfo_log_read,
diff -urNp linux-2.4.37.7/arch/ia64/kernel/setup.c linux-2.4.37.7/arch/ia64/kernel/setup.c
--- linux-2.4.37.7/arch/ia64/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -566,7 +566,7 @@ c_stop (struct seq_file *m, void *v)
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start =c_start,
 	.next =	c_next,
 	.stop =	c_stop,
diff -urNp linux-2.4.37.7/arch/ia64/kernel/sys_ia64.c linux-2.4.37.7/arch/ia64/kernel/sys_ia64.c
--- linux-2.4.37.7/arch/ia64/kernel/sys_ia64.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/kernel/sys_ia64.c	2009-11-10 19:30:27.000000000 -0500
@@ -34,6 +34,13 @@ arch_get_unmapped_area (struct file *fil
 	if (rgn_index(addr)==REGION_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -urNp linux-2.4.37.7/arch/ia64/mm/fault.c linux-2.4.37.7/arch/ia64/mm/fault.c
--- linux-2.4.37.7/arch/ia64/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -36,6 +36,10 @@ expand_backing_store (struct vm_area_str
 	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur
 	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
+	if ((vma->vm_flags & VM_LOCKED) &&
+	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur &&
+	    !capable(CAP_IPC_LOCK))
+		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
@@ -70,6 +74,23 @@ mapped_kernel_page_is_present (unsigned 
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -122,9 +143,23 @@ ia64_do_page_fault (unsigned long addres
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT)
 		| (((isr >> IA64_ISR_R_BIT) & 1UL) << VM_READ_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void*)regs->cr_iip, (void*)regs->r12);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -urNp linux-2.4.37.7/arch/ia64/mm/hugetlbpage.c linux-2.4.37.7/arch/ia64/mm/hugetlbpage.c
--- linux-2.4.37.7/arch/ia64/mm/hugetlbpage.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/mm/hugetlbpage.c	2009-11-10 19:30:27.000000000 -0500
@@ -24,7 +24,7 @@ static long    htlbpagemem;
 int     htlbpage_max;
 static long    htlbzone_pages;
 
-struct vm_operations_struct hugetlb_vm_ops;
+const struct vm_operations_struct hugetlb_vm_ops;
 static LIST_HEAD(htlbpage_freelist);
 static spinlock_t htlbpage_lock = SPIN_LOCK_UNLOCKED;
 
@@ -512,6 +512,6 @@ static struct page *hugetlb_nopage(struc
 	return NULL;
 }
 
-struct vm_operations_struct hugetlb_vm_ops = {
+const struct vm_operations_struct hugetlb_vm_ops = {
 	.nopage =	hugetlb_nopage,
 };
diff -urNp linux-2.4.37.7/arch/ia64/mm/init.c linux-2.4.37.7/arch/ia64/mm/init.c
--- linux-2.4.37.7/arch/ia64/mm/init.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/mm/init.c	2009-11-10 19:30:27.000000000 -0500
@@ -73,7 +73,7 @@ ia64_set_rbs_bot (void)
 
 	if (stack_size > MAX_USER_STACK_SIZE)
 		stack_size = MAX_USER_STACK_SIZE;
-	current->thread.rbs_bot = STACK_TOP - stack_size;
+	current->thread.rbs_bot = PAGE_ALIGN(current->mm->start_stack - stack_size);
 }
 
 /*
@@ -105,6 +105,7 @@ ia64_init_addr_space (void)
 		vma->vm_pgoff = 0;
 		vma->vm_file = NULL;
 		vma->vm_private_data = NULL;
+		vma->vm_mirror = 0;
 		down_write(&current->mm->mmap_sem);
 		if (insert_vm_struct(current->mm, vma)) {
 			up_write(&current->mm->mmap_sem);
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/drivers/ifconfig_net.c linux-2.4.37.7/arch/ia64/sn/io/drivers/ifconfig_net.c
--- linux-2.4.37.7/arch/ia64/sn/io/drivers/ifconfig_net.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/drivers/ifconfig_net.c	2009-11-10 19:30:27.000000000 -0500
@@ -277,7 +277,7 @@ static int ifconfig_net_ioctl(struct ino
 
 }
 
-struct file_operations ifconfig_net_fops = {
+const struct file_operations ifconfig_net_fops = {
 	ioctl:ifconfig_net_ioctl,	/* ioctl */
 	open:ifconfig_net_open,		/* open */
 	release:ifconfig_net_close	/* release */
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/drivers/ioconfig_bus.c linux-2.4.37.7/arch/ia64/sn/io/drivers/ioconfig_bus.c
--- linux-2.4.37.7/arch/ia64/sn/io/drivers/ioconfig_bus.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/drivers/ioconfig_bus.c	2009-11-10 19:30:27.000000000 -0500
@@ -359,7 +359,7 @@ static int ioconfig_bus_close(struct ino
         return(0);
 }
 
-struct file_operations ioconfig_bus_fops = {
+const struct file_operations ioconfig_bus_fops = {
 	ioctl:ioconfig_bus_ioctl,
 	open:ioconfig_bus_open,		/* open */
 	release:ioconfig_bus_close	/* release */
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/drivers/pciba.c linux-2.4.37.7/arch/ia64/sn/io/drivers/pciba.c
--- linux-2.4.37.7/arch/ia64/sn/io/drivers/pciba.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/drivers/pciba.c	2009-11-10 19:30:27.000000000 -0500
@@ -211,7 +211,7 @@ static void dump_allocations(struct list
 #endif
 
 /* file operations for each type of node */
-static struct file_operations rom_fops = {
+static const struct file_operations rom_fops = {
 	owner:		THIS_MODULE,
 	mmap:		rom_mmap,
 	open:		generic_open,
@@ -219,20 +219,20 @@ static struct file_operations rom_fops =
 };
  
 
-static struct file_operations base_fops = {
+static const struct file_operations base_fops = {
 	owner:		THIS_MODULE,
 	mmap:		base_mmap,
 	open:		generic_open
 };
 
 
-static struct file_operations config_fops = {
+static const struct file_operations config_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		config_ioctl,
 	open:		generic_open
 };	
 
-static struct file_operations dma_fops = {
+static const struct file_operations dma_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		dma_ioctl,
 	mmap:		dma_mmap,
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/hwgdfs/hcl.c linux-2.4.37.7/arch/ia64/sn/io/hwgdfs/hcl.c
--- linux-2.4.37.7/arch/ia64/sn/io/hwgdfs/hcl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/hwgdfs/hcl.c	2009-11-10 19:30:27.000000000 -0500
@@ -106,7 +106,7 @@ static int hcl_ioctl(struct inode * inod
 
 }
 
-struct file_operations hcl_fops = {
+const struct file_operations hcl_fops = {
 	(struct module *)0,
 	NULL,		/* lseek - default */
 	NULL,		/* read - general block-dev read */
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/hwgfs/hcl.c linux-2.4.37.7/arch/ia64/sn/io/hwgfs/hcl.c
--- linux-2.4.37.7/arch/ia64/sn/io/hwgfs/hcl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/hwgfs/hcl.c	2009-11-10 19:30:27.000000000 -0500
@@ -108,7 +108,7 @@ static int hcl_ioctl(struct inode * inod
 
 }
 
-struct file_operations hcl_fops = {
+const struct file_operations hcl_fops = {
 	(struct module *)0,
 	NULL,		/* lseek - default */
 	NULL,		/* read - general block-dev read */
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/hwgfs/ramfs.c linux-2.4.37.7/arch/ia64/sn/io/hwgfs/ramfs.c
--- linux-2.4.37.7/arch/ia64/sn/io/hwgfs/ramfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/hwgfs/ramfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -18,10 +18,10 @@
 /* some random number */
 #define HWGFS_MAGIC	0x12061983
 
-static struct super_operations hwgfs_ops;
-static struct address_space_operations hwgfs_aops;
-static struct file_operations hwgfs_file_operations;
-static struct inode_operations hwgfs_dir_inode_operations;
+static const struct super_operations hwgfs_ops;
+static const struct address_space_operations hwgfs_aops;
+static const struct file_operations hwgfs_file_operations;
+static const struct inode_operations hwgfs_dir_inode_operations;
 
 static int hwgfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -247,21 +247,21 @@ static int hwgfs_sync_file(struct file *
 	return 0;
 }
 
-static struct address_space_operations hwgfs_aops = {
+static const struct address_space_operations hwgfs_aops = {
 	.readpage	= hwgfs_readpage,
 	.writepage	= fail_writepage,
 	.prepare_write	= hwgfs_prepare_write,
 	.commit_write	= hwgfs_commit_write
 };
 
-static struct file_operations hwgfs_file_operations = {
+static const struct file_operations hwgfs_file_operations = {
 	.read		= generic_file_read,
 	.write		= generic_file_write,
 	.mmap		= generic_file_mmap,
 	.fsync		= hwgfs_sync_file,
 };
 
-static struct inode_operations hwgfs_dir_inode_operations = {
+static const struct inode_operations hwgfs_dir_inode_operations = {
 	.create		= hwgfs_create,
 	.lookup		= hwgfs_lookup,
 	.link		= hwgfs_link,
@@ -273,7 +273,7 @@ static struct inode_operations hwgfs_dir
 	.rename		= hwgfs_rename,
 };
 
-static struct super_operations hwgfs_ops = {
+static const struct super_operations hwgfs_ops = {
 	.statfs		= hwgfs_statfs,
 	.put_inode	= force_delete,
 };
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/sn2/pcibr/pcibr_dvr.c linux-2.4.37.7/arch/ia64/sn/io/sn2/pcibr/pcibr_dvr.c
--- linux-2.4.37.7/arch/ia64/sn/io/sn2/pcibr/pcibr_dvr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/sn2/pcibr/pcibr_dvr.c	2009-11-10 19:30:27.000000000 -0500
@@ -577,7 +577,7 @@ pcibr_mmap(struct file * file, struct vm
  * appropriate function name below.
  */
 static int pcibr_mmap(struct file * file, struct vm_area_struct * vma);
-struct file_operations pcibr_fops = {
+const struct file_operations pcibr_fops = {
 	.owner		= THIS_MODULE,
 	.mmap		= pcibr_mmap,
 };
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/sn2/shub.c linux-2.4.37.7/arch/ia64/sn/io/sn2/shub.c
--- linux-2.4.37.7/arch/ia64/sn/io/sn2/shub.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/sn2/shub.c	2009-11-10 19:30:27.000000000 -0500
@@ -223,7 +223,7 @@ shubstats_ioctl(struct inode *inode, str
 	return 0;
 }
 
-struct file_operations shub_mon_fops = {
+const struct file_operations shub_mon_fops = {
 	        ioctl:          shubstats_ioctl,
 };
 
diff -urNp linux-2.4.37.7/arch/ia64/sn/io/sn2/xbow.c linux-2.4.37.7/arch/ia64/sn/io/sn2/xbow.c
--- linux-2.4.37.7/arch/ia64/sn/io/sn2/xbow.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ia64/sn/io/sn2/xbow.c	2009-11-10 19:30:27.000000000 -0500
@@ -141,7 +141,7 @@ xbow_mmap(struct file * file, struct vm_
  * As each of the functions are implemented, put the
  * appropriate function name below.
  */
-struct file_operations xbow_fops = {
+const struct file_operations xbow_fops = {
         .owner		= THIS_MODULE,
         .mmap		= xbow_mmap,
 };
diff -urNp linux-2.4.37.7/arch/m68k/atari/joystick.c linux-2.4.37.7/arch/m68k/atari/joystick.c
--- linux-2.4.37.7/arch/m68k/atari/joystick.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/m68k/atari/joystick.c	2009-11-10 19:30:27.000000000 -0500
@@ -121,7 +121,7 @@ static unsigned int joystick_poll(struct
     return 0;
 }
 
-struct file_operations atari_joystick_fops = {
+const struct file_operations atari_joystick_fops = {
 	read:		read_joystick,
 	write:		write_joystick,
 	poll:		joystick_poll,
diff -urNp linux-2.4.37.7/arch/m68k/bvme6000/rtc.c linux-2.4.37.7/arch/m68k/bvme6000/rtc.c
--- linux-2.4.37.7/arch/m68k/bvme6000/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/m68k/bvme6000/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -161,7 +161,7 @@ static int rtc_release(struct inode *ino
  *	The various file operations we support.
  */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	ioctl:		rtc_ioctl,
 	open:		rtc_open,
 	release:	rtc_release,
diff -urNp linux-2.4.37.7/arch/m68k/config.in linux-2.4.37.7/arch/m68k/config.in
--- linux-2.4.37.7/arch/m68k/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/m68k/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -558,3 +558,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/m68k/kernel/setup.c linux-2.4.37.7/arch/m68k/kernel/setup.c
--- linux-2.4.37.7/arch/m68k/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/m68k/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -531,7 +531,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/m68k/mvme16x/rtc.c linux-2.4.37.7/arch/m68k/mvme16x/rtc.c
--- linux-2.4.37.7/arch/m68k/mvme16x/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/m68k/mvme16x/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -150,7 +150,7 @@ static int rtc_release(struct inode *ino
  *	The various file operations we support.
  */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	ioctl:		rtc_ioctl,
 	open:		rtc_open,
 	release:	rtc_release,
diff -urNp linux-2.4.37.7/arch/mips/config.in linux-2.4.37.7/arch/mips/config.in
--- linux-2.4.37.7/arch/mips/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -7,3 +7,11 @@ define_bool CONFIG_MIPS32 y
 define_bool CONFIG_MIPS64 n
 
 source arch/mips/config-shared.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+        source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/mips/kernel/proc.c linux-2.4.37.7/arch/mips/kernel/proc.c
--- linux-2.4.37.7/arch/mips/kernel/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips/kernel/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -143,7 +143,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start	= c_start,
 	.next	= c_next,
 	.stop	= c_stop,
diff -urNp linux-2.4.37.7/arch/mips/kernel/syscall.c linux-2.4.37.7/arch/mips/kernel/syscall.c
--- linux-2.4.37.7/arch/mips/kernel/syscall.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips/kernel/syscall.c	2009-11-10 19:30:27.000000000 -0500
@@ -82,6 +82,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -92,6 +97,13 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	addr = TASK_UNMAPPED_BASE;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
diff -urNp linux-2.4.37.7/arch/mips/mm/fault.c linux-2.4.37.7/arch/mips/mm/fault.c
--- linux-2.4.37.7/arch/mips/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -69,6 +69,23 @@ void bust_spinlocks(int yes)
 	}
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -urNp linux-2.4.37.7/arch/mips/sibyte/sb1250/bcm1250_tbprof.c linux-2.4.37.7/arch/mips/sibyte/sb1250/bcm1250_tbprof.c
--- linux-2.4.37.7/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2009-11-10 19:30:27.000000000 -0500
@@ -356,7 +356,7 @@ static int sbprof_tb_ioctl(struct inode 
 	return error;
 }
 
-static struct file_operations sbprof_tb_fops = {
+static const struct file_operations sbprof_tb_fops = {
 	.owner		= THIS_MODULE,
 	.open		= sbprof_tb_open,
 	.release	= sbprof_tb_release,
diff -urNp linux-2.4.37.7/arch/mips64/config.in linux-2.4.37.7/arch/mips64/config.in
--- linux-2.4.37.7/arch/mips64/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -7,3 +7,11 @@ define_bool CONFIG_MIPS32 n
 define_bool CONFIG_MIPS64 y
 
 source arch/mips/config-shared.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+        source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/mips64/kernel/binfmt_elfn32.c linux-2.4.37.7/arch/mips64/kernel/binfmt_elfn32.c
--- linux-2.4.37.7/arch/mips64/kernel/binfmt_elfn32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/kernel/binfmt_elfn32.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,6 +50,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -urNp linux-2.4.37.7/arch/mips64/kernel/binfmt_elfo32.c linux-2.4.37.7/arch/mips64/kernel/binfmt_elfo32.c
--- linux-2.4.37.7/arch/mips64/kernel/binfmt_elfo32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/kernel/binfmt_elfo32.c	2009-11-10 19:30:27.000000000 -0500
@@ -52,6 +52,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -urNp linux-2.4.37.7/arch/mips64/kernel/proc.c linux-2.4.37.7/arch/mips64/kernel/proc.c
--- linux-2.4.37.7/arch/mips64/kernel/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/kernel/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -143,7 +143,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start	= c_start,
 	.next	= c_next,
 	.stop	= c_stop,
diff -urNp linux-2.4.37.7/arch/mips64/kernel/syscall.c linux-2.4.37.7/arch/mips64/kernel/syscall.c
--- linux-2.4.37.7/arch/mips64/kernel/syscall.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/kernel/syscall.c	2009-11-10 19:30:27.000000000 -0500
@@ -80,6 +80,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -90,6 +95,13 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	addr = TASK_UNMAPPED_BASE;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
diff -urNp linux-2.4.37.7/arch/mips64/mm/fault.c linux-2.4.37.7/arch/mips64/mm/fault.c
--- linux-2.4.37.7/arch/mips64/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/mips64/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -90,6 +90,24 @@ void bust_spinlocks(int yes)
 	}
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -urNp linux-2.4.37.7/arch/parisc/config.in linux-2.4.37.7/arch/parisc/config.in
--- linux-2.4.37.7/arch/parisc/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -204,3 +204,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/parisc/kernel/ioctl32.c linux-2.4.37.7/arch/parisc/kernel/ioctl32.c
--- linux-2.4.37.7/arch/parisc/kernel/ioctl32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/ioctl32.c	2009-11-10 19:30:27.000000000 -0500
@@ -1435,7 +1435,11 @@ static int vt_check(struct file *file)
 	 * To have permissions to do most of the vt ioctls, we either have
 	 * to be the owner of the tty, or super-user.
 	 */
+#ifdef CONFIG_GRKERNSEC
+	if (current->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (current->tty == tty || suser())
+#endif
 		return 1;
 	return 0;                                                    
 }
diff -urNp linux-2.4.37.7/arch/parisc/kernel/perf.c linux-2.4.37.7/arch/parisc/kernel/perf.c
--- linux-2.4.37.7/arch/parisc/kernel/perf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/perf.c	2009-11-10 19:30:27.000000000 -0500
@@ -479,7 +479,7 @@ static int perf_ioctl(struct inode *inod
 	return -ENOTTY;
 }
 
-static struct file_operations perf_fops = {
+static const struct file_operations perf_fops = {
 	llseek: no_llseek,
 	read: perf_read,
 	write: perf_write,
diff -urNp linux-2.4.37.7/arch/parisc/kernel/ptrace.c linux-2.4.37.7/arch/parisc/kernel/ptrace.c
--- linux-2.4.37.7/arch/parisc/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,7 +15,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/personality.h>
-
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -119,6 +119,9 @@ long sys_ptrace(long request, pid_t pid,
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urNp linux-2.4.37.7/arch/parisc/kernel/setup.c linux-2.4.37.7/arch/parisc/kernel/setup.c
--- linux-2.4.37.7/arch/parisc/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -180,7 +180,7 @@ c_stop (struct seq_file *m, void *v)
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/parisc/kernel/sys_parisc32.c linux-2.4.37.7/arch/parisc/kernel/sys_parisc32.c
--- linux-2.4.37.7/arch/parisc/kernel/sys_parisc32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/sys_parisc32.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,6 +50,7 @@
 #include <linux/highmem.h>
 #include <linux/highuid.h>
 #include <linux/mman.h>
+#include <linux/grsecurity.h>
 
 #include <asm/types.h>
 #include <asm/uaccess.h>
@@ -177,6 +178,11 @@ do_execve32(char * filename, u32 * argv,
 	struct file *file;
 	int retval;
 	int i;
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 
 	file = open_exec(filename);
 
@@ -184,7 +190,26 @@ do_execve32(char * filename, u32 * argv,
 	if (IS_ERR(file))
 		return retval;
 
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes), 1);
+
+	if (gr_handle_nproc()) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+
+	if (!gr_acl_handle_execve(file->f_dentry, file->f_vfsmnt)) {
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+	bprm.p -= (net_random() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));
 
 	DBG(("do_execve32(%s, %p, %p, %p)\n", filename, argv, envp, regs));
@@ -209,11 +234,24 @@ do_execve32(char * filename, u32 * argv,
 	if (retval < 0)
 		goto out;
 	
+	if (!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
 	if (retval < 0)
 		goto out;
 
 	bprm.exec = bprm.p;
+
+	gr_log_chroot_exec(file->f_dentry, file->f_vfsmnt);
+
 	retval = copy_strings32(bprm.envc, envp, &bprm);
 	if (retval < 0)
 		goto out;
@@ -222,11 +260,32 @@ do_execve32(char * filename, u32 * argv,
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+
+	gr_set_proc_label(file->f_dentry, file->f_vfsmnt);
+
 	retval = search_binary_handler(&bprm,regs);
-	if (retval >= 0)
+	if (retval >= 0) {
+#ifdef CONFIG_GRKERNSEC
+		if (old_exec_file)
+			fput(old_exec_file);
+#endif
 		/* execve success */
 		return retval;
+	}
 
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
 	allow_write_access(bprm.file);
diff -urNp linux-2.4.37.7/arch/parisc/kernel/sys_parisc.c linux-2.4.37.7/arch/parisc/kernel/sys_parisc.c
--- linux-2.4.37.7/arch/parisc/kernel/sys_parisc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/sys_parisc.c	2009-11-10 19:30:27.000000000 -0500
@@ -90,6 +90,11 @@ unsigned long arch_get_unmapped_area(str
 		inode = filp->f_dentry->d_inode;
 	}
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+#endif
+
 	if (inode && (flags & MAP_SHARED) && (inode->i_mapping->i_mmap_shared)) {
 		addr = get_shared_area(inode, addr, len, pgoff);
 	} else {
@@ -104,6 +109,7 @@ static unsigned long do_mmap2(unsigned l
 {
 	struct file * file = NULL;
 	unsigned long error = -EBADF;
+
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
 		if (!file)
diff -urNp linux-2.4.37.7/arch/parisc/kernel/traps.c linux-2.4.37.7/arch/parisc/kernel/traps.c
--- linux-2.4.37.7/arch/parisc/kernel/traps.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/kernel/traps.c	2009-11-10 19:30:27.000000000 -0500
@@ -637,9 +637,7 @@ void handle_interruption(int code, struc
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -urNp linux-2.4.37.7/arch/parisc/mm/fault.c linux-2.4.37.7/arch/parisc/mm/fault.c
--- linux-2.4.37.7/arch/parisc/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/parisc/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,6 +15,7 @@
 #include <linux/ptrace.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -53,7 +54,7 @@
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -139,6 +140,115 @@ parisc_acctyp(unsigned long code, unsign
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC  
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed 
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int*)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int*)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int*)addr);
+			err |= get_user(bv, (unsigned int*)(addr+4));
+			err |= get_user(ldw2, (unsigned int*)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int*)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int*)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void do_page_fault(struct pt_regs *regs, unsigned long code,
 			      unsigned long address)
 {
@@ -164,8 +274,33 @@ good_area:
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)instruction_pointer(regs), (void*)regs->gr[30]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -urNp linux-2.4.37.7/arch/ppc/config.in linux-2.4.37.7/arch/ppc/config.in
--- linux-2.4.37.7/arch/ppc/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -666,3 +666,12 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urNp linux-2.4.37.7/arch/ppc/kernel/head_4xx.S linux-2.4.37.7/arch/ppc/kernel/head_4xx.S
--- linux-2.4.37.7/arch/ppc/kernel/head_4xx.S	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/kernel/head_4xx.S	2009-11-10 19:30:27.000000000 -0500
@@ -296,15 +296,12 @@ label:
 
 	/* Most of the Linux PTE is ready to load into the TLB LO.
 	 * We set ZSEL, where only the LS-bit determines user access.
-	 * We set execute, because we don't have the granularity to
-	 * properly set this at the page level (Linux problem).
 	 * If shared is set, we cause a zero PID->TID load.
 	 * Many of these bits are software only.  Bits we don't set
 	 * here we (properly should) assume have the appropriate value.
 	 */
 	li	r22, 0x0ce2
 	andc	r21, r21, r22		/* Make sure 20, 21 are zero */
-	ori	r21, r21, _PAGE_HWEXEC	/* make it executable */
 
 	/* find the TLB index that caused the fault.  It has to be here.
 	*/
@@ -783,7 +780,6 @@ finish_tlb_load:
 	stw	r23, tlb_4xx_index@l(0)
 
 6:
-	ori	r21, r21, _PAGE_HWEXEC		/* make it executable */
 	tlbwe	r21, r23, TLB_DATA		/* Load TLB LO */
 
 	/* Create EPN.  This is the faulting address plus a static
diff -urNp linux-2.4.37.7/arch/ppc/kernel/ppc_htab.c linux-2.4.37.7/arch/ppc/kernel/ppc_htab.c
--- linux-2.4.37.7/arch/ppc/kernel/ppc_htab.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/kernel/ppc_htab.c	2009-11-10 19:30:27.000000000 -0500
@@ -61,7 +61,7 @@ extern unsigned int htab_hash_searches;
 #define PMC1 953
 #define PMC2 954
 
-struct file_operations ppc_htab_operations = {
+const struct file_operations ppc_htab_operations = {
         llseek:         ppc_htab_lseek,
         read:           ppc_htab_read,
         write:          ppc_htab_write,
diff -urNp linux-2.4.37.7/arch/ppc/kernel/ptrace.c linux-2.4.37.7/arch/ppc/kernel/ptrace.c
--- linux-2.4.37.7/arch/ppc/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -24,6 +24,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -195,6 +196,9 @@ int sys_ptrace(long request, long pid, l
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urNp linux-2.4.37.7/arch/ppc/kernel/setup.c linux-2.4.37.7/arch/ppc/kernel/setup.c
--- linux-2.4.37.7/arch/ppc/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -238,7 +238,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/ppc/mm/fault.c linux-2.4.37.7/arch/ppc/mm/fault.c
--- linux-2.4.37.7/arch/ppc/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -26,6 +26,9 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -52,6 +55,359 @@ extern void die_if_kernel(char *, struct
 void bad_page_fault(struct pt_regs *, unsigned long, int sig);
 void do_page_fault(struct pt_regs *, unsigned long, unsigned long);
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static struct page* pax_syscall_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(page);
+	return page;
+}
+
+static const struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.nopage = pax_syscall_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int*)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int*)addr);
+			err |= get_user(add, (unsigned int*)(addr+4));
+			err |= get_user(li2, (unsigned int*)(addr+8));
+			err |= get_user(addis2, (unsigned int*)(addr+12));
+			err |= get_user(mtctr, (unsigned int*)(addr+16));
+			err |= get_user(li3, (unsigned int*)(addr+20));
+			err |= get_user(addis3, (unsigned int*)(addr+24));
+			err |= get_user(bctr, (unsigned int*)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(addi, (unsigned int*)(addr+4));
+			err |= get_user(rlwinm, (unsigned int*)(addr+8));
+			err |= get_user(add, (unsigned int*)(addr+12));
+			err |= get_user(li2, (unsigned int*)(addr+16));
+			err |= get_user(addis2, (unsigned int*)(addr+20));
+			err |= get_user(mtctr, (unsigned int*)(addr+24));
+			err |= get_user(li3, (unsigned int*)(addr+28));
+			err |= get_user(addis3, (unsigned int*)(addr+32));
+			err |= get_user(bctr, (unsigned int*)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(lwz, (unsigned int*)(addr+4));
+			err |= get_user(mtctr, (unsigned int*)(addr+8));
+			err |= get_user(bctr, (unsigned int*)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int*)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38007777U && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = 0x7777UL;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38006666U && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = 0x6666UL;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -112,7 +468,7 @@ void do_page_fault(struct pt_regs *regs,
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (regs->trap == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx || CONFIG_BOOKE */
@@ -245,6 +601,33 @@ bad_area:
 
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (current->mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((regs->trap == 0x400) && (regs->nip == address)) {
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		info.si_code = code;
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/ioctl32.c linux-2.4.37.7/arch/ppc64/kernel/ioctl32.c
--- linux-2.4.37.7/arch/ppc64/kernel/ioctl32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/ioctl32.c	2009-11-10 19:30:27.000000000 -0500
@@ -1827,7 +1827,11 @@ static int vt_check(struct file *file)
 	 * To have permissions to do most of the vt ioctls, we either have
 	 * to be the owner of the tty, or super-user.
 	 */
+#ifdef CONFIG_GRKERNSEC
+	if (current->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (current->tty == tty || suser())
+#endif
 		return 1;
 	return 0;                                                    
 }
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/lparcfg.c linux-2.4.37.7/arch/ppc64/kernel/lparcfg.c
--- linux-2.4.37.7/arch/ppc64/kernel/lparcfg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/lparcfg.c	2009-11-10 19:30:27.000000000 -0500
@@ -432,7 +432,7 @@ static int lparcfg_open(struct inode * i
 	return 0;
 }
 
-struct file_operations lparcfg_fops = {
+const struct file_operations lparcfg_fops = {
 	owner:		THIS_MODULE,
 	read:		lparcfg_read,
 	open:		lparcfg_open,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/nvram.c linux-2.4.37.7/arch/ppc64/kernel/nvram.c
--- linux-2.4.37.7/arch/ppc64/kernel/nvram.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/nvram.c	2009-11-10 19:30:27.000000000 -0500
@@ -149,7 +149,7 @@ static int dev_ppc64_nvram_ioctl(struct 
 	return -EINVAL;
 }
 
-struct file_operations nvram_fops = {
+const struct file_operations nvram_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	dev_ppc64_nvram_llseek,
 	.read =		dev_ppc64_read_nvram,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/proc_pmc.c linux-2.4.37.7/arch/ppc64/kernel/proc_pmc.c
--- linux-2.4.37.7/arch/ppc64/kernel/proc_pmc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/proc_pmc.c	2009-11-10 19:30:27.000000000 -0500
@@ -100,7 +100,7 @@ static loff_t  nacamap_seek( struct file
 static ssize_t nacamap_read( struct file *file, char *buf, size_t nbytes, loff_t *ppos);
 static int     nacamap_mmap( struct file *file, struct vm_area_struct *vma );
 
-static struct file_operations nacamap_fops = {
+static const struct file_operations nacamap_fops = {
 	llseek:	nacamap_seek,
 	read:	nacamap_read,
 	mmap:	nacamap_mmap
@@ -116,17 +116,17 @@ static ssize_t read_timeslice(struct fil
 static ssize_t write_timeslice(struct file * file, const char * buf,
 			     size_t count, loff_t *ppos);
 
-static struct file_operations proc_profile_operations = {
+static const struct file_operations proc_profile_operations = {
 	read:		read_profile,
 	write:		write_profile,
 };
 
-static struct file_operations proc_trace_operations = {
+static const struct file_operations proc_trace_operations = {
 	read:		read_trace,
 	write:		write_trace,
 };
 
-static struct file_operations proc_timeslice_operations = {
+static const struct file_operations proc_timeslice_operations = {
 	read:		read_timeslice,
 	write:		write_timeslice,
 };
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/rtasd.c linux-2.4.37.7/arch/ppc64/kernel/rtasd.c
--- linux-2.4.37.7/arch/ppc64/kernel/rtasd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/rtasd.c	2009-11-10 19:30:27.000000000 -0500
@@ -276,7 +276,7 @@ static unsigned int rtas_log_poll(struct
 	return 0;
 }
 
-struct file_operations proc_rtas_log_operations = {
+const struct file_operations proc_rtas_log_operations = {
 	.read =		rtas_log_read,
 	.poll =		rtas_log_poll,
 	.open =		rtas_log_open,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/rtas_flash.c linux-2.4.37.7/arch/ppc64/kernel/rtas_flash.c
--- linux-2.4.37.7/arch/ppc64/kernel/rtas_flash.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/rtas_flash.c	2009-11-10 19:30:27.000000000 -0500
@@ -618,21 +618,21 @@ static inline struct proc_dir_entry * cr
 	return ent;
 }
 
-static struct file_operations rtas_flash_operations = {
+static const struct file_operations rtas_flash_operations = {
 	read:		rtas_flash_read,
 	write:		rtas_flash_write,
 	open:		rtas_excl_open,
 	release:	rtas_flash_release,
 };
 
-static struct file_operations manage_flash_operations = {
+static const struct file_operations manage_flash_operations = {
 	read:		manage_flash_read,
 	write:		manage_flash_write,
 	open:		rtas_excl_open,
 	release:	rtas_excl_release,
 };
 
-static struct file_operations validate_flash_operations = {
+static const struct file_operations validate_flash_operations = {
 	read:		validate_flash_read,
 	write:		validate_flash_write,
 	open:		rtas_excl_open,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/rtas-proc.c linux-2.4.37.7/arch/ppc64/kernel/rtas-proc.c
--- linux-2.4.37.7/arch/ppc64/kernel/rtas-proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/rtas-proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -176,30 +176,30 @@ static ssize_t ppc_rtas_errinjct_write(s
 static ssize_t ppc_rtas_errinjct_read(struct file *file, char *buf,
 				      size_t count, loff_t *ppos);
 
-struct file_operations ppc_rtas_poweron_operations = {
+const struct file_operations ppc_rtas_poweron_operations = {
 	.read =		ppc_rtas_poweron_read,
 	.write =	ppc_rtas_poweron_write
 };
-struct file_operations ppc_rtas_progress_operations = {
+const struct file_operations ppc_rtas_progress_operations = {
 	.read =		ppc_rtas_progress_read,
 	.write =	ppc_rtas_progress_write
 };
 
-struct file_operations ppc_rtas_clock_operations = {
+const struct file_operations ppc_rtas_clock_operations = {
 	.read =		ppc_rtas_clock_read,
 	.write =	ppc_rtas_clock_write
 };
 
-struct file_operations ppc_rtas_tone_freq_operations = {
+const struct file_operations ppc_rtas_tone_freq_operations = {
 	.read =		ppc_rtas_tone_freq_read,
 	.write =	ppc_rtas_tone_freq_write
 };
-struct file_operations ppc_rtas_tone_volume_operations = {
+const struct file_operations ppc_rtas_tone_volume_operations = {
 	.read =		ppc_rtas_tone_volume_read,
 	.write =	ppc_rtas_tone_volume_write
 };
 
-struct file_operations ppc_rtas_errinjct_operations = {
+const struct file_operations ppc_rtas_errinjct_operations = {
     .open =		ppc_rtas_errinjct_open,
     .read = 		ppc_rtas_errinjct_read,
     .write = 		ppc_rtas_errinjct_write,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/rtc.c linux-2.4.37.7/arch/ppc64/kernel/rtc.c
--- linux-2.4.37.7/arch/ppc64/kernel/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -179,7 +179,7 @@ static int rtc_release(struct inode *ino
 /*
  *	The various file operations we support.
  */
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	rtc_llseek,
 	.read =		rtc_read,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/scanlog.c linux-2.4.37.7/arch/ppc64/kernel/scanlog.c
--- linux-2.4.37.7/arch/ppc64/kernel/scanlog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/scanlog.c	2009-11-10 19:30:27.000000000 -0500
@@ -190,7 +190,7 @@ static int scanlog_release(struct inode 
 	return 0;
 }
 
-struct file_operations scanlog_fops = {
+const struct file_operations scanlog_fops = {
 	owner:		THIS_MODULE,
 	read:		scanlog_read,
 	write:		scanlog_write,
diff -urNp linux-2.4.37.7/arch/ppc64/kernel/setup.c linux-2.4.37.7/arch/ppc64/kernel/setup.c
--- linux-2.4.37.7/arch/ppc64/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/ppc64/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -306,7 +306,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start =c_start,
 	.next =	c_next,
 	.stop =	c_stop,
diff -urNp linux-2.4.37.7/arch/s390/config.in linux-2.4.37.7/arch/s390/config.in
--- linux-2.4.37.7/arch/s390/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -87,3 +87,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/s390/kernel/debug.c linux-2.4.37.7/arch/s390/kernel/debug.c
--- linux-2.4.37.7/arch/s390/kernel/debug.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390/kernel/debug.c	2009-11-10 19:30:27.000000000 -0500
@@ -159,14 +159,14 @@ DECLARE_MUTEX(debug_lock);
 
 static int initialized = 0;
 
-static struct file_operations debug_file_ops = {
+static const struct file_operations debug_file_ops = {
 	read:    debug_output,
 	write:   debug_input,	
 	open:    debug_open,
 	release: debug_close,
 };
 
-static struct inode_operations debug_inode_ops = {
+static const struct inode_operations debug_inode_ops = {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
 	default_file_ops: &debug_file_ops,	/* file ops */
 #endif
diff -urNp linux-2.4.37.7/arch/s390/kernel/setup.c linux-2.4.37.7/arch/s390/kernel/setup.c
--- linux-2.4.37.7/arch/s390/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -686,7 +686,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/s390x/config.in linux-2.4.37.7/arch/s390x/config.in
--- linux-2.4.37.7/arch/s390x/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390x/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -91,3 +91,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/s390x/kernel/debug.c linux-2.4.37.7/arch/s390x/kernel/debug.c
--- linux-2.4.37.7/arch/s390x/kernel/debug.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390x/kernel/debug.c	2009-11-10 19:30:27.000000000 -0500
@@ -159,14 +159,14 @@ DECLARE_MUTEX(debug_lock);
 
 static int initialized = 0;
 
-static struct file_operations debug_file_ops = {
+static const struct file_operations debug_file_ops = {
 	read:    debug_output,
 	write:   debug_input,	
 	open:    debug_open,
 	release: debug_close,
 };
 
-static struct inode_operations debug_inode_ops = {
+static const struct inode_operations debug_inode_ops = {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
 	default_file_ops: &debug_file_ops,	/* file ops */
 #endif
diff -urNp linux-2.4.37.7/arch/s390x/kernel/setup.c linux-2.4.37.7/arch/s390x/kernel/setup.c
--- linux-2.4.37.7/arch/s390x/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/s390x/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -545,7 +545,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/sh/config.in linux-2.4.37.7/arch/sh/config.in
--- linux-2.4.37.7/arch/sh/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sh/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -493,3 +493,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/sh/kernel/setup.c linux-2.4.37.7/arch/sh/kernel/setup.c
--- linux-2.4.37.7/arch/sh/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sh/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -566,7 +566,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/sh64/kernel/setup.c linux-2.4.37.7/arch/sh64/kernel/setup.c
--- linux-2.4.37.7/arch/sh64/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sh64/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -353,7 +353,7 @@ static void *c_next(struct seq_file *m, 
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/sparc/boot/Makefile linux-2.4.37.7/arch/sparc/boot/Makefile
--- linux-2.4.37.7/arch/sparc/boot/Makefile	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/boot/Makefile	2009-11-10 19:30:27.000000000 -0500
@@ -24,7 +24,7 @@ clean:
 
 BTOBJS := $(HEAD) init/main.o init/version.o init/do_mounts.o
 BTLIBS := $(CORE_FILES_NO_BTFIX) $(FILESYSTEMS) \
-	$(DRIVERS) $(NETWORKS)
+	$(DRIVERS) $(NETWORKS) $(GRSECURITY)
 
 GENFILES := include/linux/version.h include/linux/compile.h $(foreach dirname, $(CORE_FILES_NO_BTFIX), _dir_$(dir $(dirname)))
 .PHONY : $(GENFILES)
diff -urNp linux-2.4.37.7/arch/sparc/config.in linux-2.4.37.7/arch/sparc/config.in
--- linux-2.4.37.7/arch/sparc/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -282,3 +282,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/sparc/kernel/apc.c linux-2.4.37.7/arch/sparc/kernel/apc.c
--- linux-2.4.37.7/arch/sparc/kernel/apc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/kernel/apc.c	2009-11-10 19:30:27.000000000 -0500
@@ -130,7 +130,7 @@ static int apc_ioctl(struct inode *inode
 	return 0;
 }
 
-static struct file_operations apc_fops = {
+static const struct file_operations apc_fops = {
 	ioctl:		apc_ioctl,
 	open:		apc_open,
 	release:	apc_release,
diff -urNp linux-2.4.37.7/arch/sparc/kernel/ptrace.c linux-2.4.37.7/arch/sparc/kernel/ptrace.c
--- linux-2.4.37.7/arch/sparc/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -17,6 +17,7 @@
 #include <linux/user.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -310,6 +311,9 @@ asmlinkage void do_ptrace(struct pt_regs
 		goto out;
 	}
 
+	if(gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urNp linux-2.4.37.7/arch/sparc/kernel/setup.c linux-2.4.37.7/arch/sparc/kernel/setup.c
--- linux-2.4.37.7/arch/sparc/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -516,7 +516,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/sparc/kernel/sys_sparc.c linux-2.4.37.7/arch/sparc/kernel/sys_sparc.c
--- linux-2.4.37.7/arch/sparc/kernel/sys_sparc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/kernel/sys_sparc.c	2009-11-10 19:30:27.000000000 -0500
@@ -54,6 +54,13 @@ unsigned long arch_get_unmapped_area(str
 		return -ENOMEM;
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -urNp linux-2.4.37.7/arch/sparc/mm/fault.c linux-2.4.37.7/arch/sparc/mm/fault.c
--- linux-2.4.37.7/arch/sparc/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -19,6 +19,9 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/segment.h>
@@ -219,6 +222,248 @@ static unsigned long compute_si_addr(str
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	return page;
+}
+
+static const struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->pc);
+		err |= get_user(sethi2, (unsigned int*)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->pc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned int addr;
+
+			addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(ba, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->pc-4));
+		err |= get_user(call, (unsigned int*)regs->pc);
+		err |= get_user(nop, (unsigned int*)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -282,6 +527,24 @@ good_area:
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)regs->u_regs[UREG_FP]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -urNp linux-2.4.37.7/arch/sparc/mm/init.c linux-2.4.37.7/arch/sparc/mm/init.c
--- linux-2.4.37.7/arch/sparc/mm/init.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/mm/init.c	2009-11-10 19:30:27.000000000 -0500
@@ -350,17 +350,17 @@ void __init paging_init(void)
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -urNp linux-2.4.37.7/arch/sparc/mm/srmmu.c linux-2.4.37.7/arch/sparc/mm/srmmu.c
--- linux-2.4.37.7/arch/sparc/mm/srmmu.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc/mm/srmmu.c	2009-11-10 19:30:27.000000000 -0500
@@ -2047,6 +2047,13 @@ void __init ld_mmu_srmmu(void)
 	BTFIXUPSET_INT(page_shared, pgprot_val(SRMMU_PAGE_SHARED));
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	BTFIXUPSET_INT(page_shared_noexec, pgprot_val(SRMMU_PAGE_SHARED_NOEXEC));
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 	pg_iobits = SRMMU_VALID | SRMMU_WRITE | SRMMU_REF;
diff -urNp linux-2.4.37.7/arch/sparc64/config.in linux-2.4.37.7/arch/sparc64/config.in
--- linux-2.4.37.7/arch/sparc64/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -320,3 +320,11 @@ endmenu
 
 source crypto/Config.in
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/sparc64/kernel/ioctl32.c linux-2.4.37.7/arch/sparc64/kernel/ioctl32.c
--- linux-2.4.37.7/arch/sparc64/kernel/ioctl32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/kernel/ioctl32.c	2009-11-10 19:30:27.000000000 -0500
@@ -2053,7 +2053,11 @@ static int vt_check(struct file *file)
 	 * To have permissions to do most of the vt ioctls, we either have
 	 * to be the owner of the tty, or super-user.
 	 */
+#ifdef CONFIG_GRKERNSEC
+	if (current->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (current->tty == tty || suser())
+#endif
 		return 1;
 	return 0;                                                    
 }
diff -urNp linux-2.4.37.7/arch/sparc64/kernel/ptrace.c linux-2.4.37.7/arch/sparc64/kernel/ptrace.c
--- linux-2.4.37.7/arch/sparc64/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -18,6 +18,7 @@
 #include <linux/user.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/asi.h>
 #include <asm/pgtable.h>
@@ -161,6 +162,11 @@ asmlinkage void do_ptrace(struct pt_regs
 		goto out;
 	}
 
+	if (gr_handle_ptrace(child, (long)request)) {
+		pt_error_return(regs, EPERM);
+		goto out_tsk;
+	}
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urNp linux-2.4.37.7/arch/sparc64/kernel/setup.c linux-2.4.37.7/arch/sparc64/kernel/setup.c
--- linux-2.4.37.7/arch/sparc64/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -690,7 +690,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/sparc64/kernel/sys_sparc32.c linux-2.4.37.7/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.4.37.7/arch/sparc64/kernel/sys_sparc32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/kernel/sys_sparc32.c	2009-11-10 19:30:27.000000000 -0500
@@ -53,6 +53,8 @@
 #include <linux/vmalloc.h>
 #include <linux/dnotify.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/types.h>
 #include <asm/ipc.h>
@@ -3274,8 +3276,18 @@ do_execve32(char * filename, u32 * argv,
 	struct file * file;
 	int retval;
 	int i;
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+	bprm.p -= (net_random() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES * sizeof(bprm.page[0]));
 
 	file = open_exec(filename);
@@ -3284,6 +3296,20 @@ do_execve32(char * filename, u32 * argv,
 	if (IS_ERR(file))
 		return retval;
 
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes), 1);
+
+	if (gr_handle_nproc()) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+
+	if (!gr_acl_handle_execve(file->f_dentry, file->f_vfsmnt)) {
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+
 	bprm.file = file;
 	bprm.filename = filename;
 	bprm.sh_bang = 0;
@@ -3304,11 +3330,24 @@ do_execve32(char * filename, u32 * argv,
 	if (retval < 0)
 		goto out;
 	
+	if(!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
 	if (retval < 0)
 		goto out;
 
 	bprm.exec = bprm.p;
+
+	gr_log_chroot_exec(file->f_dentry, file->f_vfsmnt);
+
 	retval = copy_strings32(bprm.envc, envp, &bprm);
 	if (retval < 0)
 		goto out;
@@ -3317,11 +3356,35 @@ do_execve32(char * filename, u32 * argv,
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+
+        retval = gr_set_proc_label(file->f_dentry, file->f_vfsmnt);
+	if (retval < 0)
+		goto out_fail;
+
 	retval = search_binary_handler(&bprm, regs);
-	if (retval >= 0)
+	if (retval >= 0) {
+#ifdef CONFIG_GRKERNSEC
+		if (old_exec_file)
+			fput(old_exec_file);
+#endif
 		/* execve success */
 		return retval;
+	}
 
+out_fail:
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
 	allow_write_access(bprm.file);
diff -urNp linux-2.4.37.7/arch/sparc64/kernel/sys_sparc.c linux-2.4.37.7/arch/sparc64/kernel/sys_sparc.c
--- linux-2.4.37.7/arch/sparc64/kernel/sys_sparc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/kernel/sys_sparc.c	2009-11-10 19:30:27.000000000 -0500
@@ -63,6 +63,13 @@ unsigned long arch_get_unmapped_area(str
 		task_size = 0xf0000000UL;
 	if (len > task_size || len > -PAGE_OFFSET)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -urNp linux-2.4.37.7/arch/sparc64/mm/fault.c linux-2.4.37.7/arch/sparc64/mm/fault.c
--- linux-2.4.37.7/arch/sparc64/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -16,6 +16,9 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -306,6 +309,369 @@ cannot_handle:
 	unhandled_fault (address, current, regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_EMUPLT
+static void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	return page;
+}
+
+static const struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->tpc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned long addr;
+
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int mov1, call, mov2;
+
+		err = get_user(mov1, (unsigned int*)regs->tpc);
+		err |= get_user(call, (unsigned int*)(regs->tpc+4));
+		err |= get_user(mov2, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if (mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(or1, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or2, (unsigned int*)(regs->tpc+12));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020 &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or, (unsigned int*)(regs->tpc+12));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+16));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+20));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020 &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #7 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->tpc-4));
+		err |= get_user(call, (unsigned int*)regs->tpc);
+		err |= get_user(nop, (unsigned int*)(regs->tpc+4));
+
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -345,6 +711,7 @@ asmlinkage void do_sparc64_fault(struct 
 
 	if ((current->thread.flags & SPARC_FLAG_32BIT) != 0) {
 		regs->tpc &= 0xffffffff;
+		regs->tnpc &= 0xffffffff;
 		address &= 0xffffffff;
 	}
 
@@ -353,6 +720,29 @@ asmlinkage void do_sparc64_fault(struct 
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			goto fault_done;
+#endif
+
+		}
+		pax_report_fault(regs, (void*)regs->tpc, (void*)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -urNp linux-2.4.37.7/arch/sparc64/solaris/socksys.c linux-2.4.37.7/arch/sparc64/solaris/socksys.c
--- linux-2.4.37.7/arch/sparc64/solaris/socksys.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/sparc64/solaris/socksys.c	2009-11-10 19:30:27.000000000 -0500
@@ -49,7 +49,7 @@ extern void mykfree(void *);
 
 static unsigned int (*sock_poll)(struct file *, poll_table *);
 
-static struct file_operations socksys_file_ops = {
+static const struct file_operations socksys_file_ops = {
 	/* Currently empty */
 };
 
@@ -156,7 +156,7 @@ static unsigned int socksys_poll(struct 
 	return mask;
 }
 	
-static struct file_operations socksys_fops = {
+static const struct file_operations socksys_fops = {
 	open:		socksys_open,
 	release:	socksys_release,
 };
diff -urNp linux-2.4.37.7/arch/x86_64/config.in linux-2.4.37.7/arch/x86_64/config.in
--- linux-2.4.37.7/arch/x86_64/config.in	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/config.in	2009-11-10 19:30:27.000000000 -0500
@@ -262,3 +262,11 @@ int 'Kernel messages buffer length shift
 endmenu
 
 source lib/Config.in
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+	source grsecurity/Config.in
+fi
+endmenu
diff -urNp linux-2.4.37.7/arch/x86_64/ia32/ia32_binfmt.c linux-2.4.37.7/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.4.37.7/arch/x86_64/ia32/ia32_binfmt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/ia32/ia32_binfmt.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,7 +28,14 @@ struct elf_phdr; 
 
 #define ELF_NAME "elf/i386"
 
-#define IA32_STACK_TOP IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK (current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK 0UL
+#endif
+
+#define IA32_STACK_TOP (IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+   
 #define ELF_ET_DYN_BASE		(IA32_PAGE_OFFSET/3 + 0x1000000)
 
 #undef ELF_ARCH
@@ -129,6 +136,13 @@ struct elf_prpsinfo
 #include <asm/ia32.h>
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x08048000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 typedef struct user_i387_ia32_struct elf_fpregset_t;
 typedef struct user32_fxsr_struct elf_fpxregset_t;
 
@@ -218,7 +232,7 @@ static void elf32_init(struct pt_regs *r
 	me->thread.flags |= THREAD_IA32;
 }
 
-extern void put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address);
+extern int put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address);
  
 
 int ia32_setup_arg_pages(struct linux_binprm *bprm)
@@ -243,7 +257,13 @@ int ia32_setup_arg_pages(struct linux_bi
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = IA32_STACK_TOP;
-		mpnt->vm_flags = vm_stack_flags32; 
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		mpnt->vm_flags = VM_STACK_FLAGS;
+#else
+		mpnt->vm_flags = vm_stack_flags32;
+#endif
+
 		mpnt->vm_page_prot = (mpnt->vm_flags & VM_EXEC) ? 
 			PAGE_COPY_EXEC : PAGE_COPY;
 		mpnt->vm_ops = NULL;
@@ -260,16 +280,18 @@ int ia32_setup_arg_pages(struct linux_bi
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
 		struct page *page = bprm->page[i];
+		int retval;
 		if (page) {
 			bprm->page[i] = NULL;
-			current->mm->rss++;
-			put_dirty_page(current,page,stack_base);
+			retval = put_dirty_page(current,page,stack_base);
+			if (!ret)
+				ret = retval;
 		}
 		stack_base += PAGE_SIZE;
 	}
 	up_write(&current->mm->mmap_sem);
-	
-	return 0;
+
+	return ret;
 }
 static unsigned long
 elf32_map (struct file *filep, unsigned long addr, struct elf_phdr *eppnt, int prot, int type)
@@ -277,8 +299,10 @@ elf32_map (struct file *filep, unsigned 
 	unsigned long map_addr;
 	struct task_struct *me = current; 
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ) 
 		prot |= PROT_EXEC; 
+#endif
 
 	down_write(&me->mm->mmap_sem);
 	map_addr = do_mmap(filep, ELF_PAGESTART(addr),
diff -urNp linux-2.4.37.7/arch/x86_64/ia32/ia32_ioctl.c linux-2.4.37.7/arch/x86_64/ia32/ia32_ioctl.c
--- linux-2.4.37.7/arch/x86_64/ia32/ia32_ioctl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/ia32/ia32_ioctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -1963,7 +1963,11 @@ static int vt_check(struct file *file)
 	 * To have permissions to do most of the vt ioctls, we either have
 	 * to be the owner of the tty, or super-user.
 	 */
+#ifdef CONFIG_GRKERNSEC
+	if (current->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (current->tty == tty || suser())
+#endif
 		return 1;
 	return 0;                                                    
 }
diff -urNp linux-2.4.37.7/arch/x86_64/ia32/sys_ia32.c linux-2.4.37.7/arch/x86_64/ia32/sys_ia32.c
--- linux-2.4.37.7/arch/x86_64/ia32/sys_ia32.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/ia32/sys_ia32.c	2009-11-10 19:30:27.000000000 -0500
@@ -333,8 +333,11 @@ sys32_mmap(struct mmap_arg_struct *arg)
 			return -EBADF;
 	}
 	
+
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (a.prot & PROT_READ) 
 		a.prot |= PROT_EXEC; 
+#endif
 
 	mm = current->mm; 
 	down_write(&mm->mmap_sem); 
@@ -351,8 +354,12 @@ extern asmlinkage long sys_mprotect(unsi
 
 asmlinkage long sys32_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
+
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ) 
 		prot |= PROT_EXEC; 
+#endif
+
 	return sys_mprotect(start,len,prot); 
 }
 
@@ -2121,8 +2128,10 @@ asmlinkage long sys32_mmap2(unsigned lon
 			return -EBADF;
 	}
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ)
 		prot |= PROT_EXEC;
+#endif
 
 	down_write(&mm->mmap_sem);
 	error = do_mmap_pgoff(file, addr, len, prot, flags|MAP_32BIT, pgoff);
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/cpuid.c linux-2.4.37.7/arch/x86_64/kernel/cpuid.c
--- linux-2.4.37.7/arch/x86_64/kernel/cpuid.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/cpuid.c	2009-11-10 19:30:27.000000000 -0500
@@ -133,7 +133,7 @@ static int cpuid_open(struct inode *inod
 /*
  * File operations we support
  */
-static struct file_operations cpuid_fops = {
+static const struct file_operations cpuid_fops = {
   owner:	THIS_MODULE,
   llseek:	cpuid_seek,
   read:		cpuid_read,
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/ioport.c linux-2.4.37.7/arch/x86_64/kernel/ioport.c
--- linux-2.4.37.7/arch/x86_64/kernel/ioport.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/ioport.c	2009-11-10 19:30:27.000000000 -0500
@@ -38,8 +38,16 @@ asmlinkage long sys_ioperm(unsigned long
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
+
+#ifdef CONFIG_GRKERNSEC_IO
+	if (turn_on) {
+		gr_handle_ioperm();
+		return -EPERM;
+	}
+#else
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
+#endif
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -89,8 +97,13 @@ asmlinkage long sys_iopl(unsigned int le
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
+#ifdef CONFIG_GRKERNSEC_IO
+		gr_handle_iopl();
+		return -EPERM;
+#else
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
+#endif
 	}
 	regs->eflags = (regs->eflags &~ 0x3000UL) | (level << 12);
 	return 0;
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/msr.c linux-2.4.37.7/arch/x86_64/kernel/msr.c
--- linux-2.4.37.7/arch/x86_64/kernel/msr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/msr.c	2009-11-10 19:30:27.000000000 -0500
@@ -240,7 +240,7 @@ static int msr_open(struct inode *inode,
 /*
  * File operations we support
  */
-static struct file_operations msr_fops = {
+static const struct file_operations msr_fops = {
   owner:	THIS_MODULE,
   llseek:	msr_seek,
   read:		msr_read,
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/mtrr.c linux-2.4.37.7/arch/x86_64/kernel/mtrr.c
--- linux-2.4.37.7/arch/x86_64/kernel/mtrr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/mtrr.c	2009-11-10 19:30:27.000000000 -0500
@@ -981,6 +981,9 @@ static ssize_t mtrr_write (struct file *
 	char *ptr;
 	char line[LINE_SIZE];
 
+	if (len == 0)
+		return -EINVAL;
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -1208,7 +1211,7 @@ static int mtrr_close (struct inode *ino
 }
 
 
-static struct file_operations mtrr_fops = {
+static const struct file_operations mtrr_fops = {
 	owner:	THIS_MODULE,
 	read:	mtrr_read,
 	write:	mtrr_write,
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/ptrace.c linux-2.4.37.7/arch/x86_64/kernel/ptrace.c
--- linux-2.4.37.7/arch/x86_64/kernel/ptrace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/ptrace.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,6 +15,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -206,6 +207,9 @@ asmlinkage long sys_ptrace(long request,
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child, request))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/setup64.c linux-2.4.37.7/arch/x86_64/kernel/setup64.c
--- linux-2.4.37.7/arch/x86_64/kernel/setup64.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/setup64.c	2009-11-10 19:30:27.000000000 -0500
@@ -36,11 +36,18 @@ struct desc_ptr idt_descr = { 256 * 16, 
    correct flags everywhere. */
 unsigned long __supported_pte_mask = ~0UL; 
 static int do_not_nx __initdata = 0;  
-unsigned long vm_stack_flags = __VM_STACK_FLAGS; 
-unsigned long vm_stack_flags32 = __VM_STACK_FLAGS; 
+
+#ifdef CONFIG_PAX_PAGEEXEC
+unsigned long vm_stack_flags = __VM_DATA_DEFAULT_FLAGS;
+unsigned long vm_stack_flags32 = __VM_DATA_DEFAULT_FLAGS;
+#else
+unsigned long vm_stack_flags = __VM_STACK_FLAGS;
+unsigned long vm_stack_flags32 = __VM_STACK_FLAGS;
+#endif
+
 unsigned long vm_data_default_flags = __VM_DATA_DEFAULT_FLAGS; 
 unsigned long vm_data_default_flags32 = __VM_DATA_DEFAULT_FLAGS; 
-unsigned long vm_force_exec32 = PROT_EXEC; 
+unsigned long vm_force_exec32 = 0; 
 
 char boot_cpu_stack[IRQSTACKSIZE] __cacheline_aligned;
 
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/setup.c linux-2.4.37.7/arch/x86_64/kernel/setup.c
--- linux-2.4.37.7/arch/x86_64/kernel/setup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/setup.c	2009-11-10 19:30:27.000000000 -0500
@@ -913,7 +913,7 @@ static void c_stop(struct seq_file *m, v
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	start:	c_start,
 	next:	c_next,
 	stop:	c_stop,
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/signal.c linux-2.4.37.7/arch/x86_64/kernel/signal.c
--- linux-2.4.37.7/arch/x86_64/kernel/signal.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/signal.c	2009-11-10 19:30:27.000000000 -0500
@@ -144,7 +144,7 @@ restore_sigcontext(struct pt_regs *regs,
 	COPY(rdx); COPY(rcx); 
 	COPY(rip);
 	if (regs->rip >= TASK_SIZE && regs->rip < VSYSCALL_START) { 
-		regs->rip = 0;
+		regs->rip = ~0UL;
 		return -EFAULT;
 	}
 	COPY(r8);
@@ -361,7 +361,7 @@ static void setup_rt_frame(int sig, stru
 	if (regs->rip >= TASK_SIZE) { 
 		if (sig == SIGSEGV)
 			ka->sa.sa_handler = SIG_DFL;
-		regs->rip = 0;
+		regs->rip = ~0UL;
 	}
 	regs->cs = __USER_CS;
 	regs->ss = __USER_DS; 
diff -urNp linux-2.4.37.7/arch/x86_64/kernel/sys_x86_64.c linux-2.4.37.7/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.4.37.7/arch/x86_64/kernel/sys_x86_64.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/kernel/sys_x86_64.c	2009-11-10 19:30:27.000000000 -0500
@@ -72,6 +72,13 @@ unsigned long arch_get_unmapped_area(str
 	unsigned long end = TASK_SIZE;
 
 	if (current->thread.flags & THREAD_IA32) {
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = TASK_UNMAPPED_32 + current->mm->delta_mmap;
+		else
+#endif
+
 		if (!addr) 
 			addr = TASK_UNMAPPED_32;
 		end = 0xffff0000;
@@ -82,10 +89,24 @@ unsigned long arch_get_unmapped_area(str
 		   base down for this case.  This may give conflicts
 		   with the heap, but we assume that malloc falls back
 		   to mmap. Give it 1GB of playground for now. -AK */ 
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = 0x40000000 + (current->mm->delta_mmap & 0x0FFFFFFFU);
+		else
+#endif
+
 		if (!addr) 
 			addr = 0x40000000; 
 		end = 0x80000000;		
 	} else { 
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = TASK_UNMAPPED_64 + current->mm->delta_mmap;
+		else
+#endif
+
 		if (!addr) 
 			addr = TASK_UNMAPPED_64; 
 		end = TASK_SIZE; 
diff -urNp linux-2.4.37.7/arch/x86_64/mm/fault.c linux-2.4.37.7/arch/x86_64/mm/fault.c
--- linux-2.4.37.7/arch/x86_64/mm/fault.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/arch/x86_64/mm/fault.c	2009-11-10 19:30:27.000000000 -0500
@@ -173,6 +173,33 @@ static int is_prefetch(struct pt_regs *r
 	return prefetch;
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned char*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-8: ");
+	for (i = -1; i < 10; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long*)sp+i))
+			printk("???????????????? ");
+		else
+			printk("%16lx ", c);
+	}
+	printk("\n");
+}
+#endif
+
 int page_fault_trace; 
 int exception_trace = 1;
 
@@ -267,6 +294,15 @@ again:
  * we can handle it..
  */
 good_area:
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (error_code & 16) && !(vma->vm_flags & VM_EXEC)) {
+		up_read(&mm->mmap_sem);
+		pax_report_fault(regs, (void*)regs->rip, (void*)regs->rsp);
+		do_exit(SIGKILL);
+	}
+#endif
+
 	info.si_code = SEGV_ACCERR;
 	write = 0;
 	switch (error_code & 3) {
diff -urNp linux-2.4.37.7/crypto/proc.c linux-2.4.37.7/crypto/proc.c
--- linux-2.4.37.7/crypto/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/crypto/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -86,7 +86,7 @@ static int c_show(struct seq_file *m, vo
 	return 0;
 }
 
-static struct seq_operations crypto_seq_ops = {
+static const struct seq_operations crypto_seq_ops = {
 	.start		= c_start,
 	.next		= c_next,
 	.stop		= c_stop,
@@ -98,7 +98,7 @@ static int crypto_info_open(struct inode
 	return seq_open(file, &crypto_seq_ops);
 }
         
-static struct file_operations proc_crypto_ops = {
+static const struct file_operations proc_crypto_ops = {
 	.open		= crypto_info_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
diff -urNp linux-2.4.37.7/Documentation/Configure.help linux-2.4.37.7/Documentation/Configure.help
--- linux-2.4.37.7/Documentation/Configure.help	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/Documentation/Configure.help	2009-11-10 19:30:27.000000000 -0500
@@ -23530,6 +23530,933 @@ CONFIG_CF_AREA5
 
   "Area6" will work for most boards. For ADX, select "Area5".
 
+Grsecurity
+CONFIG_GRKERNSEC
+  If you say Y here, you will be able to configure many features that
+  will enhance the security of your system.  It is highly recommended
+  that you say Y here and read through the help for each option so
+  you fully understand the features and can evaluate their usefulness
+  for your machine.
+
+Additional security levels
+CONFIG_GRKERNSEC_LOW
+
+  Low additional security
+  -----------------------------------------------------------------------
+  If you choose this option, several of the grsecurity options will
+  be enabled that will give you greater protection against a number
+  of attacks, while assuring that none of your software will have any 
+  conflicts with the additional security measures.  If you run a lot of 
+  unusual software, or you are having problems with the higher security 
+  levels, you should say Y here.  With this option, the following features
+  are enabled:
+  
+  linking restrictions
+  fifo restrictions
+  enforcing nproc on execve()
+  restricted dmesg
+  enforced chdir("/") on chroot
+  runtime module disabling
+
+  Medium additional security
+  -----------------------------------------------------------------------
+  If you say Y here, several features in addition to those included in the 
+  low additional security level will be enabled.  These features provide
+  even more security to your system, though in rare cases they may
+  be incompatible with very old or poorly written software.  If you 
+  enable this option, make sure that your auth service (identd) is 
+  running as gid 10 (usually group wheel). With this option the following 
+  features (in addition to those provided in the low additional security 
+  level) will be enabled:
+
+  random tcp source ports
+  failed fork logging
+  time change logging
+  signal logging
+  deny mounts in chroot
+  deny double chrooting
+  deny sysctl writes in chroot
+  deny mknod in chroot
+  deny access to abstract AF_UNIX sockets out of chroot
+  deny pivot_root in chroot
+  denied writes of /dev/kmem, /dev/mem, and /dev/port
+  /proc restrictions with special gid set to 10 (usually wheel)
+  address space layout randomization
+  removal of addresses from /proc/<pid>/[maps|stat]
+
+  High additional security
+  ----------------------------------------------------------------------
+  If you say Y here, many of the features of grsecurity will be enabled,
+  that will protect you against many kinds of attacks against
+  your system.  The heightened security comes at a cost of an 
+  increased chance of incompatibilities with rare software on your 
+  machine.  Since this security level enables PaX, you should view 
+  <http://pax.grsecurity.net> and read about the PaX project.  While 
+  you are there, download chpax and run it on binaries that cause 
+  problems with PaX.  Also remember that since the /proc restrictions are 
+  enabled, you must run your identd as group wheel (gid 10).  
+  This security level enables the following features in addition to those
+  listed in the low and medium security levels:
+
+  additional /proc restrictions
+  chmod restrictions in chroot
+  no signals, ptrace, or viewing processes outside of chroot
+  capability restrictions in chroot
+  deny fchdir out of chroot
+  priority restrictions in chroot
+  segmentation-based implementation of PaX
+  mprotect restrictions
+  kernel stack randomization
+  mount/unmount/remount logging
+  kernel symbol hiding
+  destroy unused shared memory
+
+Customized additional security
+CONFIG_GRKERNSEC_CUSTOM
+  If you say Y here, you will be able to configure every grsecurity 
+  option, which allows you to enable many more features that aren't 
+  covered in the basic security levels.  These additional features include 
+  TPE, socket restrictions, and the sysctl system for grsecurity.  It is 
+  advised that you read through the help for each option to determine its 
+  usefulness in your situation.
+
+Support soft mode
+CONFIG_PAX_SOFTMODE
+  Enabling this option will allow you to run PaX in soft mode, that
+  is, PaX features will not be enforced by default, only on executables
+  marked explicitly.  You must also enable PT_PAX_FLAGS support as it
+  is the only way to mark executables for soft mode use.
+
+  Soft mode can be activated by using the "pax_softmode=1" kernel command
+  line option on boot.  Furthermore you can control various PaX features
+  at runtime via the entries in /proc/sys/kernel/pax.
+
+Use legacy ELF header marking
+CONFIG_PAX_EI_PAX
+  Enabling this option will allow you to control PaX features on
+  a per executable basis via the 'chpax' utility available at
+  http://pax.grsecurity.net/.  The control flags will be read from
+  an otherwise reserved part of the ELF header.  This marking has
+  numerous drawbacks (no support for soft-mode, toolchain does not
+  know about the non-standard use of the ELF header) therefore it
+  has been deprecated in favour of PT_PAX_FLAGS support.
+
+  If you have applications not marked by the PT_PAX_FLAGS ELF
+  program header then you MUST enable this option otherwise they
+  will not get any protection.
+
+  Note that if you enable PT_PAX_FLAGS marking support as well,
+  the PT_PAX_FLAG marks will override the legacy EI_PAX marks.
+
+Use ELF program header marking
+CONFIG_PAX_PT_PAX_FLAGS
+  Enabling this option will allow you to control PaX features on
+  a per executable basis via the 'paxctl' utility available at
+  http://pax.grsecurity.net/.  The control flags will be read from
+  a PaX specific ELF program header (PT_PAX_FLAGS).  This marking
+  has the benefits of supporting both soft mode and being fully
+  integrated into the toolchain (the binutils patch is available
+  from http://pax.grsecurity.net).
+
+  If you have applications not marked by the PT_PAX_FLAGS ELF
+  program header then you MUST enable the EI_PAX marking support
+  otherwise they will not get any protection.
+
+  Note that if you enable the legacy EI_PAX marking support as well,
+  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+
+MAC system integration
+CONFIG_PAX_NO_ACL_FLAGS
+  Mandatory Access Control systems have the option of controlling
+  PaX flags on a per executable basis, choose the method supported
+  by your particular system.
+
+  - "none": if your MAC system does not interact with PaX,
+  - "direct": if your MAC system defines pax_set_initial_flags() itself,
+  - "hook": if your MAC system uses the pax_set_initial_flags_func callback.
+
+  NOTE: this option is for developers/integrators only.
+
+Enforce non-executable pages
+CONFIG_PAX_NOEXEC
+  By design some architectures do not allow for protecting memory
+  pages against execution or even if they do, Linux does not make
+  use of this feature.  In practice this means that if a page is
+  readable (such as the stack or heap) it is also executable.
+
+  There is a well known exploit technique that makes use of this
+  fact and a common programming mistake where an attacker can
+  introduce code of his choice somewhere in the attacked program's
+  memory (typically the stack or the heap) and then execute it.
+
+  If the attacked program was running with different (typically
+  higher) privileges than that of the attacker, then he can elevate
+  his own privilege level (e.g. get a root shell, write to files for
+  which he does not have write access to, etc).
+
+  Enabling this option will let you choose from various features
+  that prevent the injection and execution of 'foreign' code in
+  a program.
+
+  This will also break programs that rely on the old behaviour and
+  expect that dynamically allocated memory via the malloc() family
+  of functions is executable (which it is not).  Notable examples
+  are the XFree86 4.x server, the java runtime and wine.
+
+Paging based non-executable pages
+CONFIG_PAX_PAGEEXEC
+  This implementation is based on the paging feature of the CPU.
+  On i386 it has a variable performance impact on applications
+  depending on their memory usage pattern.  You should carefully
+  test your applications before using this feature in production.
+  On alpha, parisc, sparc and sparc64 there is no performance
+  impact.  On ppc there is a slight performance impact.
+
+Segmentation based non-executable pages
+CONFIG_PAX_SEGMEXEC
+  This implementation is based on the segmentation feature of the
+  CPU and has little performance impact, however applications will
+  be limited to a 1.5 GB address space instead of the normal 3 GB.
+
+Emulate trampolines
+CONFIG_PAX_EMUTRAMP
+  There are some programs and libraries that for one reason or
+  another attempt to execute special small code snippets from
+  non-executable memory pages.  Most notable examples are the
+  signal handler return code generated by the kernel itself and
+  the GCC trampolines.
+
+  If you enabled CONFIG_PAX_PAGEEXEC or 
+  CONFIG_PAX_SEGMEXEC then such programs will no longer
+  work under your kernel.
+
+  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+  utilities to enable trampoline emulation for the affected programs
+  yet still have the protection provided by the non-executable pages.
+
+  On parisc and ppc you MUST enable this option and EMUSIGRT as
+  well, otherwise your system will not even boot.
+
+  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+  utilities to disable CONFIG_PAX_PAGEEXEC and 
+  CONFIG_PAX_SEGMEXEC for the affected files.
+
+  NOTE: enabling this feature *may* open up a loophole in the
+  protection provided by non-executable pages that an attacker
+  could abuse.  Therefore the best solution is to not have any
+  files on your system that would require this option.  This can
+  be achieved by not using libc5 (which relies on the kernel
+  signal handler return code) and not using or rewriting programs
+  that make use of the nested function implementation of GCC.
+  Skilled users can just fix GCC itself so that it implements
+  nested function calls in a way that does not interfere with PaX.
+
+Automatically emulate sigreturn trampolines
+CONFIG_PAX_EMUSIGRT
+  Enabling this option will have the kernel automatically detect
+  and emulate signal return trampolines executing on the stack
+  that would otherwise lead to task termination.
+
+  This solution is intended as a temporary one for users with
+  legacy versions of libc (libc5, glibc 2.0, uClibc before 0.9.17,
+  Modula-3 runtime, etc) or executables linked to such, basically
+  everything that does not specify its own SA_RESTORER function in
+  normal executable memory like glibc 2.1+ does.
+
+  On parisc and ppc you MUST enable this option, otherwise your
+  system will not even boot.
+
+  NOTE: this feature cannot be disabled on a per executable basis
+  and since it *does* open up a loophole in the protection provided
+  by non-executable pages, the best solution is to not have any
+  files on your system that would require this option.
+
+Restrict mprotect()
+CONFIG_PAX_MPROTECT
+  Enabling this option will prevent programs from
+   - changing the executable status of memory pages that were
+     not originally created as executable,
+   - making read-only executable pages writable again,
+   - creating executable pages from anonymous memory.
+
+  You should say Y here to complete the protection provided by
+  the enforcement of non-executable pages.
+
+  NOTE: you can use the 'chpax' utility to control this
+  feature on a per file basis. chpax is available at
+  <http://pax.grsecurity.net>
+
+Disallow ELF text relocations
+CONFIG_PAX_NOELFRELOCS
+  Non-executable pages and mprotect() restrictions are effective
+  in preventing the introduction of new executable code into an
+  attacked task's address space.  There remain only two venues
+  for this kind of attack: if the attacker can execute already
+  existing code in the attacked task then he can either have it
+  create and mmap() a file containing his code or have it mmap()
+  an already existing ELF library that does not have position
+  independent code in it and use mprotect() on it to make it
+  writable and copy his code there.  While protecting against
+  the former approach is beyond PaX, the latter can be prevented
+  by having only PIC ELF libraries on one's system (which do not
+  need to relocate their code).  If you are sure this is your case,
+  then enable this option otherwise be careful as you may not even
+  be able to boot or log on your system (for example, some PAM
+  modules are erroneously compiled as non-PIC by default).
+
+  NOTE: if you are using dynamic ELF executables (as suggested
+  when using ASLR) then you must have made sure that you linked
+  your files using the PIC version of crt1 (the et_dyn.zip package
+  referenced there has already been updated to support this).
+
+Enforce non-executable kernel pages
+CONFIG_PAX_KERNEXEC
+  This is the kernel land equivalent of PAGEEXEC and MPROTECT,
+  that is, enabling this option will make it harder to inject
+  and execute 'foreign' code in kernel memory itself.
+
+Address Space Layout Randomization
+CONFIG_PAX_ASLR
+  Many if not most exploit techniques rely on the knowledge of
+  certain addresses in the attacked program.  The following options
+  will allow the kernel to apply a certain amount of randomization
+  to specific parts of the program thereby forcing an attacker to
+  guess them in most cases.  Any failed guess will most likely crash
+  the attacked program which allows the kernel to detect such attempts
+  and react on them.  PaX itself provides no reaction mechanisms,
+  instead it is strongly encouraged that you make use of grsecurity's
+  built-in crash detection features or develop one yourself.
+
+  By saying Y here you can choose to randomize the following areas:
+   - top of the task's kernel stack
+   - top of the task's userland stack
+   - base address for mmap() requests that do not specify one
+     (this includes all libraries)
+   - base address of the main executable
+
+  It is strongly recommended to say Y here as address space layout
+  randomization has negligible impact on performance yet it provides
+  a very effective protection.
+
+  NOTE: you can use the 'chpax' or 'paxctl' utilities to control most
+  of these features on a per file basis.
+
+Randomize kernel stack base
+CONFIG_PAX_RANDKSTACK
+  By saying Y here the kernel will randomize every task's kernel
+  stack on every system call.  This will not only force an attacker
+  to guess it but also prevent him from making use of possible
+  leaked information about it.
+
+  Since the kernel stack is a rather scarce resource, randomization
+  may cause unexpected stack overflows, therefore you should very
+  carefully test your system.  Note that once enabled in the kernel
+  configuration, this feature cannot be disabled on a per file basis.
+
+Randomize user stack base
+CONFIG_PAX_RANDUSTACK
+  By saying Y here the kernel will randomize every task's userland
+  stack.  The randomization is done in two steps where the second
+  one may apply a big amount of shift to the top of the stack and
+  cause problems for programs that want to use lots of memory (more
+  than 2.5 GB if SEGMEXEC is not active, or 1.25 GB when it is).
+  For this reason the second step can be controlled by 'chpax' or
+  'paxctl' on a per file basis.
+
+Allow ELF ET_EXEC text relocations
+CONFIG_PAX_ETEXECRELOCS
+  On some architectures like the alpha there are incorrectly
+  created applications that require text relocations and would
+  not work without enabling this option.  If you are an alpha
+  user, you should enable this option and disable it once you
+  have made sure that none of your applications need it.
+
+Automatically emulate ELF PLT
+CONFIG_PAX_EMUPLT
+  Enabling this option will have the kernel automatically detect
+  and emulate the Procedure Linkage Table entries in ELF files.
+  On some architectures such entries are in writable memory, and
+  become non-executable leading to task termination.  Therefore
+  it is mandatory that you enable this option on alpha, parisc, ppc,
+  sparc and sparc64, otherwise your system would not even boot.
+
+  NOTE: this feature *does* open up a loophole in the protection
+  provided by the non-executable pages, therefore the proper
+  solution is to modify the toolchain to produce a PLT that does
+  not need to be writable.
+
+Randomize mmap() base
+CONFIG_PAX_RANDMMAP
+  By saying Y here the kernel will use a randomized base address for
+  mmap() requests that do not specify one themselves.  As a result
+  all dynamically loaded libraries will appear at random addresses
+  and therefore be harder to exploit by a technique where an attacker
+  attempts to execute library code for his purposes (e.g. spawn a
+  shell from an exploited program that is running at an elevated
+  privilege level).
+
+  Furthermore, if a program is relinked as a dynamic ELF file, its
+  base address will be randomized as well, completing the full
+  randomization of the address space layout.  Attacking such programs
+  becomes a guess game.  You can find an example of doing this at
+  <http://pax.grsecurity.net/et_dyn.zip> and practical samples at
+  <http://www.grsecurity.net/grsec-gcc-specs.tar.gz> .
+
+  NOTE: you can use the 'chpax' or 'paxctl' utilities to control this
+  feature on a per file basis.
+
+Deny writing to /dev/kmem, /dev/mem, and /dev/port
+CONFIG_GRKERNSEC_KMEM
+  If you say Y here, /dev/kmem and /dev/mem won't be allowed to
+  be written to via mmap or otherwise to modify the running kernel.
+  /dev/port will also not be allowed to be opened. If you have module
+  support disabled, enabling this will close up four ways that are
+  currently used  to insert malicious code into the running kernel.
+  Even with all these features enabled, we still highly recommend that
+  you use the RBAC system, as it is still possible for an attacker to 
+  modify the running kernel through privileged I/O granted by ioperm/iopl.
+  If you are not using XFree86, you may be able to stop this additional
+  case by enabling the 'Disable privileged I/O' option. Though nothing
+  legitimately writes to /dev/kmem, XFree86 does need to write to /dev/mem,
+  but only to video memory, which is the only writing we allow in this
+  case.  If /dev/kmem or /dev/mem are mmaped without PROT_WRITE, they will
+  not be allowed to mprotect it with PROT_WRITE later.
+  It is highly recommended that you say Y here if you meet all the 
+  conditions above.
+
+Disable privileged I/O
+CONFIG_GRKERNSEC_IO
+  If you say Y here, all ioperm and iopl calls will return an error.
+  Ioperm and iopl can be used to modify the running kernel.
+  Unfortunately, some programs need this access to operate properly,
+  the most notable of which are XFree86 and hwclock.  hwclock can be
+  remedied by having RTC support in the kernel, so CONFIG_RTC is
+  enabled if this option is enabled, to ensure that hwclock operates
+  correctly.  XFree86 still will not operate correctly with this option
+  enabled, so DO NOT CHOOSE Y IF YOU USE XFree86.  If you use XFree86
+  and you still want to protect your kernel against modification,
+  use the RBAC system.
+
+Runtime module disabling
+CONFIG_GRKERNSEC_MODSTOP
+  If you say Y here, you will be able to disable the ability to (un)load
+  modules at runtime.  This feature is useful if you need the ability
+  to load kernel modules at boot time, but do not want to allow an
+  attacker to load a rootkit kernel module into the system, or to remove
+  a loaded kernel module important to system functioning.  You should
+  enable the /dev/mem protection feature as well, since rootkits can be
+  inserted into the kernel via other methods than kernel modules.  Since
+  an untrusted module could still be loaded by modifying init scripts and
+  rebooting the system, it is also recommended that you enable the RBAC
+  system.  If you enable this option, a sysctl option with name
+  "disable_modules" will be created.  Setting this option to "1" disables
+  module loading.  After this option is set, no further writes to it are
+  allowed until the system is rebooted.
+
+Hide kernel symbols
+CONFIG_GRKERNSEC_HIDESYM
+  If you say Y here, getting information on loaded modules, and 
+  displaying all kernel symbols through a syscall will be restricted
+  to users with CAP_SYS_MODULE.  This option is only effective 
+  provided the following conditions are met:
+  1) The kernel using grsecurity is not precompiled by some distribution
+  2) You are using the RBAC system and hiding other files such as your
+     kernel image and System.map
+  3) You have the additional /proc restrictions enabled, which removes
+     /proc/kcore
+  If the above conditions are met, this option will aid to provide a
+  useful protection against local and remote kernel exploitation of
+  overflows and arbitrary read/write vulnerabilities.
+
+Deter exploit bruteforcing
+CONFIG_GRKERNSEC_BRUTE
+  If you say Y here, attempts to bruteforce exploits against forking
+  daemons such as apache or sshd will be deterred.  When a child of a 
+  forking daemon is killed by PaX or crashes due to an illegal 
+  instruction, the parent process will be delayed 30 seconds upon every
+  subsequent fork until the administrator is able to assess the 
+  situation and restart the daemon.  It is recommended that you also 
+  enable signal logging in the auditing section so that logs are 
+  generated when a process performs an illegal instruction.
+
+/proc/<pid>/ipaddr support
+CONFIG_GRKERNSEC_PROC_IPADDR
+  If you say Y here, a new entry will be added to each /proc/<pid>
+  directory that contains the IP address of the person using the task.
+  The IP is carried across local TCP and AF_UNIX stream sockets.
+  This information can be useful for IDS/IPSes to perform remote response
+  to a local attack.  The entry is readable by only the owner of the 
+  process (and root if he has CAP_DAC_OVERRIDE, which can be removed via
+  the RBAC system), and thus does not create privacy concerns.
+
+Proc Restrictions
+CONFIG_GRKERNSEC_PROC
+  If you say Y here, the permissions of the /proc filesystem
+  will be altered to enhance system security and privacy.  You MUST 
+  choose either a user only restriction or a user and group restriction.
+  Depending upon the option you choose, you can either restrict users to 
+  see only the processes they themselves run, or choose a group that can
+  view all processes and files normally restricted to root if you choose
+  the "restrict to user only" option.  NOTE: If you're running identd as 
+  a non-root user, you will have to run it as the group you specify here.
+
+Restrict /proc to user only
+CONFIG_GRKERNSEC_PROC_USER
+  If you say Y here, non-root users will only be able to view their own 
+  processes, and restricts them from viewing network-related information,  
+  and viewing kernel symbol and module information.
+
+Restrict /proc to user and group
+CONFIG_GRKERNSEC_PROC_USERGROUP
+  If you say Y here, you will be able to select a group that will be
+  able to view all processes, network-related information, and
+  kernel and symbol information.  This option is useful if you want
+  to run identd as a non-root user.
+
+Harden kernel heap management
+CONFIG_GRKERNSEC_KHEAP
+  If you say Y here, the kernel heap management routines will be 
+  modified to provide greater resilience against kernel heap 
+  exploitation.  Specifically, this option prevents allocated
+  shared memory IPC structures from being targeted by the only public
+  technique for reliable kernel heap exploitation.
+
+Remove addresses from /proc/pid/[maps|stat]
+CONFIG_GRKERNSEC_PROC_MEMMAP
+  If you say Y here, the /proc/<pid>/maps and /proc/<pid>/stat files will
+  give no information about the addresses of its mappings if
+  PaX features that rely on random addresses are enabled on the task.
+  If you use PaX it is greatly recommended that you say Y here as it 
+  closes up a hole that makes the full ASLR useless for suid 
+  binaries.
+
+Additional proc restrictions
+CONFIG_GRKERNSEC_PROC_ADD
+  If you say Y here, additional restrictions will be placed on
+  /proc that keep normal users from viewing device information and 
+  slabinfo information that could be useful for exploits.
+
+Dmesg(8) Restriction
+CONFIG_GRKERNSEC_DMESG
+  If you say Y here, non-root users will not be able to use dmesg(8)
+  to view up to the last 4kb of messages in the kernel's log buffer.
+  If the sysctl option is enabled, a sysctl option with name "dmesg" is 
+  created.
+
+Destroy unused shared memory
+CONFIG_GRKERNSEC_SHM
+  If you say Y here, shared memory will be destroyed when no one is 
+  attached to it.  Otherwise, resources involved with the shared 
+  memory can be used up and not be associated with any process (as the 
+  shared memory still exists, and the creating process has exited).  If 
+  the sysctl option is enabled, a sysctl option with name 
+  "destroy_unused_shm" is created.
+
+Linking restrictions
+CONFIG_GRKERNSEC_LINK
+  If you say Y here, /tmp race exploits will be prevented, since users
+  will no longer be able to follow symlinks owned by other users in 
+  world-writable +t directories (i.e. /tmp), unless the owner of the 
+  symlink is the owner of the directory. users will also not be
+  able to hardlink to files they do not own.  If the sysctl option is
+  enabled, a sysctl option with name "linking_restrictions" is created.
+
+FIFO restrictions
+CONFIG_GRKERNSEC_FIFO
+  If you say Y here, users will not be able to write to FIFOs they don't
+  own in world-writable +t directories (i.e. /tmp), unless the owner of
+  the FIFO is the same owner of the directory it's held in.  If the sysctl
+  option is enabled, a sysctl option with name "fifo_restrictions" is 
+  created.
+
+Enforce RLIMIT_NPROC on execs
+CONFIG_GRKERNSEC_EXECVE
+  If you say Y here, users with a resource limit on processes will
+  have the value checked during execve() calls.  The current system
+  only checks the system limit during fork() calls.  If the sysctl option
+  is enabled, a sysctl option with name "execve_limiting" is created.
+
+Single group for auditing
+CONFIG_GRKERNSEC_AUDIT_GROUP
+  If you say Y here, the exec, chdir, (un)mount, and ipc logging features
+  will only operate on a group you specify.  This option is recommended
+  if you only want to watch certain users instead of having a large
+  amount of logs from the entire system.  If the sysctl option is enabled,
+  a sysctl option with name "audit_group" is created.
+
+GID for auditing
+CONFIG_GRKERNSEC_AUDIT_GID
+  Here you can choose the GID that will be the target of kernel auditing.
+  Remember to add the users you want to log to the GID specified here.
+  If the sysctl option is enabled, a sysctl option with name "audit_gid" 
+  is created.
+
+Chdir logging
+CONFIG_GRKERNSEC_AUDIT_CHDIR
+  If you say Y here, all chdir() calls will be logged.  If the sysctl 
+  option is enabled, a sysctl option with name "audit_chdir" is created.
+
+(Un)Mount logging
+CONFIG_GRKERNSEC_AUDIT_MOUNT
+  If you say Y here, all mounts and unmounts will be logged.  If the 
+  sysctl option is enabled, a sysctl option with name "audit_mount" is 
+  created.
+
+IPC logging
+CONFIG_GRKERNSEC_AUDIT_IPC
+  If you say Y here, creation and removal of message queues, semaphores,
+  and shared memory will be logged.  If the sysctl option is enabled, a
+  sysctl option with name "audit_ipc" is created.
+
+Exec logging
+CONFIG_GRKERNSEC_EXECLOG
+  If you say Y here, all execve() calls will be logged (since the
+  other exec*() calls are frontends to execve(), all execution
+  will be logged).  Useful for shell-servers that like to keep track
+  of their users.  If the sysctl option is enabled, a sysctl option with
+  name "exec_logging" is created.
+  WARNING: This option when enabled will produce a LOT of logs, especially
+  on an active system.
+
+Resource logging
+CONFIG_GRKERNSEC_RESLOG
+  If you say Y here, all attempts to overstep resource limits will
+  be logged with the resource name, the requested size, and the current
+  limit.  It is highly recommended that you say Y here. If the sysctl 
+  option is enabled, a sysctl option with name "resource_logging" is 
+  created. If the RBAC system is enabled, the sysctl value is ignored.
+
+Signal logging
+CONFIG_GRKERNSEC_SIGNAL
+  If you say Y here, certain important signals will be logged, such as
+  SIGSEGV, which will as a result inform you of when a error in a program
+  occurred, which in some cases could mean a possible exploit attempt.
+  If the sysctl option is enabled, a sysctl option with name 
+  "signal_logging" is created.
+
+Fork failure logging
+CONFIG_GRKERNSEC_FORKFAIL
+  If you say Y here, all failed fork() attempts will be logged.
+  This could suggest a fork bomb, or someone attempting to overstep
+  their process limit.  If the sysctl option is enabled, a sysctl option
+  with name "forkfail_logging" is created.
+
+Time change logging
+CONFIG_GRKERNSEC_TIME
+  If you say Y here, any changes of the system clock will be logged.
+  If the sysctl option is enabled, a sysctl option with name 
+  "timechange_logging" is created.
+
+ELF text relocations logging
+CONFIG_GRKERNSEC_AUDIT_TEXTREL
+  If you say Y here, text relocations will be logged with the filename 
+  of the offending library or binary.  The purpose of the feature is 
+  to help Linux distribution developers get rid of libraries and 
+  binaries that need text relocations which hinder the future progress 
+  of PaX.  Only Linux distribution developers should say Y here, and 
+  never on a production machine, as this option creates an information 
+  leak that could aid an attacker in defeating the randomization of
+  a single memory region.  If the sysctl option is enabled, a sysctl
+  option with name "audit_textrel" is created.
+
+Chroot jail restrictions
+CONFIG_GRKERNSEC_CHROOT
+  If you say Y here, you will be able to choose several options that will
+  make breaking out of a chrooted jail much more difficult.  If you
+  encounter no software incompatibilities with the following options, it
+  is recommended that you enable each one.
+
+Deny access to abstract AF_UNIX sockets out of chroot
+CONFIG_GRKERNSEC_CHROOT_UNIX
+  If you say Y here, processes inside a chroot will not be able to
+  connect to abstract (meaning not belonging to a filesystem) Unix
+  domain sockets that were bound outside of a chroot.  It is recommended
+  that you say Y here.  If the sysctl option is enabled, a sysctl option
+  with name "chroot_deny_unix" is created.
+
+Deny shmat() out of chroot
+CONFIG_GRKERNSEC_CHROOT_SHMAT
+  If you say Y here, processes inside a chroot will not be able to attach
+  to shared memory segments that were created outside of the chroot jail.
+  It is recommended that you say Y here.  If the sysctl option is enabled,
+  a sysctl option with name "chroot_deny_shmat" is created.
+
+Protect outside processes
+CONFIG_GRKERNSEC_CHROOT_FINDTASK
+  If you say Y here, processes inside a chroot will not be able to
+  kill, send signals with fcntl, ptrace, capget, getpgid, setpgid, getsid,
+  getsid, or view any process outside of the chroot.  If the sysctl option
+  is enabled, a sysctl option with name "chroot_findtask" is created.
+
+Deny mounts in chroot
+CONFIG_GRKERNSEC_CHROOT_MOUNT
+  If you say Y here, processes inside a chroot will not be able to
+  mount or remount filesystems.  If the sysctl option is enabled, a 
+  sysctl option with name "chroot_deny_mount" is created.
+
+Deny pivot_root in chroot
+CONFIG_GRKERNSEC_CHROOT_PIVOT
+  If you say Y here, processes inside a chroot will not be able to use
+  a function called pivot_root() that was introduced in Linux 2.3.41.  It 
+  works similar to chroot in that it changes the root filesystem.  This 
+  function could be misused in a chrooted process to attempt to break out 
+  of the chroot, and therefore should not be allowed.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_pivot" is 
+  created.
+
+Deny double-chroots
+CONFIG_GRKERNSEC_CHROOT_DOUBLE
+  If you say Y here, processes inside a chroot will not be able to chroot
+  again outside of the chroot.  This is a widely used method of breaking 
+  out of a chroot jail and should not be allowed.  If the sysctl option 
+  is enabled, a sysctl option with name "chroot_deny_chroot" is created.
+
+Deny fchdir outside of chroot
+CONFIG_GRKERNSEC_CHROOT_FCHDIR
+  If you say Y here, a well-known method of breaking chroots by fchdir'ing
+  to a file descriptor of the chrooting process that points to a directory
+  outside the filesystem will be stopped.  If the sysctl option
+  is enabled, a sysctl option with name "chroot_deny_fchdir" is created.
+
+Enforce chdir("/") on all chroots
+CONFIG_GRKERNSEC_CHROOT_CHDIR
+  If you say Y here, the current working directory of all newly-chrooted
+  applications will be set to the the root directory of the chroot.
+  The man page on chroot(2) states:
+  Note that this call does not change  the  current  working
+  directory,  so  that `.' can be outside the tree rooted at
+  `/'.  In particular, the  super-user  can  escape  from  a
+  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.  
+
+  It is recommended that you say Y here, since it's not known to break
+  any software.  If the sysctl option is enabled, a sysctl option with
+  name "chroot_enforce_chdir" is created.
+
+Deny (f)chmod +s in chroot
+CONFIG_GRKERNSEC_CHROOT_CHMOD
+  If you say Y here, processes inside a chroot will not be able to chmod
+  or fchmod files to make them have suid or sgid bits.  This protects 
+  against another published method of breaking a chroot.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+  created.
+
+Deny mknod in chroot
+CONFIG_GRKERNSEC_CHROOT_MKNOD
+  If you say Y here, processes inside a chroot will not be allowed to
+  mknod.  The problem with using mknod inside a chroot is that it
+  would allow an attacker to create a device entry that is the same
+  as one on the physical root of your system, which could range from
+  anything from the console device to a device for your harddrive (which
+  they could then use to wipe the drive or steal data).  It is recommended
+  that you say Y here, unless you run into software incompatibilities.
+  If the sysctl option is enabled, a sysctl option with name
+  "chroot_deny_mknod" is created.
+
+Restrict priority changes in chroot
+CONFIG_GRKERNSEC_CHROOT_NICE
+  If you say Y here, processes inside a chroot will not be able to raise
+  the priority of processes in the chroot, or alter the priority of 
+  processes outside the chroot.  This provides more security than simply
+  removing CAP_SYS_NICE from the process' capability set.  If the
+  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+  is created.
+
+Log all execs within chroot
+CONFIG_GRKERNSEC_CHROOT_EXECLOG
+  If you say Y here, all executions inside a chroot jail will be logged 
+  to syslog.  This can cause a large amount of logs if certain
+  applications (eg. djb's daemontools) are installed on the system, and
+  is therefore left as an option.  If the sysctl option is enabled, a 
+  sysctl option with name "chroot_execlog" is created.
+
+Deny sysctl writes in chroot
+CONFIG_GRKERNSEC_CHROOT_SYSCTL
+  If you say Y here, an attacker in a chroot will not be able to
+  write to sysctl entries, either by sysctl(2) or through a /proc
+  interface.  It is strongly recommended that you say Y here. If the
+  sysctl option is enabled, a sysctl option with name 
+  "chroot_deny_sysctl" is created.
+
+Chroot jail capability restrictions
+CONFIG_GRKERNSEC_CHROOT_CAPS
+  If you say Y here, the capabilities on all root processes within a
+  chroot jail will be lowered to stop module insertion, raw i/o,
+  system and net admin tasks, rebooting the system, modifying immutable 
+  files, modifying IPC owned by another, and changing the system time.
+  This is left an option because it can break some apps.  Disable this
+  if your chrooted apps are having problems performing those kinds of
+  tasks.  If the sysctl option is enabled, a sysctl option with
+  name "chroot_caps" is created.
+
+Trusted path execution
+CONFIG_GRKERNSEC_TPE
+  If you say Y here, you will be able to choose a gid to add to the
+  supplementary groups of users you want to mark as "untrusted."
+  These users will not be able to execute any files that are not in
+  root-owned directories writable only by root.  If the sysctl option
+  is enabled, a sysctl option with name "tpe" is created.
+
+Invert GID option
+CONFIG_GRKERNSEC_TPE_INVERT
+  If you say Y here, the group you specify in the TPE configuration will 
+  decide what group TPE restrictions will be *disabled* for.  This 
+  option is useful if you want TPE restrictions to be applied to most
+  users on the system.
+
+Group for trusted path execution
+CONFIG_GRKERNSEC_TPE_GID
+  If you have selected the "Invert GID option" above, setting this
+  GID determines what group TPE restrictions will be *disabled* for.
+  If you have not selected the "Invert GID option" above, setting this
+  GID determines what group TPE restrictions will be *enabled* for.
+  If the sysctl option is enabled, a sysctl option with name "tpe_gid" 
+  is created.
+
+Partially restrict non-root users
+CONFIG_GRKERNSEC_TPE_ALL
+  If you say Y here, All non-root users other than the ones in the 
+  group specified in the main TPE option will only be allowed to
+  execute files in directories they own that are not group or
+  world-writable, or in directories owned by root and writable only by
+  root.  If the sysctl option is enabled, a sysctl option with name 
+  "tpe_restrict_all" is created.
+
+Larger entropy pools
+CONFIG_GRKERNSEC_RANDNET
+  If you say Y here, the entropy pools used for many features of Linux
+  and grsecurity will be doubled in size.  Since several grsecurity 
+  features use additional randomness, it is recommended that you say Y 
+  here.  Saying Y here has a similar effect as modifying
+  /proc/sys/kernel/random/poolsize.
+
+TCP/UDP blackhole
+CONFIG_GRKERNSEC_BLACKHOLE
+  If you say Y here, neither TCP resets nor ICMP
+  destination-unreachable packets will be sent in response to packets
+  send to ports for which no associated listening process exists.
+  This feature supports both IPV4 and IPV6 and exempts the
+  loopback interface from blackholing.  Enabling this feature
+  makes a host more resilient to DoS attacks and reduces network
+  visibility against scanners.
+
+Socket restrictions
+CONFIG_GRKERNSEC_SOCKET
+  If you say Y here, you will be able to choose from several options.
+  If you assign a GID on your system and add it to the supplementary
+  groups of users you want to restrict socket access to, this patch
+  will perform up to three things, based on the option(s) you choose.
+
+Deny all socket access
+CONFIG_GRKERNSEC_SOCKET_ALL
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine or run server
+  applications from your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_all" is created.
+
+Group for disabled socket access
+CONFIG_GRKERNSEC_SOCKET_ALL_GID
+  Here you can choose the GID to disable socket access for. Remember to 
+  add the users you want socket access disabled for to the GID 
+  specified here.  If the sysctl option is enabled, a sysctl option with 
+  name "socket_all_gid" is created.
+
+Deny all client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine, but will be
+  able to run servers.  If this option is enabled, all users in the group
+  you specify will have to use passive mode when initiating ftp transfers
+  from the shell on your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_client" is created.
+
+Group for disabled client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT_GID
+  Here you can choose the GID to disable client socket access for. 
+  Remember to add the users you want client socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, a sysctl 
+  option with name "socket_client_gid" is created.
+
+Deny all server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to run server applications from your machine.  If the sysctl 
+  option is enabled, a sysctl option with name "socket_server" is created.
+
+Group for disabled server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER_GID
+  Here you can choose the GID to disable server socket access for. 
+  Remember to add the users you want server socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, a sysctl 
+  option with name "socket_server_gid" is created.
+
+Sysctl support
+CONFIG_GRKERNSEC_SYSCTL
+  If you say Y here, you will be able to change the options that
+  grsecurity runs with at bootup, without having to recompile your
+  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+  to enable (1) or disable (0) various features.  All the sysctl entries
+  are mutable until the "grsec_lock" entry is set to a non-zero value.
+  All features enabled in the kernel configuration are disabled at boot
+  if you do not say Y to the "Turn on features by default" option.
+  All options should be set at startup, and the grsec_lock entry should 
+  be set to a non-zero value after all the options are set.
+  *THIS IS EXTREMELY IMPORTANT*
+
+Turn on features by default
+CONFIG_GRKERNSEC_SYSCTL_ON
+  If you say Y here, instead of having all features enabled in the
+  kernel configuration disabled at boot time, the features will be
+  enabled at boot time.  It is recommended you say Y here unless
+  there is some reason you would want all sysctl-tunable features to
+  be disabled by default.  As mentioned elsewhere, it is important
+  to enable the grsec_lock entry once you have finished modifying
+  the sysctl entries.
+
+Number of burst messages
+CONFIG_GRKERNSEC_FLOODBURST
+  This option allows you to choose the maximum number of messages allowed
+  within the flood time interval you chose in a separate option.  The 
+  default should be suitable for most people, however if you find that 
+  many of your logs are being interpreted as flooding, you may want to 
+  raise this value.
+
+Seconds in between log messages
+CONFIG_GRKERNSEC_FLOODTIME
+  This option allows you to enforce the number of seconds between
+  grsecurity log messages.  The default should be suitable for most 
+  people, however, if you choose to change it, choose a value small enough
+  to allow informative logs to be produced, but large enough to
+  prevent flooding.
+
+Disable RBAC system
+CONFIG_GRKERNSEC_NO_RBAC
+  If you say Y here, the /dev/grsec device will be removed from the kernel,
+  preventing the RBAC system from being enabled.  You should only say Y
+  here if you have no intention of using the RBAC system, so as to prevent
+  an attacker with root access from misusing the RBAC system to hide files
+  and processes when loadable module support and /dev/[k]mem have been
+  locked down.
+
+Hide kernel processes
+CONFIG_GRKERNSEC_ACL_HIDEKERN
+  If you say Y here, all kernel threads will be hidden to all 
+  processes but those whose subject has the "view hidden processes"
+  flag.
+
+Maximum tries before password lockout
+CONFIG_GRKERNSEC_ACL_MAXTRIES
+  This option enforces the maximum number of times a user can attempt
+  to authorize themselves with the grsecurity RBAC system before being
+  denied the ability to attempt authorization again for a specified time.  
+  The lower the number, the harder it will be to brute-force a password.
+
+Time to wait after max password tries, in seconds
+CONFIG_GRKERNSEC_ACL_TIMEOUT
+  This option specifies the time the user must wait after attempting to 
+  authorize to the RBAC system with the maximum number of invalid 
+  passwords.  The higher the number, the harder it will be to brute-force 
+  a password.
+
 Disable data cache
 CONFIG_DCACHE_DISABLE
   This option allows you to run the kernel with data cache disabled.
@@ -29158,6 +30085,42 @@ CONFIG_SOUND_WM97XX
   
   If unsure, say N.
 
+Sanitize all freed memory
+CONFIG_PAX_MEMORY_SANITIZE
+  By saying Y here the kernel will erase memory pages as soon as they
+  are freed.  This in turn reduces the lifetime of data stored in the
+  pages, making it less likely that sensitive information such as
+  passwords, cryptographic secrets, etc stay in memory for too long.
+
+  This is especially useful for programs whose runtime is short, long
+  lived processes and the kernel itself benefit from this as long as
+  they operate on whole memory pages and ensure timely freeing of pages
+  that may hold sensitive information.
+
+  The tradeoff is performance impact, on a single CPU system kernel
+  compilation sees a 3% slowdown, other systems and workloads may vary
+  and you are advised to test this feature on your expected workload
+  before deploying it.
+
+  Note that this feature does not protect data stored in live pages,
+  e.g., process memory swapped to disk may stay there for a long time.
+
+Prevent invalid userland pointer dereference
+CONFIG_PAX_MEMORY_UDEREF
+  By saying Y here the kernel will be prevented from dereferencing
+  userland pointers in contexts where the kernel expects only kernel
+  pointers.  This is both a useful runtime debugging feature and a
+  security measure that prevents exploiting a class of kernel bugs.
+
+  The tradeoff is that some virtualization solutions may experience
+  a huge slowdown and therefore you should not enable this feature
+  for kernels meant to run in such environments.  Whether a given VM
+  solution is affected or not is best determined by simply trying it
+  out, the performance impact will be obvious right on boot as this
+  mechanism engages from very early on.  A good rule of thumb is that
+  VMs running on CPUs without hardware virtualization support (i.e.,
+  the majority of IA-32 CPUs) will likely experience the slowdown.
+
 #
 # A couple of things I keep forgetting:
 #   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet,
diff -urNp linux-2.4.37.7/Documentation/DocBook/mousedrivers.tmpl linux-2.4.37.7/Documentation/DocBook/mousedrivers.tmpl
--- linux-2.4.37.7/Documentation/DocBook/mousedrivers.tmpl	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/Documentation/DocBook/mousedrivers.tmpl	2009-11-10 19:30:27.000000000 -0500
@@ -248,7 +248,7 @@ void cleanup_module(void)
   </para>
 
   <programlisting>
-struct file_operations our_mouse_fops = {
+const struct file_operations our_mouse_fops = {
         owner: THIS_MODULE,            /* Automatic usage management */
         read:  read_mouse,             /* You can read a mouse */
         write: write_mouse,            /* This won't do a lot */
@@ -894,7 +894,7 @@ static void ourmouse_interrupt(int irq, 
   </para>
 
   <programlisting>
-struct file_operations our_mouse_fops = {
+const struct file_operations our_mouse_fops = {
         owner: THIS_MODULE
         read:  read_mouse,      /* You can read a mouse */
         write: write_mouse,     /* This won't do a lot */
diff -urNp linux-2.4.37.7/drivers/acorn/char/i2c.c linux-2.4.37.7/drivers/acorn/char/i2c.c
--- linux-2.4.37.7/drivers/acorn/char/i2c.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/acorn/char/i2c.c	2009-11-10 19:30:27.000000000 -0500
@@ -200,7 +200,7 @@ static int rtc_ioctl(struct inode *inode
 	return -EINVAL;
 }
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	ioctl:	rtc_ioctl,
 };
 
diff -urNp linux-2.4.37.7/drivers/acorn/char/mouse_ps2.c linux-2.4.37.7/drivers/acorn/char/mouse_ps2.c
--- linux-2.4.37.7/drivers/acorn/char/mouse_ps2.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/acorn/char/mouse_ps2.c	2009-11-10 19:30:27.000000000 -0500
@@ -249,7 +249,7 @@ static unsigned int aux_poll(struct file
 	return 0;
 }
 
-struct file_operations psaux_fops = {
+const struct file_operations psaux_fops = {
 	read:		read_aux,
 	write:		write_aux,
 	poll:		aux_poll,
diff -urNp linux-2.4.37.7/drivers/acpi/system.c linux-2.4.37.7/drivers/acpi/system.c
--- linux-2.4.37.7/drivers/acpi/system.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/acpi/system.c	2009-11-10 19:30:27.000000000 -0500
@@ -423,7 +423,7 @@ static int acpi_system_close_event(struc
 static unsigned int acpi_system_poll_event(struct file *file, poll_table *wait);
 
 
-static struct file_operations acpi_system_event_ops = {
+static const struct file_operations acpi_system_event_ops = {
 	.open =		acpi_system_open_event,
 	.read =		acpi_system_read_event,
 	.release =	acpi_system_close_event,
@@ -519,7 +519,7 @@ acpi_system_poll_event(
 
 static ssize_t acpi_system_read_dsdt (struct file*, char*, size_t, loff_t*);
 
-static struct file_operations acpi_system_dsdt_ops = {
+static const struct file_operations acpi_system_dsdt_ops = {
 	.read =			acpi_system_read_dsdt,
 };
 
@@ -562,7 +562,7 @@ acpi_system_read_dsdt (
 
 static ssize_t acpi_system_read_fadt (struct file*, char*, size_t, loff_t*);
 
-static struct file_operations acpi_system_fadt_ops = {
+static const struct file_operations acpi_system_fadt_ops = {
 	.read =			acpi_system_read_fadt,
 };
 
diff -urNp linux-2.4.37.7/drivers/block/acsi_slm.c linux-2.4.37.7/drivers/block/acsi_slm.c
--- linux-2.4.37.7/drivers/block/acsi_slm.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/acsi_slm.c	2009-11-10 19:30:27.000000000 -0500
@@ -272,7 +272,7 @@ static int slm_get_pagesize( int device,
 
 static struct timer_list slm_timer = { function: slm_test_ready };
 
-static struct file_operations slm_fops = {
+static const struct file_operations slm_fops = {
 	owner:		THIS_MODULE,
 	read:		slm_read,
 	write:		slm_write,
diff -urNp linux-2.4.37.7/drivers/block/genhd.c linux-2.4.37.7/drivers/block/genhd.c
--- linux-2.4.37.7/drivers/block/genhd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/genhd.c	2009-11-10 19:30:27.000000000 -0500
@@ -226,7 +226,7 @@ static int part_show(struct seq_file *s,
 	return 0;
 }
 
-struct seq_operations partitions_op = {
+const struct seq_operations partitions_op = {
 	.start		= part_start,
 	.next		= part_next,
 	.stop		= part_stop,
diff -urNp linux-2.4.37.7/drivers/block/loop.c linux-2.4.37.7/drivers/block/loop.c
--- linux-2.4.37.7/drivers/block/loop.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/loop.c	2009-11-10 19:30:27.000000000 -0500
@@ -176,7 +176,7 @@ static int lo_send(struct loop_device *l
 {
 	struct file *file = lo->lo_backing_file; /* kudos to NFsckingS */
 	struct address_space *mapping = file->f_dentry->d_inode->i_mapping;
-	struct address_space_operations *aops = mapping->a_ops;
+	const struct address_space_operations *aops = mapping->a_ops;
 	struct page *page;
 	char *kaddr, *data;
 	unsigned long index;
@@ -650,7 +650,7 @@ static int loop_set_fd(struct loop_devic
 			goto out_putf;
 		}
 	} else if (S_ISREG(inode->i_mode)) {
-		struct address_space_operations *aops = inode->i_mapping->a_ops;
+		const struct address_space_operations *aops = inode->i_mapping->a_ops;
 		/*
 		 * If we can't read - sorry. If we only can't write - well,
 		 * it's going to be read-only.
diff -urNp linux-2.4.37.7/drivers/block/paride/pg.c linux-2.4.37.7/drivers/block/paride/pg.c
--- linux-2.4.37.7/drivers/block/paride/pg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/paride/pg.c	2009-11-10 19:30:27.000000000 -0500
@@ -261,7 +261,7 @@ static char pg_scratch[512];            
 
 /* kernel glue structures */
 
-static struct file_operations pg_fops = {
+static const struct file_operations pg_fops = {
 	owner:		THIS_MODULE,
 	read:		pg_read,
 	write:		pg_write,
diff -urNp linux-2.4.37.7/drivers/block/paride/pt.c linux-2.4.37.7/drivers/block/paride/pt.c
--- linux-2.4.37.7/drivers/block/paride/pt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/paride/pt.c	2009-11-10 19:30:27.000000000 -0500
@@ -263,7 +263,7 @@ static char pt_scratch[512];            
 
 /* kernel glue structures */
 
-static struct file_operations pt_fops = {
+static const struct file_operations pt_fops = {
 	owner:		THIS_MODULE,
 	read:		pt_read,
 	write:		pt_write,
diff -urNp linux-2.4.37.7/drivers/block/rd.c linux-2.4.37.7/drivers/block/rd.c
--- linux-2.4.37.7/drivers/block/rd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/block/rd.c	2009-11-10 19:30:27.000000000 -0500
@@ -151,7 +151,7 @@ static int ramdisk_commit_write(struct f
 	return 0;
 }
 
-static struct address_space_operations ramdisk_aops = {
+static const struct address_space_operations ramdisk_aops = {
 	readpage: ramdisk_readpage,
 	writepage: fail_writepage,
 	prepare_write: ramdisk_prepare_write,
@@ -352,7 +352,7 @@ static int initrd_release(struct inode *
 }
 
 
-static struct file_operations initrd_fops = {
+static const struct file_operations initrd_fops = {
 	read:		initrd_read,
 	release:	initrd_release,
 };
diff -urNp linux-2.4.37.7/drivers/bluetooth/hci_vhci.c linux-2.4.37.7/drivers/bluetooth/hci_vhci.c
--- linux-2.4.37.7/drivers/bluetooth/hci_vhci.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/bluetooth/hci_vhci.c	2009-11-10 19:30:27.000000000 -0500
@@ -306,7 +306,7 @@ static int hci_vhci_chr_close(struct ino
 	return 0;
 }
 
-static struct file_operations hci_vhci_fops = {
+static const struct file_operations hci_vhci_fops = {
 	owner:	THIS_MODULE,	
 	llseek:	hci_vhci_chr_lseek,
 	read:	hci_vhci_chr_read,
diff -urNp linux-2.4.37.7/drivers/char/acquirewdt.c linux-2.4.37.7/drivers/char/acquirewdt.c
--- linux-2.4.37.7/drivers/char/acquirewdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/acquirewdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -207,7 +207,7 @@ static int acq_notify_sys(struct notifie
  */
  
  
-static struct file_operations acq_fops = {
+static const struct file_operations acq_fops = {
 	owner:		THIS_MODULE,
 	read:		acq_read,
 	write:		acq_write,
diff -urNp linux-2.4.37.7/drivers/char/advantechwdt.c linux-2.4.37.7/drivers/char/advantechwdt.c
--- linux-2.4.37.7/drivers/char/advantechwdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/advantechwdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -246,7 +246,7 @@ advwdt_notify_sys(struct notifier_block 
  *	Kernel Interfaces
  */
  
-static struct file_operations advwdt_fops = {
+static const struct file_operations advwdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	write:		advwdt_write,
diff -urNp linux-2.4.37.7/drivers/char/agp/agpgart_fe.c linux-2.4.37.7/drivers/char/agp/agpgart_fe.c
--- linux-2.4.37.7/drivers/char/agp/agpgart_fe.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/agp/agpgart_fe.c	2009-11-10 19:30:27.000000000 -0500
@@ -1075,8 +1075,7 @@ ioctl_out:
 	return ret_val;
 }
 
-static struct file_operations agp_fops =
-{
+static const struct file_operations agp_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		agp_read,
diff -urNp linux-2.4.37.7/drivers/char/alim1535d_wdt.c linux-2.4.37.7/drivers/char/alim1535d_wdt.c
--- linux-2.4.37.7/drivers/char/alim1535d_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/alim1535d_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -302,7 +302,7 @@ static int __init ali_find_watchdog(void
 	return 0;
 }
 
-static struct file_operations ali_fops = {
+static const struct file_operations ali_fops = {
 	owner:		THIS_MODULE,
 	write:		ali_write,
 	ioctl:		ali_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/alim7101_wdt.c linux-2.4.37.7/drivers/char/alim7101_wdt.c
--- linux-2.4.37.7/drivers/char/alim7101_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/alim7101_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -239,7 +239,7 @@ static int fop_ioctl(struct inode *inode
 	}
 }
 
-static struct file_operations wdt_fops = {
+static const struct file_operations wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		fop_read,
diff -urNp linux-2.4.37.7/drivers/char/amd768_rng.c linux-2.4.37.7/drivers/char/amd768_rng.c
--- linux-2.4.37.7/drivers/char/amd768_rng.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/amd768_rng.c	2009-11-10 19:30:27.000000000 -0500
@@ -167,7 +167,7 @@ static ssize_t rng_dev_read (struct file
 }
 
 
-static struct file_operations rng_chrdev_ops = {
+static const struct file_operations rng_chrdev_ops = {
 	owner:		THIS_MODULE,
 	open:		rng_dev_open,
 	release:	rng_dev_release,
diff -urNp linux-2.4.37.7/drivers/char/applicom.c linux-2.4.37.7/drivers/char/applicom.c
--- linux-2.4.37.7/drivers/char/applicom.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/applicom.c	2009-11-10 19:30:27.000000000 -0500
@@ -118,7 +118,7 @@ static int ac_ioctl(struct inode *, stru
 		    unsigned long);
 static void ac_interrupt(int, void *, struct pt_regs *);
 
-static struct file_operations ac_fops = {
+static const struct file_operations ac_fops = {
 	owner:THIS_MODULE,
 	llseek:no_llseek,
 	read:ac_read,
diff -urNp linux-2.4.37.7/drivers/char/au1000_gpio.c linux-2.4.37.7/drivers/char/au1000_gpio.c
--- linux-2.4.37.7/drivers/char/au1000_gpio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/au1000_gpio.c	2009-11-10 19:30:27.000000000 -0500
@@ -235,8 +235,7 @@ static int au1000gpio_ioctl(struct inode
 }
 
 
-static struct file_operations au1000gpio_fops =
-{
+static const struct file_operations au1000gpio_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		au1000gpio_ioctl,
 	open:		au1000gpio_open,
diff -urNp linux-2.4.37.7/drivers/char/au1000_ts.c linux-2.4.37.7/drivers/char/au1000_ts.c
--- linux-2.4.37.7/drivers/char/au1000_ts.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/au1000_ts.c	2009-11-10 19:30:27.000000000 -0500
@@ -587,7 +587,7 @@ au1000_release(struct inode * inode, str
 }
 
 
-static struct file_operations ts_fops = {
+static const struct file_operations ts_fops = {
 	read:           au1000_read,
 	poll:           au1000_poll,
 	ioctl:		au1000_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/au1000_usbraw.c linux-2.4.37.7/drivers/char/au1000_usbraw.c
--- linux-2.4.37.7/drivers/char/au1000_usbraw.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/au1000_usbraw.c	2009-11-10 19:30:27.000000000 -0500
@@ -457,7 +457,7 @@ static int usbraw_ioctl(struct inode *in
 }
 
 
-static struct file_operations usbraw_fops = {
+static const struct file_operations usbraw_fops = {
         owner:          THIS_MODULE,
         write:          usbraw_write,
 	read:           usbraw_read,
diff -urNp linux-2.4.37.7/drivers/char/briq_panel.c linux-2.4.37.7/drivers/char/briq_panel.c
--- linux-2.4.37.7/drivers/char/briq_panel.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/briq_panel.c	2009-11-10 19:30:27.000000000 -0500
@@ -168,7 +168,7 @@ static ssize_t do_write(struct file *fil
 }
 
 
-static struct file_operations vfd_fops = {
+static const struct file_operations vfd_fops = {
 	read:		do_read,	/* Read */
 	write:		do_write,	/* Write */
 	open:		do_open,	/* Open */
diff -urNp linux-2.4.37.7/drivers/char/busmouse.c linux-2.4.37.7/drivers/char/busmouse.c
--- linux-2.4.37.7/drivers/char/busmouse.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/busmouse.c	2009-11-10 19:30:27.000000000 -0500
@@ -332,8 +332,7 @@ static unsigned int busmouse_poll(struct
 	return 0;
 }
 
-struct file_operations busmouse_fops=
-{
+const struct file_operations busmouse_fops = {
 	owner:		THIS_MODULE,
 	read:		busmouse_read,
 	write:		busmouse_write,
diff -urNp linux-2.4.37.7/drivers/char/defkeymap.c linux-2.4.37.7/drivers/char/defkeymap.c
--- linux-2.4.37.7/drivers/char/defkeymap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/defkeymap.c	2009-11-10 19:30:27.000000000 -0500
@@ -18,47 +18,130 @@ u_short plain_map[NR_KEYS] = {
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
 	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03c,	0xf10a,
 	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf210,	0xf211,	0xf20e,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 u_short shift_map[NR_KEYS] = {
 	0xf200,	0xf01b,	0xf021,	0xf040,	0xf023,	0xf024,	0xf025,	0xf05e,
-	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf009,
+	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf809,
 	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
 	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf201,	0xf702,	0xfb41,	0xfb53,
 	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf03a,
 	0xf022,	0xf07e,	0xf700,	0xf07c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
 	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf700,	0xf30c,
-	0xf703,	0xf020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
-	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf213,	0xf203,	0xf307,
+	0xf703,	0xf020,	0xf207,	0xf10c,	0xf10d,	0xf10e,	0xf10f,	0xf110,
+	0xf111,	0xf112,	0xf113,	0xf11e,	0xf11f,	0xf208,	0xf203,	0xf307,
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
-	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf120,
+	0xf121,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf206,	0xf206,	0xf210,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 u_short altgr_map[NR_KEYS] = {
 	0xf200,	0xf200,	0xf200,	0xf040,	0xf200,	0xf024,	0xf200,	0xf200,
 	0xf07b,	0xf05b,	0xf05d,	0xf07d,	0xf05c,	0xf200,	0xf200,	0xf200,
-	0xfb71,	0xfb77,	0xf918,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
-	0xfb6f,	0xfb70,	0xf200,	0xf07e,	0xf201,	0xf702,	0xf914,	0xfb73,
-	0xf917,	0xf919,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf200,
-	0xf200,	0xf200,	0xf700,	0xf200,	0xfb7a,	0xfb78,	0xf916,	0xfb76,
-	0xf915,	0xfb6e,	0xfb6d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
+	0xfb6f,	0xfb70,	0xf200,	0xf07e,	0xf201,	0xf702,	0xfb61,	0xfb73,
+	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
+	0xfb62,	0xfb6e,	0xfb6d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
 	0xf703,	0xf200,	0xf207,	0xf50c,	0xf50d,	0xf50e,	0xf50f,	0xf510,
-	0xf511,	0xf512,	0xf513,	0xf514,	0xf515,	0xf208,	0xf202,	0xf911,
-	0xf912,	0xf913,	0xf30b,	0xf90e,	0xf90f,	0xf910,	0xf30a,	0xf90b,
-	0xf90c,	0xf90d,	0xf90a,	0xf310,	0xf206,	0xf200,	0xf07c,	0xf516,
+	0xf511,	0xf512,	0xf513,	0xf514,	0xf515,	0xf208,	0xf202,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf07c,	0xf516,
 	0xf517,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf211,	0xf210,	0xf211,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_altgr_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
+	0xfb4f,	0xfb50,	0xf200,	0xf200,	0xf201,	0xf702,	0xfb41,	0xfb53,
+	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
+	0xfb42,	0xfb4e,	0xfb4d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf20e,	0xf20e,	0xf206,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
@@ -70,15 +153,31 @@ u_short ctrl_map[NR_KEYS] = {
 	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
 	0xf007,	0xf000,	0xf700,	0xf01c,	0xf01a,	0xf018,	0xf003,	0xf016,
 	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf700,	0xf30c,
-	0xf703,	0xf000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
-	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
+	0xf703,	0xf000,	0xf207,	0xf122,	0xf123,	0xf124,	0xf125,	0xf126,
+	0xf127,	0xf128,	0xf129,	0xf12a,	0xf12b,	0xf208,	0xf204,	0xf307,
 	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf10a,
-	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf12c,
+	0xf12d,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 u_short shift_ctrl_map[NR_KEYS] = {
@@ -88,6 +187,76 @@ u_short shift_ctrl_map[NR_KEYS] = {
 	0xf00f,	0xf010,	0xf200,	0xf200,	0xf201,	0xf702,	0xf001,	0xf013,
 	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
 	0xf200,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
+	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf200,	0xf07f,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf12e,	0xf12f,	0xf130,	0xf131,	0xf132,
+	0xf133,	0xf134,	0xf135,	0xf136,	0xf137,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf138,
+	0xf139,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short altgr_ctrl_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
+	0xf00f,	0xf010,	0xf200,	0xf200,	0xf201,	0xf702,	0xf001,	0xf013,
+	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
+	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_altgr_ctrl_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
+	0xf00f,	0xf010,	0xf200,	0xf200,	0xf201,	0xf702,	0xf001,	0xf013,
+	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
 	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
 	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
@@ -98,6 +267,22 @@ u_short shift_ctrl_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 u_short alt_map[NR_KEYS] = {
@@ -117,6 +302,127 @@ u_short alt_map[NR_KEYS] = {
 	0xf118,	0xf210,	0xf211,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf821,	0xf840,	0xf823,	0xf824,	0xf825,	0xf85e,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf851,	0xf857,	0xf845,	0xf852,	0xf854,	0xf859,	0xf855,	0xf849,
+	0xf84f,	0xf850,	0xf87b,	0xf87d,	0xf201,	0xf702,	0xf841,	0xf853,
+	0xf844,	0xf846,	0xf847,	0xf848,	0xf84a,	0xf84b,	0xf84c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf87c,	0xf85a,	0xf858,	0xf843,	0xf856,
+	0xf842,	0xf84e,	0xf84d,	0xf83c,	0xf83e,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short altgr_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf871,	0xf877,	0xf865,	0xf872,	0xf874,	0xf879,	0xf875,	0xf869,
+	0xf86f,	0xf870,	0xf200,	0xf200,	0xf201,	0xf702,	0xf861,	0xf873,
+	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf87a,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_altgr_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf851,	0xf857,	0xf845,	0xf852,	0xf854,	0xf859,	0xf855,	0xf849,
+	0xf84f,	0xf850,	0xf200,	0xf200,	0xf201,	0xf702,	0xf841,	0xf853,
+	0xf844,	0xf846,	0xf847,	0xf848,	0xf84a,	0xf84b,	0xf84c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf85a,	0xf858,	0xf843,	0xf856,
+	0xf842,	0xf84e,	0xf84d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 u_short ctrl_alt_map[NR_KEYS] = {
@@ -136,16 +442,137 @@ u_short ctrl_alt_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_ctrl_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf819,	0xf815,	0xf809,
+	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
+	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf81a,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short altgr_ctrl_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf819,	0xf815,	0xf809,
+	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
+	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf81a,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_altgr_ctrl_alt_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf819,	0xf815,	0xf809,
+	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
+	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf81a,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 ushort *key_maps[MAX_NR_KEYMAPS] = {
-	plain_map, shift_map, altgr_map, 0,
-	ctrl_map, shift_ctrl_map, 0, 0,
-	alt_map, 0, 0, 0,
-	ctrl_alt_map,	0
+	plain_map, shift_map, altgr_map, shift_altgr_map,
+	ctrl_map, shift_ctrl_map, altgr_ctrl_map, shift_altgr_ctrl_map,
+	alt_map, shift_alt_map, altgr_alt_map, shift_altgr_alt_map,
+	ctrl_alt_map, shift_ctrl_alt_map, altgr_ctrl_alt_map, shift_altgr_ctrl_alt_map,	0
 };
 
-unsigned int keymap_count = 7;
+unsigned int keymap_count = 16;
 
 /*
  * Philosophy: most people do not define more strings, but they who do
diff -urNp linux-2.4.37.7/drivers/char/drm/drm_drv.h linux-2.4.37.7/drivers/char/drm/drm_drv.h
--- linux-2.4.37.7/drivers/char/drm/drm_drv.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/drm_drv.h	2009-11-10 19:30:27.000000000 -0500
@@ -114,7 +114,7 @@
 #endif
 #ifndef DRIVER_FOPS
 #define DRIVER_FOPS				\
-static struct file_operations	DRM(fops) = {	\
+static const struct file_operations	DRM(fops) = {	\
 	.owner   = THIS_MODULE,			\
 	.open	 = DRM(open),			\
 	.flush	 = DRM(flush),			\
diff -urNp linux-2.4.37.7/drivers/char/drm/drm_stub.h linux-2.4.37.7/drivers/char/drm/drm_stub.h
--- linux-2.4.37.7/drivers/char/drm/drm_stub.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/drm_stub.h	2009-11-10 19:30:27.000000000 -0500
@@ -65,7 +65,7 @@ static int DRM(stub_open)(struct inode *
 	return err;
 }
 
-static struct file_operations DRM(stub_fops) = {
+static const struct file_operations DRM(stub_fops) = {
 	.owner = THIS_MODULE,
 	.open  = DRM(stub_open)
 };
diff -urNp linux-2.4.37.7/drivers/char/drm/drm_vm.h linux-2.4.37.7/drivers/char/drm/drm_vm.h
--- linux-2.4.37.7/drivers/char/drm/drm_vm.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/drm_vm.h	2009-11-10 19:30:27.000000000 -0500
@@ -31,25 +31,25 @@
 
 #include "drmP.h"
 
-struct vm_operations_struct   DRM(vm_ops) = {
+const struct vm_operations_struct   DRM(vm_ops) = {
 	nopage:	 DRM(vm_nopage),
 	open:	 DRM(vm_open),
 	close:	 DRM(vm_close),
 };
 
-struct vm_operations_struct   DRM(vm_shm_ops) = {
+const struct vm_operations_struct   DRM(vm_shm_ops) = {
 	nopage:	 DRM(vm_shm_nopage),
 	open:	 DRM(vm_open),
 	close:	 DRM(vm_shm_close),
 };
 
-struct vm_operations_struct   DRM(vm_dma_ops) = {
+const struct vm_operations_struct   DRM(vm_dma_ops) = {
 	nopage:	 DRM(vm_dma_nopage),
 	open:	 DRM(vm_open),
 	close:	 DRM(vm_close),
 };
 
-struct vm_operations_struct   DRM(vm_sg_ops) = {
+const struct vm_operations_struct   DRM(vm_sg_ops) = {
 	nopage:  DRM(vm_sg_nopage),
 	open:    DRM(vm_open),
 	close:   DRM(vm_close),
diff -urNp linux-2.4.37.7/drivers/char/drm/ffb_drv.c linux-2.4.37.7/drivers/char/drm/ffb_drv.c
--- linux-2.4.37.7/drivers/char/drm/ffb_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/ffb_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -27,7 +27,7 @@
 #define DRIVER_PATCHLEVEL	1
 
 #define DRIVER_FOPS						\
-static struct file_operations	DRM(fops) = {			\
+static const struct file_operations	DRM(fops) = {			\
 	owner:   		THIS_MODULE,			\
 	open:	 		DRM(open),			\
 	flush:	 		DRM(flush),			\
diff -urNp linux-2.4.37.7/drivers/char/drm/i810_dma.c linux-2.4.37.7/drivers/char/drm/i810_dma.c
--- linux-2.4.37.7/drivers/char/drm/i810_dma.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/i810_dma.c	2009-11-10 19:30:27.000000000 -0500
@@ -131,7 +131,7 @@ static int i810_freelist_put(drm_device_
    	return 0;
 }
 
-static struct file_operations i810_buffer_fops = {
+static const struct file_operations i810_buffer_fops = {
 	.open	 = DRM(open),
 	.flush	 = DRM(flush),
 	.release = DRM(release),
diff -urNp linux-2.4.37.7/drivers/char/drm/i830_dma.c linux-2.4.37.7/drivers/char/drm/i830_dma.c
--- linux-2.4.37.7/drivers/char/drm/i830_dma.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm/i830_dma.c	2009-11-10 19:30:27.000000000 -0500
@@ -120,7 +120,7 @@ static int i830_freelist_put(drm_device_
    	return 0;
 }
 
-static struct file_operations i830_buffer_fops = {
+static const struct file_operations i830_buffer_fops = {
 	.open	 = DRM(open),
 	.flush	 = DRM(flush),
 	.release = DRM(release),
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/ffb_drv.c linux-2.4.37.7/drivers/char/drm-4.0/ffb_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/ffb_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/ffb_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -47,7 +47,7 @@ extern int ffb_newctx(struct inode *, st
 extern int ffb_rmctx(struct inode *, struct file *, unsigned int, unsigned long);
 extern int ffb_context_switch(drm_device_t *, int, int);
 
-static struct file_operations ffb_fops = {
+static const struct file_operations ffb_fops = {
 	owner:			THIS_MODULE,
 	open:			ffb_open,
 	flush:			drm_flush,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/gamma_drv.c linux-2.4.37.7/drivers/char/drm-4.0/gamma_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/gamma_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/gamma_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -49,7 +49,7 @@
 
 static drm_device_t	      gamma_device;
 
-static struct file_operations gamma_fops = {
+static const struct file_operations gamma_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/i810_dma.c linux-2.4.37.7/drivers/char/drm-4.0/i810_dma.c
--- linux-2.4.37.7/drivers/char/drm-4.0/i810_dma.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/i810_dma.c	2009-11-10 19:30:27.000000000 -0500
@@ -143,7 +143,7 @@ static int i810_freelist_put(drm_device_
    	return 0;
 }
 
-static struct file_operations i810_buffer_fops = {
+static const struct file_operations i810_buffer_fops = {
 	open:	 i810_open,
 	flush:	 drm_flush,
 	release: i810_release,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/i810_drv.c linux-2.4.37.7/drivers/char/drm-4.0/i810_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/i810_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/i810_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -43,7 +43,7 @@
 static drm_device_t	      i810_device;
 drm_ctx_t		      i810_res_ctx;
 
-static struct file_operations i810_fops = {
+static const struct file_operations i810_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/mga_drv.c linux-2.4.37.7/drivers/char/drm-4.0/mga_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/mga_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/mga_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,7 +44,7 @@
 static drm_device_t	      mga_device;
 drm_ctx_t		      mga_res_ctx;
 
-static struct file_operations mga_fops = {
+static const struct file_operations mga_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/r128_drv.c linux-2.4.37.7/drivers/char/drm-4.0/r128_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/r128_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/r128_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,7 +45,7 @@
 static drm_device_t	r128_device;
 drm_ctx_t		r128_res_ctx;
 
-static struct file_operations r128_fops = {
+static const struct file_operations r128_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/radeon_drv.c linux-2.4.37.7/drivers/char/drm-4.0/radeon_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/radeon_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/radeon_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -42,7 +42,7 @@
 static drm_device_t	      radeon_device;
 drm_ctx_t	              radeon_res_ctx;
 
-static struct file_operations radeon_fops = {
+static const struct file_operations radeon_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/tdfx_drv.c linux-2.4.37.7/drivers/char/drm-4.0/tdfx_drv.c
--- linux-2.4.37.7/drivers/char/drm-4.0/tdfx_drv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/tdfx_drv.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,7 +44,7 @@
 static drm_device_t	      tdfx_device;
 drm_ctx_t	              tdfx_res_ctx;
 
-static struct file_operations tdfx_fops = {
+static const struct file_operations tdfx_fops = {
 #if LINUX_VERSION_CODE >= 0x020400
 				/* This started being used during 2.4.0-test */
 	owner:   THIS_MODULE,
diff -urNp linux-2.4.37.7/drivers/char/drm-4.0/vm.c linux-2.4.37.7/drivers/char/drm-4.0/vm.c
--- linux-2.4.37.7/drivers/char/drm-4.0/vm.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/drm-4.0/vm.c	2009-11-10 19:30:27.000000000 -0500
@@ -32,25 +32,25 @@
 #define __NO_VERSION__
 #include "drmP.h"
 
-struct vm_operations_struct   drm_vm_ops = {
+const struct vm_operations_struct   drm_vm_ops = {
 	nopage:	 drm_vm_nopage,
 	open:	 drm_vm_open,
 	close:	 drm_vm_close,
 };
 
-struct vm_operations_struct   drm_vm_shm_ops = {
+const struct vm_operations_struct   drm_vm_shm_ops = {
 	nopage:	 drm_vm_shm_nopage,
 	open:	 drm_vm_open,
 	close:	 drm_vm_close,
 };
 
-struct vm_operations_struct   drm_vm_shm_lock_ops = {
+const struct vm_operations_struct   drm_vm_shm_lock_ops = {
 	nopage:	 drm_vm_shm_nopage_lock,
 	open:	 drm_vm_open,
 	close:	 drm_vm_close,
 };
 
-struct vm_operations_struct   drm_vm_dma_ops = {
+const struct vm_operations_struct   drm_vm_dma_ops = {
 	nopage:	 drm_vm_dma_nopage,
 	open:	 drm_vm_open,
 	close:	 drm_vm_close,
diff -urNp linux-2.4.37.7/drivers/char/ds1286.c linux-2.4.37.7/drivers/char/ds1286.c
--- linux-2.4.37.7/drivers/char/ds1286.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ds1286.c	2009-11-10 19:30:27.000000000 -0500
@@ -280,7 +280,7 @@ static unsigned int ds1286_poll(struct f
  *	The various file operations we support.
  */
 
-static struct file_operations ds1286_fops = {
+static const struct file_operations ds1286_fops = {
 	.llseek		= no_llseek,
 	.read		= ds1286_read,
 	.poll		= ds1286_poll,
diff -urNp linux-2.4.37.7/drivers/char/ds1620.c linux-2.4.37.7/drivers/char/ds1620.c
--- linux-2.4.37.7/drivers/char/ds1620.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ds1620.c	2009-11-10 19:30:27.000000000 -0500
@@ -336,7 +336,7 @@ proc_therm_ds1620_read(char *buf, char *
 static struct proc_dir_entry *proc_therm_ds1620;
 #endif
 
-static struct file_operations ds1620_fops = {
+static const struct file_operations ds1620_fops = {
 	owner:		THIS_MODULE,
 	read:		ds1620_read,
 	ioctl:		ds1620_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/ds1742.c linux-2.4.37.7/drivers/char/ds1742.c
--- linux-2.4.37.7/drivers/char/ds1742.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ds1742.c	2009-11-10 19:30:27.000000000 -0500
@@ -312,7 +312,7 @@ static int ds1742_release(struct inode *
 	return 0;
 }
 
-static struct file_operations ds1742_fops = {
+static const struct file_operations ds1742_fops = {
 	owner:THIS_MODULE,
 	llseek:no_llseek,
 	ioctl:ds1742_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/dsp56k.c linux-2.4.37.7/drivers/char/dsp56k.c
--- linux-2.4.37.7/drivers/char/dsp56k.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/dsp56k.c	2009-11-10 19:30:27.000000000 -0500
@@ -488,7 +488,7 @@ static int dsp56k_release(struct inode *
 	return 0;
 }
 
-static struct file_operations dsp56k_fops = {
+static const struct file_operations dsp56k_fops = {
 	owner:		THIS_MODULE,
 	read:		dsp56k_read,
 	write:		dsp56k_write,
diff -urNp linux-2.4.37.7/drivers/char/dtlk.c linux-2.4.37.7/drivers/char/dtlk.c
--- linux-2.4.37.7/drivers/char/dtlk.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/dtlk.c	2009-11-10 19:30:27.000000000 -0500
@@ -97,8 +97,7 @@ static int dtlk_release(struct inode *, 
 static int dtlk_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg);
 
-static struct file_operations dtlk_fops =
-{
+static const struct file_operations dtlk_fops = {
 	owner:		THIS_MODULE,
 	read:		dtlk_read,
 	write:		dtlk_write,
diff -urNp linux-2.4.37.7/drivers/char/efirtc.c linux-2.4.37.7/drivers/char/efirtc.c
--- linux-2.4.37.7/drivers/char/efirtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/efirtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -282,7 +282,7 @@ efi_rtc_close(struct inode *inode, struc
  *	The various file operations we support.
  */
 
-static struct file_operations efi_rtc_fops = {
+static const struct file_operations efi_rtc_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		efi_rtc_ioctl,
 	open:		efi_rtc_open,
diff -urNp linux-2.4.37.7/drivers/char/eurotechwdt.c linux-2.4.37.7/drivers/char/eurotechwdt.c
--- linux-2.4.37.7/drivers/char/eurotechwdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/eurotechwdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -386,7 +386,7 @@ static int eurwdt_notify_sys(struct noti
  */
  
  
-static struct file_operations eurwdt_fops = {
+static const struct file_operations eurwdt_fops = {
         owner:          THIS_MODULE,
         llseek:         no_llseek,
         write:          eurwdt_write,
diff -urNp linux-2.4.37.7/drivers/char/fetchop.c linux-2.4.37.7/drivers/char/fetchop.c
--- linux-2.4.37.7/drivers/char/fetchop.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/fetchop.c	2009-11-10 19:30:27.000000000 -0500
@@ -75,7 +75,7 @@ static int fetchop_mmap(struct file *fil
 static void fetchop_open(struct vm_area_struct *vma);
 static void fetchop_close(struct vm_area_struct *vma);
 
-static struct file_operations fetchop_fops = {
+static const struct file_operations fetchop_fops = {
 	owner:		THIS_MODULE,
 	mmap:		fetchop_mmap,
 };
@@ -86,7 +86,7 @@ static struct miscdevice fetchop_miscdev
 	&fetchop_fops
 };
 
-static struct vm_operations_struct fetchop_vm_ops = {
+static const struct vm_operations_struct fetchop_vm_ops = {
 	open:		fetchop_open,
 	close:		fetchop_close,
 };
diff -urNp linux-2.4.37.7/drivers/char/ftape/zftape/zftape-init.c linux-2.4.37.7/drivers/char/ftape/zftape/zftape-init.c
--- linux-2.4.37.7/drivers/char/ftape/zftape/zftape-init.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ftape/zftape/zftape-init.c	2009-11-10 19:30:27.000000000 -0500
@@ -94,8 +94,7 @@ static ssize_t zft_read (struct file *fp
 static ssize_t zft_write(struct file *fp, const char *buff,
 			 size_t req_len, loff_t *ppos);
 
-static struct file_operations zft_cdev =
-{
+static const struct file_operations zft_cdev = {
 	owner:		THIS_MODULE,
 	read:		zft_read,
 	write:		zft_write,
@@ -205,7 +204,7 @@ static int  zft_mmap(struct file *filep,
 	lock_kernel();
 	if ((result = ftape_mmap(vma)) >= 0) {
 #ifndef MSYNC_BUG_WAS_FIXED
-		static struct vm_operations_struct dummy = { NULL, };
+		static const struct vm_operations_struct dummy = { NULL, };
 		vma->vm_ops = &dummy;
 #endif
 	}
diff -urNp linux-2.4.37.7/drivers/char/genrtc.c linux-2.4.37.7/drivers/char/genrtc.c
--- linux-2.4.37.7/drivers/char/genrtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/genrtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -476,7 +476,7 @@ static int gen_rtc_read_proc(char *page,
  *	The various file operations we support.
  */
 
-static struct file_operations gen_rtc_fops = {
+static const struct file_operations gen_rtc_fops = {
 	.owner		= THIS_MODULE,
 #ifdef CONFIG_GEN_RTC_X
 	.read		= gen_rtc_read,
diff -urNp linux-2.4.37.7/drivers/char/geodewdt.c linux-2.4.37.7/drivers/char/geodewdt.c
--- linux-2.4.37.7/drivers/char/geodewdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/geodewdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -183,7 +183,7 @@ static int geodewdt_notify_sys(struct no
         return NOTIFY_DONE;
 }
 
-static struct file_operations geodewdt_fops = {
+static const struct file_operations geodewdt_fops = {
         .owner          = THIS_MODULE,
         .llseek         = no_llseek,
         .write          = geodewdt_write,
diff -urNp linux-2.4.37.7/drivers/char/hp_psaux.c linux-2.4.37.7/drivers/char/hp_psaux.c
--- linux-2.4.37.7/drivers/char/hp_psaux.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/hp_psaux.c	2009-11-10 19:30:27.000000000 -0500
@@ -414,7 +414,7 @@ static int release_aux(struct inode * in
 	return 0;
 }
 
-static struct file_operations psaux_fops = {
+static const struct file_operations psaux_fops = {
 	read:		read_aux,
 	write:		write_aux,
 	poll:		aux_poll,
diff -urNp linux-2.4.37.7/drivers/char/hw_random.c linux-2.4.37.7/drivers/char/hw_random.c
--- linux-2.4.37.7/drivers/char/hw_random.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/hw_random.c	2009-11-10 19:30:27.000000000 -0500
@@ -106,7 +106,7 @@ struct rng_operations {
 };
 static struct rng_operations *rng_ops;
 
-static struct file_operations rng_chrdev_ops = {
+static const struct file_operations rng_chrdev_ops = {
 	.owner		= THIS_MODULE,
 	.open		= rng_dev_open,
 	.read		= rng_dev_read,
diff -urNp linux-2.4.37.7/drivers/char/i810_rng.c linux-2.4.37.7/drivers/char/i810_rng.c
--- linux-2.4.37.7/drivers/char/i810_rng.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/i810_rng.c	2009-11-10 19:30:27.000000000 -0500
@@ -260,7 +260,7 @@ static ssize_t rng_dev_read (struct file
 }
 
 
-static struct file_operations rng_chrdev_ops = {
+static const struct file_operations rng_chrdev_ops = {
 	owner:		THIS_MODULE,
 	open:		rng_dev_open,
 	release:	rng_dev_release,
diff -urNp linux-2.4.37.7/drivers/char/i810-tco.c linux-2.4.37.7/drivers/char/i810-tco.c
--- linux-2.4.37.7/drivers/char/i810-tco.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/i810-tco.c	2009-11-10 19:30:27.000000000 -0500
@@ -376,7 +376,7 @@ static unsigned char __init i810tco_getd
 	return 0;
 }
 
-static struct file_operations i810tco_fops = {
+static const struct file_operations i810tco_fops = {
 	owner:		THIS_MODULE,
 	write:		i810tco_write,
 	ioctl:		i810tco_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/i8k.c linux-2.4.37.7/drivers/char/i8k.c
--- linux-2.4.37.7/drivers/char/i8k.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/i8k.c	2009-11-10 19:30:27.000000000 -0500
@@ -112,7 +112,7 @@ static int i8k_ioctl(struct inode *, str
 		     unsigned long);
 static void i8k_keys_set_timer(void);
 
-static struct file_operations i8k_fops = {
+static const struct file_operations i8k_fops = {
     read:	i8k_read,
     ioctl:	i8k_ioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/ib700wdt.c linux-2.4.37.7/drivers/char/ib700wdt.c
--- linux-2.4.37.7/drivers/char/ib700wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ib700wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -280,7 +280,7 @@ ibwdt_notify_sys(struct notifier_block *
  *	Kernel Interfaces
  */
 
-static struct file_operations ibwdt_fops = {
+static const struct file_operations ibwdt_fops = {
 	owner:		THIS_MODULE,
 	read:		ibwdt_read,
 	write:		ibwdt_write,
diff -urNp linux-2.4.37.7/drivers/char/indydog.c linux-2.4.37.7/drivers/char/indydog.c
--- linux-2.4.37.7/drivers/char/indydog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/indydog.c	2009-11-10 19:30:27.000000000 -0500
@@ -137,7 +137,7 @@ static int indydog_ioctl(struct inode *i
 	}
 }
 
-static struct file_operations indydog_fops = {
+static const struct file_operations indydog_fops = {
 	owner:		THIS_MODULE,
 	write:		indydog_write,
 	ioctl:		indydog_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/ip27-rtc.c linux-2.4.37.7/drivers/char/ip27-rtc.c
--- linux-2.4.37.7/drivers/char/ip27-rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ip27-rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -192,7 +192,7 @@ static int rtc_release(struct inode *ino
  *	The various file operations we support.
  */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.ioctl		= rtc_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/ip2main.c linux-2.4.37.7/drivers/char/ip2main.c
--- linux-2.4.37.7/drivers/char/ip2main.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ip2main.c	2009-11-10 19:30:27.000000000 -0500
@@ -354,7 +354,7 @@ static struct termios    * TermiosLocked
 /* This is the driver descriptor for the ip2ipl device, which is used to
  * download the loadware to the boards.
  */
-static struct file_operations ip2_ipl = {
+static const struct file_operations ip2_ipl = {
 	owner:		THIS_MODULE,
 	read:		ip2_ipl_read,
 	write:		ip2_ipl_write,
diff -urNp linux-2.4.37.7/drivers/char/ipmi/ipmi_devintf.c linux-2.4.37.7/drivers/char/ipmi/ipmi_devintf.c
--- linux-2.4.37.7/drivers/char/ipmi/ipmi_devintf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ipmi/ipmi_devintf.c	2009-11-10 19:30:27.000000000 -0500
@@ -423,7 +423,7 @@ static int ipmi_ioctl(struct inode  *ino
 }
 
 
-static struct file_operations ipmi_fops = {
+static const struct file_operations ipmi_fops = {
 	owner:   THIS_MODULE,
 	ioctl:   ipmi_ioctl,
 	open:    ipmi_open,
diff -urNp linux-2.4.37.7/drivers/char/ipmi/ipmi_watchdog.c linux-2.4.37.7/drivers/char/ipmi/ipmi_watchdog.c
--- linux-2.4.37.7/drivers/char/ipmi/ipmi_watchdog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ipmi/ipmi_watchdog.c	2009-11-10 19:30:27.000000000 -0500
@@ -699,7 +699,7 @@ static int ipmi_close(struct inode *ino,
 	return 0;
 }
 
-static struct file_operations ipmi_wdog_fops = {
+static const struct file_operations ipmi_wdog_fops = {
 	.owner   = THIS_MODULE,
 	.read    = ipmi_read,
 	.poll    = ipmi_poll,
diff -urNp linux-2.4.37.7/drivers/char/isicom.c linux-2.4.37.7/drivers/char/isicom.c
--- linux-2.4.37.7/drivers/char/isicom.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/isicom.c	2009-11-10 19:30:27.000000000 -0500
@@ -113,7 +113,7 @@ static signed char linuxb_to_isib[] = {
  *
  */
 
-static struct file_operations ISILoad_fops = {
+static const struct file_operations ISILoad_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		ISILoad_ioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/istallion.c linux-2.4.37.7/drivers/char/istallion.c
--- linux-2.4.37.7/drivers/char/istallion.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/istallion.c	2009-11-10 19:30:27.000000000 -0500
@@ -782,7 +782,7 @@ static inline int	stli_initpcibrd(int br
  *	will give access to the shared memory on the Stallion intelligent
  *	board. This is also a very useful debugging tool.
  */
-static struct file_operations	stli_fsiomem = {
+static const struct file_operations	stli_fsiomem = {
 	owner:		THIS_MODULE,
 	read:		stli_memread,
 	write:		stli_memwrite,
diff -urNp linux-2.4.37.7/drivers/char/ite_gpio.c linux-2.4.37.7/drivers/char/ite_gpio.c
--- linux-2.4.37.7/drivers/char/ite_gpio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ite_gpio.c	2009-11-10 19:30:27.000000000 -0500
@@ -364,7 +364,7 @@ DEB(printk("interrupt 0x%x %d\n",ITE_GPA
 	}
 }
 
-static struct file_operations ite_gpio_fops = {
+static const struct file_operations ite_gpio_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		ite_gpio_ioctl,
 	open:		ite_gpio_open,
diff -urNp linux-2.4.37.7/drivers/char/keyboard.c linux-2.4.37.7/drivers/char/keyboard.c
--- linux-2.4.37.7/drivers/char/keyboard.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/keyboard.c	2009-11-10 19:30:27.000000000 -0500
@@ -545,6 +545,16 @@ static void do_spec(unsigned char value,
 	if ((kbd->kbdmode == VC_RAW || kbd->kbdmode == VC_MEDIUMRAW) &&
 	    !(SPECIALS_ALLOWED_IN_RAW_MODE & (1 << value)))
 		return;
+
+#if defined(CONFIG_GRKERNSEC_PROC) || defined(CONFIG_GRKERNSEC_PROC_MEMMAP)
+	{
+		void *func = spec_fn_table[value];
+		if (func == show_state || func == show_ptregs ||
+		    func == show_mem)
+			return;
+	}
+#endif
+
 	spec_fn_table[value]();
 }
 
diff -urNp linux-2.4.37.7/drivers/char/lcd.c linux-2.4.37.7/drivers/char/lcd.c
--- linux-2.4.37.7/drivers/char/lcd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/lcd.c	2009-11-10 19:30:27.000000000 -0500
@@ -556,7 +556,7 @@ static long lcd_read(struct inode *inode
  *	The various file operations we support.
  */
 
-static struct file_operations lcd_fops = {
+static const struct file_operations lcd_fops = {
 	read:		lcd_read,
 	ioctl:		lcd_ioctl,
 	open:		lcd_open,
diff -urNp linux-2.4.37.7/drivers/char/lp.c linux-2.4.37.7/drivers/char/lp.c
--- linux-2.4.37.7/drivers/char/lp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/lp.c	2009-11-10 19:30:27.000000000 -0500
@@ -664,7 +664,7 @@ static int lp_ioctl(struct inode *inode,
 	return retval;
 }
 
-static struct file_operations lp_fops = {
+static const struct file_operations lp_fops = {
 	owner:		THIS_MODULE,
 	write:		lp_write,
 	ioctl:		lp_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/machzwd.c linux-2.4.37.7/drivers/char/machzwd.c
--- linux-2.4.37.7/drivers/char/machzwd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/machzwd.c	2009-11-10 19:30:27.000000000 -0500
@@ -448,7 +448,7 @@ static int zf_notify_sys(struct notifier
 
 
 
-static struct file_operations zf_fops = {
+static const struct file_operations zf_fops = {
 	owner:          THIS_MODULE,
 	read:           zf_read,
 	write:          zf_write,
diff -urNp linux-2.4.37.7/drivers/char/mem.c linux-2.4.37.7/drivers/char/mem.c
--- linux-2.4.37.7/drivers/char/mem.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mem.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/tty.h>
 #include <linux/capability.h>
 #include <linux/ptrace.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -42,6 +43,10 @@ extern void mda_console_init(void);
 #if defined(CONFIG_S390_TAPE) && defined(CONFIG_S390_TAPE_CHAR)
 extern void tapechar_init(void);
 #endif
+
+#ifdef CONFIG_GRKERNSEC
+extern struct file_operations grsec_fops;
+#endif
      
 static ssize_t do_write_mem(struct file * file, void *p, unsigned long realp,
 			    const char * buf, size_t count, loff_t *ppos)
@@ -115,6 +120,11 @@ static ssize_t write_mem(struct file * f
 	unsigned long p = *ppos;
 	unsigned long end_mem;
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_mem_write();
+	return -EPERM;
+#endif
+
 	end_mem = __pa(high_memory);
 	if (p >= end_mem)
 		return 0;
@@ -187,6 +197,12 @@ static int mmap_mem(struct file * file, 
 {
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	if (gr_handle_mem_mmap(offset, vma))
+		return -EPERM;
+#endif
+
+
 	/*
 	 * Accessing memory above the top the kernel knows about or
 	 * through a file pointer that was marked O_SYNC will be
@@ -286,6 +302,11 @@ static ssize_t write_kmem(struct file * 
 	ssize_t virtr = 0;
 	char * kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_kmem_write();
+	return -EPERM;
+#endif
+
 	if (p < (unsigned long) high_memory) {
 		wrote = count;
 		if (count > (unsigned long) high_memory - p)
@@ -402,9 +423,25 @@ static inline size_t read_zero_pagealign
 			count = size;
 
 		zap_page_range(mm, addr, count);
-        	if (zeromap_page_range(addr, count, PAGE_COPY))
+        	if (zeromap_page_range(addr, count, vma->vm_page_prot))
 			break;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR) {
+			unsigned long addr_m;
+			struct vm_area_struct * vma_m;
+
+			addr_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(mm, addr_m);
+			if (vma_m && vma_m->vm_start == addr_m && (vma_m->vm_flags & VM_MIRROR)) {
+				addr_m = addr + vma->vm_mirror;
+				zap_page_range(mm, addr_m, count);
+			} else
+				printk(KERN_ERR "PAX: VMMIRROR: read_zero bug, %08lx, %08lx\n",
+				       addr, vma->vm_start);
+		}
+#endif
+
 		size -= count;
 		buf += count;
 		addr += count;
@@ -526,6 +563,15 @@ static loff_t memory_lseek(struct file *
 
 static int open_port(struct inode * inode, struct file * filp)
 {
+#ifdef CONFIG_GRKERNSEC_KMEM
+	gr_handle_open_port();
+	return -EPERM;
+#endif
+	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+}
+
+static int open_mem(struct inode * inode, struct file * filp)
+{
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
@@ -574,7 +620,7 @@ out:
 	return page;
 }
 
-struct vm_operations_struct kmem_vm_ops = {
+const struct vm_operations_struct kmem_vm_ops = {
 	nopage:		kmem_vm_nopage,
 };
 
@@ -583,6 +629,11 @@ static int mmap_kmem(struct file * file,
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 	unsigned long size = vma->vm_end - vma->vm_start;
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	if (gr_handle_mem_mmap(offset, vma))
+		return -EPERM;
+#endif
+
 	/*
 	 * If the user is not attempting to mmap a high memory address then
 	 * the standard mmap_mem mechanism will work.  High memory addresses
@@ -618,10 +669,9 @@ static int mmap_kmem(struct file * file,
 #define full_lseek      null_lseek
 #define write_zero	write_null
 #define read_full       read_zero
-#define open_mem	open_port
 #define open_kmem	open_mem
 
-static struct file_operations mem_fops = {
+static const struct file_operations mem_fops = {
 	llseek:		memory_lseek,
 	read:		read_mem,
 	write:		write_mem,
@@ -629,7 +679,7 @@ static struct file_operations mem_fops =
 	open:		open_mem,
 };
 
-static struct file_operations kmem_fops = {
+static const struct file_operations kmem_fops = {
 	llseek:		memory_lseek,
 	read:		read_kmem,
 	write:		write_kmem,
@@ -637,14 +687,14 @@ static struct file_operations kmem_fops 
 	open:		open_kmem,
 };
 
-static struct file_operations null_fops = {
+static const struct file_operations null_fops = {
 	llseek:		null_lseek,
 	read:		read_null,
 	write:		write_null,
 };
 
 #if defined(CONFIG_ISA) || !defined(__mc68000__)
-static struct file_operations port_fops = {
+static const struct file_operations port_fops = {
 	llseek:		memory_lseek,
 	read:		read_port,
 	write:		write_port,
@@ -652,14 +702,14 @@ static struct file_operations port_fops 
 };
 #endif
 
-static struct file_operations zero_fops = {
+static const struct file_operations zero_fops = {
 	llseek:		zero_lseek,
 	read:		read_zero,
 	write:		write_zero,
 	mmap:		mmap_zero,
 };
 
-static struct file_operations full_fops = {
+static const struct file_operations full_fops = {
 	llseek:		full_lseek,
 	read:		read_full,
 	write:		write_full,
@@ -694,6 +744,11 @@ static int memory_open(struct inode * in
 		case 9:
 			filp->f_op = &urandom_fops;
 			break;
+#ifdef CONFIG_GRKERNSEC
+		case 13:
+			filp->f_op = &grsec_fops;
+			break;
+#endif
 		default:
 			return -ENXIO;
 	}
@@ -709,7 +764,7 @@ void __init memory_devfs_register (void)
 	unsigned short minor;
 	char *name;
 	umode_t mode;
-	struct file_operations *fops;
+	const struct file_operations *fops;
     } list[] = { /* list of minor devices */
 	{1, "mem",     S_IRUSR | S_IWUSR | S_IRGRP, &mem_fops},
 	{2, "kmem",    S_IRUSR | S_IWUSR | S_IRGRP, &kmem_fops},
@@ -720,7 +775,10 @@ void __init memory_devfs_register (void)
 	{5, "zero",    S_IRUGO | S_IWUGO,           &zero_fops},
 	{7, "full",    S_IRUGO | S_IWUGO,           &full_fops},
 	{8, "random",  S_IRUGO | S_IWUSR,           &random_fops},
-	{9, "urandom", S_IRUGO | S_IWUSR,           &urandom_fops}
+	{9, "urandom", S_IRUGO | S_IWUSR,           &urandom_fops},
+#if defined(CONFIG_GRKERNSEC) && !defined(CONFIG_GRKERNSEC_NO_RBAC)
+	{13,"grsec",   S_IRUSR | S_IWUGO,	    &grsec_fops}
+#endif
     };
     int i;
 
@@ -731,7 +789,7 @@ void __init memory_devfs_register (void)
 			list[i].fops, NULL);
 }
 
-static struct file_operations memory_fops = {
+static const struct file_operations memory_fops = {
 	open:		memory_open,	/* just a selector for the real open */
 };
 
diff -urNp linux-2.4.37.7/drivers/char/mips_rtc.c linux-2.4.37.7/drivers/char/mips_rtc.c
--- linux-2.4.37.7/drivers/char/mips_rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mips_rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -138,7 +138,7 @@ static int rtc_release(struct inode *ino
  *	The various file operations we support.
  */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	owner:THIS_MODULE,
 	llseek:no_llseek,
 	ioctl:rtc_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/misc.c linux-2.4.37.7/drivers/char/misc.c
--- linux-2.4.37.7/drivers/char/misc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/misc.c	2009-11-10 19:30:27.000000000 -0500
@@ -104,7 +104,7 @@ static int misc_open(struct inode * inod
 	int minor = MINOR(inode->i_rdev);
 	struct miscdevice *c;
 	int err = -ENODEV;
-	struct file_operations *old_fops, *new_fops = NULL;
+	const struct file_operations *old_fops, *new_fops = NULL;
 	
 	down(&misc_sem);
 	
@@ -143,7 +143,7 @@ fail:
 	return err;
 }
 
-static struct file_operations misc_fops = {
+static const struct file_operations misc_fops = {
 	owner:		THIS_MODULE,
 	open:		misc_open,
 };
diff -urNp linux-2.4.37.7/drivers/char/mixcomwd.c linux-2.4.37.7/drivers/char/mixcomwd.c
--- linux-2.4.37.7/drivers/char/mixcomwd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mixcomwd.c	2009-11-10 19:30:27.000000000 -0500
@@ -197,8 +197,7 @@ static int mixcomwd_ioctl(struct inode *
 	return 0;
 }
 
-static struct file_operations mixcomwd_fops=
-{
+static const struct file_operations mixcomwd_fops = {
 	owner:		THIS_MODULE,
 	write:		mixcomwd_write,
 	ioctl:		mixcomwd_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/mk712.c linux-2.4.37.7/drivers/char/mk712.c
--- linux-2.4.37.7/drivers/char/mk712.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mk712.c	2009-11-10 19:30:27.000000000 -0500
@@ -415,7 +415,7 @@ static ssize_t mk712_write(struct file *
 	return -EINVAL;
 }
 
-struct file_operations mk712_fops = {
+const struct file_operations mk712_fops = {
 	owner: THIS_MODULE,
 	read: mk712_read,
 	write: mk712_write,
diff -urNp linux-2.4.37.7/drivers/char/mpc8xx_wdt.c linux-2.4.37.7/drivers/char/mpc8xx_wdt.c
--- linux-2.4.37.7/drivers/char/mpc8xx_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mpc8xx_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -144,7 +144,7 @@ mpc8xx_wdt_ioctl(struct inode *inode, st
 	return 0;
 }
 
-static struct file_operations mpc8xx_wdt_fops = {
+static const struct file_operations mpc8xx_wdt_fops = {
 	.owner = THIS_MODULE,
 	.write = mpc8xx_wdt_write,
 	.ioctl = mpc8xx_wdt_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/mwave/mwavedd.c linux-2.4.37.7/drivers/char/mwave/mwavedd.c
--- linux-2.4.37.7/drivers/char/mwave/mwavedd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/mwave/mwavedd.c	2009-11-10 19:30:27.000000000 -0500
@@ -431,7 +431,7 @@ static int register_serial_portandirq(un
 
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-static struct file_operations mwave_fops = {
+static const struct file_operations mwave_fops = {
 	owner:THIS_MODULE,
 	read:mwave_read,
 	write:mwave_write,
@@ -440,7 +440,7 @@ static struct file_operations mwave_fops
 	release:mwave_close
 };
 #else
-static struct file_operations mwave_fops = {
+static const struct file_operations mwave_fops = {
 	NULL,			/* lseek */
 	mwave_read,		/* read */
 	mwave_write,		/* write */
diff -urNp linux-2.4.37.7/drivers/char/nvram.c linux-2.4.37.7/drivers/char/nvram.c
--- linux-2.4.37.7/drivers/char/nvram.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/nvram.c	2009-11-10 19:30:27.000000000 -0500
@@ -443,7 +443,7 @@ nvram_read_proc(char *buffer, char **sta
 
 #endif /* CONFIG_PROC_FS */
 
-static struct file_operations nvram_fops = {
+static const struct file_operations nvram_fops = {
 	owner:		THIS_MODULE,
 	llseek:		nvram_llseek,
 	read:		nvram_read,
diff -urNp linux-2.4.37.7/drivers/char/nwbutton.c linux-2.4.37.7/drivers/char/nwbutton.c
--- linux-2.4.37.7/drivers/char/nwbutton.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/nwbutton.c	2009-11-10 19:30:27.000000000 -0500
@@ -182,7 +182,7 @@ static int button_read (struct file *fil
  * attempts to perform these operations on the device.
  */
 
-static struct file_operations button_fops = {
+static const struct file_operations button_fops = {
 	owner:		THIS_MODULE,
 	read:		button_read,
 };
diff -urNp linux-2.4.37.7/drivers/char/nwflash.c linux-2.4.37.7/drivers/char/nwflash.c
--- linux-2.4.37.7/drivers/char/nwflash.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/nwflash.c	2009-11-10 19:30:27.000000000 -0500
@@ -636,8 +636,7 @@ static void kick_open(void)
 	udelay(25);
 }
 
-static struct file_operations flash_fops =
-{
+static const struct file_operations flash_fops = {
 	owner:		THIS_MODULE,
 	llseek:		flash_llseek,
 	read:		flash_read,
diff -urNp linux-2.4.37.7/drivers/char/pc110pad.c linux-2.4.37.7/drivers/char/pc110pad.c
--- linux-2.4.37.7/drivers/char/pc110pad.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/pc110pad.c	2009-11-10 19:30:27.000000000 -0500
@@ -770,7 +770,7 @@ static int pad_ioctl(struct inode *inode
 }
 
 
-static struct file_operations pad_fops = {
+static const struct file_operations pad_fops = {
 	owner:		THIS_MODULE,
 	read:		read_pad,
 	write:		write_pad,
diff -urNp linux-2.4.37.7/drivers/char/pc_keyb.c linux-2.4.37.7/drivers/char/pc_keyb.c
--- linux-2.4.37.7/drivers/char/pc_keyb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/pc_keyb.c	2009-11-10 19:30:27.000000000 -0500
@@ -1182,7 +1182,7 @@ static unsigned int aux_poll(struct file
 	return 0;
 }
 
-struct file_operations psaux_fops = {
+const struct file_operations psaux_fops = {
 	read:		read_aux,
 	write:		write_aux,
 	poll:		aux_poll,
diff -urNp linux-2.4.37.7/drivers/char/pcwd.c linux-2.4.37.7/drivers/char/pcwd.c
--- linux-2.4.37.7/drivers/char/pcwd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/pcwd.c	2009-11-10 19:30:27.000000000 -0500
@@ -710,7 +710,7 @@ static struct pci_driver pcwd_driver = {
 	probe:pcwd_init_one,
 };
 
-static struct file_operations pcwd_fops = {
+static const struct file_operations pcwd_fops = {
 	owner:THIS_MODULE,
 	write:pcwd_write,
 	ioctl:pcwd_ioctl,
@@ -724,7 +724,7 @@ static struct miscdevice pcwd_miscdev = 
 	&pcwd_fops
 };
 
-static struct file_operations pcwd_temp_fops = {
+static const struct file_operations pcwd_temp_fops = {
 	owner:THIS_MODULE,
 	read:pcwd_read,
 	open:pcwd_open,
diff -urNp linux-2.4.37.7/drivers/char/ppdev.c linux-2.4.37.7/drivers/char/ppdev.c
--- linux-2.4.37.7/drivers/char/ppdev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/ppdev.c	2009-11-10 19:30:27.000000000 -0500
@@ -743,7 +743,7 @@ static unsigned int pp_poll (struct file
 	return mask;
 }
 
-static struct file_operations pp_fops = {
+static const struct file_operations pp_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		pp_read,
diff -urNp linux-2.4.37.7/drivers/char/qpmouse.c linux-2.4.37.7/drivers/char/qpmouse.c
--- linux-2.4.37.7/drivers/char/qpmouse.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/qpmouse.c	2009-11-10 19:30:27.000000000 -0500
@@ -288,7 +288,7 @@ repeat:
 	return 0;
 }
 
-struct file_operations qp_fops = {
+const struct file_operations qp_fops = {
 	owner:		THIS_MODULE,
 	read:		read_qp,
 	write:		write_qp,
diff -urNp linux-2.4.37.7/drivers/char/qtronix.c linux-2.4.37.7/drivers/char/qtronix.c
--- linux-2.4.37.7/drivers/char/qtronix.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/qtronix.c	2009-11-10 19:30:27.000000000 -0500
@@ -569,7 +569,7 @@ static unsigned int aux_poll(struct file
 	return 0;
 }
 
-struct file_operations psaux_fops = {
+const struct file_operations psaux_fops = {
 	read:		read_aux,
 	write:		write_aux,
 	poll:		aux_poll,
diff -urNp linux-2.4.37.7/drivers/char/random.c linux-2.4.37.7/drivers/char/random.c
--- linux-2.4.37.7/drivers/char/random.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/random.c	2009-11-10 19:30:27.000000000 -0500
@@ -262,9 +262,15 @@
 /*
  * Configuration information
  */
+#ifdef CONFIG_GRKERNSEC_RANDNET
+#define DEFAULT_POOL_SIZE 1024
+#define SECONDARY_POOL_SIZE 256
+#define BATCH_ENTROPY_SIZE 512
+#else
 #define DEFAULT_POOL_SIZE 512
 #define SECONDARY_POOL_SIZE 128
 #define BATCH_ENTROPY_SIZE 256
+#endif
 #define USE_SHA
 
 /*
@@ -1699,14 +1705,14 @@ random_ioctl(struct inode * inode, struc
 	}
 }
 
-struct file_operations random_fops = {
+const struct file_operations random_fops = {
 	read:		random_read,
 	write:		random_write,
 	poll:		random_poll,
 	ioctl:		random_ioctl,
 };
 
-struct file_operations urandom_fops = {
+const struct file_operations urandom_fops = {
 	read:		urandom_read,
 	write:		random_write,
 	ioctl:		random_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/raw.c linux-2.4.37.7/drivers/char/raw.c
--- linux-2.4.37.7/drivers/char/raw.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/raw.c	2009-11-10 19:30:27.000000000 -0500
@@ -37,7 +37,7 @@ int	raw_ctl_ioctl(struct inode *, struct
 int	raw_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
 
 
-static struct file_operations raw_fops = {
+static const struct file_operations raw_fops = {
 	read:		raw_read,
 	write:		raw_write,
 	open:		raw_open,
@@ -45,7 +45,7 @@ static struct file_operations raw_fops =
 	ioctl:		raw_ioctl,
 };
 
-static struct file_operations raw_ctl_fops = {
+static const struct file_operations raw_ctl_fops = {
 	ioctl:		raw_ctl_ioctl,
 	open:		raw_open,
 };
diff -urNp linux-2.4.37.7/drivers/char/rio/rio_linux.c linux-2.4.37.7/drivers/char/rio/rio_linux.c
--- linux-2.4.37.7/drivers/char/rio/rio_linux.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/rio/rio_linux.c	2009-11-10 19:30:27.000000000 -0500
@@ -276,7 +276,7 @@ static struct real_driver rio_real_drive
  *
  */
 
-static struct file_operations rio_fw_fops = {
+static const struct file_operations rio_fw_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		rio_fw_ioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/rtc.c linux-2.4.37.7/drivers/char/rtc.c
--- linux-2.4.37.7/drivers/char/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -686,7 +686,7 @@ static unsigned int rtc_poll(struct file
  *	The various file operations we support.
  */
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		rtc_read,
diff -urNp linux-2.4.37.7/drivers/char/sbc60xxwdt.c linux-2.4.37.7/drivers/char/sbc60xxwdt.c
--- linux-2.4.37.7/drivers/char/sbc60xxwdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/sbc60xxwdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -251,7 +251,7 @@ static int fop_ioctl(struct inode *inode
 	}
 }
 
-static struct file_operations wdt_fops = {
+static const struct file_operations wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		fop_read,
diff -urNp linux-2.4.37.7/drivers/char/sc1200wdt.c linux-2.4.37.7/drivers/char/sc1200wdt.c
--- linux-2.4.37.7/drivers/char/sc1200wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/sc1200wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -292,8 +292,7 @@ static struct notifier_block sc1200wdt_n
 	notifier_call:	sc1200wdt_notify_sys
 };
 
-static struct file_operations sc1200wdt_fops =
-{
+static const struct file_operations sc1200wdt_fops = {
 	owner:		THIS_MODULE,
 	write:		sc1200wdt_write,
 	ioctl:		sc1200wdt_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/sc520_wdt.c linux-2.4.37.7/drivers/char/sc520_wdt.c
--- linux-2.4.37.7/drivers/char/sc520_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/sc520_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -286,7 +286,7 @@ static int fop_ioctl(struct inode *inode
 	}
 }
 
-static struct file_operations wdt_fops = {
+static const struct file_operations wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		fop_llseek,
 	write:		fop_write,
diff -urNp linux-2.4.37.7/drivers/char/scx200_gpio.c linux-2.4.37.7/drivers/char/scx200_gpio.c
--- linux-2.4.37.7/drivers/char/scx200_gpio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/scx200_gpio.c	2009-11-10 19:30:27.000000000 -0500
@@ -106,7 +106,7 @@ static int scx200_gpio_release(struct in
 }
 
 
-static struct file_operations scx200_gpio_fops = {
+static const struct file_operations scx200_gpio_fops = {
 	.owner   = THIS_MODULE,
 	.write   = scx200_gpio_write,
 	.read    = scx200_gpio_read,
diff -urNp linux-2.4.37.7/drivers/char/scx200_wdt.c linux-2.4.37.7/drivers/char/scx200_wdt.c
--- linux-2.4.37.7/drivers/char/scx200_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/scx200_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -200,7 +200,7 @@ static int scx200_wdt_ioctl(struct inode
 	}
 }
 
-static struct file_operations scx200_wdt_fops = {
+static const struct file_operations scx200_wdt_fops = {
 	.owner	 = THIS_MODULE,
 	.write   = scx200_wdt_write,
 	.ioctl   = scx200_wdt_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/shwdt.c linux-2.4.37.7/drivers/char/shwdt.c
--- linux-2.4.37.7/drivers/char/shwdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/shwdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -405,7 +405,7 @@ static int sh_wdt_notify_sys(struct noti
 	return NOTIFY_DONE;
 }
 
-static struct file_operations sh_wdt_fops = {
+static const struct file_operations sh_wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	write:		sh_wdt_write,
diff -urNp linux-2.4.37.7/drivers/char/softdog.c linux-2.4.37.7/drivers/char/softdog.c
--- linux-2.4.37.7/drivers/char/softdog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/softdog.c	2009-11-10 19:30:27.000000000 -0500
@@ -198,7 +198,7 @@ static int softdog_ioctl(struct inode *i
 	}
 }
 
-static struct file_operations softdog_fops = {
+static const struct file_operations softdog_fops = {
 	owner:		THIS_MODULE,
 	write:		softdog_write,
 	ioctl:		softdog_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/sonypi.c linux-2.4.37.7/drivers/char/sonypi.c
--- linux-2.4.37.7/drivers/char/sonypi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/sonypi.c	2009-11-10 19:30:27.000000000 -0500
@@ -613,7 +613,7 @@ static int sonypi_misc_ioctl(struct inod
 	return ret;
 }
 
-static struct file_operations sonypi_misc_fops = {
+static const struct file_operations sonypi_misc_fops = {
 	.owner		= THIS_MODULE,
 	.read		= sonypi_misc_read,
 	.poll		= sonypi_misc_poll,
diff -urNp linux-2.4.37.7/drivers/char/stallion.c linux-2.4.37.7/drivers/char/stallion.c
--- linux-2.4.37.7/drivers/char/stallion.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/stallion.c	2009-11-10 19:30:27.000000000 -0500
@@ -735,7 +735,7 @@ static unsigned int	sc26198_baudtable[] 
  *	Define the driver info for a user level control device. Used mainly
  *	to get at port stats - only not using the port device itself.
  */
-static struct file_operations	stl_fsiomem = {
+static const struct file_operations	stl_fsiomem = {
 	owner:		THIS_MODULE,
 	ioctl:		stl_memioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/sx.c linux-2.4.37.7/drivers/char/sx.c
--- linux-2.4.37.7/drivers/char/sx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/sx.c	2009-11-10 19:30:27.000000000 -0500
@@ -421,7 +421,7 @@ static struct real_driver sx_real_driver
  *
  */
 
-static struct file_operations sx_fw_fops = {
+static const struct file_operations sx_fw_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		sx_fw_ioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/tipar.c linux-2.4.37.7/drivers/char/tipar.c
--- linux-2.4.37.7/drivers/char/tipar.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/tipar.c	2009-11-10 19:30:27.000000000 -0500
@@ -384,7 +384,7 @@ tipar_ioctl(struct inode *inode, struct 
 
 /* ----- kernel module registering ------------------------------------ */
 
-static struct file_operations tipar_fops = {
+static const struct file_operations tipar_fops = {
 	owner:THIS_MODULE,
 	llseek:no_llseek,
 	read:tipar_read,
diff -urNp linux-2.4.37.7/drivers/char/toshiba.c linux-2.4.37.7/drivers/char/toshiba.c
--- linux-2.4.37.7/drivers/char/toshiba.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/toshiba.c	2009-11-10 19:30:27.000000000 -0500
@@ -90,7 +90,7 @@ static int tosh_ioctl(struct inode *, st
 	unsigned long);
 
 
-static struct file_operations tosh_fops = {
+static const struct file_operations tosh_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		tosh_ioctl,
 };
diff -urNp linux-2.4.37.7/drivers/char/tpqic02.c linux-2.4.37.7/drivers/char/tpqic02.c
--- linux-2.4.37.7/drivers/char/tpqic02.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/tpqic02.c	2009-11-10 19:30:27.000000000 -0500
@@ -2703,7 +2703,7 @@ static int qic02_tape_ioctl(struct inode
 
 
 /* These are (most) of the interface functions: */
-static struct file_operations qic02_tape_fops = {
+static const struct file_operations qic02_tape_fops = {
 	owner:THIS_MODULE,
 	llseek:no_llseek,
 	read:qic02_tape_read,
diff -urNp linux-2.4.37.7/drivers/char/tty_io.c linux-2.4.37.7/drivers/char/tty_io.c
--- linux-2.4.37.7/drivers/char/tty_io.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/tty_io.c	2009-11-10 19:30:27.000000000 -0500
@@ -671,7 +671,7 @@ static int hung_up_tty_ioctl(struct inod
 	return cmd == TIOCSPGRP ? -ENOTTY : -EIO;
 }
 
-static struct file_operations tty_fops = {
+static const struct file_operations tty_fops = {
 	llseek:		no_llseek,
 	read:		tty_read,
 	write:		tty_write,
@@ -682,7 +682,7 @@ static struct file_operations tty_fops =
 	fasync:		tty_fasync,
 };
 
-static struct file_operations hung_up_tty_fops = {
+static const struct file_operations hung_up_tty_fops = {
 	llseek:		no_llseek,
 	read:		hung_up_tty_read,
 	write:		hung_up_tty_write,
@@ -1775,7 +1775,11 @@ init_dev_done:
 		retval = -ENODEV;
 	filp->f_flags = saved_flags;
 
+#ifdef CONFIG_GRKERNSEC
+	if (!retval && test_bit(TTY_EXCLUSIVE, &tty->flags) && !capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (!retval && test_bit(TTY_EXCLUSIVE, &tty->flags) && !suser())
+#endif
 		retval = -EBUSY;
 
 	if (retval) {
@@ -1882,7 +1886,11 @@ static int tiocsti(struct tty_struct *tt
 	char ch, mbz = 0;
 	struct tty_ldisc *ld;
 
+#ifdef CONFIG_GRKERNSEC
+	if ((current->tty != tty) && !capable(CAP_SYS_TTY_CONFIG))
+#else
 	if ((current->tty != tty) && !suser())
+#endif
 		return -EPERM;
 	if (get_user(ch, arg))
 		return -EFAULT;
@@ -1922,7 +1930,11 @@ static int tioccons(struct inode *inode,
 	if (inode->i_rdev == SYSCONS_DEV ||
 	    inode->i_rdev == CONSOLE_DEV) {
 		struct file *f;
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+#else
 		if (!suser())
+#endif
 			return -EPERM;
 		spin_lock(&redirect_lock);
 		f = redirect;
@@ -1974,7 +1986,11 @@ static int tiocsctty(struct tty_struct *
 		 * This tty is already the controlling
 		 * tty for another session group!
 		 */
+#ifdef CONFIG_GRKERNSEC
+		if ((arg == 1) && capable(CAP_SYS_ADMIN)) {
+#else
 		if ((arg == 1) && suser()) {
+#endif
 			/*
 			 * Steal it away
 			 */
diff -urNp linux-2.4.37.7/drivers/char/vc_screen.c linux-2.4.37.7/drivers/char/vc_screen.c
--- linux-2.4.37.7/drivers/char/vc_screen.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/vc_screen.c	2009-11-10 19:30:27.000000000 -0500
@@ -471,7 +471,7 @@ vcs_open(struct inode *inode, struct fil
 	return 0;
 }
 
-static struct file_operations vcs_fops = {
+static const struct file_operations vcs_fops = {
 	llseek:		vcs_lseek,
 	read:		vcs_read,
 	write:		vcs_write,
diff -urNp linux-2.4.37.7/drivers/char/vt.c linux-2.4.37.7/drivers/char/vt.c
--- linux-2.4.37.7/drivers/char/vt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/vt.c	2009-11-10 19:30:27.000000000 -0500
@@ -182,6 +182,11 @@ do_kdsk_ioctl(int cmd, struct kbentry *u
 	case KDSKBENT:
 		if (!perm)
 			return -EPERM;
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+			return -EPERM;
+#endif
+
 		if (!i && v == K_NOSUCHMAP) {
 			/* disallocate map */
 			key_map = key_maps[s];
@@ -307,6 +312,11 @@ do_kdgkb_ioctl(int cmd, struct kbsentry 
 		if (!perm)
 			return -EPERM;
 
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+			return -EPERM;
+#endif
+
 		q = func_table[i];
 		first_free = funcbufptr + (funcbufsize - funcbufleft);
 		for (j = i+1; j < MAX_NR_FUNC && !func_table[j]; j++) 
@@ -449,7 +459,11 @@ int vt_ioctl(struct tty_struct *tty, str
 	 * to be the owner of the tty, or super-user.
 	 */
 	perm = 0;
+#ifdef CONFIG_GRKERNSEC
+	if (current->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+#else
 	if (current->tty == tty || suser())
+#endif
 		perm = 1;
  
 	kbd = kbd_table + console;
@@ -1043,12 +1057,20 @@ int vt_ioctl(struct tty_struct *tty, str
 		return do_unimap_ioctl(cmd, (struct unimapdesc *)arg, perm);
 
 	case VT_LOCKSWITCH:
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+#else
 		if (!suser())
+#endif
 		   return -EPERM;
 		vt_dont_switch = 1;
 		return 0;
 	case VT_UNLOCKSWITCH:
+#ifdef CONFIG_GRKERNSEC
+		if (!capable(CAP_SYS_TTY_CONFIG))
+#else
 		if (!suser())
+#endif
 		   return -EPERM;
 		vt_dont_switch = 0;
 		return 0;
diff -urNp linux-2.4.37.7/drivers/char/w83877f_wdt.c linux-2.4.37.7/drivers/char/w83877f_wdt.c
--- linux-2.4.37.7/drivers/char/w83877f_wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/w83877f_wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -268,7 +268,7 @@ static int fop_ioctl(struct inode *inode
 	}
 }
 
-static struct file_operations wdt_fops = {
+static const struct file_operations wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		fop_read,
diff -urNp linux-2.4.37.7/drivers/char/wafer5823wdt.c linux-2.4.37.7/drivers/char/wafer5823wdt.c
--- linux-2.4.37.7/drivers/char/wafer5823wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/wafer5823wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -199,7 +199,7 @@ static int wafwdt_notify_sys(struct noti
  *	Kernel Interfaces
  */
 
-static struct file_operations wafwdt_fops = {
+static const struct file_operations wafwdt_fops = {
 	owner:THIS_MODULE,
 	write:wafwdt_write,
 	ioctl:wafwdt_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/wdt285.c linux-2.4.37.7/drivers/char/wdt285.c
--- linux-2.4.37.7/drivers/char/wdt285.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/wdt285.c	2009-11-10 19:30:27.000000000 -0500
@@ -161,8 +161,7 @@ static int watchdog_ioctl(struct inode *
 	}
 }
 
-static struct file_operations watchdog_fops=
-{
+static const struct file_operations watchdog_fops = {
 	owner:		THIS_MODULE,
 	write:		watchdog_write,
 	ioctl:		watchdog_ioctl,
diff -urNp linux-2.4.37.7/drivers/char/wdt977.c linux-2.4.37.7/drivers/char/wdt977.c
--- linux-2.4.37.7/drivers/char/wdt977.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/wdt977.c	2009-11-10 19:30:27.000000000 -0500
@@ -194,8 +194,7 @@ static ssize_t wdt977_write(struct file 
 	return 1;
 }
 
-static struct file_operations wdt977_fops=
-{
+static const struct file_operations wdt977_fops = {
 	owner:		THIS_MODULE,
 	write:		wdt977_write,
 	open:		wdt977_open,
diff -urNp linux-2.4.37.7/drivers/char/wdt.c linux-2.4.37.7/drivers/char/wdt.c
--- linux-2.4.37.7/drivers/char/wdt.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/wdt.c	2009-11-10 19:30:27.000000000 -0500
@@ -459,7 +459,7 @@ static int wdt_notify_sys(struct notifie
  */
  
  
-static struct file_operations wdt_fops = {
+static const struct file_operations wdt_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		wdt_read,
diff -urNp linux-2.4.37.7/drivers/char/wdt_pci.c linux-2.4.37.7/drivers/char/wdt_pci.c
--- linux-2.4.37.7/drivers/char/wdt_pci.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/char/wdt_pci.c	2009-11-10 19:30:27.000000000 -0500
@@ -475,7 +475,7 @@ static int wdtpci_notify_sys(struct noti
  */
  
  
-static struct file_operations wdtpci_fops = {
+static const struct file_operations wdtpci_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		wdtpci_read,
diff -urNp linux-2.4.37.7/drivers/gsc/eisa_eeprom.c linux-2.4.37.7/drivers/gsc/eisa_eeprom.c
--- linux-2.4.37.7/drivers/gsc/eisa_eeprom.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/gsc/eisa_eeprom.c	2009-11-10 19:30:27.000000000 -0500
@@ -84,7 +84,7 @@ static int eisa_eeprom_release(struct in
 /*
  *	The various file operations we support.
  */
-static struct file_operations eisa_eeprom_fops = {
+static const struct file_operations eisa_eeprom_fops = {
 	owner:		THIS_MODULE,
 	llseek:		eisa_eeprom_llseek,
 	read:		eisa_eeprom_read,
diff -urNp linux-2.4.37.7/drivers/hil/hp_sdc_rtc.c linux-2.4.37.7/drivers/hil/hp_sdc_rtc.c
--- linux-2.4.37.7/drivers/hil/hp_sdc_rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/hil/hp_sdc_rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -675,7 +675,7 @@ static int hp_sdc_rtc_ioctl(struct inode
 #endif
 }
 
-static struct file_operations hp_sdc_rtc_fops = {
+static const struct file_operations hp_sdc_rtc_fops = {
         .owner =	THIS_MODULE,
         .llseek =	hp_sdc_rtc_llseek,
         .read =		hp_sdc_rtc_read,
diff -urNp linux-2.4.37.7/drivers/hotplug/cpqphp_nvram.c linux-2.4.37.7/drivers/hotplug/cpqphp_nvram.c
--- linux-2.4.37.7/drivers/hotplug/cpqphp_nvram.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/hotplug/cpqphp_nvram.c	2009-11-10 19:30:27.000000000 -0500
@@ -425,9 +425,13 @@ static u32 store_HRT (void *rom_start)
 
 void compaq_nvram_init (void *rom_start)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	if (rom_start) {
 		compaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);
 	}
+#endif
+
 	dbg("int15 entry  = %p\n", compaq_int15_entry_point);
 
 	/* initialize our int15 lock */
diff -urNp linux-2.4.37.7/drivers/hotplug/pci_hotplug_core.c linux-2.4.37.7/drivers/hotplug/pci_hotplug_core.c
--- linux-2.4.37.7/drivers/hotplug/pci_hotplug_core.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/hotplug/pci_hotplug_core.c	2009-11-10 19:30:27.000000000 -0500
@@ -80,9 +80,9 @@ struct hotplug_slot_core {
 	struct dentry	*cur_bus_speed_dentry;
 };
 
-static struct super_operations pcihpfs_ops;
-static struct file_operations default_file_operations;
-static struct inode_operations pcihpfs_dir_inode_operations;
+static const struct super_operations pcihpfs_ops;
+static const struct file_operations default_file_operations;
+static const struct inode_operations pcihpfs_dir_inode_operations;
 static struct vfsmount *pcihpfs_mount;	/* one of the mounts of our fs for reference counting */
 static int pcihpfs_mount_count;		/* times we have mounted our fs */
 static spinlock_t mount_lock;		/* protects our mount_count */
@@ -269,7 +269,7 @@ static int default_open (struct inode *i
 	return 0;
 }
 
-static struct file_operations default_file_operations = {
+static const struct file_operations default_file_operations = {
 	read:		default_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -279,7 +279,7 @@ static struct file_operations default_fi
 /* file ops for the "power" files */
 static ssize_t power_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
 static ssize_t power_write_file (struct file *file, const char *buf, size_t count, loff_t *ppos);
-static struct file_operations power_file_operations = {
+static const struct file_operations power_file_operations = {
 	read:		power_read_file,
 	write:		power_write_file,
 	open:		default_open,
@@ -289,7 +289,7 @@ static struct file_operations power_file
 /* file ops for the "attention" files */
 static ssize_t attention_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
 static ssize_t attention_write_file (struct file *file, const char *buf, size_t count, loff_t *ppos);
-static struct file_operations attention_file_operations = {
+static const struct file_operations attention_file_operations = {
 	read:		attention_read_file,
 	write:		attention_write_file,
 	open:		default_open,
@@ -298,7 +298,7 @@ static struct file_operations attention_
 
 /* file ops for the "latch" files */
 static ssize_t latch_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
-static struct file_operations latch_file_operations = {
+static const struct file_operations latch_file_operations = {
 	read:		latch_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -307,7 +307,7 @@ static struct file_operations latch_file
 
 /* file ops for the "presence" files */
 static ssize_t presence_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
-static struct file_operations presence_file_operations = {
+static const struct file_operations presence_file_operations = {
 	read:		presence_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -316,7 +316,7 @@ static struct file_operations presence_f
 
 /* file ops for the "address" files */
 static ssize_t address_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
-static struct file_operations address_file_operations = {
+static const struct file_operations address_file_operations = {
 	read:		address_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -325,7 +325,7 @@ static struct file_operations address_fi
 
 /* file ops for the "max bus speed" files */
 static ssize_t max_bus_speed_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
-static struct file_operations max_bus_speed_file_operations = {
+static const struct file_operations max_bus_speed_file_operations = {
 	read:		max_bus_speed_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -334,7 +334,7 @@ static struct file_operations max_bus_sp
 
 /* file ops for the "current bus speed" files */
 static ssize_t cur_bus_speed_read_file (struct file *file, char *buf, size_t count, loff_t *offset);
-static struct file_operations cur_bus_speed_file_operations = {
+static const struct file_operations cur_bus_speed_file_operations = {
 	read:		cur_bus_speed_read_file,
 	write:		default_write_file,
 	open:		default_open,
@@ -343,14 +343,14 @@ static struct file_operations cur_bus_sp
 
 /* file ops for the "test" files */
 static ssize_t test_write_file (struct file *file, const char *buf, size_t count, loff_t *ppos);
-static struct file_operations test_file_operations = {
+static const struct file_operations test_file_operations = {
 	read:		default_read_file,
 	write:		test_write_file,
 	open:		default_open,
 	llseek:		default_file_lseek,
 };
 
-static struct inode_operations pcihpfs_dir_inode_operations = {
+static const struct inode_operations pcihpfs_dir_inode_operations = {
 	create:		pcihpfs_create,
 	lookup:		pcihpfs_lookup,
 	unlink:		pcihpfs_unlink,
@@ -359,7 +359,7 @@ static struct inode_operations pcihpfs_d
 	mknod:		pcihpfs_mknod,
 };
 
-static struct super_operations pcihpfs_ops = {
+static const struct super_operations pcihpfs_ops = {
 	statfs:		pcihpfs_statfs,
 	put_inode:	force_delete,
 };
@@ -514,7 +514,7 @@ static int pcihpfs_create_by_name (const
 
 static struct dentry *fs_create_file (const char *name, mode_t mode,
 				      struct dentry *parent, void *data,
-				      struct file_operations *fops)
+				      const struct file_operations *fops)
 {
 	struct dentry *dentry;
 	int error;
diff -urNp linux-2.4.37.7/drivers/i2c/i2c-core.c linux-2.4.37.7/drivers/i2c/i2c-core.c
--- linux-2.4.37.7/drivers/i2c/i2c-core.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/i2c/i2c-core.c	2009-11-10 19:30:27.000000000 -0500
@@ -86,7 +86,7 @@ static int read_bus_i2c(char *buf, char 
 
 /* To implement the dynamic /proc/bus/i2c-? files, we need our own 
    implementation of the read hook */
-static struct file_operations i2cproc_operations = {
+static const struct file_operations i2cproc_operations = {
 	.read		= i2cproc_bus_read,
 };
 
diff -urNp linux-2.4.37.7/drivers/i2c/i2c-dev.c linux-2.4.37.7/drivers/i2c/i2c-dev.c
--- linux-2.4.37.7/drivers/i2c/i2c-dev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/i2c/i2c-dev.c	2009-11-10 19:30:27.000000000 -0500
@@ -79,7 +79,7 @@ extern
        int __init i2c_dev_init(void);
 static int i2cdev_cleanup(void);
 
-static struct file_operations i2cdev_fops = {
+static const struct file_operations i2cdev_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= i2cdev_read,
diff -urNp linux-2.4.37.7/drivers/ide/ide-tape.c linux-2.4.37.7/drivers/ide/ide-tape.c
--- linux-2.4.37.7/drivers/ide/ide-tape.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ide/ide-tape.c	2009-11-10 19:30:27.000000000 -0500
@@ -6500,7 +6500,7 @@ static ide_module_t idetape_module = {
 /*
  *	Our character device supporting functions, passed to register_chrdev.
  */
-static struct file_operations idetape_fops = {
+static const struct file_operations idetape_fops = {
 	owner:		THIS_MODULE,
 	read:		idetape_chrdev_read,
 	write:		idetape_chrdev_write,
diff -urNp linux-2.4.37.7/drivers/ieee1394/amdtp.c linux-2.4.37.7/drivers/ieee1394/amdtp.c
--- linux-2.4.37.7/drivers/ieee1394/amdtp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/amdtp.c	2009-11-10 19:30:27.000000000 -0500
@@ -1196,8 +1196,7 @@ static int amdtp_release(struct inode *i
 	return 0;
 }
 
-static struct file_operations amdtp_fops =
-{
+static const struct file_operations amdtp_fops = {
 	.owner =	THIS_MODULE,
 	.write =	amdtp_write,
 	.poll =		amdtp_poll,
diff -urNp linux-2.4.37.7/drivers/ieee1394/dma.c linux-2.4.37.7/drivers/ieee1394/dma.c
--- linux-2.4.37.7/drivers/ieee1394/dma.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/dma.c	2009-11-10 19:30:27.000000000 -0500
@@ -210,7 +210,7 @@ out:
 	return ret;
 }
 
-static struct vm_operations_struct dma_region_vm_ops = {
+static const struct vm_operations_struct dma_region_vm_ops = {
 	.nopage	= dma_region_pagefault,
 };
 
diff -urNp linux-2.4.37.7/drivers/ieee1394/dv1394.c linux-2.4.37.7/drivers/ieee1394/dv1394.c
--- linux-2.4.37.7/drivers/ieee1394/dv1394.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/dv1394.c	2009-11-10 19:30:27.000000000 -0500
@@ -2414,8 +2414,7 @@ out:
 	spin_unlock(&video->spinlock);
 }
 
-static struct file_operations dv1394_fops=
-{
+static const struct file_operations dv1394_fops = {
 	.owner =	THIS_MODULE,
 	.poll =         dv1394_poll,
 	.ioctl =	dv1394_ioctl,
diff -urNp linux-2.4.37.7/drivers/ieee1394/ieee1394_core.c linux-2.4.37.7/drivers/ieee1394/ieee1394_core.c
--- linux-2.4.37.7/drivers/ieee1394/ieee1394_core.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/ieee1394_core.c	2009-11-10 19:30:27.000000000 -0500
@@ -1008,7 +1008,7 @@ static rwlock_t ieee1394_chardevs_lock =
 
 static int ieee1394_dispatch_open(struct inode *inode, struct file *file);
 
-static struct file_operations ieee1394_chardev_ops = {
+static const struct file_operations ieee1394_chardev_ops = {
 	.owner =THIS_MODULE,
 	.open =	ieee1394_dispatch_open,
 };
diff -urNp linux-2.4.37.7/drivers/ieee1394/ohci1394.c linux-2.4.37.7/drivers/ieee1394/ohci1394.c
--- linux-2.4.37.7/drivers/ieee1394/ohci1394.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/ohci1394.c	2009-11-10 19:30:27.000000000 -0500
@@ -169,8 +169,8 @@ static char version[] __devinitdata =
 
 /* Module Parameters */
 MODULE_PARM(phys_dma,"i");
-MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 1).");
-static int phys_dma = 1;
+MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 0).");
+static int phys_dma = 0;
 
 static void dma_trm_tasklet(unsigned long data);
 static void dma_trm_reset(struct dma_trm_ctx *d);
diff -urNp linux-2.4.37.7/drivers/ieee1394/pcilynx.c linux-2.4.37.7/drivers/ieee1394/pcilynx.c
--- linux-2.4.37.7/drivers/ieee1394/pcilynx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/pcilynx.c	2009-11-10 19:30:27.000000000 -0500
@@ -861,7 +861,7 @@ static ssize_t mem_read (struct file*, c
 static ssize_t mem_write(struct file*, const char*, size_t, loff_t*);
 
 
-static struct file_operations aux_ops = {
+static const struct file_operations aux_ops = {
 	.owner =	THIS_MODULE,
         .read =         mem_read,
         .write =        mem_write,
diff -urNp linux-2.4.37.7/drivers/ieee1394/raw1394.c linux-2.4.37.7/drivers/ieee1394/raw1394.c
--- linux-2.4.37.7/drivers/ieee1394/raw1394.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/raw1394.c	2009-11-10 19:30:27.000000000 -0500
@@ -2538,7 +2538,7 @@ static struct hpsb_highlevel raw1394_hig
         .fcp_request = fcp_request,
 };
 
-static struct file_operations file_ops = {
+static const struct file_operations file_ops = {
 	.owner =	THIS_MODULE,
         .read =		raw1394_read, 
         .write =	raw1394_write,
diff -urNp linux-2.4.37.7/drivers/ieee1394/video1394.c linux-2.4.37.7/drivers/ieee1394/video1394.c
--- linux-2.4.37.7/drivers/ieee1394/video1394.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/ieee1394/video1394.c	2009-11-10 19:30:27.000000000 -0500
@@ -1254,8 +1254,7 @@ static int video1394_release(struct inod
 	return 0;
 }
 
-static struct file_operations video1394_fops=
-{
+static const struct file_operations video1394_fops = {
 	.owner =	THIS_MODULE,
 	.ioctl =	video1394_ioctl,
 	.mmap =		video1394_mmap,
diff -urNp linux-2.4.37.7/drivers/input/evdev.c linux-2.4.37.7/drivers/input/evdev.c
--- linux-2.4.37.7/drivers/input/evdev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/input/evdev.c	2009-11-10 19:30:27.000000000 -0500
@@ -317,7 +317,7 @@ static int evdev_ioctl(struct inode *ino
 	return -EINVAL;
 }
 
-static struct file_operations evdev_fops = {
+static const struct file_operations evdev_fops = {
 	owner:		THIS_MODULE,
 	read:		evdev_read,
 	write:		evdev_write,
diff -urNp linux-2.4.37.7/drivers/input/input.c linux-2.4.37.7/drivers/input/input.c
--- linux-2.4.37.7/drivers/input/input.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/input/input.c	2009-11-10 19:30:27.000000000 -0500
@@ -371,7 +371,7 @@ void input_unregister_handler(struct inp
 static int input_open_file(struct inode *inode, struct file *file)
 {
 	struct input_handler *handler = input_table[MINOR(inode->i_rdev) >> 5];
-	struct file_operations *old_fops, *new_fops = NULL;
+	const struct file_operations *old_fops, *new_fops = NULL;
 	int err;
 
 	/* No load-on-demand here? */
@@ -401,7 +401,7 @@ static int input_open_file(struct inode 
 	return err;
 }
 
-static struct file_operations input_fops = {
+static const struct file_operations input_fops = {
 	owner: THIS_MODULE,
 	open: input_open_file,
 };
diff -urNp linux-2.4.37.7/drivers/input/joydev.c linux-2.4.37.7/drivers/input/joydev.c
--- linux-2.4.37.7/drivers/input/joydev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/input/joydev.c	2009-11-10 19:30:27.000000000 -0500
@@ -409,7 +409,7 @@ static int joydev_ioctl(struct inode *in
 	return -EINVAL;
 }
 
-static struct file_operations joydev_fops = {
+static const struct file_operations joydev_fops = {
 	owner:		THIS_MODULE,
 	read:		joydev_read,
 	write:		joydev_write,
diff -urNp linux-2.4.37.7/drivers/input/mousedev.c linux-2.4.37.7/drivers/input/mousedev.c
--- linux-2.4.37.7/drivers/input/mousedev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/input/mousedev.c	2009-11-10 19:30:27.000000000 -0500
@@ -393,7 +393,7 @@ static unsigned int mousedev_poll(struct
 	return 0;
 }
 
-struct file_operations mousedev_fops = {
+const struct file_operations mousedev_fops = {
 	owner:		THIS_MODULE,
 	read:		mousedev_read,
 	write:		mousedev_write,
diff -urNp linux-2.4.37.7/drivers/input/uinput.c linux-2.4.37.7/drivers/input/uinput.c
--- linux-2.4.37.7/drivers/input/uinput.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/input/uinput.c	2009-11-10 19:30:27.000000000 -0500
@@ -393,7 +393,7 @@ static int uinput_ioctl(struct inode *in
 	return retval;
 }
 
-struct file_operations uinput_fops = {
+const struct file_operations uinput_fops = {
 	owner:		THIS_MODULE,
 	open:		uinput_open,
 	release:	uinput_close,
diff -urNp linux-2.4.37.7/drivers/isdn/avmb1/capi.c linux-2.4.37.7/drivers/isdn/avmb1/capi.c
--- linux-2.4.37.7/drivers/isdn/avmb1/capi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/avmb1/capi.c	2009-11-10 19:30:27.000000000 -0500
@@ -1068,8 +1068,7 @@ capi_release(struct inode *inode, struct
 	return 0;
 }
 
-static struct file_operations capi_fops =
-{
+static const struct file_operations capi_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		capi_read,
@@ -1258,8 +1257,7 @@ capinc_raw_release(struct inode *inode, 
 	return 0;
 }
 
-static struct file_operations capinc_raw_fops =
-{
+static const struct file_operations capinc_raw_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		capinc_raw_read,
diff -urNp linux-2.4.37.7/drivers/isdn/avmb1/capifs.c linux-2.4.37.7/drivers/isdn/avmb1/capifs.c
--- linux-2.4.37.7/drivers/isdn/avmb1/capifs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/avmb1/capifs.c	2009-11-10 19:30:27.000000000 -0500
@@ -71,16 +71,16 @@ static struct dentry *capifs_root_lookup
 static int capifs_revalidate(struct dentry *, int);
 static struct inode *capifs_new_inode(struct super_block *sb);
 
-static struct file_operations capifs_root_operations = {
+static const struct file_operations capifs_root_operations = {
 	read:		generic_read_dir,
 	readdir:	capifs_root_readdir,
 };
 
-struct inode_operations capifs_root_inode_operations = {
+const struct inode_operations capifs_root_inode_operations = {
 	lookup: capifs_root_lookup,
 };
 
-static struct dentry_operations capifs_dentry_operations = {
+static const struct dentry_operations capifs_dentry_operations = {
 	d_revalidate: capifs_revalidate,
 };
 
@@ -217,7 +217,7 @@ static void capifs_put_super(struct supe
 
 static int capifs_statfs(struct super_block *sb, struct statfs *buf);
 
-static struct super_operations capifs_sops = {
+static const struct super_operations capifs_sops = {
 	put_super:	capifs_put_super,
 	statfs:		capifs_statfs,
 };
diff -urNp linux-2.4.37.7/drivers/isdn/divert/divert_procfs.c linux-2.4.37.7/drivers/isdn/divert/divert_procfs.c
--- linux-2.4.37.7/drivers/isdn/divert/divert_procfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/divert/divert_procfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -266,8 +266,7 @@ isdn_divert_ioctl(struct inode *inode, s
 
 
 #ifdef CONFIG_PROC_FS
-static struct file_operations isdn_fops =
-{
+static const struct file_operations isdn_fops = {
 	llseek:         no_llseek,
 	read:           isdn_divert_read,
 	write:          isdn_divert_write,
diff -urNp linux-2.4.37.7/drivers/isdn/hysdn/hysdn_procconf.c linux-2.4.37.7/drivers/isdn/hysdn/hysdn_procconf.c
--- linux-2.4.37.7/drivers/isdn/hysdn/hysdn_procconf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/hysdn/hysdn_procconf.c	2009-11-10 19:30:27.000000000 -0500
@@ -378,8 +378,7 @@ hysdn_conf_close(struct inode *ino, stru
 /******************************************************/
 /* table for conf filesystem functions defined above. */
 /******************************************************/
-static struct file_operations conf_fops =
-{
+static const struct file_operations conf_fops = {
 	llseek:         no_llseek,
 	read:           hysdn_conf_read,
 	write:          hysdn_conf_write,
diff -urNp linux-2.4.37.7/drivers/isdn/hysdn/hysdn_proclog.c linux-2.4.37.7/drivers/isdn/hysdn/hysdn_proclog.c
--- linux-2.4.37.7/drivers/isdn/hysdn/hysdn_proclog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/hysdn/hysdn_proclog.c	2009-11-10 19:30:27.000000000 -0500
@@ -390,8 +390,7 @@ hysdn_log_poll(struct file *file, poll_t
 /**************************************************/
 /* table for log filesystem functions defined above. */
 /**************************************************/
-static struct file_operations log_fops =
-{
+static const struct file_operations log_fops = {
 	llseek:         no_llseek,
 	read:           hysdn_log_read,
 	write:          hysdn_log_write,
diff -urNp linux-2.4.37.7/drivers/isdn/isdn_common.c linux-2.4.37.7/drivers/isdn/isdn_common.c
--- linux-2.4.37.7/drivers/isdn/isdn_common.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/isdn/isdn_common.c	2009-11-10 19:30:27.000000000 -0500
@@ -1753,8 +1753,7 @@ isdn_close(struct inode *ino, struct fil
 	return 0;
 }
 
-static struct file_operations isdn_fops =
-{
+static const struct file_operations isdn_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		isdn_read,
diff -urNp linux-2.4.37.7/drivers/macintosh/adb.c linux-2.4.37.7/drivers/macintosh/adb.c
--- linux-2.4.37.7/drivers/macintosh/adb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/adb.c	2009-11-10 19:30:27.000000000 -0500
@@ -835,7 +835,7 @@ out:
 	return ret;
 }
 
-static struct file_operations adb_fops = {
+static const struct file_operations adb_fops = {
 	llseek:		no_llseek,
 	read:		adb_read,
 	write:		adb_write,
diff -urNp linux-2.4.37.7/drivers/macintosh/ans-lcd.c linux-2.4.37.7/drivers/macintosh/ans-lcd.c
--- linux-2.4.37.7/drivers/macintosh/ans-lcd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/ans-lcd.c	2009-11-10 19:30:27.000000000 -0500
@@ -118,7 +118,7 @@ anslcd_open( struct inode * inode, struc
 	return 0;
 }
 
-struct file_operations anslcd_fops = {
+const struct file_operations anslcd_fops = {
 	write:	anslcd_write,
 	ioctl:	anslcd_ioctl,
 	open:	anslcd_open,
diff -urNp linux-2.4.37.7/drivers/macintosh/apm_emu.c linux-2.4.37.7/drivers/macintosh/apm_emu.c
--- linux-2.4.37.7/drivers/macintosh/apm_emu.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/apm_emu.c	2009-11-10 19:30:27.000000000 -0500
@@ -498,7 +498,7 @@ static int apm_emu_get_info(char *buf, c
 	return p - buf;
 }
 
-static struct file_operations apm_bios_fops = {
+static const struct file_operations apm_bios_fops = {
 	owner:		THIS_MODULE,
 	read:		do_read,
 	poll:		do_poll,
diff -urNp linux-2.4.37.7/drivers/macintosh/nvram.c linux-2.4.37.7/drivers/macintosh/nvram.c
--- linux-2.4.37.7/drivers/macintosh/nvram.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/nvram.c	2009-11-10 19:30:27.000000000 -0500
@@ -97,7 +97,7 @@ static int nvram_ioctl(struct inode *ino
 	return 0;
 }
 
-struct file_operations nvram_fops = {
+const struct file_operations nvram_fops = {
 	owner:		THIS_MODULE,
 	llseek:		nvram_llseek,
 	read:		read_nvram,
diff -urNp linux-2.4.37.7/drivers/macintosh/rtc.c linux-2.4.37.7/drivers/macintosh/rtc.c
--- linux-2.4.37.7/drivers/macintosh/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -115,7 +115,7 @@ static int rtc_release(struct inode *ino
 	return 0;
 }
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		rtc_ioctl,
diff -urNp linux-2.4.37.7/drivers/macintosh/via-pmu68k.c linux-2.4.37.7/drivers/macintosh/via-pmu68k.c
--- linux-2.4.37.7/drivers/macintosh/via-pmu68k.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/via-pmu68k.c	2009-11-10 19:30:27.000000000 -0500
@@ -1039,7 +1039,7 @@ static int /*__openfirmware*/ pmu_ioctl(
 	return -EINVAL;
 }
 
-static struct file_operations pmu_device_fops = {
+static const struct file_operations pmu_device_fops = {
 	read:		pmu_read,
 	write:		pmu_write,
 	ioctl:		pmu_ioctl,
diff -urNp linux-2.4.37.7/drivers/macintosh/via-pmu.c linux-2.4.37.7/drivers/macintosh/via-pmu.c
--- linux-2.4.37.7/drivers/macintosh/via-pmu.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/macintosh/via-pmu.c	2009-11-10 19:30:27.000000000 -0500
@@ -2825,7 +2825,7 @@ static int pmu_ioctl(struct inode * inod
 	return -EINVAL;
 }
 
-static struct file_operations pmu_device_fops = {
+static const struct file_operations pmu_device_fops = {
 	read:		pmu_read,
 	write:		pmu_write,
 	poll:		pmu_fpoll,
diff -urNp linux-2.4.37.7/drivers/md/lvm.c linux-2.4.37.7/drivers/md/lvm.c
--- linux-2.4.37.7/drivers/md/lvm.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/md/lvm.c	2009-11-10 19:30:27.000000000 -0500
@@ -405,7 +405,7 @@ static struct buffer_head *_pe_requests;
 static DECLARE_RWSEM(_pe_lock);
 
 
-struct file_operations lvm_chr_fops = {
+const struct file_operations lvm_chr_fops = {
 	owner:THIS_MODULE,
 	open:lvm_chr_open,
 	release:lvm_chr_close,
diff -urNp linux-2.4.37.7/drivers/md/lvm-internal.h linux-2.4.37.7/drivers/md/lvm-internal.h
--- linux-2.4.37.7/drivers/md/lvm-internal.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/md/lvm-internal.h	2009-11-10 19:30:27.000000000 -0500
@@ -45,7 +45,6 @@ extern int loadtime;
 extern const char *const lvm_name;
 
 
-extern uint vg_count;
 extern vg_t *vg[];
 extern struct file_operations lvm_chr_fops;
 
diff -urNp linux-2.4.37.7/drivers/md/md.c linux-2.4.37.7/drivers/md/md.c
--- linux-2.4.37.7/drivers/md/md.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/md/md.c	2009-11-10 19:30:27.000000000 -0500
@@ -3295,7 +3295,7 @@ static int md_seq_show(struct seq_file *
 }
 
   
-static struct seq_operations md_seq_ops = {
+static const struct seq_operations md_seq_ops = {
 	.start  = md_seq_start,
 	.next   = md_seq_next,
 	.stop   = md_seq_stop,
@@ -3310,7 +3310,7 @@ static int md_seq_open(struct inode *ino
 	return error;
 }
 
-static struct file_operations md_seq_fops = {
+static const struct file_operations md_seq_fops = {
 	.open           = md_seq_open,
 	.read           = seq_read,
 	.llseek         = seq_lseek,
diff -urNp linux-2.4.37.7/drivers/media/radio/miropcm20-rds.c linux-2.4.37.7/drivers/media/radio/miropcm20-rds.c
--- linux-2.4.37.7/drivers/media/radio/miropcm20-rds.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/radio/miropcm20-rds.c	2009-11-10 19:30:27.000000000 -0500
@@ -105,7 +105,7 @@ static ssize_t rds_f_read(struct file *f
 	}
 }
 
-static struct file_operations rds_f_ops = {
+static const struct file_operations rds_f_ops = {
 	read:    rds_f_read,
 	open:    rds_f_open,
 	release: rds_f_release
diff -urNp linux-2.4.37.7/drivers/media/video/cpia.c linux-2.4.37.7/drivers/media/video/cpia.c
--- linux-2.4.37.7/drivers/media/video/cpia.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/video/cpia.c	2009-11-10 19:30:27.000000000 -0500
@@ -3064,7 +3064,7 @@ static int cpia_mmap(struct file *file, 
 	return 0;
 }
 
-static struct file_operations cpia_fops = {
+static const struct file_operations cpia_fops = {
 	owner:		THIS_MODULE,
 	open:		cpia_open,
 	release:	cpia_close,
diff -urNp linux-2.4.37.7/drivers/media/video/meye.c linux-2.4.37.7/drivers/media/video/meye.c
--- linux-2.4.37.7/drivers/media/video/meye.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/video/meye.c	2009-11-10 19:30:27.000000000 -0500
@@ -1252,7 +1252,7 @@ static int meye_mmap(struct file *file, 
 	return 0;
 }
 
-static struct file_operations meye_fops = {
+static const struct file_operations meye_fops = {
 	.owner		= THIS_MODULE,
 	.open		= meye_open,
 	.release	= meye_release,
diff -urNp linux-2.4.37.7/drivers/media/video/tvmixer.c linux-2.4.37.7/drivers/media/video/tvmixer.c
--- linux-2.4.37.7/drivers/media/video/tvmixer.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/video/tvmixer.c	2009-11-10 19:30:27.000000000 -0500
@@ -226,7 +226,7 @@ static struct i2c_driver driver = {
         .detach_client   = tvmixer_clients,
 };
 
-static struct file_operations tvmixer_fops = {
+static const struct file_operations tvmixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek         = no_llseek,
 	.ioctl          = tvmixer_ioctl,
diff -urNp linux-2.4.37.7/drivers/media/video/videodev.c linux-2.4.37.7/drivers/media/video/videodev.c
--- linux-2.4.37.7/drivers/media/video/videodev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/video/videodev.c	2009-11-10 19:30:27.000000000 -0500
@@ -155,7 +155,7 @@ static int video_open(struct inode *inod
 		}
 	}
 	if (vfl->fops) {
-		struct file_operations *old_fops;
+		const struct file_operations *old_fops;
 
 		old_fops = file->f_op;
                 file->f_op = fops_get(vfl->fops);
@@ -489,8 +489,7 @@ static void videodev_proc_destroy_dev (s
 
 #endif /* CONFIG_VIDEO_PROC_FS */
 
-static struct file_operations video_fops=
-{
+static const struct file_operations video_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		video_read,
diff -urNp linux-2.4.37.7/drivers/media/video/vino.c linux-2.4.37.7/drivers/media/video/vino.c
--- linux-2.4.37.7/drivers/media/video/vino.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/media/video/vino.c	2009-11-10 19:30:27.000000000 -0500
@@ -1007,7 +1007,7 @@ static int vino_ioctl(struct inode *inod
 	return err;
 }
 
-static struct file_operations vino_fops = {
+static const struct file_operations vino_fops = {
 	.owner		= THIS_MODULE,
 	.open		= vino_open,
 	.release	= vino_close,
diff -urNp linux-2.4.37.7/drivers/message/fusion/mptctl.c linux-2.4.37.7/drivers/message/fusion/mptctl.c
--- linux-2.4.37.7/drivers/message/fusion/mptctl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/message/fusion/mptctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -2738,7 +2738,7 @@ mptctl_hp_targetinfo(unsigned long arg)
 #define	owner_THIS_MODULE
 #endif
 
-static struct file_operations mptctl_fops = {
+static const struct file_operations mptctl_fops = {
 	owner_THIS_MODULE
 	.llseek =	no_llseek,
 	.read =		mptctl_read,
diff -urNp linux-2.4.37.7/drivers/message/i2o/i2o_config.c linux-2.4.37.7/drivers/message/i2o/i2o_config.c
--- linux-2.4.37.7/drivers/message/i2o/i2o_config.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/message/i2o/i2o_config.c	2009-11-10 19:30:27.000000000 -0500
@@ -890,8 +890,7 @@ static int cfg_fasync(int fd, struct fil
 	return fasync_helper(fd, fp, on, &p->fasync);
 }
 
-static struct file_operations config_fops =
-{
+static const struct file_operations config_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		cfg_read,
diff -urNp linux-2.4.37.7/drivers/mtd/devices/doc2001.c linux-2.4.37.7/drivers/mtd/devices/doc2001.c
--- linux-2.4.37.7/drivers/mtd/devices/doc2001.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/devices/doc2001.c	2009-11-10 19:30:27.000000000 -0500
@@ -418,6 +418,8 @@ static int doc_read_ecc (struct mtd_info
 	/* Don't allow read past end of device */
 	if (from >= this->totlen)
 		return -EINVAL;
+	if (!len)
+		return -EINVAL;
 
 	/* Don't allow a single read to cross a 512-byte block boundary */
 	if (from + len > ((from | 0x1ff) + 1)) 
diff -urNp linux-2.4.37.7/drivers/mtd/ftl.c linux-2.4.37.7/drivers/mtd/ftl.c
--- linux-2.4.37.7/drivers/mtd/ftl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/ftl.c	2009-11-10 19:30:27.000000000 -0500
@@ -231,7 +231,7 @@ static int ftl_reread_partitions(int min
 static void ftl_erase_callback(struct erase_info *done);
 
 #if LINUX_VERSION_CODE < 0x20326
-static struct file_operations ftl_blk_fops = {
+static const struct file_operations ftl_blk_fops = {
     open:	ftl_open,
     release:	ftl_close,
     ioctl:	ftl_ioctl,
diff -urNp linux-2.4.37.7/drivers/mtd/mtdblock.c linux-2.4.37.7/drivers/mtd/mtdblock.c
--- linux-2.4.37.7/drivers/mtd/mtdblock.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/mtdblock.c	2009-11-10 19:30:27.000000000 -0500
@@ -567,8 +567,7 @@ static int mtdblock_ioctl(struct inode *
 }
 
 #if LINUX_VERSION_CODE < 0x20326
-static struct file_operations mtd_fops =
-{
+static const struct file_operations mtd_fops = {
 	open: mtdblock_open,
 	ioctl: mtdblock_ioctl,
 	release: mtdblock_release,
diff -urNp linux-2.4.37.7/drivers/mtd/mtdblock_ro.c linux-2.4.37.7/drivers/mtd/mtdblock_ro.c
--- linux-2.4.37.7/drivers/mtd/mtdblock_ro.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/mtdblock_ro.c	2009-11-10 19:30:27.000000000 -0500
@@ -242,8 +242,7 @@ static int mtdblock_ioctl(struct inode *
 }
 
 #if LINUX_VERSION_CODE < 0x20326
-static struct file_operations mtd_fops =
-{
+static const struct file_operations mtd_fops = {
 	open: mtdblock_open,
 	ioctl: mtdblock_ioctl,
 	release: mtdblock_release,
diff -urNp linux-2.4.37.7/drivers/mtd/mtdchar.c linux-2.4.37.7/drivers/mtd/mtdchar.c
--- linux-2.4.37.7/drivers/mtd/mtdchar.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/mtdchar.c	2009-11-10 19:30:27.000000000 -0500
@@ -533,7 +533,7 @@ static int mtd_ioctl(struct inode *inode
 	return ret;
 } /* memory_ioctl */
 
-static struct file_operations mtd_fops = {
+static const struct file_operations mtd_fops = {
 	owner:		THIS_MODULE,
 	llseek:		mtd_lseek,     	/* lseek */
 	read:		mtd_read,	/* read */
diff -urNp linux-2.4.37.7/drivers/mtd/nftlcore.c linux-2.4.37.7/drivers/mtd/nftlcore.c
--- linux-2.4.37.7/drivers/mtd/nftlcore.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/mtd/nftlcore.c	2009-11-10 19:30:27.000000000 -0500
@@ -1020,7 +1020,7 @@ static int nftl_release(struct inode *in
 	return 0;
 }
 #if LINUX_VERSION_CODE < 0x20326
-static struct file_operations nftl_fops = {
+static const struct file_operations nftl_fops = {
 	read:		block_read,
 	write:		block_write,
 	ioctl:		nftl_ioctl,
diff -urNp linux-2.4.37.7/drivers/net/bonding/bond_main.c linux-2.4.37.7/drivers/net/bonding/bond_main.c
--- linux-2.4.37.7/drivers/net/bonding/bond_main.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/bonding/bond_main.c	2009-11-10 19:30:27.000000000 -0500
@@ -3246,7 +3246,7 @@ static int bond_info_seq_show(struct seq
 	return 0;
 }
 
-static struct seq_operations bond_info_seq_ops = {
+static const struct seq_operations bond_info_seq_ops = {
 	.start = bond_info_seq_start,
 	.next  = bond_info_seq_next,
 	.stop  = bond_info_seq_stop,
@@ -3270,7 +3270,7 @@ static int bond_info_open(struct inode *
 	return res;
 }
 
-static struct file_operations bond_info_fops = {
+static const struct file_operations bond_info_fops = {
 	.owner   = THIS_MODULE,
 	.open    = bond_info_open,
 	.read    = seq_read,
diff -urNp linux-2.4.37.7/drivers/net/ibmveth.c linux-2.4.37.7/drivers/net/ibmveth.c
--- linux-2.4.37.7/drivers/net/ibmveth.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/ibmveth.c	2009-11-10 19:30:27.000000000 -0500
@@ -1013,7 +1013,7 @@ static int ibmveth_seq_show(struct seq_f
 	
 	return 0;
 }
-static struct seq_operations ibmveth_seq_ops = {
+static const struct seq_operations ibmveth_seq_ops = {
 	.start = ibmveth_seq_start,
 	.next  = ibmveth_seq_next,
 	.stop  = ibmveth_seq_stop,
@@ -1036,7 +1036,7 @@ static int ibmveth_proc_open(struct inod
 	return rc;
 }
 
-static struct file_operations ibmveth_proc_fops = {
+static const struct file_operations ibmveth_proc_fops = {
 	.owner	 = THIS_MODULE,
 	.open    = ibmveth_proc_open,
 	.read    = seq_read,
diff -urNp linux-2.4.37.7/drivers/net/ppp_generic.c linux-2.4.37.7/drivers/net/ppp_generic.c
--- linux-2.4.37.7/drivers/net/ppp_generic.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/ppp_generic.c	2009-11-10 19:30:27.000000000 -0500
@@ -764,7 +764,7 @@ static int ppp_unattached_ioctl(struct p
 	return err;
 }
 
-static struct file_operations ppp_device_fops = {
+static const struct file_operations ppp_device_fops = {
 	owner:		THIS_MODULE,
 	read:		ppp_read,
 	write:		ppp_write,
diff -urNp linux-2.4.37.7/drivers/net/tun.c linux-2.4.37.7/drivers/net/tun.c
--- linux-2.4.37.7/drivers/net/tun.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/tun.c	2009-11-10 19:30:27.000000000 -0500
@@ -563,7 +563,7 @@ static int tun_chr_close(struct inode *i
 	return 0;
 }
 
-static struct file_operations tun_fops = {
+static const struct file_operations tun_fops = {
 	owner:	THIS_MODULE,	
 	llseek:	no_llseek,
 	read:	tun_chr_read,
diff -urNp linux-2.4.37.7/drivers/net/wan/8253x/8253xini.c linux-2.4.37.7/drivers/net/wan/8253x/8253xini.c
--- linux-2.4.37.7/drivers/net/wan/8253x/8253xini.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/wan/8253x/8253xini.c	2009-11-10 19:30:27.000000000 -0500
@@ -182,8 +182,7 @@ struct net_device auraXX20n_prototype = 
 	sab8253xn_init /* network driver initialization */
 };
 
-struct file_operations sab8253xc_fops =
-{
+const struct file_operations sab8253xc_fops = {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0))
 	NULL,
 #endif
diff -urNp linux-2.4.37.7/drivers/net/wan/comx.c linux-2.4.37.7/drivers/net/wan/comx.c
--- linux-2.4.37.7/drivers/net/wan/comx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/wan/comx.c	2009-11-10 19:30:27.000000000 -0500
@@ -96,7 +96,7 @@ static int comx_mkdir(struct inode *, st
 static int comx_rmdir(struct inode *, struct dentry *);
 static struct dentry *comx_lookup(struct inode *, struct dentry *);
 
-static struct inode_operations comx_root_inode_ops = {
+static const struct inode_operations comx_root_inode_ops = {
 	lookup:	comx_lookup,
 	mkdir: comx_mkdir,
 	rmdir: comx_rmdir,
@@ -106,7 +106,7 @@ static int comx_delete_dentry(struct den
 static struct proc_dir_entry *create_comx_proc_entry(char *name, int mode,
 	int size, struct proc_dir_entry *dir);
 
-static struct dentry_operations comx_dentry_operations = {
+static const struct dentry_operations comx_dentry_operations = {
 	d_delete:	comx_delete_dentry,
 };
 
diff -urNp linux-2.4.37.7/drivers/net/wan/cosa.c linux-2.4.37.7/drivers/net/wan/cosa.c
--- linux-2.4.37.7/drivers/net/wan/cosa.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/wan/cosa.c	2009-11-10 19:30:27.000000000 -0500
@@ -310,7 +310,7 @@ static int cosa_chardev_ioctl(struct ino
 static int cosa_fasync(struct inode *inode, struct file *file, int on);
 #endif
 
-static struct file_operations cosa_fops = {
+static const struct file_operations cosa_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		cosa_read,
diff -urNp linux-2.4.37.7/drivers/net/wan/sdla_ppp.c linux-2.4.37.7/drivers/net/wan/sdla_ppp.c
--- linux-2.4.37.7/drivers/net/wan/sdla_ppp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/wan/sdla_ppp.c	2009-11-10 19:30:27.000000000 -0500
@@ -467,7 +467,7 @@ static int update(wan_device_t *wandev)
 	sdla_t* card = wandev->private;
  	netdevice_t* dev;
         volatile ppp_private_area_t *ppp_priv_area;
-	ppp_flags_t *flags = card->flags;
+	ppp_flags_t *flags;
 	unsigned long timeout;
 
 	/* sanity checks */
@@ -491,6 +491,7 @@ static int update(wan_device_t *wandev)
 	
 	ppp_priv_area->update_comms_stats = 2;
 	ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_UPDATE;
+	flags = card->flags;
 	flags->imask |= PPP_INTR_TIMER;	
 	
 	/* wait a maximum of 1 second for the statistics to be updated */ 
diff -urNp linux-2.4.37.7/drivers/net/wireless/airo.c linux-2.4.37.7/drivers/net/wireless/airo.c
--- linux-2.4.37.7/drivers/net/wireless/airo.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/net/wireless/airo.c	2009-11-10 19:30:27.000000000 -0500
@@ -3473,53 +3473,53 @@ static int proc_BSSList_open( struct ino
 static int proc_config_open( struct inode *inode, struct file *file );
 static int proc_wepkey_open( struct inode *inode, struct file *file );
 
-static struct file_operations proc_statsdelta_ops = {
+static const struct file_operations proc_statsdelta_ops = {
 	.read		= proc_read,
 	.open		= proc_statsdelta_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_stats_ops = {
+static const struct file_operations proc_stats_ops = {
 	.read		= proc_read,
 	.open		= proc_stats_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_status_ops = {
+static const struct file_operations proc_status_ops = {
 	.read		= proc_read,
 	.open		= proc_status_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_SSID_ops = {
+static const struct file_operations proc_SSID_ops = {
 	.read		= proc_read,
 	.write		= proc_write,
 	.open		= proc_SSID_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_BSSList_ops = {
+static const struct file_operations proc_BSSList_ops = {
 	.read		= proc_read,
 	.write		= proc_write,
 	.open		= proc_BSSList_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_APList_ops = {
+static const struct file_operations proc_APList_ops = {
 	.read		= proc_read,
 	.write		= proc_write,
 	.open		= proc_APList_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_config_ops = {
+static const struct file_operations proc_config_ops = {
 	.read		= proc_read,
 	.write		= proc_write,
 	.open		= proc_config_open,
 	.release	= proc_close
 };
 
-static struct file_operations proc_wepkey_ops = {
+static const struct file_operations proc_wepkey_ops = {
 	.read		= proc_read,
 	.write		= proc_write,
 	.open		= proc_wepkey_open,
diff -urNp linux-2.4.37.7/drivers/pci/proc.c linux-2.4.37.7/drivers/pci/proc.c
--- linux-2.4.37.7/drivers/pci/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/pci/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -284,7 +284,7 @@ static int proc_bus_pci_release(struct i
 }
 #endif /* HAVE_PCI_MMAP */
 
-static struct file_operations proc_bus_pci_operations = {
+static const struct file_operations proc_bus_pci_operations = {
 	llseek:		proc_bus_pci_lseek,
 	read:		proc_bus_pci_read,
 	write:		proc_bus_pci_write,
@@ -364,7 +364,7 @@ static int show_device(struct seq_file *
 	return 0;
 }
 
-static struct seq_operations proc_bus_pci_devices_op = {
+static const struct seq_operations proc_bus_pci_devices_op = {
 	start:	pci_seq_start,
 	next:	pci_seq_next,
 	stop:	pci_seq_stop,
@@ -524,7 +524,7 @@ static int show_dev_config(struct seq_fi
 	return 0;
 }
 
-static struct seq_operations proc_pci_op = {
+static const struct seq_operations proc_pci_op = {
 	start:	pci_seq_start,
 	next:	pci_seq_next,
 	stop:	pci_seq_stop,
@@ -535,7 +535,7 @@ static int proc_bus_pci_dev_open(struct 
 {
 	return seq_open(file, &proc_bus_pci_devices_op);
 }
-static struct file_operations proc_bus_pci_dev_operations = {
+static const struct file_operations proc_bus_pci_dev_operations = {
 	open:		proc_bus_pci_dev_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -545,7 +545,7 @@ static int proc_pci_open(struct inode *i
 {
 	return seq_open(file, &proc_pci_op);
 }
-static struct file_operations proc_pci_operations = {
+static const struct file_operations proc_pci_operations = {
 	open:		proc_pci_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -564,7 +564,15 @@ static int __init pci_proc_init(void)
 		pci_for_each_dev(dev) {
 			pci_proc_attach_device(dev);
 		}
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+		entry = create_proc_entry("pci", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+		entry = create_proc_entry("pci", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 		entry = create_proc_entry("pci", 0, NULL);
+#endif
 		if (entry)
 			entry->proc_fops = &proc_pci_operations;
 	}
diff -urNp linux-2.4.37.7/drivers/pcmcia/ds.c linux-2.4.37.7/drivers/pcmcia/ds.c
--- linux-2.4.37.7/drivers/pcmcia/ds.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/pcmcia/ds.c	2009-11-10 19:30:27.000000000 -0500
@@ -867,7 +867,7 @@ static int ds_ioctl(struct inode * inode
 
 /*====================================================================*/
 
-static struct file_operations ds_fops = {
+static const struct file_operations ds_fops = {
 	owner:		THIS_MODULE,
 	open:		ds_open,
 	release:	ds_release,
diff -urNp linux-2.4.37.7/drivers/pnp/isapnp_proc.c linux-2.4.37.7/drivers/pnp/isapnp_proc.c
--- linux-2.4.37.7/drivers/pnp/isapnp_proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/pnp/isapnp_proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -205,8 +205,7 @@ static unsigned int isapnp_info_entry_po
 	return POLLIN | POLLRDNORM;
 }
 
-static struct file_operations isapnp_info_entry_operations =
-{
+static const struct file_operations isapnp_info_entry_operations = {
 	llseek:		isapnp_info_entry_lseek,
 	read:		isapnp_info_entry_read,
 	write:		isapnp_info_entry_write,
@@ -269,8 +268,7 @@ static ssize_t isapnp_proc_bus_read(stru
 	return nbytes;
 }
 
-static struct file_operations isapnp_proc_bus_file_operations =
-{
+static const struct file_operations isapnp_proc_bus_file_operations = {
 	llseek:		isapnp_proc_bus_lseek,
 	read:		isapnp_proc_bus_read,
 };
diff -urNp linux-2.4.37.7/drivers/s390/block/dasd.c linux-2.4.37.7/drivers/s390/block/dasd.c
--- linux-2.4.37.7/drivers/s390/block/dasd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/block/dasd.c	2009-11-10 19:30:27.000000000 -0500
@@ -4968,14 +4968,14 @@ dasd_devices_close (struct inode *inode,
 	return rc;
 }
 
-static struct file_operations dasd_devices_file_ops = {
+static const struct file_operations dasd_devices_file_ops = {
 	read:dasd_generic_read,	        /* read */
 	write:dasd_devices_write,	/* write */
 	open:dasd_devices_open,	        /* open */
 	release:dasd_devices_close,	/* close */
 };
 
-static struct inode_operations dasd_devices_inode_ops = {
+static const struct inode_operations dasd_devices_inode_ops = {
 };
 
 static int
@@ -5248,14 +5248,14 @@ dasd_statistics_write (struct file *file
 	return user_len;
 }
 
-static struct file_operations dasd_statistics_file_ops = {
+static const struct file_operations dasd_statistics_file_ops = {
 	read:dasd_generic_read,	        /* read */
 	write:dasd_statistics_write,	/* write */
 	open:dasd_statistics_open,	/* open */
 	release:dasd_devices_close,	/* close */
 };
 
-static struct inode_operations dasd_statistics_inode_ops = {
+static const struct inode_operations dasd_statistics_inode_ops = {
 };
 
 int
diff -urNp linux-2.4.37.7/drivers/s390/block/xpram.c linux-2.4.37.7/drivers/s390/block/xpram.c
--- linux-2.4.37.7/drivers/s390/block/xpram.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/block/xpram.c	2009-11-10 19:30:27.000000000 -0500
@@ -717,7 +717,7 @@ int xpram_ioctl (struct inode *inode, st
  */
 
 #if (XPRAM_VERSION == 22)
-struct file_operations xpram_fops = {
+const struct file_operations xpram_fops = {
 	NULL,          /* lseek: default */
 	block_read,
 	block_write,
diff -urNp linux-2.4.37.7/drivers/s390/char/tapeblock.c linux-2.4.37.7/drivers/s390/char/tapeblock.c
--- linux-2.4.37.7/drivers/s390/char/tapeblock.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/char/tapeblock.c	2009-11-10 19:30:27.000000000 -0500
@@ -38,7 +38,7 @@
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 static struct block_device_operations tapeblock_fops = {
 #else
-static struct file_operations tapeblock_fops = {
+static const struct file_operations tapeblock_fops = {
 #endif
     owner   : THIS_MODULE,
     open    : tapeblock_open,      /* open */
diff -urNp linux-2.4.37.7/drivers/s390/char/tape.c linux-2.4.37.7/drivers/s390/char/tape.c
--- linux-2.4.37.7/drivers/s390/char/tape.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/char/tape.c	2009-11-10 19:30:27.000000000 -0500
@@ -203,15 +203,13 @@ tape_devices_release (struct inode *inod
 	return rc;
 }
 
-static struct file_operations tape_devices_file_ops =
-{
+static const struct file_operations tape_devices_file_ops = {
 	read:tape_devices_read,	/* read */
 	open:tape_devices_open,	/* open */
 	release:tape_devices_release,	/* close */
 };
 
-static struct inode_operations tape_devices_inode_ops =
-{
+static const struct inode_operations tape_devices_inode_ops = {
 #if !(LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 	default_file_ops:&tape_devices_file_ops		/* file ops */
 #endif				/* LINUX_IS_24 */
diff -urNp linux-2.4.37.7/drivers/s390/char/tapechar.c linux-2.4.37.7/drivers/s390/char/tapechar.c
--- linux-2.4.37.7/drivers/s390/char/tapechar.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/char/tapechar.c	2009-11-10 19:30:27.000000000 -0500
@@ -36,8 +36,7 @@
 /*
  * file operation structure for tape devices
  */
-static struct file_operations tape_fops =
-{
+static const struct file_operations tape_fops = {
     //    owner   : THIS_MODULE,
 	llseek:NULL,		/* lseek - default */
 	read:tape_read,		/* read  */
diff -urNp linux-2.4.37.7/drivers/s390/char/tubfs.c linux-2.4.37.7/drivers/s390/char/tubfs.c
--- linux-2.4.37.7/drivers/s390/char/tubfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/char/tubfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,7 +22,7 @@ static int fs3270_wait(tub_t *, long *);
 static void fs3270_int(tub_t *tubp, devstat_t *dsp);
 extern void tty3270_refresh(tub_t *);
 
-static struct file_operations fs3270_fops = {
+static const struct file_operations fs3270_fops = {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
 	owner: THIS_MODULE,		/* owner */
 #endif
diff -urNp linux-2.4.37.7/drivers/s390/net/ctcmain.c linux-2.4.37.7/drivers/s390/net/ctcmain.c
--- linux-2.4.37.7/drivers/s390/net/ctcmain.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/net/ctcmain.c	2009-11-10 19:30:27.000000000 -0500
@@ -3202,38 +3202,38 @@ static ssize_t ctc_stat_read(struct file
 	return ret;
 }
 
-static struct file_operations ctc_stat_fops = {
+static const struct file_operations ctc_stat_fops = {
 	read:    ctc_stat_read,
 	write:   ctc_stat_write,
 	open:    ctc_stat_open,
 	release: ctc_stat_close,
 };
 
-static struct file_operations ctc_ctrl_fops = {
+static const struct file_operations ctc_ctrl_fops = {
 	read:    ctc_ctrl_read,
 	write:   ctc_ctrl_write,
 	open:    ctc_ctrl_open,
 	release: ctc_ctrl_close,
 };
 
-static struct file_operations ctc_loglevel_fops = {
+static const struct file_operations ctc_loglevel_fops = {
 	read:    ctc_loglevel_read,
 	write:   ctc_loglevel_write,
 	open:    ctc_loglevel_open,
 	release: ctc_loglevel_close,
 };
 
-static struct inode_operations ctc_stat_iops = {
+static const struct inode_operations ctc_stat_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &ctc_stat_fops
 #endif
 };
-static struct inode_operations ctc_ctrl_iops = {
+static const struct inode_operations ctc_ctrl_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &ctc_ctrl_fops
 #endif
 };
-static struct inode_operations ctc_loglevel_iops = {
+static const struct inode_operations ctc_loglevel_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &ctc_loglevel_fops
 #endif
diff -urNp linux-2.4.37.7/drivers/s390/net/netiucv.c linux-2.4.37.7/drivers/s390/net/netiucv.c
--- linux-2.4.37.7/drivers/s390/net/netiucv.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/net/netiucv.c	2009-11-10 19:30:27.000000000 -0500
@@ -1648,39 +1648,39 @@ netiucv_stat_read(struct file *file, cha
 	return ret;
 }
 
-static struct file_operations netiucv_stat_fops = {
+static const struct file_operations netiucv_stat_fops = {
 	read:    netiucv_stat_read,
 	write:   netiucv_stat_write,
 	open:    netiucv_stat_open,
 	release: netiucv_stat_close,
 };
 
-static struct file_operations netiucv_buffer_fops = {
+static const struct file_operations netiucv_buffer_fops = {
 	read:    netiucv_buffer_read,
 	write:   netiucv_buffer_write,
 	open:    netiucv_buffer_open,
 	release: netiucv_buffer_close,
 };
 
-static struct file_operations netiucv_user_fops = {
+static const struct file_operations netiucv_user_fops = {
 	read:    netiucv_user_read,
 	write:   netiucv_user_write,
 	open:    netiucv_user_open,
 	release: netiucv_user_close,
 };
 
-static struct inode_operations netiucv_stat_iops = {
+static const struct inode_operations netiucv_stat_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &netiucv_stat_fops
 #endif
 };
-static struct inode_operations netiucv_buffer_iops = {
+static const struct inode_operations netiucv_buffer_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &netiucv_buffer_fops
 #endif
 };
 
-static struct inode_operations netiucv_user_iops = {
+static const struct inode_operations netiucv_user_iops = {
 #if LINUX_VERSION_CODE < 0x020363
 	default_file_ops: &netiucv_user_fops
 #endif
diff -urNp linux-2.4.37.7/drivers/s390/net/qeth.c linux-2.4.37.7/drivers/s390/net/qeth.c
--- linux-2.4.37.7/drivers/s390/net/qeth.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/net/qeth.c	2009-11-10 19:30:27.000000000 -0500
@@ -10929,8 +10929,7 @@ static int qeth_procfile_ioctl(struct in
      return result;
 };
 
-static struct file_operations qeth_procfile_fops =
-{
+static const struct file_operations qeth_procfile_fops = {
 	ioctl:qeth_procfile_ioctl,
 	read:qeth_procfile_read,
 	write:qeth_procfile_write,
@@ -10940,8 +10939,7 @@ static struct file_operations qeth_procf
 
 static struct proc_dir_entry *qeth_proc_file;
 
-static struct file_operations qeth_ipato_procfile_fops =
-{
+static const struct file_operations qeth_ipato_procfile_fops = {
 	read:qeth_procfile_read, /* same as above! */
 	write:qeth_ipato_procfile_write,
 	open:qeth_ipato_procfile_open,
diff -urNp linux-2.4.37.7/drivers/s390/s390io.c linux-2.4.37.7/drivers/s390/s390io.c
--- linux-2.4.37.7/drivers/s390/s390io.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/s390/s390io.c	2009-11-10 19:30:27.000000000 -0500
@@ -8350,7 +8350,7 @@ chan_subch_read (struct file *file, char
 	}
 }
 
-static struct file_operations chan_subch_file_ops = {
+static const struct file_operations chan_subch_file_ops = {
 	read:chan_subch_read, open:chan_subch_open, release:chan_subch_close,
 };
 
@@ -8597,17 +8597,17 @@ cio_chpid_entry_open (struct inode *inod
 	return rc;
 }
 
-static struct file_operations cio_sensedata_entry_file_ops = {
+static const struct file_operations cio_sensedata_entry_file_ops = {
 	read:cio_device_entry_read, open:cio_sensedata_entry_open,
 	release:cio_device_entry_close,
 };
 
-static struct file_operations cio_in_use_entry_file_ops = {
+static const struct file_operations cio_in_use_entry_file_ops = {
 	read:cio_device_entry_read, open:cio_in_use_entry_open,
 	release:cio_device_entry_close,
 };
 
-static struct file_operations cio_chpid_entry_file_ops = {
+static const struct file_operations cio_chpid_entry_file_ops = {
 	read:cio_device_entry_read, open:cio_chpid_entry_open,
 	release:cio_device_entry_close,
 };
@@ -8926,7 +8926,7 @@ cio_ignore_proc_write (struct file *file
 	return user_len;
 }
 
-static struct file_operations cio_ignore_proc_file_ops = {
+static const struct file_operations cio_ignore_proc_file_ops = {
 	read:cio_ignore_proc_read, open:cio_ignore_proc_open,
 	write:cio_ignore_proc_write, release:cio_ignore_proc_close,
 };
@@ -9019,7 +9019,7 @@ cio_irq_proc_read (struct file *file, ch
 	}
 }
 
-static struct file_operations cio_irq_proc_file_ops = {
+static const struct file_operations cio_irq_proc_file_ops = {
 	read:cio_irq_proc_read, open:cio_irq_proc_open,
 	release:cio_irq_proc_close,
 };
@@ -9177,7 +9177,7 @@ cio_chpids_proc_write (struct file *file
 	return user_len;
 }
 
-static struct file_operations cio_chpids_proc_file_ops =
+static const struct file_operations cio_chpids_proc_file_ops =
 {
 	read:cio_chpids_proc_read,
 	open:cio_chpids_proc_open,
diff -urNp linux-2.4.37.7/drivers/sbus/audio/audio.c linux-2.4.37.7/drivers/sbus/audio/audio.c
--- linux-2.4.37.7/drivers/sbus/audio/audio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/audio/audio.c	2009-11-10 19:30:27.000000000 -0500
@@ -1701,7 +1701,7 @@ static int sparcaudio_ioctl(struct inode
 	return retval;
 }
 
-static struct file_operations sparcaudioctl_fops = {
+static const struct file_operations sparcaudioctl_fops = {
 	owner:		THIS_MODULE,
 	poll:		sparcaudio_poll,
 	ioctl:		sparcaudio_ioctl,
@@ -1893,7 +1893,7 @@ static int sparcaudio_release(struct ino
         return 0;
 }
 
-static struct file_operations sparcaudio_fops = {
+static const struct file_operations sparcaudio_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		sparcaudio_read,
diff -urNp linux-2.4.37.7/drivers/sbus/char/bpp.c linux-2.4.37.7/drivers/sbus/char/bpp.c
--- linux-2.4.37.7/drivers/sbus/char/bpp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/bpp.c	2009-11-10 19:30:27.000000000 -0500
@@ -859,7 +859,7 @@ static int bpp_ioctl(struct inode *inode
       return errno;
 }
 
-static struct file_operations bpp_fops = {
+static const struct file_operations bpp_fops = {
 	owner:		THIS_MODULE,
 	read:		bpp_read,
 	write:		bpp_write,
diff -urNp linux-2.4.37.7/drivers/sbus/char/cpwatchdog.c linux-2.4.37.7/drivers/sbus/char/cpwatchdog.c
--- linux-2.4.37.7/drivers/sbus/char/cpwatchdog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/cpwatchdog.c	2009-11-10 19:30:27.000000000 -0500
@@ -461,7 +461,7 @@ static void wd_interrupt(int irq, void *
 	return;
 }
 
-static struct file_operations wd_fops = {
+static const struct file_operations wd_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		wd_ioctl,
 	open:		wd_open,
diff -urNp linux-2.4.37.7/drivers/sbus/char/display7seg.c linux-2.4.37.7/drivers/sbus/char/display7seg.c
--- linux-2.4.37.7/drivers/sbus/char/display7seg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/display7seg.c	2009-11-10 19:30:27.000000000 -0500
@@ -164,7 +164,7 @@ static int d7s_ioctl(struct inode *inode
 	return 0;
 }
 
-static struct file_operations d7s_fops = {
+static const struct file_operations d7s_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		d7s_ioctl,
 	open:		d7s_open,
diff -urNp linux-2.4.37.7/drivers/sbus/char/envctrl.c linux-2.4.37.7/drivers/sbus/char/envctrl.c
--- linux-2.4.37.7/drivers/sbus/char/envctrl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/envctrl.c	2009-11-10 19:30:27.000000000 -0500
@@ -721,7 +721,7 @@ envctrl_release(struct inode *inode, str
 	return 0;
 }
 
-static struct file_operations envctrl_fops = {
+static const struct file_operations envctrl_fops = {
 	owner:		THIS_MODULE,
 	read:		envctrl_read,
 	ioctl:		envctrl_ioctl,
diff -urNp linux-2.4.37.7/drivers/sbus/char/flash.c linux-2.4.37.7/drivers/sbus/char/flash.c
--- linux-2.4.37.7/drivers/sbus/char/flash.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/flash.c	2009-11-10 19:30:27.000000000 -0500
@@ -147,7 +147,7 @@ flash_release(struct inode *inode, struc
 	return 0;
 }
 
-static struct file_operations flash_fops = {
+static const struct file_operations flash_fops = {
 	/* no write to the Flash, use mmap
 	 * and play flash dependent tricks.
 	 */
diff -urNp linux-2.4.37.7/drivers/sbus/char/jsflash.c linux-2.4.37.7/drivers/sbus/char/jsflash.c
--- linux-2.4.37.7/drivers/sbus/char/jsflash.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/jsflash.c	2009-11-10 19:30:27.000000000 -0500
@@ -533,7 +533,7 @@ static int jsfd_release(struct inode *in
 	return 0;
 }
 
-static struct file_operations jsf_fops = {
+static const struct file_operations jsf_fops = {
 	owner:		THIS_MODULE,
 	llseek:		jsf_lseek,
 	read:		jsf_read,
diff -urNp linux-2.4.37.7/drivers/sbus/char/openprom.c linux-2.4.37.7/drivers/sbus/char/openprom.c
--- linux-2.4.37.7/drivers/sbus/char/openprom.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/openprom.c	2009-11-10 19:30:27.000000000 -0500
@@ -610,7 +610,7 @@ static int openprom_release(struct inode
 	return 0;
 }
 
-static struct file_operations openprom_fops = {
+static const struct file_operations openprom_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		openprom_ioctl,
diff -urNp linux-2.4.37.7/drivers/sbus/char/pcikbd.c linux-2.4.37.7/drivers/sbus/char/pcikbd.c
--- linux-2.4.37.7/drivers/sbus/char/pcikbd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/pcikbd.c	2009-11-10 19:30:27.000000000 -0500
@@ -1183,7 +1183,7 @@ static unsigned int aux_poll(struct file
 	return 0;
 }
 
-struct file_operations psaux_fops = {
+const struct file_operations psaux_fops = {
 	owner:		THIS_MODULE,
 	read:		aux_read,
 	write:		aux_write,
@@ -1198,7 +1198,7 @@ static int aux_no_open(struct inode *ino
 	return -ENODEV;
 }
 
-struct file_operations psaux_no_fops = {
+const struct file_operations psaux_no_fops = {
 	owner:		THIS_MODULE,
 	open:		aux_no_open,
 };
diff -urNp linux-2.4.37.7/drivers/sbus/char/riowatchdog.c linux-2.4.37.7/drivers/sbus/char/riowatchdog.c
--- linux-2.4.37.7/drivers/sbus/char/riowatchdog.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/riowatchdog.c	2009-11-10 19:30:27.000000000 -0500
@@ -199,7 +199,7 @@ static ssize_t riowd_read(struct file *f
 	return -EINVAL;
 }
 
-static struct file_operations riowd_fops = {
+static const struct file_operations riowd_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		riowd_ioctl,
 	open:		riowd_open,
diff -urNp linux-2.4.37.7/drivers/sbus/char/rtc.c linux-2.4.37.7/drivers/sbus/char/rtc.c
--- linux-2.4.37.7/drivers/sbus/char/rtc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/rtc.c	2009-11-10 19:30:27.000000000 -0500
@@ -137,7 +137,7 @@ static int rtc_release(struct inode *ino
 	return 0;
 }
 
-static struct file_operations rtc_fops = {
+static const struct file_operations rtc_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		rtc_ioctl,
diff -urNp linux-2.4.37.7/drivers/sbus/char/sunkbd.c linux-2.4.37.7/drivers/sbus/char/sunkbd.c
--- linux-2.4.37.7/drivers/sbus/char/sunkbd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/sunkbd.c	2009-11-10 19:30:27.000000000 -0500
@@ -1546,8 +1546,7 @@ kbd_close (struct inode *i, struct file 
 	return 0;
 }
 
-static struct file_operations kbd_fops =
-{
+static const struct file_operations kbd_fops = {
 	read:		kbd_read,
 	poll:		kbd_poll,
 	ioctl:		kbd_ioctl,
diff -urNp linux-2.4.37.7/drivers/sbus/char/sunmouse.c linux-2.4.37.7/drivers/sbus/char/sunmouse.c
--- linux-2.4.37.7/drivers/sbus/char/sunmouse.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/sunmouse.c	2009-11-10 19:30:27.000000000 -0500
@@ -586,7 +586,7 @@ sun_mouse_ioctl (struct inode *inode, st
 	return 0;
 }
 
-struct file_operations sun_mouse_fops = {
+const struct file_operations sun_mouse_fops = {
 	read:		sun_mouse_read,
 	write:		sun_mouse_write,
 	poll:		sun_mouse_poll,
diff -urNp linux-2.4.37.7/drivers/sbus/char/uctrl.c linux-2.4.37.7/drivers/sbus/char/uctrl.c
--- linux-2.4.37.7/drivers/sbus/char/uctrl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/uctrl.c	2009-11-10 19:30:27.000000000 -0500
@@ -223,7 +223,7 @@ void uctrl_interrupt(int irq, void *dev_
 	printk("in uctrl_interrupt\n");
 }
 
-static struct file_operations uctrl_fops = {
+static const struct file_operations uctrl_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		uctrl_ioctl,
diff -urNp linux-2.4.37.7/drivers/sbus/char/vfc_dev.c linux-2.4.37.7/drivers/sbus/char/vfc_dev.c
--- linux-2.4.37.7/drivers/sbus/char/vfc_dev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sbus/char/vfc_dev.c	2009-11-10 19:30:27.000000000 -0500
@@ -43,7 +43,7 @@
 #include "vfc.h"
 #include <asm/vfc_ioctls.h>
 
-static struct file_operations vfc_fops;
+static const struct file_operations vfc_fops;
 static devfs_handle_t devfs_handle;  /*  For the directory  */
 struct vfc_dev **vfc_dev_lst;
 static char vfcstr[]="vfc";
@@ -642,7 +642,7 @@ static int vfc_mmap(struct inode *inode,
 }
 
 
-static struct file_operations vfc_fops = {
+static const struct file_operations vfc_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		vfc_ioctl,
diff -urNp linux-2.4.37.7/drivers/scsi/3w-xxxx.c linux-2.4.37.7/drivers/scsi/3w-xxxx.c
--- linux-2.4.37.7/drivers/scsi/3w-xxxx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/3w-xxxx.c	2009-11-10 19:30:27.000000000 -0500
@@ -234,7 +234,7 @@ static struct notifier_block tw_notifier
 };
 
 /* File operations struct for character device */
-static struct file_operations tw_fops = {
+static const struct file_operations tw_fops = {
 	owner: THIS_MODULE,
 	ioctl: tw_chrdev_ioctl,
 	open: tw_chrdev_open,
diff -urNp linux-2.4.37.7/drivers/scsi/aacraid/linit.c linux-2.4.37.7/drivers/scsi/aacraid/linit.c
--- linux-2.4.37.7/drivers/scsi/aacraid/linit.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/aacraid/linit.c	2009-11-10 19:30:27.000000000 -0500
@@ -122,7 +122,7 @@ static int aac_cfg_ioctl(struct inode * 
 static int aac_cfg_open(struct inode * inode, struct file * file);
 static int aac_cfg_release(struct inode * inode,struct file * file);
 
-static struct file_operations aac_cfg_fops = {
+static const struct file_operations aac_cfg_fops = {
 	owner: THIS_MODULE,
 	ioctl: aac_cfg_ioctl,
 	open: aac_cfg_open,
diff -urNp linux-2.4.37.7/drivers/scsi/dpt_i2o.c linux-2.4.37.7/drivers/scsi/dpt_i2o.c
--- linux-2.4.37.7/drivers/scsi/dpt_i2o.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/dpt_i2o.c	2009-11-10 19:30:27.000000000 -0500
@@ -110,7 +110,7 @@ static adpt_hba* hbas[DPTI_MAX_HBA];
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
-static struct file_operations adpt_fops = {
+static const struct file_operations adpt_fops = {
 	ioctl: adpt_ioctl,
 	open: adpt_open,
 	release: adpt_close
diff -urNp linux-2.4.37.7/drivers/scsi/gdth.c linux-2.4.37.7/drivers/scsi/gdth.c
--- linux-2.4.37.7/drivers/scsi/gdth.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/gdth.c	2009-11-10 19:30:27.000000000 -0500
@@ -698,7 +698,7 @@ MODULE_LICENSE("GPL");
 #endif
 
 /* ioctl interface */
-static struct file_operations gdth_fops = {
+static const struct file_operations gdth_fops = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     .ioctl   = gdth_ioctl,
     .open    = gdth_open,
diff -urNp linux-2.4.37.7/drivers/scsi/libata-scsi.c linux-2.4.37.7/drivers/scsi/libata-scsi.c
--- linux-2.4.37.7/drivers/scsi/libata-scsi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/libata-scsi.c	2009-11-10 19:30:27.000000000 -0500
@@ -1497,7 +1497,7 @@ unsigned int ata_scsiop_inq_80(struct at
 	return 0;
 }
 
-static const char *inq_83_str = "Linux ATA-SCSI simulator";
+static const char inq_83_str[] = "Linux ATA-SCSI simulator";
 
 /**
  *	ata_scsiop_inq_83 - Simulate INQUIRY EVPD page 83, device identity
@@ -1516,13 +1516,13 @@ unsigned int ata_scsiop_inq_83(struct at
 			      unsigned int buflen)
 {
 	rbuf[1] = 0x83;			/* this page code */
-	rbuf[3] = 4 + strlen(inq_83_str);	/* page len */
+	rbuf[3] = 3 + sizeof(inq_83_str);	/* page len */
 
 	/* our one and only identification descriptor (vendor-specific) */
-	if (buflen > (strlen(inq_83_str) + 4 + 4 - 1)) {
+	if (buflen >= (sizeof(inq_83_str) + 4 + 4 - 1)) {
 		rbuf[4 + 0] = 2;	/* code set: ASCII */
-		rbuf[4 + 3] = strlen(inq_83_str);
-		memcpy(rbuf + 4 + 4, inq_83_str, strlen(inq_83_str));
+		rbuf[4 + 3] = sizeof(inq_83_str)-1;
+		memcpy(rbuf + 4 + 4, inq_83_str, sizeof(inq_83_str)-1);
 	}
 
 	return 0;
diff -urNp linux-2.4.37.7/drivers/scsi/megaraid2.c linux-2.4.37.7/drivers/scsi/megaraid2.c
--- linux-2.4.37.7/drivers/scsi/megaraid2.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/megaraid2.c	2009-11-10 19:30:27.000000000 -0500
@@ -97,7 +97,7 @@ static struct semaphore megaraid_ioc_mtx
 /*
  * The File Operations structure for the serial/ioctl interface of the driver
  */
-static struct file_operations megadev_fops = {
+static const struct file_operations megadev_fops = {
 	.ioctl		= megadev_ioctl_entry,
 	.open		= megadev_open,
 	.release	= megadev_close,
diff -urNp linux-2.4.37.7/drivers/scsi/megaraid.c linux-2.4.37.7/drivers/scsi/megaraid.c
--- linux-2.4.37.7/drivers/scsi/megaraid.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/megaraid.c	2009-11-10 19:30:27.000000000 -0500
@@ -873,7 +873,7 @@ struct mega_hbas mega_hbas[MAX_CONTROLLE
  */
 /* For controller re-ordering */ 
 
-static struct file_operations megadev_fops = {
+static const struct file_operations megadev_fops = {
 	ioctl:megadev_ioctl_entry,
 	open:megadev_open,
 	release:megadev_close,
diff -urNp linux-2.4.37.7/drivers/scsi/osst.c linux-2.4.37.7/drivers/scsi/osst.c
--- linux-2.4.37.7/drivers/scsi/osst.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/osst.c	2009-11-10 19:30:27.000000000 -0500
@@ -5501,7 +5501,7 @@ __setup("osst=", osst_setup);
 #endif
 
 
-static struct file_operations osst_fops = {
+static const struct file_operations osst_fops = {
 	read:		osst_read,
 	write:		osst_write,
 	ioctl:		osst_ioctl,
diff -urNp linux-2.4.37.7/drivers/scsi/sg.c linux-2.4.37.7/drivers/scsi/sg.c
--- linux-2.4.37.7/drivers/scsi/sg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/sg.c	2009-11-10 19:30:27.000000000 -0500
@@ -1149,7 +1149,7 @@ static struct page * sg_vma_nopage(struc
     return page;
 }
 
-static struct vm_operations_struct sg_mmap_vm_ops = {
+static const struct vm_operations_struct sg_mmap_vm_ops = {
     nopage : sg_vma_nopage,
 };
 
@@ -1321,7 +1321,7 @@ static void sg_cmd_done_bh(Scsi_Cmnd * S
     }
 }
 
-static struct file_operations sg_fops = {
+static const struct file_operations sg_fops = {
 	owner:		THIS_MODULE,
 	read:		sg_read,
 	write:		sg_write,
diff -urNp linux-2.4.37.7/drivers/scsi/st.c linux-2.4.37.7/drivers/scsi/st.c
--- linux-2.4.37.7/drivers/scsi/st.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/scsi/st.c	2009-11-10 19:30:27.000000000 -0500
@@ -3772,8 +3772,7 @@ __setup("st=", st_setup);
 #endif
 
 
-static struct file_operations st_fops =
-{
+static const struct file_operations st_fops = {
 	owner:		THIS_MODULE,
 	read:		st_read,
 	write:		st_write,
diff -urNp linux-2.4.37.7/drivers/sound/ac97_plugin_wm97xx.c linux-2.4.37.7/drivers/sound/ac97_plugin_wm97xx.c
--- linux-2.4.37.7/drivers/sound/ac97_plugin_wm97xx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/ac97_plugin_wm97xx.c	2009-11-10 19:30:27.000000000 -0500
@@ -789,7 +789,7 @@ static int wm97xx_release(struct inode *
 	return 0;
 }
 
-static struct file_operations ts_fops = {
+static const struct file_operations ts_fops = {
 	owner:		THIS_MODULE,
 	read:           wm97xx_read,
 	poll:           wm97xx_poll,
diff -urNp linux-2.4.37.7/drivers/sound/ad1889.c linux-2.4.37.7/drivers/sound/ad1889.c
--- linux-2.4.37.7/drivers/sound/ad1889.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/ad1889.c	2009-11-10 19:30:27.000000000 -0500
@@ -776,7 +776,7 @@ static int ad1889_release(struct inode *
 	return 0;
 }
 
-static struct file_operations ad1889_fops = {
+static const struct file_operations ad1889_fops = {
 	llseek:         no_llseek,
 	read:           ad1889_read,
 	write:          ad1889_write,
@@ -811,7 +811,7 @@ static int ad1889_mixer_ioctl(struct ino
 	return codec->mixer_ioctl(codec, cmd, arg);
 }
 
-static struct file_operations ad1889_mixer_fops = {
+static const struct file_operations ad1889_mixer_fops = {
 	llseek:         no_llseek,
 	ioctl:		ad1889_mixer_ioctl,
 	open:		ad1889_mixer_open,
diff -urNp linux-2.4.37.7/drivers/sound/btaudio.c linux-2.4.37.7/drivers/sound/btaudio.c
--- linux-2.4.37.7/drivers/sound/btaudio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/btaudio.c	2009-11-10 19:30:27.000000000 -0500
@@ -425,7 +425,7 @@ static int btaudio_mixer_ioctl(struct in
 	return 0;
 }
 
-static struct file_operations btaudio_mixer_fops = {
+static const struct file_operations btaudio_mixer_fops = {
 	owner:   THIS_MODULE,
 	llseek:  no_llseek,
 	open:    btaudio_mixer_open,
@@ -790,7 +790,7 @@ static unsigned int btaudio_dsp_poll(str
 	return mask;
 }
 
-static struct file_operations btaudio_digital_dsp_fops = {
+static const struct file_operations btaudio_digital_dsp_fops = {
 	owner:   THIS_MODULE,
 	llseek:  no_llseek,
 	open:    btaudio_dsp_open_digital,
@@ -801,7 +801,7 @@ static struct file_operations btaudio_di
 	poll:    btaudio_dsp_poll,
 };
 
-static struct file_operations btaudio_analog_dsp_fops = {
+static const struct file_operations btaudio_analog_dsp_fops = {
 	owner:   THIS_MODULE,
 	llseek:  no_llseek,
 	open:    btaudio_dsp_open_analog,
diff -urNp linux-2.4.37.7/drivers/sound/dmasound/dmasound_core.c linux-2.4.37.7/drivers/sound/dmasound/dmasound_core.c
--- linux-2.4.37.7/drivers/sound/dmasound/dmasound_core.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/dmasound/dmasound_core.c	2009-11-10 19:30:27.000000000 -0500
@@ -365,7 +365,7 @@ static int mixer_ioctl(struct inode *ino
 	return -EINVAL;
 }
 
-static struct file_operations mixer_fops =
+static const struct file_operations mixer_fops =
 {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
@@ -1325,7 +1325,7 @@ static int sq_ioctl(struct inode *inode,
 	return -EINVAL;
 }
 
-static struct file_operations sq_fops =
+static const struct file_operations sq_fops =
 {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
@@ -1548,7 +1548,7 @@ static ssize_t state_read(struct file *f
 	return n;
 }
 
-static struct file_operations state_fops = {
+static const struct file_operations state_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		state_read,
diff -urNp linux-2.4.37.7/drivers/sound/emu10k1/audio.c linux-2.4.37.7/drivers/sound/emu10k1/audio.c
--- linux-2.4.37.7/drivers/sound/emu10k1/audio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/emu10k1/audio.c	2009-11-10 19:30:27.000000000 -0500
@@ -1020,7 +1020,7 @@ static struct page *emu10k1_mm_nopage (s
 	return dmapage;
 }
 
-struct vm_operations_struct emu10k1_mm_ops = {
+const struct vm_operations_struct emu10k1_mm_ops = {
 	nopage:         emu10k1_mm_nopage,
 };
 
@@ -1558,7 +1558,7 @@ void emu10k1_waveout_bh(unsigned long re
 	return;
 }
 
-struct file_operations emu10k1_audio_fops = {
+const struct file_operations emu10k1_audio_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		emu10k1_audio_read,
diff -urNp linux-2.4.37.7/drivers/sound/emu10k1/midi.c linux-2.4.37.7/drivers/sound/emu10k1/midi.c
--- linux-2.4.37.7/drivers/sound/emu10k1/midi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/emu10k1/midi.c	2009-11-10 19:30:27.000000000 -0500
@@ -465,7 +465,7 @@ int emu10k1_midi_callback(unsigned long 
 }
 
 /* MIDI file operations */
-struct file_operations emu10k1_midi_fops = {
+const struct file_operations emu10k1_midi_fops = {
 	owner:		THIS_MODULE,
 	read:		emu10k1_midi_read,
 	write:		emu10k1_midi_write,
diff -urNp linux-2.4.37.7/drivers/sound/emu10k1/mixer.c linux-2.4.37.7/drivers/sound/emu10k1/mixer.c
--- linux-2.4.37.7/drivers/sound/emu10k1/mixer.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/emu10k1/mixer.c	2009-11-10 19:30:27.000000000 -0500
@@ -675,7 +675,7 @@ static int emu10k1_mixer_release(struct 
 	return 0;
 }
 
-struct file_operations emu10k1_mixer_fops = {
+const struct file_operations emu10k1_mixer_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		emu10k1_mixer_ioctl,
diff -urNp linux-2.4.37.7/drivers/sound/forte.c linux-2.4.37.7/drivers/sound/forte.c
--- linux-2.4.37.7/drivers/sound/forte.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/forte.c	2009-11-10 19:30:27.000000000 -0500
@@ -365,7 +365,7 @@ forte_mixer_ioctl (struct inode *inode, 
 }
 
 
-static struct file_operations forte_mixer_fops = {
+static const struct file_operations forte_mixer_fops = {
 	.owner			= THIS_MODULE,
 	.llseek			= no_llseek,
 	.ioctl			= forte_mixer_ioctl,
@@ -1667,7 +1667,7 @@ forte_dsp_read (struct file *file, char 
 }
 
 
-static struct file_operations forte_dsp_fops = {
+static const struct file_operations forte_dsp_fops = {
 	.owner			= THIS_MODULE,
 	.llseek			= &no_llseek,
 	.read			= &forte_dsp_read,
diff -urNp linux-2.4.37.7/drivers/sound/hal2.c linux-2.4.37.7/drivers/sound/hal2.c
--- linux-2.4.37.7/drivers/sound/hal2.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/hal2.c	2009-11-10 19:30:27.000000000 -0500
@@ -1372,7 +1372,7 @@ static int hal2_release(struct inode *in
 	return 0;
 }
 
-static struct file_operations hal2_audio_fops = {
+static const struct file_operations hal2_audio_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= hal2_read,
@@ -1383,7 +1383,7 @@ static struct file_operations hal2_audio
 	.release	= hal2_release,
 };
 
-static struct file_operations hal2_mixer_fops = {
+static const struct file_operations hal2_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.ioctl		= hal2_ioctl_mixdev,
diff -urNp linux-2.4.37.7/drivers/sound/harmony.c linux-2.4.37.7/drivers/sound/harmony.c
--- linux-2.4.37.7/drivers/sound/harmony.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/harmony.c	2009-11-10 19:30:27.000000000 -0500
@@ -809,7 +809,7 @@ static void harmony_interrupt(int irq, v
  * Sound playing functions
  */
 
-static struct file_operations harmony_audio_fops = {
+static const struct file_operations harmony_audio_fops = {
 	owner:	THIS_MODULE,
 	llseek:	no_llseek,
 	read: 	harmony_audio_read,
@@ -1131,7 +1131,7 @@ static int harmony_mixer_release(struct 
 	return 0;
 }
 
-static struct file_operations harmony_mixer_fops = {
+static const struct file_operations harmony_mixer_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	open:		harmony_mixer_open,
diff -urNp linux-2.4.37.7/drivers/sound/maestro3.c linux-2.4.37.7/drivers/sound/maestro3.c
--- linux-2.4.37.7/drivers/sound/maestro3.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/maestro3.c	2009-11-10 19:30:27.000000000 -0500
@@ -2176,7 +2176,7 @@ static int m3_ioctl_mixdev(struct inode 
     return codec->mixer_ioctl(codec, cmd, arg);
 }
 
-static struct file_operations m3_mixer_fops = {
+static const struct file_operations m3_mixer_fops = {
     llseek:         no_llseek,
     ioctl:          m3_ioctl_mixdev,
     open:           m3_open_mixdev,
@@ -2554,7 +2554,7 @@ static void m3_enable_ints(struct m3_car
             io + ASSP_CONTROL_C);
 }
 
-static struct file_operations m3_audio_fops = {
+static const struct file_operations m3_audio_fops = {
     llseek:     &no_llseek,
     read:       &m3_read,
     write:      &m3_write,
diff -urNp linux-2.4.37.7/drivers/sound/maestro.c linux-2.4.37.7/drivers/sound/maestro.c
--- linux-2.4.37.7/drivers/sound/maestro.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/maestro.c	2009-11-10 19:30:27.000000000 -0500
@@ -3097,7 +3097,7 @@ ess_release(struct inode *inode, struct 
 	return 0;
 }
 
-static struct file_operations ess_audio_fops = {
+static const struct file_operations ess_audio_fops = {
 	owner:		THIS_MODULE,
 	llseek:         no_llseek,
 	read:           ess_read,
diff -urNp linux-2.4.37.7/drivers/sound/msnd_pinnacle.c linux-2.4.37.7/drivers/sound/msnd_pinnacle.c
--- linux-2.4.37.7/drivers/sound/msnd_pinnacle.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/msnd_pinnacle.c	2009-11-10 19:30:27.000000000 -0500
@@ -1100,7 +1100,7 @@ static void intr(int irq, void *dev_id, 
 	}
 }
 
-static struct file_operations dev_fileops = {
+static const struct file_operations dev_fileops = {
 	owner:		THIS_MODULE,
 	read:		dev_read,
 	write:		dev_write,
diff -urNp linux-2.4.37.7/drivers/sound/rme96xx.c linux-2.4.37.7/drivers/sound/rme96xx.c
--- linux-2.4.37.7/drivers/sound/rme96xx.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/rme96xx.c	2009-11-10 19:30:27.000000000 -0500
@@ -254,8 +254,8 @@ static const char invalid_magic[] = KERN
 /* --------------------------------------------------------------------- */
 
 
-static struct file_operations rme96xx_audio_fops;
-static struct file_operations rme96xx_mixer_fops;
+static const struct file_operations rme96xx_audio_fops;
+static const struct file_operations rme96xx_mixer_fops;
 static int numcards;
 
 typedef int32_t raw_sample_t;
@@ -1736,7 +1736,7 @@ static unsigned int rme96xx_poll(struct 
 }
 
 
-static struct file_operations rme96xx_audio_fops = {
+static const struct file_operations rme96xx_audio_fops = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	owner: THIS_MODULE,
 #endif
diff -urNp linux-2.4.37.7/drivers/sound/soundcard.c linux-2.4.37.7/drivers/sound/soundcard.c
--- linux-2.4.37.7/drivers/sound/soundcard.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/soundcard.c	2009-11-10 19:30:27.000000000 -0500
@@ -493,7 +493,7 @@ static int sound_mmap(struct file *file,
 	return 0;
 }
 
-struct file_operations oss_sound_fops = {
+const struct file_operations oss_sound_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		sound_read,
diff -urNp linux-2.4.37.7/drivers/sound/sound_core.c linux-2.4.37.7/drivers/sound/sound_core.c
--- linux-2.4.37.7/drivers/sound/sound_core.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/sound_core.c	2009-11-10 19:30:27.000000000 -0500
@@ -52,7 +52,7 @@
 struct sound_unit
 {
 	int unit_minor;
-	struct file_operations *unit_fops;
+	const struct file_operations *unit_fops;
 	struct sound_unit *next;
 	devfs_handle_t de;
 };
@@ -69,7 +69,7 @@ extern int msnd_pinnacle_init(void);
  *	join into it. Called with the lock asserted
  */
 
-static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, struct file_operations *fops, int index, int low, int top)
+static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, const struct file_operations *fops, int index, int low, int top)
 {
 	int n=low;
 
@@ -154,7 +154,7 @@ static spinlock_t sound_loader_lock = SP
 
 static devfs_handle_t devfs_handle;
  
-static int sound_insert_unit(struct sound_unit **list, struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode)
+static int sound_insert_unit(struct sound_unit **list, const struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode)
 {
 	int r;
 	struct sound_unit *s=(struct sound_unit *)kmalloc(sizeof(struct sound_unit), GFP_KERNEL);
@@ -229,7 +229,7 @@ static struct sound_unit *chains[16];
  *	a negative error code is returned.
  */
  
-int register_sound_special(struct file_operations *fops, int unit)
+int register_sound_special(const struct file_operations *fops, int unit)
 {
 	char *name;
 
@@ -299,7 +299,7 @@ EXPORT_SYMBOL(register_sound_special);
  *	number is returned, on failure a negative error code is returned.
  */
 
-int register_sound_mixer(struct file_operations *fops, int dev)
+int register_sound_mixer(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
 				 "mixer", S_IRUSR | S_IWUSR);
@@ -317,7 +317,7 @@ EXPORT_SYMBOL(register_sound_mixer);
  *	number is returned, on failure a negative error code is returned.
  */
 
-int register_sound_midi(struct file_operations *fops, int dev)
+int register_sound_midi(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
 				 "midi", S_IRUSR | S_IWUSR);
@@ -343,7 +343,7 @@ EXPORT_SYMBOL(register_sound_midi);
  *	and will always allocate them as a matching pair - eg dsp3/audio3
  */
 
-int register_sound_dsp(struct file_operations *fops, int dev)
+int register_sound_dsp(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
 				 "dsp", S_IWUSR | S_IRUSR);
@@ -362,7 +362,7 @@ EXPORT_SYMBOL(register_sound_dsp);
  */
 
 
-int register_sound_synth(struct file_operations *fops, int dev)
+int register_sound_synth(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
 				 "synth", S_IRUSR | S_IWUSR);
@@ -456,8 +456,7 @@ EXPORT_SYMBOL(unregister_sound_synth);
 
 static int soundcore_open(struct inode *, struct file *);
 
-static struct file_operations soundcore_fops=
-{
+static const struct file_operations soundcore_fops = {
 	/* We must have an owner or the module locking fails */
 	owner:	THIS_MODULE,
 	open:	soundcore_open,
@@ -482,7 +481,7 @@ int soundcore_open(struct inode *inode, 
 	int chain;
 	int unit=MINOR(inode->i_rdev);
 	struct sound_unit *s;
-	struct file_operations *new_fops = NULL;
+	const struct file_operations *new_fops = NULL;
 
 	chain=unit&0x0F;
 	if(chain==4 || chain==5)	/* dsp/audio/dsp16 */
@@ -525,7 +524,7 @@ int soundcore_open(struct inode *inode, 
 		 * switching ->f_op in the first place.
 		 */
 		int err = 0;
-		struct file_operations *old_fops = file->f_op;
+		const struct file_operations *old_fops = file->f_op;
 		file->f_op = new_fops;
 		spin_unlock(&sound_loader_lock);
 		if(file->f_op->open)
diff -urNp linux-2.4.37.7/drivers/sound/via82cxxx_audio.c linux-2.4.37.7/drivers/sound/via82cxxx_audio.c
--- linux-2.4.37.7/drivers/sound/via82cxxx_audio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/via82cxxx_audio.c	2009-11-10 19:30:27.000000000 -0500
@@ -1629,7 +1629,7 @@ out:
 }
 
 
-static struct file_operations via_mixer_fops = {
+static const struct file_operations via_mixer_fops = {
 	owner:		THIS_MODULE,
 	open:		via_mixer_open,
 	llseek:		no_llseek,
@@ -2048,7 +2048,7 @@ static int via_interrupt_init (struct vi
  *
  */
 
-static struct file_operations via_dsp_fops = {
+static const struct file_operations via_dsp_fops = {
 	owner:		THIS_MODULE,
 	open:		via_dsp_open,
 	release:	via_dsp_release,
@@ -2168,7 +2168,7 @@ static int via_mm_swapout (struct page *
 #endif /* VM_RESERVED */
 
 
-struct vm_operations_struct via_mm_ops = {
+const struct vm_operations_struct via_mm_ops = {
 	nopage:		via_mm_nopage,
 
 #ifndef VM_RESERVED
diff -urNp linux-2.4.37.7/drivers/sound/vwsnd.c linux-2.4.37.7/drivers/sound/vwsnd.c
--- linux-2.4.37.7/drivers/sound/vwsnd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/sound/vwsnd.c	2009-11-10 19:30:27.000000000 -0500
@@ -3029,7 +3029,7 @@ static int vwsnd_audio_release(struct in
 	return err;
 }
 
-static struct file_operations vwsnd_audio_fops = {
+static const struct file_operations vwsnd_audio_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		vwsnd_audio_read,
@@ -3219,7 +3219,7 @@ static int vwsnd_mixer_ioctl(struct inod
 	return retval;
 }
 
-static struct file_operations vwsnd_mixer_fops = {
+static const struct file_operations vwsnd_mixer_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	ioctl:		vwsnd_mixer_ioctl,
diff -urNp linux-2.4.37.7/drivers/telephony/ixj.c linux-2.4.37.7/drivers/telephony/ixj.c
--- linux-2.4.37.7/drivers/telephony/ixj.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/telephony/ixj.c	2009-11-10 19:30:27.000000000 -0500
@@ -6767,8 +6767,7 @@ static int ixj_fasync(int fd, struct fil
 	return fasync_helper(fd, file_p, mode, &j->async_queue);
 }
 
-struct file_operations ixj_fops =
-{
+const struct file_operations ixj_fops = {
         owner:          THIS_MODULE,
         read:           ixj_enhanced_read,
         write:          ixj_enhanced_write,
diff -urNp linux-2.4.37.7/drivers/telephony/phonedev.c linux-2.4.37.7/drivers/telephony/phonedev.c
--- linux-2.4.37.7/drivers/telephony/phonedev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/telephony/phonedev.c	2009-11-10 19:30:27.000000000 -0500
@@ -49,7 +49,7 @@ static int phone_open(struct inode *inod
 	unsigned int minor = MINOR(inode->i_rdev);
 	int err = 0;
 	struct phone_device *p;
-	struct file_operations *old_fops, *new_fops = NULL;
+	const struct file_operations *old_fops, *new_fops = NULL;
 
 	if (minor >= PHONE_NUM_DEVICES)
 		return -ENODEV;
@@ -133,8 +133,7 @@ void phone_unregister_device(struct phon
 }
 
 
-static struct file_operations phone_fops =
-{
+static const struct file_operations phone_fops = {
 	owner:		THIS_MODULE,
 	open:		phone_open,
 };
diff -urNp linux-2.4.37.7/drivers/usb/auermain.c linux-2.4.37.7/drivers/usb/auermain.c
--- linux-2.4.37.7/drivers/usb/auermain.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/auermain.c	2009-11-10 19:30:27.000000000 -0500
@@ -547,7 +547,7 @@ void auerswald_removeservice(struct auer
 
 /*----------------------------------------------------------------------*/
 /* File operation structure                                             */
-static struct file_operations auerswald_fops = {
+static const struct file_operations auerswald_fops = {
 	owner:THIS_MODULE,
 	llseek:auerchar_llseek,
 	read:auerchar_read,
diff -urNp linux-2.4.37.7/drivers/usb/brlvger.c linux-2.4.37.7/drivers/usb/brlvger.c
--- linux-2.4.37.7/drivers/usb/brlvger.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/brlvger.c	2009-11-10 19:30:27.000000000 -0500
@@ -228,8 +228,7 @@ static struct usb_device_id brlvger_ids 
 };
 MODULE_DEVICE_TABLE (usb, brlvger_ids);
 
-static struct file_operations brlvger_fops =
-{
+static const struct file_operations brlvger_fops = {
 	owner:		THIS_MODULE,
 	llseek:		brlvger_llseek,
 	read:		brlvger_read,
diff -urNp linux-2.4.37.7/drivers/usb/dabusb.c linux-2.4.37.7/drivers/usb/dabusb.c
--- linux-2.4.37.7/drivers/usb/dabusb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/dabusb.c	2009-11-10 19:30:27.000000000 -0500
@@ -698,8 +698,7 @@ static int dabusb_ioctl (struct inode *i
 	return ret;
 }
 
-static struct file_operations dabusb_fops =
-{
+static const struct file_operations dabusb_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		dabusb_read,
diff -urNp linux-2.4.37.7/drivers/usb/devices.c linux-2.4.37.7/drivers/usb/devices.c
--- linux-2.4.37.7/drivers/usb/devices.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/devices.c	2009-11-10 19:30:27.000000000 -0500
@@ -664,7 +664,7 @@ static loff_t usb_device_lseek(struct fi
 	}
 }
 
-struct file_operations usbdevfs_devices_fops = {
+const struct file_operations usbdevfs_devices_fops = {
 	llseek:		usb_device_lseek,
 	read:		usb_device_read,
 	poll:		usb_device_poll,
diff -urNp linux-2.4.37.7/drivers/usb/devio.c linux-2.4.37.7/drivers/usb/devio.c
--- linux-2.4.37.7/drivers/usb/devio.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/devio.c	2009-11-10 19:30:27.000000000 -0500
@@ -1310,7 +1310,7 @@ static unsigned int usbdev_poll(struct f
 	return mask;
 }
 
-struct file_operations usbdevfs_device_file_operations = {
+const struct file_operations usbdevfs_device_file_operations = {
 	llseek:		usbdev_lseek,
 	read:		usbdev_read,
 	poll:		usbdev_poll,
diff -urNp linux-2.4.37.7/drivers/usb/drivers.c linux-2.4.37.7/drivers/usb/drivers.c
--- linux-2.4.37.7/drivers/usb/drivers.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/drivers.c	2009-11-10 19:30:27.000000000 -0500
@@ -113,7 +113,7 @@ static loff_t usb_driver_lseek(struct fi
 	}
 }
 
-struct file_operations usbdevfs_drivers_fops = {
+const struct file_operations usbdevfs_drivers_fops = {
 	llseek:		usb_driver_lseek,
 	read:		usb_driver_read,
 };
diff -urNp linux-2.4.37.7/drivers/usb/hiddev.c linux-2.4.37.7/drivers/usb/hiddev.c
--- linux-2.4.37.7/drivers/usb/hiddev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/hiddev.c	2009-11-10 19:30:27.000000000 -0500
@@ -686,7 +686,7 @@ static int hiddev_ioctl(struct inode *in
 	return -EINVAL;
 }
 
-static struct file_operations hiddev_fops = {
+static const struct file_operations hiddev_fops = {
 	owner:		THIS_MODULE,
 	read:		hiddev_read,
 	write:		hiddev_write,
diff -urNp linux-2.4.37.7/drivers/usb/host/uhci-debug.h linux-2.4.37.7/drivers/usb/host/uhci-debug.h
--- linux-2.4.37.7/drivers/usb/host/uhci-debug.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/host/uhci-debug.h	2009-11-10 19:30:27.000000000 -0500
@@ -561,7 +561,7 @@ static int uhci_proc_release(struct inod
 	return 0;
 }
 
-static struct file_operations uhci_proc_operations = {
+static const struct file_operations uhci_proc_operations = {
 	open:		uhci_proc_open,
 	llseek:		uhci_proc_lseek,
 	read:		uhci_proc_read,
diff -urNp linux-2.4.37.7/drivers/usb/inode.c linux-2.4.37.7/drivers/usb/inode.c
--- linux-2.4.37.7/drivers/usb/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -41,8 +41,8 @@
 #include <linux/usbdevice_fs.h>
 #include <asm/uaccess.h>
 
-static struct inode_operations usbdevfs_bus_inode_operations;
-static struct file_operations usbdevfs_bus_file_operations;
+static const struct inode_operations usbdevfs_bus_inode_operations;
+static const struct file_operations usbdevfs_bus_file_operations;
 
 /* --------------------------------------------------------------------- */
 
@@ -55,7 +55,7 @@ static LIST_HEAD(superlist);
 
 struct special {
 	const char *name;
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	struct inode *inode;
 	struct list_head inodes;
 };
@@ -313,7 +313,7 @@ static int usbdevfs_revalidate(struct de
 	return 1;
 }
 
-static struct dentry_operations usbdevfs_dentry_operations = {
+static const struct dentry_operations usbdevfs_dentry_operations = {
 	d_revalidate:	usbdevfs_revalidate,
 };
 
@@ -490,19 +490,19 @@ static int usbdevfs_bus_readdir(struct f
 	}
 }
 
-static struct file_operations usbdevfs_root_file_operations = {
+static const struct file_operations usbdevfs_root_file_operations = {
 	readdir: usbdevfs_root_readdir,
 };
 
-static struct inode_operations usbdevfs_root_inode_operations = {
+static const struct inode_operations usbdevfs_root_inode_operations = {
 	lookup: usbdevfs_root_lookup,
 };
 
-static struct file_operations usbdevfs_bus_file_operations = {
+static const struct file_operations usbdevfs_bus_file_operations = {
 	readdir: usbdevfs_bus_readdir,
 };
 
-static struct inode_operations usbdevfs_bus_inode_operations = {
+static const struct inode_operations usbdevfs_bus_inode_operations = {
 	lookup: usbdevfs_bus_lookup,
 };
 
@@ -595,7 +595,7 @@ static int usbdevfs_remount(struct super
 	return 0;
 }
 
-static struct super_operations usbdevfs_sops = { 
+static const struct super_operations usbdevfs_sops = { 
 	read_inode:	usbdevfs_read_inode,
 	put_super:	usbdevfs_put_super,
 	statfs:		usbdevfs_statfs,
diff -urNp linux-2.4.37.7/drivers/usb/mdc800.c linux-2.4.37.7/drivers/usb/mdc800.c
--- linux-2.4.37.7/drivers/usb/mdc800.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/mdc800.c	2009-11-10 19:30:27.000000000 -0500
@@ -916,8 +916,7 @@ static ssize_t mdc800_device_write (stru
 ****************************************************************************/
 
 /* File Operations of this drivers */
-static struct file_operations mdc800_device_ops =
-{
+static const struct file_operations mdc800_device_ops = {
 	owner:		THIS_MODULE,
 	read:		mdc800_device_read,
 	write:		mdc800_device_write,
diff -urNp linux-2.4.37.7/drivers/usb/ov511.c linux-2.4.37.7/drivers/usb/ov511.c
--- linux-2.4.37.7/drivers/usb/ov511.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/ov511.c	2009-11-10 19:30:27.000000000 -0500
@@ -410,7 +410,7 @@ rvfree(void *mem, unsigned long size)
 static struct proc_dir_entry *ov511_proc_entry = NULL;
 extern struct proc_dir_entry *video_proc_entry;
 
-static struct file_operations ov511_control_fops = {
+static const struct file_operations ov511_control_fops = {
 	.ioctl =	ov51x_control_ioctl,
 };
 
@@ -5284,7 +5284,7 @@ ov51x_v4l1_mmap(struct file *file, struc
 	return 0;
 }
 
-static struct file_operations ov511_fops = {
+static const struct file_operations ov511_fops = {
 	.owner =	THIS_MODULE,
 	.open =		ov51x_v4l1_open,
 	.release =	ov51x_v4l1_close,
diff -urNp linux-2.4.37.7/drivers/usb/printer.c linux-2.4.37.7/drivers/usb/printer.c
--- linux-2.4.37.7/drivers/usb/printer.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/printer.c	2009-11-10 19:30:27.000000000 -0500
@@ -818,7 +818,7 @@ static unsigned int usblp_quirks (__u16 
 	return 0;
 }
 
-static struct file_operations usblp_fops = {
+static const struct file_operations usblp_fops = {
 	owner:		THIS_MODULE,
 	read:		usblp_read,
 	write:		usblp_write,
diff -urNp linux-2.4.37.7/drivers/usb/rio500.c linux-2.4.37.7/drivers/usb/rio500.c
--- linux-2.4.37.7/drivers/usb/rio500.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/rio500.c	2009-11-10 19:30:27.000000000 -0500
@@ -436,8 +436,7 @@ read_rio(struct file *file, char *buffer
 	return read_count;
 }
 
-static struct
-file_operations usb_rio_fops = {
+static const struct file_operations usb_rio_fops = {
 	read:		read_rio,
 	write:		write_rio,
 	ioctl:		ioctl_rio,
diff -urNp linux-2.4.37.7/drivers/usb/scanner.c linux-2.4.37.7/drivers/usb/scanner.c
--- linux-2.4.37.7/drivers/usb/scanner.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/scanner.c	2009-11-10 19:30:27.000000000 -0500
@@ -852,8 +852,7 @@ ioctl_scanner(struct inode *inode, struc
 	return retval;
 }
 
-static struct
-file_operations usb_scanner_fops = {
+static const struct file_operations usb_scanner_fops = {
 	owner:		THIS_MODULE,
 	read:		read_scanner,
 	write:		write_scanner,
diff -urNp linux-2.4.37.7/drivers/usb/tiglusb.c linux-2.4.37.7/drivers/usb/tiglusb.c
--- linux-2.4.37.7/drivers/usb/tiglusb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/tiglusb.c	2009-11-10 19:30:27.000000000 -0500
@@ -311,7 +311,7 @@ tiglusb_ioctl (struct inode *inode, stru
 
 /* ----- kernel module registering ------------------------------------ */
 
-static struct file_operations tiglusb_fops = {
+static const struct file_operations tiglusb_fops = {
 	.owner =        THIS_MODULE,
 	.llseek =	no_llseek,
 	.read =		tiglusb_read,
diff -urNp linux-2.4.37.7/drivers/usb/usb.c linux-2.4.37.7/drivers/usb/usb.c
--- linux-2.4.37.7/drivers/usb/usb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/usb.c	2009-11-10 19:30:27.000000000 -0500
@@ -2324,7 +2324,7 @@ static int usb_open(struct inode * inode
 	int minor = MINOR(inode->i_rdev);
 	struct usb_driver *c = usb_minors[minor/16];
 	int err = -ENODEV;
-	struct file_operations *old_fops, *new_fops = NULL;
+	const struct file_operations *old_fops, *new_fops = NULL;
 
 	/*
 	 * No load-on-demand? Randy, could you ACK that it's really not
@@ -2345,7 +2345,7 @@ static int usb_open(struct inode * inode
 	return err;
 }
 
-static struct file_operations usb_fops = {
+static const struct file_operations usb_fops = {
 	owner:		THIS_MODULE,
 	open:		usb_open,
 };
diff -urNp linux-2.4.37.7/drivers/usb/usblcd.c linux-2.4.37.7/drivers/usb/usblcd.c
--- linux-2.4.37.7/drivers/usb/usblcd.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/usblcd.c	2009-11-10 19:30:27.000000000 -0500
@@ -300,8 +300,7 @@ static struct usb_device_id id_table [] 
 
 MODULE_DEVICE_TABLE (usb, id_table);
 
-static struct
-file_operations usb_lcd_fops = {
+static const struct file_operations usb_lcd_fops = {
 	.owner =	THIS_MODULE,
 	.read =		read_lcd,
 	.write =	write_lcd,
diff -urNp linux-2.4.37.7/drivers/usb/usb-midi.c linux-2.4.37.7/drivers/usb/usb-midi.c
--- linux-2.4.37.7/drivers/usb/usb-midi.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/usb-midi.c	2009-11-10 19:30:27.000000000 -0500
@@ -989,7 +989,7 @@ static int usb_midi_release(struct inode
 	return 0;
 }
 
-static struct file_operations usb_midi_fops = {
+static const struct file_operations usb_midi_fops = {
 	llseek:		usb_midi_llseek,
 	read:		usb_midi_read,
 	write:		usb_midi_write,
diff -urNp linux-2.4.37.7/drivers/usb/usb-skeleton.c linux-2.4.37.7/drivers/usb/usb-skeleton.c
--- linux-2.4.37.7/drivers/usb/usb-skeleton.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/usb-skeleton.c	2009-11-10 19:30:27.000000000 -0500
@@ -150,7 +150,7 @@ static DECLARE_MUTEX (minor_table_mutex)
  * would use "struct net_driver" instead, and a serial
  * device would use "struct tty_driver". 
  */
-static struct file_operations skel_fops = {
+static const struct file_operations skel_fops = {
 	/*
 	 * The owner field is part of the module-locking
 	 * mechanism. The idea is that the kernel knows
diff -urNp linux-2.4.37.7/drivers/usb/w9968cf.c linux-2.4.37.7/drivers/usb/w9968cf.c
--- linux-2.4.37.7/drivers/usb/w9968cf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/usb/w9968cf.c	2009-11-10 19:30:27.000000000 -0500
@@ -375,7 +375,7 @@ MODULE_PARM_DESC(specific_debug,
  ****************************************************************************/
 
 /* Video4linux interface */
-static struct file_operations w9968cf_fops;
+static const struct file_operations w9968cf_fops;
 static int w9968cf_open(struct inode*, struct file*);
 static int w9968cf_release(struct inode*, struct file*);
 static ssize_t w9968cf_read(struct file*, char*, size_t, loff_t*);
@@ -3708,7 +3708,7 @@ ioctl_fail:
 }
 
 
-static struct file_operations w9968cf_fops = {
+static const struct file_operations w9968cf_fops = {
 	.owner =   THIS_MODULE,
 	.open =    w9968cf_open,
 	.release = w9968cf_release,
diff -urNp linux-2.4.37.7/drivers/video/fbmem.c linux-2.4.37.7/drivers/video/fbmem.c
--- linux-2.4.37.7/drivers/video/fbmem.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/video/fbmem.c	2009-11-10 19:30:27.000000000 -0500
@@ -748,7 +748,7 @@ fb_release(struct inode *inode, struct f
 	return 0;
 }
 
-static struct file_operations fb_fops = {
+static const struct file_operations fb_fops = {
 	owner:		THIS_MODULE,
 	read:		fb_read,
 	write:		fb_write,
diff -urNp linux-2.4.37.7/drivers/video/vesafb.c linux-2.4.37.7/drivers/video/vesafb.c
--- linux-2.4.37.7/drivers/video/vesafb.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/video/vesafb.c	2009-11-10 19:30:27.000000000 -0500
@@ -546,7 +546,7 @@ int __init vesafb_init(void)
 	video_visual = (video_bpp == 8) ?
 		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
 
-#ifndef __i386__
+#if !defined(__i386__) || defined(CONFIG_PAX_KERNEXEC)
 	screen_info.vesapm_seg = 0;
 #endif
 
diff -urNp linux-2.4.37.7/drivers/zorro/proc.c linux-2.4.37.7/drivers/zorro/proc.c
--- linux-2.4.37.7/drivers/zorro/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/drivers/zorro/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -70,7 +70,7 @@ proc_bus_zorro_read(struct file *file, c
 	return nbytes;
 }
 
-static struct file_operations proc_bus_zorro_operations = {
+static const struct file_operations proc_bus_zorro_operations = {
 	llseek:		proc_bus_zorro_lseek,
 	read:		proc_bus_zorro_read,
 };
diff -urNp linux-2.4.37.7/fs/adfs/adfs.h linux-2.4.37.7/fs/adfs/adfs.h
--- linux-2.4.37.7/fs/adfs/adfs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/adfs/adfs.h	2009-11-10 19:30:27.000000000 -0500
@@ -95,17 +95,17 @@ extern struct dentry *adfs_lookup(struct
  */
 
 /* dir_*.c */
-extern struct inode_operations adfs_dir_inode_operations;
-extern struct file_operations adfs_dir_operations;
-extern struct dentry_operations adfs_dentry_operations;
+extern const struct inode_operations adfs_dir_inode_operations;
+extern const struct file_operations adfs_dir_operations;
+extern const struct dentry_operations adfs_dentry_operations;
 extern struct adfs_dir_ops adfs_f_dir_ops;
 extern struct adfs_dir_ops adfs_fplus_dir_ops;
 
 extern int adfs_dir_update(struct super_block *sb, struct object_info *obj);
 
 /* file.c */
-extern struct inode_operations adfs_file_inode_operations;
-extern struct file_operations adfs_file_operations;
+extern const struct inode_operations adfs_file_inode_operations;
+extern const struct file_operations adfs_file_operations;
 
 extern inline __u32 signed_asl(__u32 val, signed int shift)
 {
diff -urNp linux-2.4.37.7/fs/adfs/dir.c linux-2.4.37.7/fs/adfs/dir.c
--- linux-2.4.37.7/fs/adfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/adfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -192,7 +192,7 @@ out:
 	return ret;
 }
 
-struct file_operations adfs_dir_operations = {
+const struct file_operations adfs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	adfs_readdir,
 	fsync:		file_fsync,
@@ -259,7 +259,7 @@ adfs_compare(struct dentry *parent, stru
 	return 0;
 }
 
-struct dentry_operations adfs_dentry_operations = {
+const struct dentry_operations adfs_dentry_operations = {
 	d_hash:		adfs_hash,
 	d_compare:	adfs_compare,
 };
@@ -289,7 +289,7 @@ struct dentry *adfs_lookup(struct inode 
 /*
  * directories can handle most operations...
  */
-struct inode_operations adfs_dir_inode_operations = {
+const struct inode_operations adfs_dir_inode_operations = {
 	lookup:		adfs_lookup,
 	setattr:	adfs_notify_change,
 };
diff -urNp linux-2.4.37.7/fs/adfs/file.c linux-2.4.37.7/fs/adfs/file.c
--- linux-2.4.37.7/fs/adfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/adfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,7 +28,7 @@
 
 #include "adfs.h"
 
-struct file_operations adfs_file_operations = {
+const struct file_operations adfs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	mmap:		generic_file_mmap,
@@ -36,6 +36,6 @@ struct file_operations adfs_file_operati
 	write:		generic_file_write,
 };
 
-struct inode_operations adfs_file_inode_operations = {
+const struct inode_operations adfs_file_inode_operations = {
 	setattr:	adfs_notify_change,
 };
diff -urNp linux-2.4.37.7/fs/adfs/inode.c linux-2.4.37.7/fs/adfs/inode.c
--- linux-2.4.37.7/fs/adfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/adfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -76,7 +76,7 @@ static int _adfs_bmap(struct address_spa
 	return generic_block_bmap(mapping, block, adfs_get_block);
 }
 
-static struct address_space_operations adfs_aops = {
+static const struct address_space_operations adfs_aops = {
 	readpage:	adfs_readpage,
 	writepage:	adfs_writepage,
 	sync_page:	block_sync_page,
diff -urNp linux-2.4.37.7/fs/adfs/super.c linux-2.4.37.7/fs/adfs/super.c
--- linux-2.4.37.7/fs/adfs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/adfs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -232,7 +232,7 @@ static int adfs_statfs(struct super_bloc
 	return 0;
 }
 
-static struct super_operations adfs_sops = {
+static const struct super_operations adfs_sops = {
 	write_inode:	adfs_write_inode,
 	put_super:	adfs_put_super,
 	statfs:		adfs_statfs,
diff -urNp linux-2.4.37.7/fs/affs/dir.c linux-2.4.37.7/fs/affs/dir.c
--- linux-2.4.37.7/fs/affs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -25,7 +25,7 @@
 
 static int affs_readdir(struct file *, void *, filldir_t);
 
-struct file_operations affs_dir_operations = {
+const struct file_operations affs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	affs_readdir,
 	fsync:		file_fsync,
@@ -34,7 +34,7 @@ struct file_operations affs_dir_operatio
 /*
  * directories can handle most operations...
  */
-struct inode_operations affs_dir_inode_operations = {
+const struct inode_operations affs_dir_inode_operations = {
 	create:		affs_create,
 	lookup:		affs_lookup,
 	link:		affs_link,
diff -urNp linux-2.4.37.7/fs/affs/file.c linux-2.4.37.7/fs/affs/file.c
--- linux-2.4.37.7/fs/affs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,7 +44,7 @@ static ssize_t affs_file_write(struct fi
 static int affs_file_open(struct inode *inode, struct file *filp);
 static int affs_file_release(struct inode *inode, struct file *filp);
 
-struct file_operations affs_file_operations = {
+const struct file_operations affs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		affs_file_write,
@@ -54,7 +54,7 @@ struct file_operations affs_file_operati
 	fsync:		file_fsync,
 };
 
-struct inode_operations affs_file_inode_operations = {
+const struct inode_operations affs_file_inode_operations = {
 	truncate:	affs_truncate,
 	setattr:	affs_notify_change,
 };
@@ -427,7 +427,7 @@ static int _affs_bmap(struct address_spa
 {
 	return generic_block_bmap(mapping,block,affs_get_block);
 }
-struct address_space_operations affs_aops = {
+const struct address_space_operations affs_aops = {
 	readpage: affs_readpage,
 	writepage: affs_writepage,
 	sync_page: block_sync_page,
@@ -787,7 +787,7 @@ out:
 	goto done;
 }
 
-struct address_space_operations affs_aops_ofs = {
+const struct address_space_operations affs_aops_ofs = {
 	readpage: affs_readpage_ofs,
 	//writepage: affs_writepage_ofs,
 	//sync_page: affs_sync_page_ofs,
diff -urNp linux-2.4.37.7/fs/affs/inode.c linux-2.4.37.7/fs/affs/inode.c
--- linux-2.4.37.7/fs/affs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -31,7 +31,7 @@
 #include <asm/uaccess.h>
 #include <linux/module.h>
 
-extern struct inode_operations affs_symlink_inode_operations;
+extern const struct inode_operations affs_symlink_inode_operations;
 extern struct timezone sys_tz;
 
 void
diff -urNp linux-2.4.37.7/fs/affs/namei.c linux-2.4.37.7/fs/affs/namei.c
--- linux-2.4.37.7/fs/affs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,7 +22,7 @@
 
 typedef int (*toupper_t)(int);
 
-extern struct inode_operations affs_symlink_inode_operations;
+extern const struct inode_operations affs_symlink_inode_operations;
 
 static int	 affs_toupper(int ch);
 static int	 affs_hash_dentry(struct dentry *, struct qstr *);
@@ -31,12 +31,12 @@ static int	 affs_intl_toupper(int ch);
 static int	 affs_intl_hash_dentry(struct dentry *, struct qstr *);
 static int       affs_intl_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 
-struct dentry_operations affs_dentry_operations = {
+const struct dentry_operations affs_dentry_operations = {
 	d_hash:		affs_hash_dentry,
 	d_compare:	affs_compare_dentry,
 };
 
-struct dentry_operations affs_intl_dentry_operations = {
+const struct dentry_operations affs_intl_dentry_operations = {
 	d_hash:		affs_intl_hash_dentry,
 	d_compare:	affs_intl_compare_dentry,
 };
diff -urNp linux-2.4.37.7/fs/affs/super.c linux-2.4.37.7/fs/affs/super.c
--- linux-2.4.37.7/fs/affs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -77,7 +77,7 @@ affs_write_super(struct super_block *sb)
 	pr_debug("AFFS: write_super() at %lu, clean=%d\n", CURRENT_TIME, clean);
 }
 
-static struct super_operations affs_sops = {
+static const struct super_operations affs_sops = {
 	read_inode:	affs_read_inode,
 	write_inode:	affs_write_inode,
 	put_inode:	affs_put_inode,
diff -urNp linux-2.4.37.7/fs/affs/symlink.c linux-2.4.37.7/fs/affs/symlink.c
--- linux-2.4.37.7/fs/affs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/affs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -76,11 +76,11 @@ fail:
 	return err;
 }
 
-struct address_space_operations affs_symlink_aops = {
+const struct address_space_operations affs_symlink_aops = {
 	readpage:	affs_symlink_readpage,
 };
 
-struct inode_operations affs_symlink_inode_operations = {
+const struct inode_operations affs_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 	setattr:	affs_notify_change,
diff -urNp linux-2.4.37.7/fs/autofs/autofs_i.h linux-2.4.37.7/fs/autofs/autofs_i.h
--- linux-2.4.37.7/fs/autofs/autofs_i.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs/autofs_i.h	2009-11-10 19:30:27.000000000 -0500
@@ -137,10 +137,10 @@ struct autofs_dir_ent *autofs_expire(str
 
 /* Operations structures */
 
-extern struct inode_operations autofs_root_inode_operations;
-extern struct inode_operations autofs_symlink_inode_operations;
-extern struct inode_operations autofs_dir_inode_operations;
-extern struct file_operations autofs_root_operations;
+extern const struct inode_operations autofs_root_inode_operations;
+extern const struct inode_operations autofs_symlink_inode_operations;
+extern const struct inode_operations autofs_dir_inode_operations;
+extern const struct file_operations autofs_root_operations;
 
 /* Initializing function */
 
diff -urNp linux-2.4.37.7/fs/autofs/dir.c linux-2.4.37.7/fs/autofs/dir.c
--- linux-2.4.37.7/fs/autofs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -23,7 +23,7 @@ static struct dentry *autofs_dir_lookup(
 	return NULL;
 }
 
-struct inode_operations autofs_dir_inode_operations = {
+const struct inode_operations autofs_dir_inode_operations = {
 	lookup:		autofs_dir_lookup,
 };
 
diff -urNp linux-2.4.37.7/fs/autofs/inode.c linux-2.4.37.7/fs/autofs/inode.c
--- linux-2.4.37.7/fs/autofs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -41,7 +41,7 @@ static void autofs_put_super(struct supe
 static int autofs_statfs(struct super_block *sb, struct statfs *buf);
 static void autofs_read_inode(struct inode *inode);
 
-static struct super_operations autofs_sops = {
+static const struct super_operations autofs_sops = {
 	read_inode:	autofs_read_inode,
 	put_super:	autofs_put_super,
 	statfs:		autofs_statfs,
diff -urNp linux-2.4.37.7/fs/autofs/root.c linux-2.4.37.7/fs/autofs/root.c
--- linux-2.4.37.7/fs/autofs/root.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs/root.c	2009-11-10 19:30:27.000000000 -0500
@@ -25,13 +25,13 @@ static int autofs_root_rmdir(struct inod
 static int autofs_root_mkdir(struct inode *,struct dentry *,int);
 static int autofs_root_ioctl(struct inode *, struct file *,unsigned int,unsigned long);
 
-struct file_operations autofs_root_operations = {
+const struct file_operations autofs_root_operations = {
 	read:		generic_read_dir,
 	readdir:	autofs_root_readdir,
 	ioctl:		autofs_root_ioctl,
 };
 
-struct inode_operations autofs_root_inode_operations = {
+const struct inode_operations autofs_root_inode_operations = {
         lookup:		autofs_root_lookup,
         unlink:		autofs_root_unlink,
         symlink:	autofs_root_symlink,
@@ -187,7 +187,7 @@ static int autofs_revalidate(struct dent
 	return 1;
 }
 
-static struct dentry_operations autofs_dentry_operations = {
+static const struct dentry_operations autofs_dentry_operations = {
 	d_revalidate:	autofs_revalidate,
 };
 
diff -urNp linux-2.4.37.7/fs/autofs/symlink.c linux-2.4.37.7/fs/autofs/symlink.c
--- linux-2.4.37.7/fs/autofs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -24,7 +24,7 @@ static int autofs_follow_link(struct den
 	return vfs_follow_link(nd, s);
 }
 
-struct inode_operations autofs_symlink_inode_operations = {
+const struct inode_operations autofs_symlink_inode_operations = {
 	readlink:	autofs_readlink,
 	follow_link:	autofs_follow_link
 };
diff -urNp linux-2.4.37.7/fs/autofs4/autofs_i.h linux-2.4.37.7/fs/autofs4/autofs_i.h
--- linux-2.4.37.7/fs/autofs4/autofs_i.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs4/autofs_i.h	2009-11-10 19:30:27.000000000 -0500
@@ -136,10 +136,10 @@ int autofs4_expire_multi(struct super_bl
 
 /* Operations structures */
 
-extern struct inode_operations autofs4_symlink_inode_operations;
-extern struct inode_operations autofs4_dir_inode_operations;
-extern struct inode_operations autofs4_root_inode_operations;
-extern struct file_operations autofs4_root_operations;
+extern const struct inode_operations autofs4_symlink_inode_operations;
+extern const struct inode_operations autofs4_dir_inode_operations;
+extern const struct inode_operations autofs4_root_inode_operations;
+extern const struct file_operations autofs4_root_operations;
 
 /* Initializing function */
 
diff -urNp linux-2.4.37.7/fs/autofs4/inode.c linux-2.4.37.7/fs/autofs4/inode.c
--- linux-2.4.37.7/fs/autofs4/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs4/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -92,7 +92,7 @@ static void autofs4_put_super(struct sup
 
 static int autofs4_statfs(struct super_block *sb, struct statfs *buf);
 
-static struct super_operations autofs4_sops = {
+static const struct super_operations autofs4_sops = {
 	put_super:	autofs4_put_super,
 	statfs:		autofs4_statfs,
 };
diff -urNp linux-2.4.37.7/fs/autofs4/root.c linux-2.4.37.7/fs/autofs4/root.c
--- linux-2.4.37.7/fs/autofs4/root.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs4/root.c	2009-11-10 19:30:27.000000000 -0500
@@ -26,7 +26,7 @@ static int autofs4_dir_mkdir(struct inod
 static int autofs4_root_ioctl(struct inode *, struct file *,unsigned int,unsigned long);
 static struct dentry *autofs4_root_lookup(struct inode *,struct dentry *);
 
-struct file_operations autofs4_root_operations = {
+const struct file_operations autofs4_root_operations = {
 	open:		dcache_dir_open,
 	release:	dcache_dir_close,
 	llseek:		dcache_dir_lseek,
@@ -36,7 +36,7 @@ struct file_operations autofs4_root_oper
 	ioctl:		autofs4_root_ioctl,
 };
 
-struct inode_operations autofs4_root_inode_operations = {
+const struct inode_operations autofs4_root_inode_operations = {
 	lookup:		autofs4_root_lookup,
 	unlink:		autofs4_dir_unlink,
 	symlink:	autofs4_dir_symlink,
@@ -44,7 +44,7 @@ struct inode_operations autofs4_root_ino
 	rmdir:		autofs4_dir_rmdir,
 };
 
-struct inode_operations autofs4_dir_inode_operations = {
+const struct inode_operations autofs4_dir_inode_operations = {
 	lookup:		autofs4_dir_lookup,
 	unlink:		autofs4_dir_unlink,
 	symlink:	autofs4_dir_symlink,
@@ -216,13 +216,13 @@ static void autofs4_dentry_release(struc
 }
 
 /* For dentries of directories in the root dir */
-static struct dentry_operations autofs4_root_dentry_operations = {
+static const struct dentry_operations autofs4_root_dentry_operations = {
 	d_revalidate:	autofs4_root_revalidate,
 	d_release:	autofs4_dentry_release,
 };
 
 /* For other dentries */
-static struct dentry_operations autofs4_dentry_operations = {
+static const struct dentry_operations autofs4_dentry_operations = {
 	d_revalidate:	autofs4_revalidate,
 	d_release:	autofs4_dentry_release,
 };
diff -urNp linux-2.4.37.7/fs/autofs4/symlink.c linux-2.4.37.7/fs/autofs4/symlink.c
--- linux-2.4.37.7/fs/autofs4/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/autofs4/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -26,7 +26,7 @@ static int autofs4_follow_link(struct de
 	return vfs_follow_link(nd, ino->u.symlink);
 }
 
-struct inode_operations autofs4_symlink_inode_operations = {
+const struct inode_operations autofs4_symlink_inode_operations = {
 	readlink:	autofs4_readlink,
 	follow_link:	autofs4_follow_link
 };
diff -urNp linux-2.4.37.7/fs/bad_inode.c linux-2.4.37.7/fs/bad_inode.c
--- linux-2.4.37.7/fs/bad_inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/bad_inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -90,8 +90,7 @@ static int bad_follow_link(struct dentry
 	return vfs_follow_link(nd, ERR_PTR(-EIO));
 }
 
-static struct file_operations bad_file_ops =
-{
+static const struct file_operations bad_file_ops = {
 	llseek:		bad_file_llseek,
 	read:		bad_file_read,
 	write:		bad_file_write,
@@ -175,8 +174,7 @@ static int bad_inode_revalidate(struct d
 	return -EIO;
 }
 
-struct inode_operations bad_inode_ops =
-{
+const struct inode_operations bad_inode_ops = {
 	create:		bad_inode_create,
 	lookup:		bad_inode_lookup,
 	link:		bad_inode_link,
diff -urNp linux-2.4.37.7/fs/befs/linuxvfs.c linux-2.4.37.7/fs/befs/linuxvfs.c
--- linux-2.4.37.7/fs/befs/linuxvfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/befs/linuxvfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -66,31 +66,31 @@ static const struct super_operations bef
 	remount_fs:befs_remount,
 };
 
-struct file_operations befs_dir_operations = {
+const struct file_operations befs_dir_operations = {
 	read:generic_read_dir,
 	readdir:befs_readdir,
 };
 
-struct inode_operations befs_dir_inode_operations = {
+const struct inode_operations befs_dir_inode_operations = {
 	lookup:befs_lookup,
 };
 
-struct file_operations befs_file_operations = {
+const struct file_operations befs_file_operations = {
 	llseek:default_llseek,
 	read:generic_file_read,
 	mmap:generic_file_mmap,
 };
 
-struct inode_operations befs_file_inode_operations = {
+const struct inode_operations befs_file_inode_operations = {
 };
 
-struct address_space_operations befs_aops = {
+const struct address_space_operations befs_aops = {
 	readpage:befs_readpage,
 	sync_page:block_sync_page,
 	bmap:befs_bmap,
 };
 
-static struct inode_operations befs_symlink_inode_operations = {
+static const struct inode_operations befs_symlink_inode_operations = {
 	readlink:befs_readlink,
 	follow_link:befs_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/bfs/dir.c linux-2.4.37.7/fs/bfs/dir.c
--- linux-2.4.37.7/fs/bfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/bfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -65,7 +65,7 @@ static int bfs_readdir(struct file * f, 
 	return 0;	
 }
 
-struct file_operations bfs_dir_operations = {
+const struct file_operations bfs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	bfs_readdir,
 	fsync:		file_fsync,
@@ -243,7 +243,7 @@ end_rename:
 	return error;
 }
 
-struct inode_operations bfs_dir_inops = {
+const struct inode_operations bfs_dir_inops = {
 	create:			bfs_create,
 	lookup:			bfs_lookup,
 	link:			bfs_link,
diff -urNp linux-2.4.37.7/fs/bfs/file.c linux-2.4.37.7/fs/bfs/file.c
--- linux-2.4.37.7/fs/bfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/bfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -18,7 +18,7 @@
 #define dprintf(x...)
 #endif
 
-struct file_operations bfs_file_operations = {
+const struct file_operations bfs_file_operations = {
 	llseek: generic_file_llseek,
 	read:	generic_file_read,
 	write:	generic_file_write,
@@ -156,7 +156,7 @@ static int bfs_bmap(struct address_space
 	return generic_block_bmap(mapping, block, bfs_get_block);
 }
 
-struct address_space_operations bfs_aops = {
+const struct address_space_operations bfs_aops = {
 	readpage:	bfs_readpage,
 	writepage:	bfs_writepage,
 	sync_page:	block_sync_page,
@@ -165,4 +165,4 @@ struct address_space_operations bfs_aops
 	bmap:		bfs_bmap,
 };
 
-struct inode_operations bfs_file_inops;
+const struct inode_operations bfs_file_inops;
diff -urNp linux-2.4.37.7/fs/bfs/inode.c linux-2.4.37.7/fs/bfs/inode.c
--- linux-2.4.37.7/fs/bfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/bfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -209,7 +209,7 @@ static void bfs_write_super(struct super
 	s->s_dirt = 0;
 }
 
-static struct super_operations bfs_sops = {
+static const struct super_operations bfs_sops = {
 	read_inode:	bfs_read_inode,
 	write_inode:	bfs_write_inode,
 	delete_inode:	bfs_delete_inode,
diff -urNp linux-2.4.37.7/fs/binfmt_aout.c linux-2.4.37.7/fs/binfmt_aout.c
--- linux-2.4.37.7/fs/binfmt_aout.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/binfmt_aout.c	2009-11-10 19:30:27.000000000 -0500
@@ -121,10 +121,12 @@ static int aout_core_dump(long signr, st
 /* If the size of the dump file exceeds the rlimit, then see what would happen
    if we wrote the stack, but not the data area.  */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_dsize+dump.u_ssize, 1);
 	if ((dump.u_dsize+dump.u_ssize) >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE, 1);
 	if ((dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
@@ -132,10 +134,12 @@ static int aout_core_dump(long signr, st
 
 /* Make sure we have enough room to write the stack and data areas. */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_ssize, 1);
 	if ((dump.u_ssize) >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_ssize+1) * PAGE_SIZE, 1);
 	if ((dump.u_ssize+1) * PAGE_SIZE >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
@@ -284,6 +288,8 @@ static int load_aout_binary(struct linux
 	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
+
+	gr_learn_resource(current, RLIMIT_DATA, ex.a_data + ex.a_bss, 1);
 	if (ex.a_data + ex.a_bss > rlim)
 		return -ENOMEM;
 
@@ -315,6 +321,28 @@ static int load_aout_binary(struct linux
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->mm->pax_flags |= MF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->mm->pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))
+			current->mm->pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -408,7 +436,7 @@ static int load_aout_binary(struct linux
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -urNp linux-2.4.37.7/fs/binfmt_elf.c linux-2.4.37.7/fs/binfmt_elf.c
--- linux-2.4.37.7/fs/binfmt_elf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/binfmt_elf.c	2009-11-10 19:30:27.000000000 -0500
@@ -33,15 +33,23 @@
 #include <linux/smp_lock.h>
 #include <linux/compiler.h>
 #include <linux/highmem.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/pgalloc.h>
+#include <asm/system.h>
 
 #define DLINFO_ITEMS 13
 
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_HOOK_ACL_FLAGS
+void (*pax_set_flags_func)(struct linux_binprm * bprm);
+EXPORT_SYMBOL(pax_set_flags_func);
+#endif
+
 static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs);
 static int load_elf_library(struct file*);
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
@@ -81,18 +89,22 @@ static struct linux_binfmt elf_format = 
 
 static int set_brk(unsigned long start, unsigned long end)
 {
+	unsigned long e = end, retval;
+
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
+
+	down_write(&current->mm->mmap_sem);
 	if (end > start) {
-		unsigned long addr;
-		down_write(&current->mm->mmap_sem);
-		addr = do_brk(start, end - start);
-		up_write(&current->mm->mmap_sem);
-		if (BAD_ADDR(addr))
-			return addr;
+		retval = do_brk(start, end - start);
+		if (BAD_ADDR(retval))
+			goto out;
 	}
-	current->mm->start_brk = current->mm->brk = end;
-	return 0;
+	current->mm->start_brk = current->mm->brk = e;
+	retval = 0UL;
+out:
+	up_write(&current->mm->mmap_sem);
+	return retval;
 }
 
 
@@ -275,7 +287,7 @@ static unsigned long load_elf_interp(str
 	unsigned long load_addr = 0;
 	int load_addr_set = 0;
 	unsigned long last_bss = 0, elf_bss = 0;
-	unsigned long error = ~0UL;
+	unsigned long error = -EINVAL;
 	int retval, i, size;
 
 	/* First of all, some simple consistency checks */
@@ -397,6 +409,8 @@ static unsigned long load_elf_interp(str
 	 * switch to out-of-band error reporting.
 	 */
 	error = ((unsigned long) interp_elf_ex->e_entry) + load_addr;
+	if (BAD_ADDR(error))
+		error = -EFAULT;
 
 out_close:
 	kfree(elf_phdata);
@@ -407,7 +421,7 @@ out:
 static unsigned long load_aout_interp(struct exec * interp_ex,
 			     struct file * interpreter)
 {
-	unsigned long text_data, elf_entry = ~0UL;
+	unsigned long text_data, elf_entry = -EINVAL;
 	char * addr;
 	loff_t offset;
 
@@ -452,6 +466,171 @@ out:
 	return elf_entry;
 }
 
+#if (defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)) && defined(CONFIG_PAX_SOFTMODE)
+static unsigned long pax_parse_softmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (elf_phdata->p_flags & PF_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (elf_phdata->p_flags & PF_SEGMEXEC) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (elf_phdata->p_flags & PF_EMUTRAMP)
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (elf_phdata->p_flags & PF_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (elf_phdata->p_flags & PF_RANDMMAP)
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+static unsigned long pax_parse_hardmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC)) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (!(elf_phdata->p_flags & PF_NORANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC)) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+static long pax_parse_elf_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	unsigned long i;
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+	pax_flags = pax_parse_ei_pax(elf_ex);
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	for (i = 0UL; i < elf_ex->e_phnum; i++)
+		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+				return -EINVAL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+			if (pax_softmode)
+				pax_flags = pax_parse_softmode(&elf_phdata[i]);
+			else
+#endif
+
+				pax_flags = pax_parse_hardmode(&elf_phdata[i]);
+			break;
+		}
+#endif
+
+	if (0 > pax_check_flags(&pax_flags))
+		return -EINVAL;
+
+	current->mm->pax_flags = pax_flags;
+	return 0;
+}
+#endif
+
 /*
  * These are the functions used to load ELF style executables and shared
  * libraries.  There is no binary dependent code anywhere else.
@@ -484,7 +663,7 @@ static int load_elf_binary(struct linux_
   	struct exec interp_ex;
 	char passed_fileno[6];
 	struct files_struct *files;
-	
+
 	/* Get the exec-header */
 	elf_ex = *((struct elfhdr *) bprm->buf);
 
@@ -684,7 +863,47 @@ static int load_elf_binary(struct linux_
 	current->mm->end_data = 0;
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	current->mm->call_dl_resolve = 0UL;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	current->mm->call_syscall = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	current->mm->delta_mmap = 0UL;
+	current->mm->delta_stack = 0UL;
+#endif
+
 	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+	if (0 > pax_parse_elf_flags(&elf_ex, elf_phdata)) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+#endif
+
+#if defined(CONFIG_PAX_HAVE_ACL_FLAGS) && (defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR))
+	pax_set_initial_flags(bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	if (pax_set_initial_flags_func)
+		(*pax_set_initial_flags_func)(bprm);
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+		current->mm->delta_mmap = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN)-1)) << PAGE_SHIFT;
+		current->mm->delta_stack = (net_random() & ((1UL << PAX_DELTA_STACK_LEN)-1)) << PAGE_SHIFT;
+	}
+#endif
+
 	elf_entry = (unsigned long) elf_ex.e_entry;
 
 	/* Do this so that we can load the interpreter, if need be.  We will
@@ -693,7 +912,7 @@ static int load_elf_binary(struct linux_
 	retval = setup_arg_pages(bprm);
 	if (retval < 0) {
 		send_sig(SIGKILL, current, 0);
-		return retval;
+		goto out_free_dentry;
 	}
 	
 	current->mm->start_stack = bprm->p;
@@ -745,6 +964,20 @@ static int load_elf_binary(struct linux_
 			   base, as well as whatever program they might try to exec.  This
 		           is because the brk will follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+
+#ifdef CONFIG_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && elf_interpreter) {
+#ifdef __sparc_v9__
+				load_bias = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << (PAGE_SHIFT+1);
+#else
+				load_bias = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << PAGE_SHIFT;
+#endif
+				load_bias = ELF_PAGESTART(PAX_ELF_ET_DYN_BASE - vaddr + load_bias);
+				elf_flags |= MAP_FIXED;
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
@@ -801,6 +1034,11 @@ static int load_elf_binary(struct linux_
 	start_data += load_bias;
 	end_data += load_bias;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		elf_brk += PAGE_SIZE + ((net_random() & ~PAGE_MASK) << 4);
+#endif
+
 	/* Calling set_brk effectively mmaps the pages that we need
 	 * for the bss and break sections.  We must do this before
 	 * mapping in the interpreter, to make sure it doesn't wind
@@ -907,6 +1145,10 @@ static int load_elf_binary(struct linux_
 	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_switch_segments(current);
+#endif
+
 	start_thread(regs, elf_entry, bprm->p);
 	if (current->ptrace & PT_PTRACED)
 		send_sig(SIGTRAP, current, 0);
@@ -1052,7 +1294,7 @@ static int dump_seek(struct file *file, 
  *
  * I think we should skip something. But I am not sure how. H.J.
  */
-static inline int maydump(struct vm_area_struct *vma)
+static inline int maydump(struct vm_area_struct *vma, long signr)
 {
 	/*
 	 * If we may not read the contents, don't allow us to dump
@@ -1064,12 +1306,15 @@ static inline int maydump(struct vm_area
 	/* Do not dump I/O mapped devices! -DaveM */
 	if (vma->vm_flags & VM_IO)
 		return 0;
-#if 1
+
+	if (signr == SIGKILL)
+		return 1;
+
 	if (vma->vm_flags & (VM_WRITE|VM_GROWSUP|VM_GROWSDOWN))
 		return 1;
 	if (vma->vm_flags & (VM_READ|VM_EXEC|VM_EXECUTABLE|VM_SHARED))
 		return 0;
-#endif
+
 	return 1;
 }
 
@@ -1141,8 +1386,11 @@ static int writenote(struct memelfnote *
 #undef DUMP_SEEK
 
 #define DUMP_WRITE(addr, nr)	\
+	do { \
+	gr_learn_resource(current, RLIMIT_CORE, size + (nr), 1); \
 	if ((size += (nr)) > limit || !dump_write(file, (addr), (nr))) \
-		goto end_coredump;
+		goto end_coredump; \
+	} while (0);
 #define DUMP_SEEK(off)	\
 	if (!dump_seek(file, (off))) \
 		goto end_coredump;
@@ -1341,7 +1589,7 @@ static int elf_core_dump(long signr, str
 		phdr.p_offset = offset;
 		phdr.p_vaddr = vma->vm_start;
 		phdr.p_paddr = 0;
-		phdr.p_filesz = maydump(vma) ? sz : 0;
+		phdr.p_filesz = maydump(vma, signr) ? sz : 0;
 		phdr.p_memsz = sz;
 		offset += phdr.p_filesz;
 		phdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;
@@ -1361,7 +1609,7 @@ static int elf_core_dump(long signr, str
 	for(vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
 		unsigned long addr;
 
-		if (!maydump(vma))
+		if (!maydump(vma, signr))
 			continue;
 
 #ifdef DEBUG
diff -urNp linux-2.4.37.7/fs/binfmt_misc.c linux-2.4.37.7/fs/binfmt_misc.c
--- linux-2.4.37.7/fs/binfmt_misc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/binfmt_misc.c	2009-11-10 19:30:27.000000000 -0500
@@ -102,9 +102,11 @@ static int load_misc_binary(struct linux
 	int retval;
 
 	retval = -ENOEXEC;
-	if (!enabled)
+	if (!enabled || bprm->misc)
 		goto _ret;
 
+	bprm->misc++;
+
 	/* to keep locking time low, we copy the interpreter string */
 	read_lock(&entries_lock);
 	fmt = check_file(bprm);
@@ -479,7 +481,7 @@ static ssize_t bm_entry_write(struct fil
 	return count;
 }
 
-static struct file_operations bm_entry_operations = {
+static const struct file_operations bm_entry_operations = {
 	read:		bm_entry_read,
 	write:		bm_entry_write,
 };
@@ -538,7 +540,7 @@ static ssize_t bm_register_write(struct 
 	return count;
 }
 
-static struct file_operations bm_register_operations = {
+static const struct file_operations bm_register_operations = {
 	write:		bm_register_write,
 };
 
@@ -587,7 +589,7 @@ static ssize_t bm_status_write(struct fi
 	return count;
 }
 
-static struct file_operations bm_status_operations = {
+static const struct file_operations bm_status_operations = {
 	read:		bm_status_read,
 	write:		bm_status_write,
 };
@@ -600,7 +602,7 @@ static struct dentry * bm_lookup(struct 
 	return NULL;
 }
 
-static struct inode_operations bm_dir_inode_operations = {
+static const struct inode_operations bm_dir_inode_operations = {
 	lookup:		bm_lookup,
 };
 
@@ -614,7 +616,7 @@ static int bm_statfs(struct super_block 
 	return 0;
 }
 
-static struct super_operations s_ops = {
+static const struct super_operations s_ops = {
 	statfs:		bm_statfs,
 	put_inode:	force_delete,
 	clear_inode:	bm_clear_inode,
diff -urNp linux-2.4.37.7/fs/block_dev.c linux-2.4.37.7/fs/block_dev.c
--- linux-2.4.37.7/fs/block_dev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/block_dev.c	2009-11-10 19:30:27.000000000 -0500
@@ -220,7 +220,7 @@ static int block_fsync(struct file *filp
 
 static struct super_block *bd_read_super(struct super_block *sb, void *data, int silent)
 {
-	static struct super_operations sops = {};
+	static const struct super_operations sops = {};
 	struct inode *root = new_inode(sb);
 	if (!root)
 		return NULL;
@@ -662,7 +662,7 @@ static int blkdev_ioctl(struct inode *in
 	return -EINVAL;
 }
 
-struct address_space_operations def_blk_aops = {
+const struct address_space_operations def_blk_aops = {
 	readpage: blkdev_readpage,
 	writepage: blkdev_writepage,
 	sync_page: block_sync_page,
@@ -671,7 +671,7 @@ struct address_space_operations def_blk_
 	direct_IO: blkdev_direct_IO,
 };
 
-struct file_operations def_blk_fops = {
+const struct file_operations def_blk_fops = {
 	open:		blkdev_open,
 	release:	blkdev_close,
 	llseek:		block_llseek,
diff -urNp linux-2.4.37.7/fs/buffer.c linux-2.4.37.7/fs/buffer.c
--- linux-2.4.37.7/fs/buffer.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/buffer.c	2009-11-10 19:30:27.000000000 -0500
@@ -1865,6 +1865,9 @@ int generic_cont_expand(struct inode *in
 	int err;
 
 	err = -EFBIG;
+
+	gr_learn_resource(current, RLIMIT_FSIZE, (unsigned long) size, 1);
+
         limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
 	if (limit != RLIM_INFINITY && size > (loff_t)limit) {
 		send_sig(SIGXFSZ, current, 0);
diff -urNp linux-2.4.37.7/fs/coda/cnode.c linux-2.4.37.7/fs/coda/cnode.c
--- linux-2.4.37.7/fs/coda/cnode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/cnode.c	2009-11-10 19:30:27.000000000 -0500
@@ -32,7 +32,7 @@ static int coda_inocmp(struct inode *ino
 	return (coda_fideq((ViceFid *)opaque, &(ITOC(inode)->c_fid)));
 }
 
-static struct inode_operations coda_symlink_inode_operations = {
+static const struct inode_operations coda_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 	setattr:	coda_notify_change,
diff -urNp linux-2.4.37.7/fs/coda/dir.c linux-2.4.37.7/fs/coda/dir.c
--- linux-2.4.37.7/fs/coda/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -56,14 +56,12 @@ int coda_fsync(struct file *, struct den
 
 int coda_hasmknod;
 
-struct dentry_operations coda_dentry_operations =
-{
+const struct dentry_operations coda_dentry_operations = {
 	d_revalidate:	coda_dentry_revalidate,
 	d_delete:	coda_dentry_delete,
 };
 
-struct inode_operations coda_dir_inode_operations =
-{
+const struct inode_operations coda_dir_inode_operations = {
 	create:		coda_create,
 	lookup:		coda_lookup,
 	link:		coda_link,
@@ -78,7 +76,7 @@ struct inode_operations coda_dir_inode_o
 	setattr:	coda_notify_change,
 };
 
-struct file_operations coda_dir_operations = {
+const struct file_operations coda_dir_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_read_dir,
 	readdir:	coda_readdir,
diff -urNp linux-2.4.37.7/fs/coda/file.c linux-2.4.37.7/fs/coda/file.c
--- linux-2.4.37.7/fs/coda/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -279,7 +279,7 @@ int coda_fsync(struct file *coda_file, s
 	return err;
 }
 
-struct file_operations coda_file_operations = {
+const struct file_operations coda_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		coda_file_read,
 	write:		coda_file_write,
diff -urNp linux-2.4.37.7/fs/coda/inode.c linux-2.4.37.7/fs/coda/inode.c
--- linux-2.4.37.7/fs/coda/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -40,8 +40,7 @@ static void coda_put_super(struct super_
 static int coda_statfs(struct super_block *sb, struct statfs *buf);
 
 /* exported operations */
-struct super_operations coda_super_operations =
-{
+const struct super_operations coda_super_operations = {
 	read_inode:	coda_read_inode,
 	clear_inode:	coda_clear_inode,
 	put_super:	coda_put_super,
@@ -236,7 +235,7 @@ int coda_notify_change(struct dentry *de
 	return error;
 }
 
-struct inode_operations coda_file_inode_operations = {
+const struct inode_operations coda_file_inode_operations = {
 	permission:	coda_permission,
 	revalidate:	coda_revalidate_inode,
 	setattr:	coda_notify_change,
diff -urNp linux-2.4.37.7/fs/coda/pioctl.c linux-2.4.37.7/fs/coda/pioctl.c
--- linux-2.4.37.7/fs/coda/pioctl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/pioctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -30,13 +30,12 @@ static int coda_pioctl(struct inode * in
                        unsigned int cmd, unsigned long user_data);
 
 /* exported from this file */
-struct inode_operations coda_ioctl_inode_operations =
-{
+const struct inode_operations coda_ioctl_inode_operations = {
 	permission:	coda_ioctl_permission,
 	setattr:	coda_notify_change,
 };
 
-struct file_operations coda_ioctl_operations = {
+const struct file_operations coda_ioctl_operations = {
 	owner:		THIS_MODULE,
 	ioctl:		coda_pioctl,
 };
diff -urNp linux-2.4.37.7/fs/coda/psdev.c linux-2.4.37.7/fs/coda/psdev.c
--- linux-2.4.37.7/fs/coda/psdev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/psdev.c	2009-11-10 19:30:27.000000000 -0500
@@ -372,7 +372,7 @@ static int coda_psdev_release(struct ino
 }
 
 
-static struct file_operations coda_psdev_fops = {
+static const struct file_operations coda_psdev_fops = {
 	owner:		THIS_MODULE,
 	read:		coda_psdev_read,
 	write:		coda_psdev_write,
diff -urNp linux-2.4.37.7/fs/coda/symlink.c linux-2.4.37.7/fs/coda/symlink.c
--- linux-2.4.37.7/fs/coda/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/coda/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,6 +50,6 @@ fail:
 	return error;
 }
 
-struct address_space_operations coda_symlink_aops = {
+const struct address_space_operations coda_symlink_aops = {
 	readpage:	coda_symlink_filler
 };
diff -urNp linux-2.4.37.7/fs/cramfs/inode.c linux-2.4.37.7/fs/cramfs/inode.c
--- linux-2.4.37.7/fs/cramfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/cramfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -29,10 +29,10 @@
 #define CRAMFS_SB_FILES u.cramfs_sb.files
 #define CRAMFS_SB_FLAGS u.cramfs_sb.flags
 
-static struct super_operations cramfs_ops;
-static struct inode_operations cramfs_dir_inode_operations;
-static struct file_operations cramfs_directory_operations;
-static struct address_space_operations cramfs_aops;
+static const struct super_operations cramfs_ops;
+static const struct inode_operations cramfs_dir_inode_operations;
+static const struct file_operations cramfs_directory_operations;
+static const struct address_space_operations cramfs_aops;
 
 static DECLARE_MUTEX(read_mutex);
 
@@ -424,7 +424,7 @@ static int cramfs_readpage(struct file *
 	return 0;
 }
 
-static struct address_space_operations cramfs_aops = {
+static const struct address_space_operations cramfs_aops = {
 	readpage: cramfs_readpage
 };
 
@@ -435,16 +435,16 @@ static struct address_space_operations c
 /*
  * A directory can only readdir
  */
-static struct file_operations cramfs_directory_operations = {
+static const struct file_operations cramfs_directory_operations = {
 	read:		generic_read_dir,
 	readdir:	cramfs_readdir,
 };
 
-static struct inode_operations cramfs_dir_inode_operations = {
+static const struct inode_operations cramfs_dir_inode_operations = {
 	lookup:		cramfs_lookup,
 };
 
-static struct super_operations cramfs_ops = {
+static const struct super_operations cramfs_ops = {
 	statfs:		cramfs_statfs,
 };
 
diff -urNp linux-2.4.37.7/fs/devfs/base.c linux-2.4.37.7/fs/devfs/base.c
--- linux-2.4.37.7/fs/devfs/base.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devfs/base.c	2009-11-10 19:30:27.000000000 -0500
@@ -871,16 +871,14 @@ static int devfsd_close (struct inode *i
 #ifdef CONFIG_DEVFS_DEBUG
 static ssize_t stat_read (struct file *file, char *buf, size_t len,
 			  loff_t *ppos);
-static struct file_operations stat_fops =
-{
+static const struct file_operations stat_fops = {
     .read    = stat_read,
 };
 #endif
 
 
 /*  Devfs daemon file operations  */
-static struct file_operations devfsd_fops =
-{
+static const struct file_operations devfsd_fops = {
     .read    = devfsd_read,
     .ioctl   = devfsd_ioctl,
     .release = devfsd_close,
@@ -1545,7 +1543,7 @@ static void devfsd_notify (struct devfs_
 devfs_handle_t devfs_register (devfs_handle_t dir, const char *name,
 			       unsigned int flags,
 			       unsigned int major, unsigned int minor,
-			       umode_t mode, void *ops, void *info)
+			       umode_t mode, const void *ops, void *info)
 {
     char devtype = S_ISCHR (mode) ? DEVFS_SPECIAL_CHR : DEVFS_SPECIAL_BLK;
     int err;
@@ -2599,8 +2597,7 @@ static void devfs_clear_inode (struct in
     if ( S_ISBLK (inode->i_mode) ) bdput (inode->i_bdev);
 }   /*  End Function devfs_clear_inode  */
 
-static struct super_operations devfs_sops =
-{ 
+static const struct super_operations devfs_sops = { 
     .put_inode     = force_delete,
     .clear_inode   = devfs_clear_inode,
     .statfs        = devfs_statfs,
@@ -2822,13 +2819,11 @@ static int devfs_open (struct inode *ino
     return 0;
 }   /*  End Function devfs_open  */
 
-static struct file_operations devfs_fops =
-{
+static const struct file_operations devfs_fops = {
     .open    = devfs_open,
 };
 
-static struct file_operations devfs_dir_fops =
-{
+static const struct file_operations devfs_dir_fops = {
     .read    = generic_read_dir,
     .readdir = devfs_readdir,
     .open    = devfs_open,
@@ -2871,8 +2866,7 @@ static void devfs_d_iput (struct dentry 
 
 static int devfs_d_delete (struct dentry *dentry);
 
-static struct dentry_operations devfs_dops =
-{
+static const struct dentry_operations devfs_dops = {
     .d_delete     = devfs_d_delete,
     .d_release    = devfs_d_release,
     .d_iput       = devfs_d_iput,
@@ -2880,8 +2874,7 @@ static struct dentry_operations devfs_do
 
 static int devfs_d_revalidate_wait (struct dentry *dentry, int flags);
 
-static struct dentry_operations devfs_wait_dops =
-{
+static const struct dentry_operations devfs_wait_dops = {
     .d_delete     = devfs_d_delete,
     .d_release    = devfs_d_release,
     .d_iput       = devfs_d_iput,
@@ -3250,13 +3243,11 @@ static int devfs_follow_link (struct den
     return err;
 }   /*  End Function devfs_follow_link  */
 
-static struct inode_operations devfs_iops =
-{
+static const struct inode_operations devfs_iops = {
     .setattr        = devfs_notify_change,
 };
 
-static struct inode_operations devfs_dir_iops =
-{
+static const struct inode_operations devfs_dir_iops = {
     .lookup         = devfs_lookup,
     .unlink         = devfs_unlink,
     .symlink        = devfs_symlink,
@@ -3266,8 +3257,7 @@ static struct inode_operations devfs_dir
     .setattr        = devfs_notify_change,
 };
 
-static struct inode_operations devfs_symlink_iops =
-{
+static const struct inode_operations devfs_symlink_iops = {
     .readlink       = devfs_readlink,
     .follow_link    = devfs_follow_link,
     .setattr        = devfs_notify_change,
diff -urNp linux-2.4.37.7/fs/devfs/util.c linux-2.4.37.7/fs/devfs/util.c
--- linux-2.4.37.7/fs/devfs/util.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devfs/util.c	2009-11-10 19:30:27.000000000 -0500
@@ -120,7 +120,7 @@ EXPORT_SYMBOL(devfs_register_tape);
 void devfs_register_series (devfs_handle_t dir, const char *format,
 			    unsigned int num_entries, unsigned int flags,
 			    unsigned int major, unsigned int minor_start,
-			    umode_t mode, void *ops, void *info)
+			    umode_t mode, const void *ops, void *info)
 {
     unsigned int count;
     char devname[128];
diff -urNp linux-2.4.37.7/fs/devices.c linux-2.4.37.7/fs/devices.c
--- linux-2.4.37.7/fs/devices.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devices.c	2009-11-10 19:30:27.000000000 -0500
@@ -32,7 +32,7 @@ struct tty_driver *get_tty_driver(kdev_t
 
 struct device_struct {
 	const char * name;
-	struct file_operations * fops;
+	const struct file_operations * fops;
 };
 
 static rwlock_t chrdevs_lock = RW_LOCK_UNLOCKED;
@@ -62,9 +62,9 @@ int get_device_list(char * page)
 	Load the driver if needed.
 	Increment the reference count of module in question.
 */
-static struct file_operations * get_chrfops(unsigned int major, unsigned int minor)
+static const struct file_operations * get_chrfops(unsigned int major, unsigned int minor)
 {
-	struct file_operations *ret = NULL;
+	const struct file_operations *ret = NULL;
 
 	if (!major || major >= MAX_CHRDEV)
 		return NULL;
@@ -95,7 +95,7 @@ static struct file_operations * get_chrf
 	return ret;
 }
 
-int register_chrdev(unsigned int major, const char * name, struct file_operations *fops)
+int register_chrdev(unsigned int major, const char * name, const struct file_operations *fops)
 {
 	if (major == 0) {
 		write_lock(&chrdevs_lock);
@@ -162,7 +162,7 @@ int chrdev_open(struct inode * inode, st
  * is contain the open that then fills in the correct operations
  * depending on the special file...
  */
-static struct file_operations def_chr_fops = {
+static const struct file_operations def_chr_fops = {
 	open:		chrdev_open,
 };
 
@@ -193,7 +193,7 @@ static int sock_no_open(struct inode *ir
 	return -ENXIO;
 }
 
-static struct file_operations bad_sock_fops = {
+static const struct file_operations bad_sock_fops = {
 	open:		sock_no_open
 };
 
diff -urNp linux-2.4.37.7/fs/devpts/devpts_i.h linux-2.4.37.7/fs/devpts/devpts_i.h
--- linux-2.4.37.7/fs/devpts/devpts_i.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devpts/devpts_i.h	2009-11-10 19:30:27.000000000 -0500
@@ -37,5 +37,5 @@ extern inline struct devpts_sb_info *SBI
 	return (struct devpts_sb_info *)(sb->u.generic_sbp);
 }
 
-extern struct inode_operations devpts_root_inode_operations;
-extern struct file_operations devpts_root_operations;
+extern const struct inode_operations devpts_root_inode_operations;
+extern const struct file_operations devpts_root_operations;
diff -urNp linux-2.4.37.7/fs/devpts/inode.c linux-2.4.37.7/fs/devpts/inode.c
--- linux-2.4.37.7/fs/devpts/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devpts/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -51,7 +51,7 @@ static void devpts_put_super(struct supe
 static int devpts_statfs(struct super_block *sb, struct statfs *buf);
 static int devpts_remount (struct super_block * sb, int * flags, char * data);
 
-static struct super_operations devpts_sops = {
+static const struct super_operations devpts_sops = {
 	put_super:	devpts_put_super,
 	statfs:		devpts_statfs,
 	remount_fs:	devpts_remount,
diff -urNp linux-2.4.37.7/fs/devpts/root.c linux-2.4.37.7/fs/devpts/root.c
--- linux-2.4.37.7/fs/devpts/root.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/devpts/root.c	2009-11-10 19:30:27.000000000 -0500
@@ -20,16 +20,16 @@ static int devpts_root_readdir(struct fi
 static struct dentry *devpts_root_lookup(struct inode *,struct dentry *);
 static int devpts_revalidate(struct dentry *, int);
 
-struct file_operations devpts_root_operations = {
+const struct file_operations devpts_root_operations = {
 	read:		generic_read_dir,
 	readdir:	devpts_root_readdir,
 };
 
-struct inode_operations devpts_root_inode_operations = {
+const struct inode_operations devpts_root_inode_operations = {
 	lookup:		devpts_root_lookup,
 };
 
-static struct dentry_operations devpts_dentry_operations = {
+static const struct dentry_operations devpts_dentry_operations = {
 	d_revalidate:	devpts_revalidate,
 };
 
diff -urNp linux-2.4.37.7/fs/efs/dir.c linux-2.4.37.7/fs/efs/dir.c
--- linux-2.4.37.7/fs/efs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/efs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -8,12 +8,12 @@
 
 static int efs_readdir(struct file *, void *, filldir_t);
 
-struct file_operations efs_dir_operations = {
+const struct file_operations efs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	efs_readdir,
 };
 
-struct inode_operations efs_dir_inode_operations = {
+const struct inode_operations efs_dir_inode_operations = {
 	lookup:		efs_lookup,
 };
 
diff -urNp linux-2.4.37.7/fs/efs/inode.c linux-2.4.37.7/fs/efs/inode.c
--- linux-2.4.37.7/fs/efs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/efs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -21,7 +21,7 @@ static int _efs_bmap(struct address_spac
 {
 	return generic_block_bmap(mapping,block,efs_get_block);
 }
-struct address_space_operations efs_aops = {
+const struct address_space_operations efs_aops = {
 	readpage: efs_readpage,
 	sync_page: block_sync_page,
 	bmap: _efs_bmap
diff -urNp linux-2.4.37.7/fs/efs/super.c linux-2.4.37.7/fs/efs/super.c
--- linux-2.4.37.7/fs/efs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/efs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,7 +15,7 @@
 
 static DECLARE_FSTYPE_DEV(efs_fs_type, "efs", efs_read_super);
 
-static struct super_operations efs_superblock_operations = {
+static const struct super_operations efs_superblock_operations = {
 	read_inode:	efs_read_inode,
 	statfs:		efs_statfs,
 };
diff -urNp linux-2.4.37.7/fs/efs/symlink.c linux-2.4.37.7/fs/efs/symlink.c
--- linux-2.4.37.7/fs/efs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/efs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -52,6 +52,6 @@ fail:
 	return err;
 }
 
-struct address_space_operations efs_symlink_aops = {
+const struct address_space_operations efs_symlink_aops = {
 	readpage:	efs_symlink_readpage
 };
diff -urNp linux-2.4.37.7/fs/exec.c linux-2.4.37.7/fs/exec.c
--- linux-2.4.37.7/fs/exec.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/exec.c	2009-11-10 19:30:27.000000000 -0500
@@ -43,6 +43,9 @@
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
+#include <linux/major.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
@@ -282,7 +285,7 @@ int copy_strings_kernel(int argc,char **
  *
  * tsk->mmap_sem is held for writing.
  */
-void put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address)
+int put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address)
 {
 	pgd_t * pgd;
 	pmd_t * pmd;
@@ -315,12 +318,53 @@ void put_dirty_page(struct task_struct *
 	spin_unlock(&tsk->mm->page_table_lock);
 
 	/* no need for flush_tlb */
-	return;
+	return 0;
 out:
 	spin_unlock(&tsk->mm->page_table_lock);
 	__free_page(page);
 	force_sig(SIGKILL, tsk);
-	return;
+	return -ENOMEM;
+}
+
+static int put_dirty_page_mirror(struct task_struct * tsk, struct page *page, unsigned long address)
+{
+	pgd_t * pgd;
+	pmd_t * pmd;
+	pte_t * pte;
+	struct vm_area_struct *vma; 
+	pgprot_t prot = PAGE_COPY; 
+
+	if (page_count(page) != 1)
+		printk(KERN_ERR "mem_map disagrees with %p at %08lx\n", page, address);
+
+	page_cache_get(page);
+	pgd = pgd_offset(tsk->mm, address);
+
+	spin_lock(&tsk->mm->page_table_lock);
+	pmd = pmd_alloc(tsk->mm, pgd, address);
+	if (!pmd)
+		goto out;
+	pte = pte_alloc(tsk->mm, pmd, address);
+	if (!pte)
+		goto out;
+	if (!pte_none(*pte))
+		goto out;
+
+	vma = find_vma(tsk->mm, address);
+	if (vma)
+		prot = vma->vm_page_prot;
+	set_pte(pte, mk_pte(page, prot));
+	tsk->mm->rss++;
+	spin_unlock(&tsk->mm->page_table_lock);
+
+	/* no need for flush_tlb */
+	return 0;
+out:
+	spin_unlock(&tsk->mm->page_table_lock);
+	page_cache_release(page);
+	__free_page(page);
+	force_sig(SIGKILL, tsk);
+	return -ENOMEM;
 }
 
 int setup_arg_pages(struct linux_binprm *bprm)
@@ -329,6 +373,10 @@ int setup_arg_pages(struct linux_binprm 
 	struct vm_area_struct *mpnt;
 	int i, ret;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *mpnt_m = NULL;
+#endif
+
 	stack_base = STACK_TOP - MAX_ARG_PAGES*PAGE_SIZE;
 
 	bprm->p += stack_base;
@@ -339,37 +387,99 @@ int setup_arg_pages(struct linux_binprm 
 	mpnt = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 	if (!mpnt) 
 		return -ENOMEM; 
-	
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (VM_STACK_FLAGS & VM_MAYEXEC)) {
+		mpnt_m = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+		if (!mpnt_m) {
+			kmem_cache_free(vm_area_cachep, mpnt);
+			return -ENOMEM;
+		}
+	}
+#endif
+
 	down_write(&current->mm->mmap_sem);
 	{
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = STACK_TOP;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+		if (!(current->mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(VM_STACK_FLAGS | VM_EXEC) & 0x7];
+		else
+#endif
+
 		mpnt->vm_page_prot = protection_map[VM_STACK_FLAGS & 0x7];
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = (void *) 0;
+		mpnt->vm_mirror = 0;
 		if ((ret = insert_vm_struct(current->mm, mpnt))) {
 			up_write(&current->mm->mmap_sem);
 			kmem_cache_free(vm_area_cachep, mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m)
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+#endif
+
 			return ret;
 		}
 		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mpnt_m) {
+			*mpnt_m = *mpnt;
+			mpnt_m->vm_flags &= ~VM_WRITE;
+			if (!(VM_STACK_FLAGS & VM_EXEC)) {
+				mpnt_m->vm_flags &= ~(VM_READ | VM_EXEC);
+				mpnt_m->vm_page_prot = PAGE_NONE;
+			} else
+				mpnt_m->vm_page_prot = PAGE_READONLY;
+			mpnt_m->vm_start += SEGMEXEC_TASK_SIZE;
+			mpnt_m->vm_end += SEGMEXEC_TASK_SIZE;
+			if ((ret = insert_vm_struct(current->mm, mpnt_m))) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+				return ret;
+			}
+			mpnt_m->vm_flags |= VM_MIRROR;
+			mpnt->vm_flags |= VM_MIRROR;
+			mpnt_m->vm_mirror = mpnt->vm_start - mpnt_m->vm_start;
+			mpnt->vm_mirror = mpnt_m->vm_start - mpnt->vm_start;
+			current->mm->total_vm += (mpnt_m->vm_end - mpnt_m->vm_start) >> PAGE_SHIFT;
+		}
+#endif
+
 	} 
 
-	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
+	for (i = 0 ; i < MAX_ARG_PAGES ; i++, stack_base += PAGE_SIZE) {
 		struct page *page = bprm->page[i];
-		if (page) {
-			bprm->page[i] = NULL;
-			put_dirty_page(current,page,stack_base);
-		}
-		stack_base += PAGE_SIZE;
+		int retval;
+		if (!page)
+			continue;
+
+		bprm->page[i] = NULL;
+		retval = put_dirty_page(current,page,stack_base);
+		if (!ret)
+			ret = retval;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (!mpnt_m || retval)
+			continue;
+
+		retval = put_dirty_page_mirror(current,page,stack_base + SEGMEXEC_TASK_SIZE);
+		if (!ret)
+			ret = retval;
+#endif
+
 	}
 	up_write(&current->mm->mmap_sem);
-	
-	return 0;
+
+	return ret;
 }
 
 struct file *open_exec(const char *name)
@@ -809,8 +919,13 @@ void compute_creds(struct linux_binprm *
 	
         /* AUD: Audit candidate if current->cap_effective is set */
 
-        current->suid = current->euid = current->fsuid = bprm->e_uid;
-        current->sgid = current->egid = current->fsgid = bprm->e_gid;
+	if (!gr_check_user_change(-1, bprm->e_uid, bprm->e_uid))
+		current->suid = current->euid = current->fsuid = bprm->e_uid;
+
+	if (!gr_check_group_change(-1, bprm->e_gid, bprm->e_gid))
+	        current->sgid = current->egid = current->fsgid = bprm->e_gid;
+
+	gr_handle_chroot_caps(current);
 
 	if(do_unlock)
 		unlock_kernel();
@@ -945,6 +1060,11 @@ int do_execve(char * filename, char ** a
 	struct file *file;
 	int retval;
 	int i;
+#ifdef CONFIG_GRKERNSEC
+	struct file *old_exec_file;
+	struct acl_subject_label *old_acl;
+	struct rlimit old_rlim[RLIM_NLIMITS];
+#endif
 
 	file = open_exec(filename);
 
@@ -952,12 +1072,37 @@ int do_execve(char * filename, char ** a
 	if (IS_ERR(file))
 		return retval;
 
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes), 1);
+
+	if (gr_handle_nproc()) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+
+	if (!gr_acl_handle_execve(file->f_dentry, file->f_vfsmnt)) {
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	bprm.p -= (net_random() & ~15) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
 
 	bprm.file = file;
 	bprm.filename = filename;
 	bprm.sh_bang = 0;
+	bprm.misc = 0;
 	bprm.loader = 0;
 	bprm.exec = 0;
 	if ((bprm.argc = count(argv, bprm.p / sizeof(void *))) < 0) {
@@ -976,11 +1121,26 @@ int do_execve(char * filename, char ** a
 	if (retval < 0) 
 		goto out; 
 
+	if (!gr_tpe_allow(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if(gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
 	if (retval < 0) 
 		goto out; 
 
 	bprm.exec = bprm.p;
+
+	gr_log_chroot_exec(file->f_dentry, file->f_vfsmnt);
+
+	gr_handle_exec_args(&bprm, argv);
+
 	retval = copy_strings(bprm.envc, envp, &bprm);
 	if (retval < 0) 
 		goto out; 
@@ -989,11 +1149,35 @@ int do_execve(char * filename, char ** a
 	if (retval < 0) 
 		goto out; 
 
+#ifdef CONFIG_GRKERNSEC
+	old_acl = current->acl;
+	memcpy(old_rlim, current->rlim, sizeof(old_rlim));
+	old_exec_file = current->exec_file;
+	get_file(file);
+	current->exec_file = file;
+#endif
+
+	retval = gr_set_proc_label(file->f_dentry, file->f_vfsmnt);
+	if (retval < 0)
+		goto out_fail;
+
 	retval = search_binary_handler(&bprm,regs);
-	if (retval >= 0)
+	if (retval >= 0) {
+#ifdef CONFIG_GRKERNSEC
+		if (old_exec_file)
+			fput(old_exec_file);
+#endif
 		/* execve success */
 		return retval;
+	}
 
+out_fail:
+#ifdef CONFIG_GRKERNSEC
+	current->acl = old_acl;
+	memcpy(current->rlim, old_rlim, sizeof(old_rlim));
+	fput(current->exec_file);
+	current->exec_file = old_exec_file;
+#endif
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
 	allow_write_access(bprm.file);
@@ -1135,6 +1319,114 @@ void format_corename(char *corename, con
 	*out_ptr = 0;
 }
 
+int pax_check_flags(unsigned long * flags)
+{
+	int retval = 0;
+
+#if !defined(__i386__) || !defined(CONFIG_PAX_SEGMEXEC)
+	if (*flags & MF_PAX_SEGMEXEC)
+	{
+		*flags &= ~MF_PAX_SEGMEXEC;
+		retval = -EINVAL;
+	}
+#endif
+
+	if ((*flags & MF_PAX_PAGEEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	    &&  (*flags & MF_PAX_SEGMEXEC)
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_PAGEEXEC;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_MPROTECT)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_MPROTECT;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_EMUTRAMP)
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_EMUTRAMP;
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(pax_check_flags);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char* buffer_exec = (char*)__get_free_page(GFP_ATOMIC);
+	char* buffer_fault = (char*)__get_free_page(GFP_ATOMIC);
+	char* path_exec=NULL;
+	char* path_fault=NULL;
+	unsigned long start=0UL, end=0UL, offset=0UL;
+
+	if (buffer_exec && buffer_fault) {
+		struct vm_area_struct* vma, * vma_exec=NULL, * vma_fault=NULL;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma && (!vma_exec || !vma_fault)) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+				vma_exec = vma;
+			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+				vma_fault = vma;
+			vma = vma->vm_next;
+		}
+		if (vma_exec) {
+			path_exec = d_path(vma_exec->vm_file->f_dentry, vma_exec->vm_file->f_vfsmnt, buffer_exec, PAGE_SIZE);
+			if (IS_ERR(path_exec))
+				path_exec = "<path too long>";
+		}
+		if (vma_fault) {
+			start = vma_fault->vm_start;
+			end = vma_fault->vm_end;
+			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+			if (vma_fault->vm_file) {
+				path_fault = d_path(vma_fault->vm_file->f_dentry, vma_fault->vm_file->f_vfsmnt, buffer_fault, PAGE_SIZE);
+				if (IS_ERR(path_fault))
+					path_fault = "<path too long>";
+			} else
+				path_fault = "<anonymous mapping>";
+		}
+		up_read(&mm->mmap_sem);
+	}
+	if (tsk->curr_ip)
+		printk(KERN_ERR "PAX: From %u.%u.%u.%u: execution attempt in: %s, %08lx-%08lx %08lx\n", NIPQUAD(tsk->curr_ip), path_fault, start, end, offset);
+	else
+		printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, "
+			"PC: %p, SP: %p\n", path_exec, tsk->comm, tsk->pid,
+			tsk->uid, tsk->euid, pc, sp);
+	free_page((unsigned long)buffer_exec);
+	free_page((unsigned long)buffer_fault);
+	pax_report_insns(pc, sp);
+	do_coredump(SIGKILL, regs);
+}
+#endif
+
 int do_coredump(long signr, struct pt_regs * regs)
 {
 	struct linux_binfmt * binfmt;
@@ -1155,6 +1447,11 @@ int do_coredump(long signr, struct pt_re
 		current->fsuid = 0;
 	}
 	current->mm->dumpable = 0;
+
+	if (signr == SIGKILL || signr == SIGILL)
+		gr_handle_brute_attach(current);
+
+	gr_learn_resource(current, RLIMIT_CORE, binfmt->min_coredump, 1);
 	if (current->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)
 		goto fail;
 
@@ -1180,7 +1477,7 @@ int do_coredump(long signr, struct pt_re
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, file->f_vfsmnt) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
diff -urNp linux-2.4.37.7/fs/ext2/dir.c linux-2.4.37.7/fs/ext2/dir.c
--- linux-2.4.37.7/fs/ext2/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -619,7 +619,7 @@ not_empty:
 	return 0;
 }
 
-struct file_operations ext2_dir_operations = {
+const struct file_operations ext2_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	ext2_readdir,
 	ioctl:		ext2_ioctl,
diff -urNp linux-2.4.37.7/fs/ext2/file.c linux-2.4.37.7/fs/ext2/file.c
--- linux-2.4.37.7/fs/ext2/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -38,7 +38,7 @@ static int ext2_release_file (struct ino
  * We have mostly NULL's here: the current defaults are ok for
  * the ext2 filesystem.
  */
-struct file_operations ext2_file_operations = {
+const struct file_operations ext2_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		generic_file_write,
@@ -49,6 +49,6 @@ struct file_operations ext2_file_operati
 	fsync:		ext2_sync_file,
 };
 
-struct inode_operations ext2_file_inode_operations = {
+const struct inode_operations ext2_file_inode_operations = {
 	truncate:	ext2_truncate,
 };
diff -urNp linux-2.4.37.7/fs/ext2/inode.c linux-2.4.37.7/fs/ext2/inode.c
--- linux-2.4.37.7/fs/ext2/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -608,7 +608,7 @@ static int ext2_direct_IO(int rw, struct
 {
 	return generic_direct_IO(rw, inode, iobuf, blocknr, blocksize, ext2_get_block);
 }
-struct address_space_operations ext2_aops = {
+const struct address_space_operations ext2_aops = {
 	readpage: ext2_readpage,
 	writepage: ext2_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/ext2/namei.c linux-2.4.37.7/fs/ext2/namei.c
--- linux-2.4.37.7/fs/ext2/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -342,7 +342,7 @@ out:
 	return err;
 }
 
-struct inode_operations ext2_dir_inode_operations = {
+const struct inode_operations ext2_dir_inode_operations = {
 	create:		ext2_create,
 	lookup:		ext2_lookup,
 	link:		ext2_link,
diff -urNp linux-2.4.37.7/fs/ext2/super.c linux-2.4.37.7/fs/ext2/super.c
--- linux-2.4.37.7/fs/ext2/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -147,7 +147,7 @@ void ext2_put_super (struct super_block 
 	return;
 }
 
-static struct super_operations ext2_sops = {
+static const struct super_operations ext2_sops = {
 	read_inode:	ext2_read_inode,
 	write_inode:	ext2_write_inode,
 	put_inode:	ext2_put_inode,
diff -urNp linux-2.4.37.7/fs/ext2/symlink.c linux-2.4.37.7/fs/ext2/symlink.c
--- linux-2.4.37.7/fs/ext2/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext2/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -32,7 +32,7 @@ static int ext2_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
-struct inode_operations ext2_fast_symlink_inode_operations = {
+const struct inode_operations ext2_fast_symlink_inode_operations = {
 	readlink:	ext2_readlink,
 	follow_link:	ext2_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/ext3/dir.c linux-2.4.37.7/fs/ext3/dir.c
--- linux-2.4.37.7/fs/ext3/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,7 +28,7 @@ static unsigned char ext3_filetype_table
 
 static int ext3_readdir(struct file *, void *, filldir_t);
 
-struct file_operations ext3_dir_operations = {
+const struct file_operations ext3_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	ext3_readdir,		/* BKL held */
 	ioctl:		ext3_ioctl,		/* BKL held */
diff -urNp linux-2.4.37.7/fs/ext3/file.c linux-2.4.37.7/fs/ext3/file.c
--- linux-2.4.37.7/fs/ext3/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -110,7 +110,7 @@ force_commit:
 	return ret;
 }
 
-struct file_operations ext3_file_operations = {
+const struct file_operations ext3_file_operations = {
 	llseek:		generic_file_llseek,	/* BKL held */
 	read:		generic_file_read,	/* BKL not held.  Don't need */
 	write:		ext3_file_write,	/* BKL not held.  Don't need */
@@ -121,7 +121,7 @@ struct file_operations ext3_file_operati
 	fsync:		ext3_sync_file,		/* BKL held */
 };
 
-struct inode_operations ext3_file_inode_operations = {
+const struct inode_operations ext3_file_inode_operations = {
 	truncate:	ext3_truncate,		/* BKL held */
 	setattr:	ext3_setattr,		/* BKL held */
 };
diff -urNp linux-2.4.37.7/fs/ext3/inode.c linux-2.4.37.7/fs/ext3/inode.c
--- linux-2.4.37.7/fs/ext3/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -1389,7 +1389,7 @@ static int ext3_releasepage(struct page 
 }
 
 
-struct address_space_operations ext3_aops = {
+const struct address_space_operations ext3_aops = {
 	readpage:	ext3_readpage,		/* BKL not held.  Don't need */
 	writepage:	ext3_writepage,		/* BKL not held.  We take it */
 	sync_page:	block_sync_page,
diff -urNp linux-2.4.37.7/fs/ext3/namei.c linux-2.4.37.7/fs/ext3/namei.c
--- linux-2.4.37.7/fs/ext3/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -1111,7 +1111,7 @@ end_rename:
 /*
  * directories can handle most operations...
  */
-struct inode_operations ext3_dir_inode_operations = {
+const struct inode_operations ext3_dir_inode_operations = {
 	create:		ext3_create,		/* BKL held */
 	lookup:		ext3_lookup,		/* BKL held */
 	link:		ext3_link,		/* BKL held */
diff -urNp linux-2.4.37.7/fs/ext3/super.c linux-2.4.37.7/fs/ext3/super.c
--- linux-2.4.37.7/fs/ext3/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -450,7 +450,7 @@ void ext3_put_super (struct super_block 
 
 static struct dquot_operations ext3_qops;
 
-static struct super_operations ext3_sops = {
+static const struct super_operations ext3_sops = {
 	read_inode:	ext3_read_inode,	/* BKL held */
 	write_inode:	ext3_write_inode,	/* BKL not held.  Don't need */
 	dirty_inode:	ext3_dirty_inode,	/* BKL not held.  We take it */
diff -urNp linux-2.4.37.7/fs/ext3/symlink.c linux-2.4.37.7/fs/ext3/symlink.c
--- linux-2.4.37.7/fs/ext3/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ext3/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -33,7 +33,7 @@ static int ext3_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
-struct inode_operations ext3_fast_symlink_inode_operations = {
+const struct inode_operations ext3_fast_symlink_inode_operations = {
 	readlink:	ext3_readlink,		/* BKL not held.  Don't need */
 	follow_link:	ext3_follow_link,	/* BKL not held.  Don't need */
 };
diff -urNp linux-2.4.37.7/fs/fat/dir.c linux-2.4.37.7/fs/fat/dir.c
--- linux-2.4.37.7/fs/fat/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/fat/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -29,7 +29,7 @@
 
 #define PRINTK(X)
 
-struct file_operations fat_dir_operations = {
+const struct file_operations fat_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	fat_readdir,
 	ioctl:		fat_dir_ioctl,
diff -urNp linux-2.4.37.7/fs/fat/file.c linux-2.4.37.7/fs/fat/file.c
--- linux-2.4.37.7/fs/fat/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/fat/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -23,7 +23,7 @@
 #define PRINTK(x)
 #define Printk(x) printk x
 
-struct file_operations fat_file_operations = {
+const struct file_operations fat_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		fat_file_read,
 	write:		fat_file_write,
@@ -31,7 +31,7 @@ struct file_operations fat_file_operatio
 	fsync:		file_fsync,
 };
 
-struct inode_operations fat_file_inode_operations = {
+const struct inode_operations fat_file_inode_operations = {
 	truncate:	fat_truncate,
 	setattr:	fat_notify_change,
 };
diff -urNp linux-2.4.37.7/fs/fat/inode.c linux-2.4.37.7/fs/fat/inode.c
--- linux-2.4.37.7/fs/fat/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/fat/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -537,7 +537,7 @@ int fat_dentry_to_fh(struct dentry *de, 
 	return 3;
 }
 
-static struct super_operations fat_sops = { 
+static const struct super_operations fat_sops = { 
 	write_inode:	fat_write_inode,
 	delete_inode:	fat_delete_inode,
 	put_super:	fat_put_super,
@@ -557,7 +557,7 @@ static struct super_operations fat_sops 
  */
 struct super_block *
 fat_read_super(struct super_block *sb, void *data, int silent,
-		struct inode_operations *fs_dir_inode_ops)
+		const struct inode_operations *fs_dir_inode_ops)
 {
 	struct inode *root_inode;
 	struct buffer_head *bh;
@@ -886,7 +886,7 @@ static int _fat_bmap(struct address_spac
 {
 	return generic_block_bmap(mapping,block,fat_get_block);
 }
-static struct address_space_operations fat_aops = {
+static const struct address_space_operations fat_aops = {
 	readpage: fat_readpage,
 	writepage: fat_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/fcntl.c linux-2.4.37.7/fs/fcntl.c
--- linux-2.4.37.7/fs/fcntl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/fcntl.c	2009-11-10 19:30:27.000000000 -0500
@@ -12,6 +12,7 @@
 #include <linux/slab.h>
 #include <linux/iobuf.h>
 #include <linux/ptrace.h>
+#include <linux/grsecurity.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -65,6 +66,8 @@ static int locate_fd(struct files_struct
 	int error;
 	int start;
 
+	gr_learn_resource(current, RLIMIT_NOFILE, orig_start, 0);
+
 	write_lock(&files->file_lock);
 	
 	error = -EINVAL;
@@ -87,6 +90,7 @@ repeat:
 	}
 	
 	error = -EMFILE;
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd, 0);
 	if (newfd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
@@ -142,6 +146,8 @@ asmlinkage long sys_dup2(unsigned int ol
 	struct file * file, *tofree;
 	struct files_struct * files = current->files;
 
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd, 0);
+
 	write_lock(&files->file_lock);
 	if (!(file = fcheck(oldfd)))
 		goto out_unlock;
diff -urNp linux-2.4.37.7/fs/fifo.c linux-2.4.37.7/fs/fifo.c
--- linux-2.4.37.7/fs/fifo.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/fifo.c	2009-11-10 19:30:27.000000000 -0500
@@ -152,6 +152,6 @@ err_nolock_nocleanup:
  * is contain the open that then fills in the correct operations
  * depending on the access mode of the file...
  */
-struct file_operations def_fifo_fops = {
+const struct file_operations def_fifo_fops = {
 	open:		fifo_open,	/* will set read or write pipe_fops */
 };
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_extern.h linux-2.4.37.7/fs/freevxfs/vxfs_extern.h
--- linux-2.4.37.7/fs/freevxfs/vxfs_extern.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_extern.h	2009-11-10 19:30:27.000000000 -0500
@@ -64,8 +64,8 @@ extern void			vxfs_read_inode(struct ino
 extern void			vxfs_put_inode(struct inode *);
 
 /* vxfs_lookup.c */
-extern struct inode_operations	vxfs_dir_inode_ops;
-extern struct file_operations	vxfs_dir_operations;
+extern const struct inode_operations	vxfs_dir_inode_ops;
+extern const struct file_operations	vxfs_dir_operations;
 
 /* vxfs_olt.c */
 extern int			vxfs_read_olt(struct super_block *, u_long);
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_immed.c linux-2.4.37.7/fs/freevxfs/vxfs_immed.c
--- linux-2.4.37.7/fs/freevxfs/vxfs_immed.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_immed.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,7 +50,7 @@ static int	vxfs_immed_readpage(struct fi
  * Unliked all other operations we do not go through the pagecache,
  * but do all work directly on the inode.
  */
-struct inode_operations vxfs_immed_symlink_iops = {
+const struct inode_operations vxfs_immed_symlink_iops = {
 	.readlink =		vxfs_immed_readlink,
 	.follow_link =		vxfs_immed_follow_link,
 };
@@ -58,7 +58,7 @@ struct inode_operations vxfs_immed_symli
 /*
  * Adress space operations for immed files and directories.
  */
-struct address_space_operations vxfs_immed_aops = {
+const struct address_space_operations vxfs_immed_aops = {
 	.readpage =		vxfs_immed_readpage,
 };
 
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_inode.c linux-2.4.37.7/fs/freevxfs/vxfs_inode.c
--- linux-2.4.37.7/fs/freevxfs/vxfs_inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -42,12 +42,12 @@
 #include "vxfs_extern.h"
 
 
-extern struct address_space_operations vxfs_aops;
-extern struct address_space_operations vxfs_immed_aops;
+extern const struct address_space_operations vxfs_aops;
+extern const struct address_space_operations vxfs_immed_aops;
 
-extern struct inode_operations vxfs_immed_symlink_iops;
+extern const struct inode_operations vxfs_immed_symlink_iops;
 
-static struct file_operations vxfs_file_operations = {
+static const struct file_operations vxfs_file_operations = {
 	.open =			generic_file_open,
 	.llseek =		generic_file_llseek,
 	.read =			generic_file_read,
@@ -301,7 +301,7 @@ vxfs_read_inode(struct inode *ip)
 {
 	struct super_block		*sbp = ip->i_sb;
 	struct vxfs_inode_info		*vip;
-	struct address_space_operations	*aops;
+	const struct address_space_operations	*aops;
 	ino_t				ino = ip->i_ino;
 
 	if (!(vip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist)))
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_lookup.c linux-2.4.37.7/fs/freevxfs/vxfs_lookup.c
--- linux-2.4.37.7/fs/freevxfs/vxfs_lookup.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_lookup.c	2009-11-10 19:30:27.000000000 -0500
@@ -53,11 +53,11 @@
 static struct dentry *	vxfs_lookup(struct inode *, struct dentry *);
 static int		vxfs_readdir(struct file *, void *, filldir_t);
 
-struct inode_operations vxfs_dir_inode_ops = {
+const struct inode_operations vxfs_dir_inode_ops = {
 	.lookup =		vxfs_lookup,
 };
 
-struct file_operations vxfs_dir_operations = {
+const struct file_operations vxfs_dir_operations = {
 	.readdir =		vxfs_readdir,
 };
 
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_subr.c linux-2.4.37.7/fs/freevxfs/vxfs_subr.c
--- linux-2.4.37.7/fs/freevxfs/vxfs_subr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_subr.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,7 +44,7 @@
 static int		vxfs_readpage(struct file *, struct page *);
 static int		vxfs_bmap(struct address_space *, long);
 
-struct address_space_operations vxfs_aops = {
+const struct address_space_operations vxfs_aops = {
 	.readpage =		vxfs_readpage,
 	.bmap =			vxfs_bmap,
 	.sync_page =		block_sync_page,
diff -urNp linux-2.4.37.7/fs/freevxfs/vxfs_super.c linux-2.4.37.7/fs/freevxfs/vxfs_super.c
--- linux-2.4.37.7/fs/freevxfs/vxfs_super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/freevxfs/vxfs_super.c	2009-11-10 19:30:27.000000000 -0500
@@ -55,7 +55,7 @@ MODULE_LICENSE("Dual BSD/GPL");
 static void		vxfs_put_super(struct super_block *);
 static int		vxfs_statfs(struct super_block *, struct statfs *);
 
-static struct super_operations vxfs_super_ops = {
+static const struct super_operations vxfs_super_ops = {
 	.read_inode =		vxfs_read_inode,
 	.put_inode =		vxfs_put_inode,
 	.put_super =		vxfs_put_super,
diff -urNp linux-2.4.37.7/fs/hfs/dir_cap.c linux-2.4.37.7/fs/hfs/dir_cap.c
--- linux-2.4.37.7/fs/hfs/dir_cap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/dir_cap.c	2009-11-10 19:30:27.000000000 -0500
@@ -57,13 +57,13 @@ const struct hfs_name hfs_cap_reserved2[
 #define DOT_FINDERINFO	(&hfs_cap_reserved1[3])
 #define DOT_ROOTINFO	(&hfs_cap_reserved2[0])
 
-struct file_operations hfs_cap_dir_operations = {
+const struct file_operations hfs_cap_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	cap_readdir,
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_cap_ndir_inode_operations = {
+const struct inode_operations hfs_cap_ndir_inode_operations = {
 	create:		hfs_create,
 	lookup:		cap_lookup,
 	unlink:		hfs_unlink,
@@ -73,12 +73,12 @@ struct inode_operations hfs_cap_ndir_ino
 	setattr:	hfs_notify_change,
 };
 
-struct inode_operations hfs_cap_fdir_inode_operations = {
+const struct inode_operations hfs_cap_fdir_inode_operations = {
 	lookup:		cap_lookup,
 	setattr:	hfs_notify_change,
 };
 
-struct inode_operations hfs_cap_rdir_inode_operations = {
+const struct inode_operations hfs_cap_rdir_inode_operations = {
 	create:		hfs_create,
 	lookup:		cap_lookup,
 	setattr:	hfs_notify_change,
diff -urNp linux-2.4.37.7/fs/hfs/dir_dbl.c linux-2.4.37.7/fs/hfs/dir_dbl.c
--- linux-2.4.37.7/fs/hfs/dir_dbl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/dir_dbl.c	2009-11-10 19:30:27.000000000 -0500
@@ -56,13 +56,13 @@ const struct hfs_name hfs_dbl_reserved2[
 #define ROOTINFO	(&hfs_dbl_reserved2[0])
 #define PCNT_ROOTINFO	(&hfs_dbl_reserved2[1])
 
-struct file_operations hfs_dbl_dir_operations = {
+const struct file_operations hfs_dbl_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	dbl_readdir,
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_dbl_dir_inode_operations = {
+const struct inode_operations hfs_dbl_dir_inode_operations = {
 	create:		dbl_create,
 	lookup:		dbl_lookup,
 	unlink:		dbl_unlink,
diff -urNp linux-2.4.37.7/fs/hfs/dir_nat.c linux-2.4.37.7/fs/hfs/dir_nat.c
--- linux-2.4.37.7/fs/hfs/dir_nat.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/dir_nat.c	2009-11-10 19:30:27.000000000 -0500
@@ -62,13 +62,13 @@ const struct hfs_name hfs_nat_reserved2[
 #define DOT_PARENT	(&hfs_nat_reserved1[3])
 #define ROOTINFO        (&hfs_nat_reserved2[0])
 
-struct file_operations hfs_nat_dir_operations = {
+const struct file_operations hfs_nat_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	nat_readdir,
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_nat_ndir_inode_operations = {
+const struct inode_operations hfs_nat_ndir_inode_operations = {
 	create:		hfs_create,
 	lookup:		nat_lookup,
 	unlink:		hfs_unlink,
@@ -78,7 +78,7 @@ struct inode_operations hfs_nat_ndir_ino
 	setattr:	hfs_notify_change,
 };
 
-struct inode_operations hfs_nat_hdir_inode_operations = {
+const struct inode_operations hfs_nat_hdir_inode_operations = {
 	create:		hfs_create,
 	lookup:		nat_lookup,
 	unlink:		nat_hdr_unlink,
diff -urNp linux-2.4.37.7/fs/hfs/file.c linux-2.4.37.7/fs/hfs/file.c
--- linux-2.4.37.7/fs/hfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -31,7 +31,7 @@ static void hfs_file_truncate(struct ino
 
 /*================ Global variables ================*/
 
-struct file_operations hfs_file_operations = {
+const struct file_operations hfs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		hfs_file_read,
 	write:		hfs_file_write,
@@ -39,7 +39,7 @@ struct file_operations hfs_file_operatio
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_file_inode_operations = {
+const struct inode_operations hfs_file_inode_operations = {
 	truncate:	hfs_file_truncate,
 	setattr:	hfs_notify_change,
 };
diff -urNp linux-2.4.37.7/fs/hfs/file_cap.c linux-2.4.37.7/fs/hfs/file_cap.c
--- linux-2.4.37.7/fs/hfs/file_cap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/file_cap.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,14 +45,14 @@ static hfs_rwret_t cap_info_write(struct
 
 /*================ Global variables ================*/
 
-struct file_operations hfs_cap_info_operations = {
+const struct file_operations hfs_cap_info_operations = {
 	llseek:		cap_info_llseek,
 	read:		cap_info_read,
 	write:		cap_info_write,
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_cap_info_inode_operations = {
+const struct inode_operations hfs_cap_info_inode_operations = {
 	setattr:	hfs_notify_change_cap,
 };
 
diff -urNp linux-2.4.37.7/fs/hfs/file_hdr.c linux-2.4.37.7/fs/hfs/file_hdr.c
--- linux-2.4.37.7/fs/hfs/file_hdr.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/file_hdr.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,14 +45,14 @@ static hfs_rwret_t hdr_write(struct file
 			     hfs_rwarg_t, loff_t *);
 /*================ Global variables ================*/
 
-struct file_operations hfs_hdr_operations = {
+const struct file_operations hfs_hdr_operations = {
 	llseek:		hdr_llseek,
 	read:		hdr_read,
 	write:		hdr_write,
 	fsync:		file_fsync,
 };
 
-struct inode_operations hfs_hdr_inode_operations = {
+const struct inode_operations hfs_hdr_inode_operations = {
 	setattr:	hfs_notify_change_hdr,
 };
 
diff -urNp linux-2.4.37.7/fs/hfs/hfs.h linux-2.4.37.7/fs/hfs/hfs.h
--- linux-2.4.37.7/fs/hfs/hfs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/hfs.h	2009-11-10 19:30:27.000000000 -0500
@@ -546,5 +546,5 @@ static __inline__ void hfs_drop_special(
   }
 }
 
-extern struct dentry_operations hfs_dentry_operations;
+extern const struct dentry_operations hfs_dentry_operations;
 #endif
diff -urNp linux-2.4.37.7/fs/hfs/inode.c linux-2.4.37.7/fs/hfs/inode.c
--- linux-2.4.37.7/fs/hfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -239,7 +239,7 @@ static int hfs_bmap(struct address_space
 {
 	return generic_block_bmap(mapping,block,hfs_get_block);
 }
-struct address_space_operations hfs_aops = {
+const struct address_space_operations hfs_aops = {
 	readpage: hfs_readpage,
 	writepage: hfs_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/hfs/super.c linux-2.4.37.7/fs/hfs/super.c
--- linux-2.4.37.7/fs/hfs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -43,7 +43,7 @@ static void hfs_write_super(struct super
 
 /*================ Global variables ================*/
 
-static struct super_operations hfs_super_operations = { 
+static const struct super_operations hfs_super_operations = { 
 	read_inode:	hfs_read_inode,
 	put_inode:	hfs_put_inode,
 	put_super:	hfs_put_super,
diff -urNp linux-2.4.37.7/fs/hfs/sysdep.c linux-2.4.37.7/fs/hfs/sysdep.c
--- linux-2.4.37.7/fs/hfs/sysdep.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfs/sysdep.c	2009-11-10 19:30:27.000000000 -0500
@@ -23,8 +23,7 @@ static int hfs_revalidate_dentry(struct 
 static int hfs_hash_dentry(struct dentry *, struct qstr *);
 static int hfs_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 static void hfs_dentry_iput(struct dentry *, struct inode *);
-struct dentry_operations hfs_dentry_operations =
-{
+const struct dentry_operations hfs_dentry_operations = {
 	d_revalidate:	hfs_revalidate_dentry,	
 	d_hash:		hfs_hash_dentry,
 	d_compare:	hfs_compare_dentry,
diff -urNp linux-2.4.37.7/fs/hfsplus/dir.c linux-2.4.37.7/fs/hfsplus/dir.c
--- linux-2.4.37.7/fs/hfsplus/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfsplus/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -468,7 +468,7 @@ int hfsplus_rename(struct inode *old_dir
 	return res;
 }
 
-struct inode_operations hfsplus_dir_inode_operations = {
+const struct inode_operations hfsplus_dir_inode_operations = {
 	.lookup		= hfsplus_lookup,
 	.create		= hfsplus_create,
 	.link		= hfsplus_link,
@@ -480,7 +480,7 @@ struct inode_operations hfsplus_dir_inod
 	.rename		= hfsplus_rename,
 };
 
-struct file_operations hfsplus_dir_operations = {
+const struct file_operations hfsplus_dir_operations = {
 	.read		= generic_read_dir,
 	.readdir	= hfsplus_readdir,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
diff -urNp linux-2.4.37.7/fs/hfsplus/hfsplus_fs.h linux-2.4.37.7/fs/hfsplus/hfsplus_fs.h
--- linux-2.4.37.7/fs/hfsplus/hfsplus_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfsplus/hfsplus_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -284,7 +284,7 @@ void hfsplus_cat_write_inode(struct inod
 struct inode *hfsplus_new_inode(struct super_block *, int);
 void hfsplus_delete_inode(struct inode *);
 
-extern struct address_space_operations hfsplus_btree_aops;
+extern const struct address_space_operations hfsplus_btree_aops;
 
 /* options.c */
 int parse_options(char *, struct hfsplus_sb_info *);
diff -urNp linux-2.4.37.7/fs/hfsplus/inode.c linux-2.4.37.7/fs/hfsplus/inode.c
--- linux-2.4.37.7/fs/hfsplus/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfsplus/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -117,7 +117,7 @@ int hfsplus_releasepage(struct page *pag
 	return res;
 }
 
-struct address_space_operations hfsplus_btree_aops = {
+const struct address_space_operations hfsplus_btree_aops = {
 	.readpage	= hfsplus_readpage,
 	.writepage	= hfsplus_writepage,
 	.sync_page	= block_sync_page,
@@ -127,7 +127,7 @@ struct address_space_operations hfsplus_
 	.releasepage	= hfsplus_releasepage,
 };
 
-struct address_space_operations hfsplus_aops = {
+const struct address_space_operations hfsplus_aops = {
 	.readpage	= hfsplus_readpage,
 	.writepage	= hfsplus_writepage,
 	.sync_page	= block_sync_page,
@@ -247,15 +247,15 @@ static int hfsplus_file_release(struct i
 	return 0;
 }
 
-extern struct inode_operations hfsplus_dir_inode_operations;
-extern struct file_operations hfsplus_dir_operations;
+extern const struct inode_operations hfsplus_dir_inode_operations;
+extern const struct file_operations hfsplus_dir_operations;
 
-struct inode_operations hfsplus_file_inode_operations = {
+const struct inode_operations hfsplus_file_inode_operations = {
 	.lookup		= hfsplus_file_lookup,
 	.truncate	= hfsplus_truncate,
 };
 
-struct file_operations hfsplus_file_operations = {
+const struct file_operations hfsplus_file_operations = {
 	.llseek 	= generic_file_llseek,
 	.read		= generic_file_read,
 	//.write	= hfsplus_file_write,
diff -urNp linux-2.4.37.7/fs/hfsplus/super.c linux-2.4.37.7/fs/hfsplus/super.c
--- linux-2.4.37.7/fs/hfsplus/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hfsplus/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -255,7 +255,7 @@ int hfsplus_remount(struct super_block *
 	return 0;
 }
 
-static struct super_operations hfsplus_sops = {
+static const struct super_operations hfsplus_sops = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	.alloc_inode	= hfsplus_alloc_inode,
 	.destroy_inode	= hfsplus_destroy_inode,
diff -urNp linux-2.4.37.7/fs/hpfs/dentry.c linux-2.4.37.7/fs/hpfs/dentry.c
--- linux-2.4.37.7/fs/hpfs/dentry.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/dentry.c	2009-11-10 19:30:27.000000000 -0500
@@ -49,7 +49,7 @@ int hpfs_compare_dentry(struct dentry *d
 	return 0;
 }
 
-struct dentry_operations hpfs_dentry_operations = {
+const struct dentry_operations hpfs_dentry_operations = {
 	d_hash:		hpfs_hash_dentry,
 	d_compare:	hpfs_compare_dentry,
 };
diff -urNp linux-2.4.37.7/fs/hpfs/file.c linux-2.4.37.7/fs/hpfs/file.c
--- linux-2.4.37.7/fs/hpfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -112,7 +112,7 @@ static int _hpfs_bmap(struct address_spa
 {
 	return generic_block_bmap(mapping,block,hpfs_get_block);
 }
-struct address_space_operations hpfs_aops = {
+const struct address_space_operations hpfs_aops = {
 	readpage: hpfs_readpage,
 	writepage: hpfs_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/hpfs/hpfs_fn.h linux-2.4.37.7/fs/hpfs/hpfs_fn.h
--- linux-2.4.37.7/fs/hpfs/hpfs_fn.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/hpfs_fn.h	2009-11-10 19:30:27.000000000 -0500
@@ -312,4 +312,4 @@ void hpfs_put_super(struct super_block *
 unsigned hpfs_count_one_bitmap(struct super_block *, secno);
 int hpfs_statfs(struct super_block *, struct statfs *);
 
-extern struct address_space_operations hpfs_aops;
+extern const struct address_space_operations hpfs_aops;
diff -urNp linux-2.4.37.7/fs/hpfs/inode.c linux-2.4.37.7/fs/hpfs/inode.c
--- linux-2.4.37.7/fs/hpfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -10,8 +10,7 @@
 #include <linux/smp_lock.h>
 #include "hpfs_fn.h"
 
-static struct file_operations hpfs_file_ops =
-{
+static const struct file_operations hpfs_file_ops = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		hpfs_file_write,
@@ -21,14 +20,12 @@ static struct file_operations hpfs_file_
 	fsync:		hpfs_file_fsync,
 };
 
-static struct inode_operations hpfs_file_iops =
-{
+static const struct inode_operations hpfs_file_iops = {
 	truncate:	hpfs_truncate,
 	setattr:	hpfs_notify_change,
 };
 
-static struct file_operations hpfs_dir_ops =
-{
+static const struct file_operations hpfs_dir_ops = {
 	llseek:		hpfs_dir_lseek,
 	read:		generic_read_dir,
 	readdir:	hpfs_readdir,
@@ -37,8 +34,7 @@ static struct file_operations hpfs_dir_o
 	fsync:		hpfs_file_fsync,
 };
 
-static struct inode_operations hpfs_dir_iops =
-{
+static const struct inode_operations hpfs_dir_iops = {
 	create:		hpfs_create,
 	lookup:		hpfs_lookup,
 	unlink:		hpfs_unlink,
@@ -50,7 +46,7 @@ static struct inode_operations hpfs_dir_
 	setattr:	hpfs_notify_change,
 };
 
-struct address_space_operations hpfs_symlink_aops = {
+const struct address_space_operations hpfs_symlink_aops = {
 	readpage:	hpfs_symlink_readpage
 };
 
diff -urNp linux-2.4.37.7/fs/hpfs/namei.c linux-2.4.37.7/fs/hpfs/namei.c
--- linux-2.4.37.7/fs/hpfs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -225,7 +225,7 @@ int hpfs_mknod(struct inode *dir, struct
 	return -ENOSPC;
 }
 
-extern struct address_space_operations hpfs_symlink_aops;
+extern const struct address_space_operations hpfs_symlink_aops;
 
 int hpfs_symlink(struct inode *dir, struct dentry *dentry, const char *symlink)
 {
diff -urNp linux-2.4.37.7/fs/hpfs/super.c linux-2.4.37.7/fs/hpfs/super.c
--- linux-2.4.37.7/fs/hpfs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/hpfs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -150,8 +150,7 @@ int hpfs_statfs(struct super_block *s, s
 
 /* Super operations */
 
-static struct super_operations hpfs_sops =
-{
+static const struct super_operations hpfs_sops = {
         read_inode:	hpfs_read_inode,
 	delete_inode:	hpfs_delete_inode,
 	put_super:	hpfs_put_super,
diff -urNp linux-2.4.37.7/fs/inode.c linux-2.4.37.7/fs/inode.c
--- linux-2.4.37.7/fs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -1200,7 +1200,7 @@ void iput(struct inode *inode)
 {
 	if (inode) {
 		struct super_block *sb = inode->i_sb;
-		struct super_operations *op = NULL;
+		const struct super_operations *op = NULL;
 
 		if (inode->i_state == I_CLEAR)
 			BUG();
diff -urNp linux-2.4.37.7/fs/intermezzo/dcache.c linux-2.4.37.7/fs/intermezzo/dcache.c
--- linux-2.4.37.7/fs/intermezzo/dcache.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/dcache.c	2009-11-10 19:30:27.000000000 -0500
@@ -112,8 +112,7 @@ static void presto_d_release(struct dent
         }
 }
 
-struct dentry_operations presto_dentry_ops = 
-{
+const struct dentry_operations presto_dentry_ops = {
         .d_revalidate =  presto_d_revalidate,
         .d_release = presto_d_release
 };
diff -urNp linux-2.4.37.7/fs/intermezzo/dir.c linux-2.4.37.7/fs/intermezzo/dir.c
--- linux-2.4.37.7/fs/intermezzo/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -248,7 +248,7 @@ struct dentry *presto_lookup(struct inod
         int minor;
         ino_t ino;
         unsigned int generation;
-        struct inode_operations *iops;
+        const struct inode_operations *iops;
         int is_ilookup = 0;
 
         ENTRY;
@@ -918,8 +918,8 @@ int presto_permission(struct inode *inod
 
         if ( cache ) {
                 /* we only override the file/dir permission operations */
-                struct inode_operations *fiops = filter_c2cfiops(cache->cache_filter);
-                struct inode_operations *diops = filter_c2cdiops(cache->cache_filter);
+                const struct inode_operations *fiops = filter_c2cfiops(cache->cache_filter);
+                const struct inode_operations *diops = filter_c2cdiops(cache->cache_filter);
 
                 if ( S_ISREG(mode) && fiops && fiops->permission ) {
                         EXIT;
@@ -1388,11 +1388,11 @@ int presto_ioctl(struct inode *inode, st
         return 0;
 }
 
-struct file_operations presto_dir_fops = {
+const struct file_operations presto_dir_fops = {
         .ioctl =  presto_ioctl
 };
 
-struct inode_operations presto_dir_iops = {
+const struct inode_operations presto_dir_iops = {
         .create       = presto_create,
         .lookup       = presto_lookup,
         .link         = presto_link,
diff -urNp linux-2.4.37.7/fs/intermezzo/file.c linux-2.4.37.7/fs/intermezzo/file.c
--- linux-2.4.37.7/fs/intermezzo/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -456,14 +456,14 @@ static ssize_t presto_file_write(struct 
         return res;
 }
 
-struct file_operations presto_file_fops = {
+const struct file_operations presto_file_fops = {
         .write   = presto_file_write,
         .open    = presto_file_open,
         .release = presto_file_release,
         .ioctl   = presto_ioctl
 };
 
-struct inode_operations presto_file_iops = {
+const struct inode_operations presto_file_iops = {
         .permission   = presto_permission,
         .setattr      = presto_setattr,
 #ifdef CONFIG_FS_EXT_ATTR
diff -urNp linux-2.4.37.7/fs/intermezzo/inode.c linux-2.4.37.7/fs/intermezzo/inode.c
--- linux-2.4.37.7/fs/intermezzo/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -172,14 +172,14 @@ exit:
         return ;
 }
 
-struct super_operations presto_super_ops = {
+const struct super_operations presto_super_ops = {
         .read_inode    = presto_read_inode,
         .put_super     = presto_put_super,
 };
 
 
 /* symlinks can be chowned */
-struct inode_operations presto_sym_iops = {
+const struct inode_operations presto_sym_iops = {
         .setattr       = presto_setattr
 };
 
diff -urNp linux-2.4.37.7/fs/intermezzo/methods.c linux-2.4.37.7/fs/intermezzo/methods.c
--- linux-2.4.37.7/fs/intermezzo/methods.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/methods.c	2009-11-10 19:30:27.000000000 -0500
@@ -60,85 +60,85 @@ int filter_debug = 0xfffffff;
 static struct filter_fs filter_oppar[FILTER_FS_TYPES];
 
 /* get to the upper methods (intermezzo, snapfs) */
-inline struct super_operations *filter_c2usops(struct filter_fs *cache)
+inline const struct super_operations *filter_c2usops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_sops;
 }
 
-inline struct inode_operations *filter_c2udiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2udiops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_dir_iops;
 }
 
 
-inline struct inode_operations *filter_c2ufiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2ufiops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_file_iops;
 }
 
-inline struct inode_operations *filter_c2usiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2usiops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_sym_iops;
 }
 
 
-inline struct file_operations *filter_c2udfops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2udfops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_dir_fops;
 }
 
-inline struct file_operations *filter_c2uffops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2uffops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_file_fops;
 }
 
-inline struct file_operations *filter_c2usfops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2usfops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_sym_fops;
 }
 
-inline struct dentry_operations *filter_c2udops(struct filter_fs *cache)
+inline const struct dentry_operations *filter_c2udops(struct filter_fs *cache)
 {
         return &cache->o_fops.filter_dentry_ops;
 }
 
 /* get to the cache (lower) methods */
-inline struct super_operations *filter_c2csops(struct filter_fs *cache)
+inline const struct super_operations *filter_c2csops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_sops;
 }
 
-inline struct inode_operations *filter_c2cdiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2cdiops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_dir_iops;
 }
 
-inline struct inode_operations *filter_c2cfiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2cfiops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_file_iops;
 }
 
-inline struct inode_operations *filter_c2csiops(struct filter_fs *cache)
+inline const struct inode_operations *filter_c2csiops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_sym_iops;
 }
 
-inline struct file_operations *filter_c2cdfops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2cdfops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_dir_fops;
 }
 
-inline struct file_operations *filter_c2cffops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2cffops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_file_fops;
 }
 
-inline struct file_operations *filter_c2csfops(struct filter_fs *cache)
+inline const struct file_operations *filter_c2csfops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_sym_fops;
 }
 
-inline struct dentry_operations *filter_c2cdops(struct filter_fs *cache)
+inline const struct dentry_operations *filter_c2cdops(struct filter_fs *cache)
 {
         return cache->o_caops.cache_dentry_ops;
 }
@@ -265,7 +265,7 @@ struct filter_fs *filter_get_filter_fs(c
  *    and the underlying file system used for the cache.
  */
 
-void filter_setup_super_ops(struct filter_fs *cache, struct super_operations *cache_sops, struct super_operations *filter_sops)
+void filter_setup_super_ops(struct filter_fs *cache, const struct super_operations *cache_sops, const struct super_operations *filter_sops)
 {
         /* Get ptr to the shared struct snapfs_ops structure. */
         struct filter_ops *props = &cache->o_fops;
@@ -307,11 +307,11 @@ void filter_setup_super_ops(struct filte
 }
 
 
-void filter_setup_dir_ops(struct filter_fs *cache, struct inode *inode, struct inode_operations *filter_iops, struct file_operations *filter_fops)
+void filter_setup_dir_ops(struct filter_fs *cache, struct inode *inode, const struct inode_operations *filter_iops, const struct file_operations *filter_fops)
 {
-        struct inode_operations *cache_filter_iops;
-        struct inode_operations *cache_iops = inode->i_op;
-        struct file_operations *cache_fops = inode->i_fop;
+        const struct inode_operations *cache_filter_iops;
+        const struct inode_operations *cache_iops = inode->i_op;
+        const struct file_operations *cache_fops = inode->i_fop;
         FENTRY;
 
         if ( cache->o_flags & FILTER_DID_DIR_OPS ) {
@@ -382,11 +382,11 @@ void filter_setup_dir_ops(struct filter_
 }
 
 
-void filter_setup_file_ops(struct filter_fs *cache, struct inode *inode, struct inode_operations *filter_iops, struct file_operations *filter_fops)
+void filter_setup_file_ops(struct filter_fs *cache, struct inode *inode, const struct inode_operations *filter_iops, const struct file_operations *filter_fops)
 {
-        struct inode_operations *pr_iops;
-        struct inode_operations *cache_iops = inode->i_op;
-        struct file_operations *cache_fops = inode->i_fop;
+        const struct inode_operations *pr_iops;
+        const struct inode_operations *cache_iops = inode->i_op;
+        const struct file_operations *cache_fops = inode->i_fop;
         FENTRY;
 
         if ( cache->o_flags & FILTER_DID_FILE_OPS ) {
@@ -438,11 +438,11 @@ void filter_setup_file_ops(struct filter
 }
 
 /* XXX in 2.3 there are "fast" and "slow" symlink ops for ext2 XXX */
-void filter_setup_symlink_ops(struct filter_fs *cache, struct inode *inode, struct inode_operations *filter_iops, struct file_operations *filter_fops)
+void filter_setup_symlink_ops(struct filter_fs *cache, struct inode *inode, const struct inode_operations *filter_iops, const struct file_operations *filter_fops)
 {
-        struct inode_operations *pr_iops;
-        struct inode_operations *cache_iops = inode->i_op;
-        struct file_operations *cache_fops = inode->i_fop;
+        const struct inode_operations *pr_iops;
+        const struct inode_operations *cache_iops = inode->i_op;
+        const struct file_operations *cache_fops = inode->i_fop;
         FENTRY;
 
         if ( cache->o_flags & FILTER_DID_SYMLINK_OPS ) {
@@ -477,8 +477,8 @@ void filter_setup_symlink_ops(struct fil
 }
 
 void filter_setup_dentry_ops(struct filter_fs *cache,
-                             struct dentry_operations *cache_dop,
-                             struct dentry_operations *filter_dop)
+                             const struct dentry_operations *cache_dop,
+                             const struct dentry_operations *filter_dop)
 {
         if ( cache->o_flags & FILTER_DID_DENTRY_OPS ) {
                 FEXIT;
diff -urNp linux-2.4.37.7/fs/intermezzo/psdev.c linux-2.4.37.7/fs/intermezzo/psdev.c
--- linux-2.4.37.7/fs/intermezzo/psdev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/psdev.c	2009-11-10 19:30:27.000000000 -0500
@@ -364,7 +364,7 @@ static int presto_psdev_release(struct i
         return 0;
 }
 
-static struct file_operations presto_psdev_fops = {
+static const struct file_operations presto_psdev_fops = {
         .read    = presto_psdev_read,
         .write   = presto_psdev_write,
         .poll    = presto_psdev_poll,
diff -urNp linux-2.4.37.7/fs/intermezzo/vfs.c linux-2.4.37.7/fs/intermezzo/vfs.c
--- linux-2.4.37.7/fs/intermezzo/vfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/intermezzo/vfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -79,7 +79,7 @@
 # endif
 #endif
 
-extern struct inode_operations presto_sym_iops;
+extern const struct inode_operations presto_sym_iops;
 
 /* Write the last_rcvd values to the last_rcvd file.  We don't know what the
  * UUID or last_ctime values are, so we have to read from the file first
@@ -228,7 +228,7 @@ int presto_settime(struct presto_file_se
         int error = 0;
         struct dentry *dentry;
         struct inode *inode;
-        struct inode_operations *iops;
+        const struct inode_operations *iops;
         struct iattr iattr;
 
         ENTRY;
@@ -363,7 +363,7 @@ int presto_do_setattr(struct presto_file
 {
         struct rec_info rec;
         struct inode *inode = dentry->d_inode;
-        struct inode_operations *iops;
+        const struct inode_operations *iops;
         int error;
         struct presto_version old_ver, new_ver;
         struct izo_rollback_data rb;
@@ -521,7 +521,16 @@ int lento_setattr(const char *name, stru
                  * acl journalling is in place.
                  */
                 set_posix_acl=dentry->d_inode->i_op->set_posix_acl;
-                dentry->d_inode->i_op->set_posix_acl=NULL;
+#ifdef CONFIG_PAX_KERNEXEC
+		{
+			unsigned long cr0;
+			pax_open_kernel(cr0);
+#endif 
+	                dentry->d_inode->i_op->set_posix_acl=NULL;
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+		}
+#endif
 #endif
         }
 
@@ -537,8 +546,16 @@ int lento_setattr(const char *name, stru
 
 #ifdef CONFIG_FS_POSIX_ACL
         /* restore the inode_operations if we changed them*/
-        if (iattr->ia_valid & ATTR_MODE) 
+        if (iattr->ia_valid & ATTR_MODE) {
+#ifdef CONFIG_PAX_KERNEXEC
+		unsigned long cr0;
+		pax_open_kernel(cr0);
+#endif 
                 dentry->d_inode->i_op->set_posix_acl=set_posix_acl;
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+	}
 #endif
 
 
diff -urNp linux-2.4.37.7/fs/isofs/compress.c linux-2.4.37.7/fs/isofs/compress.c
--- linux-2.4.37.7/fs/isofs/compress.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/isofs/compress.c	2009-11-10 19:30:27.000000000 -0500
@@ -330,7 +330,7 @@ eio:
 	return err;
 }
 
-struct address_space_operations zisofs_aops = {
+const struct address_space_operations zisofs_aops = {
 	readpage: zisofs_readpage,
 	/* No sync_page operation supported? */
 	/* No bmap operation supported */
diff -urNp linux-2.4.37.7/fs/isofs/dir.c linux-2.4.37.7/fs/isofs/dir.c
--- linux-2.4.37.7/fs/isofs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/isofs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -26,8 +26,7 @@
 
 static int isofs_readdir(struct file *, void *, filldir_t);
 
-struct file_operations isofs_dir_operations =
-{
+const struct file_operations isofs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	isofs_readdir,
 };
@@ -35,8 +34,7 @@ struct file_operations isofs_dir_operati
 /*
  * directories can handle most operations...
  */
-struct inode_operations isofs_dir_inode_operations =
-{
+const struct inode_operations isofs_dir_inode_operations = {
 	lookup:		isofs_lookup,
 };
 
diff -urNp linux-2.4.37.7/fs/isofs/inode.c linux-2.4.37.7/fs/isofs/inode.c
--- linux-2.4.37.7/fs/isofs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/isofs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -73,13 +73,13 @@ static void isofs_put_super(struct super
 static void isofs_read_inode(struct inode *);
 static int isofs_statfs (struct super_block *, struct statfs *);
 
-static struct super_operations isofs_sops = {
+static const struct super_operations isofs_sops = {
 	read_inode:	isofs_read_inode,
 	put_super:	isofs_put_super,
 	statfs:		isofs_statfs,
 };
 
-static struct dentry_operations isofs_dentry_ops[] = {
+static const struct dentry_operations isofs_dentry_ops[] = {
 	{
 		d_hash:		isofs_hash,
 		d_compare:	isofs_dentry_cmp,
@@ -989,7 +989,7 @@ static int _isofs_bmap(struct address_sp
 	return generic_block_bmap(mapping,block,isofs_get_block);
 }
 
-static struct address_space_operations isofs_aops = {
+static const struct address_space_operations isofs_aops = {
 	readpage: isofs_readpage,
 	sync_page: block_sync_page,
 	bmap: _isofs_bmap
diff -urNp linux-2.4.37.7/fs/isofs/rock.c linux-2.4.37.7/fs/isofs/rock.c
--- linux-2.4.37.7/fs/isofs/rock.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/isofs/rock.c	2009-11-10 19:30:27.000000000 -0500
@@ -618,6 +618,6 @@ static int rock_ridge_symlink_readpage(s
 	return -EIO;
 }
 
-struct address_space_operations isofs_symlink_aops = {
+const struct address_space_operations isofs_symlink_aops = {
 	readpage:	rock_ridge_symlink_readpage
 };
diff -urNp linux-2.4.37.7/fs/isofs/zisofs.h linux-2.4.37.7/fs/isofs/zisofs.h
--- linux-2.4.37.7/fs/isofs/zisofs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/isofs/zisofs.h	2009-11-10 19:30:27.000000000 -0500
@@ -15,7 +15,7 @@
  */
 
 #ifdef CONFIG_ZISOFS
-extern struct address_space_operations zisofs_aops;
+extern const struct address_space_operations zisofs_aops;
 extern int __init zisofs_init(void);
 extern void __exit zisofs_cleanup(void);
 #endif
diff -urNp linux-2.4.37.7/fs/jffs/inode-v23.c linux-2.4.37.7/fs/jffs/inode-v23.c
--- linux-2.4.37.7/fs/jffs/inode-v23.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs/inode-v23.c	2009-11-10 19:30:27.000000000 -0500
@@ -60,12 +60,12 @@
 
 static int jffs_remove(struct inode *dir, struct dentry *dentry, int type);
 
-static struct super_operations jffs_ops;
-static struct file_operations jffs_file_operations;
-static struct inode_operations jffs_file_inode_operations;
-static struct file_operations jffs_dir_operations;
-static struct inode_operations jffs_dir_inode_operations;
-static struct address_space_operations jffs_address_operations;
+static const struct super_operations jffs_ops;
+static const struct file_operations jffs_file_operations;
+static const struct inode_operations jffs_file_inode_operations;
+static const struct file_operations jffs_dir_operations;
+static const struct inode_operations jffs_dir_inode_operations;
+static const struct address_space_operations jffs_address_operations;
 
 kmem_cache_t     *node_cache = NULL;
 kmem_cache_t     *fm_cache = NULL;
@@ -1574,7 +1574,7 @@ jffs_ioctl(struct inode *inode, struct f
 } /* jffs_ioctl()  */
 
 
-static struct address_space_operations jffs_address_operations = {
+static const struct address_space_operations jffs_address_operations = {
 	readpage: jffs_readpage,
 	prepare_write: jffs_prepare_write,
 	commit_write: jffs_commit_write,
@@ -1592,8 +1592,7 @@ static int jffs_fsync(struct file *f, st
 extern int generic_file_open(struct inode *, struct file *) __attribute__((weak));
 extern loff_t generic_file_llseek(struct file *, loff_t, int) __attribute__((weak));
 
-static struct file_operations jffs_file_operations =
-{
+static const struct file_operations jffs_file_operations = {
 	open:	generic_file_open,
 	llseek:	generic_file_llseek,
 	read:	generic_file_read,
@@ -1604,21 +1603,18 @@ static struct file_operations jffs_file_
 };
 
 
-static struct inode_operations jffs_file_inode_operations =
-{
+static const struct inode_operations jffs_file_inode_operations = {
 	lookup:  jffs_lookup,          /* lookup */
 	setattr: jffs_setattr,
 };
 
 
-static struct file_operations jffs_dir_operations =
-{
+static const struct file_operations jffs_dir_operations = {
 	readdir:	jffs_readdir,
 };
 
 
-static struct inode_operations jffs_dir_inode_operations =
-{
+static const struct inode_operations jffs_dir_inode_operations = {
 	create:   jffs_create,
 	lookup:   jffs_lookup,
 	unlink:   jffs_unlink,
@@ -1724,8 +1720,7 @@ jffs_write_super(struct super_block *sb)
 	jffs_garbage_collect_trigger(c);
 }
 
-static struct super_operations jffs_ops =
-{
+static const struct super_operations jffs_ops = {
 	read_inode:   jffs_read_inode,
 	delete_inode: jffs_delete_inode,
 	put_super:    jffs_put_super,
diff -urNp linux-2.4.37.7/fs/jffs2/dir.c linux-2.4.37.7/fs/jffs2/dir.c
--- linux-2.4.37.7/fs/jffs2/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs2/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -58,8 +58,7 @@ static int jffs2_mknod (struct inode *,s
 static int jffs2_rename (struct inode *, struct dentry *,
                         struct inode *, struct dentry *);
 
-struct file_operations jffs2_dir_operations =
-{
+const struct file_operations jffs2_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	jffs2_readdir,
 	ioctl:		jffs2_ioctl,
@@ -67,8 +66,7 @@ struct file_operations jffs2_dir_operati
 };
 
 
-struct inode_operations jffs2_dir_inode_operations =
-{
+const struct inode_operations jffs2_dir_inode_operations = {
 	create:		jffs2_create,
 	lookup:		jffs2_lookup,
 	link:		jffs2_link,
diff -urNp linux-2.4.37.7/fs/jffs2/file.c linux-2.4.37.7/fs/jffs2/file.c
--- linux-2.4.37.7/fs/jffs2/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs2/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -54,8 +54,7 @@ int jffs2_null_fsync(struct file *filp, 
 	return 0;
 }
 
-struct file_operations jffs2_file_operations =
-{
+const struct file_operations jffs2_file_operations = {
 	llseek:		generic_file_llseek,
 	open:		generic_file_open,
 	read:		generic_file_read,
@@ -67,13 +66,11 @@ struct file_operations jffs2_file_operat
 
 /* jffs2_file_inode_operations */
 
-struct inode_operations jffs2_file_inode_operations =
-{
+const struct inode_operations jffs2_file_inode_operations = {
 	setattr:	jffs2_setattr
 };
 
-struct address_space_operations jffs2_file_address_operations =
-{
+const struct address_space_operations jffs2_file_address_operations = {
 	readpage:	jffs2_readpage,
 	prepare_write:	jffs2_prepare_write,
 	commit_write:	jffs2_commit_write
diff -urNp linux-2.4.37.7/fs/jffs2/nodelist.h linux-2.4.37.7/fs/jffs2/nodelist.h
--- linux-2.4.37.7/fs/jffs2/nodelist.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs2/nodelist.h	2009-11-10 19:30:27.000000000 -0500
@@ -307,13 +307,13 @@ void jffs2_stop_garbage_collect_thread(s
 void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);
 
 /* dir.c */
-extern struct file_operations jffs2_dir_operations;
-extern struct inode_operations jffs2_dir_inode_operations;
+extern const struct file_operations jffs2_dir_operations;
+extern const struct inode_operations jffs2_dir_inode_operations;
 
 /* file.c */
-extern struct file_operations jffs2_file_operations;
-extern struct inode_operations jffs2_file_inode_operations;
-extern struct address_space_operations jffs2_file_address_operations;
+extern const struct file_operations jffs2_file_operations;
+extern const struct inode_operations jffs2_file_inode_operations;
+extern const struct address_space_operations jffs2_file_address_operations;
 int jffs2_null_fsync(struct file *, struct dentry *, int);
 int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
 int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
@@ -341,7 +341,7 @@ int jffs2_scan_medium(struct jffs2_sb_in
 int jffs2_build_filesystem(struct jffs2_sb_info *c);
 
 /* symlink.c */
-extern struct inode_operations jffs2_symlink_inode_operations;
+extern const struct inode_operations jffs2_symlink_inode_operations;
 
 /* erase.c */
 void jffs2_erase_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
diff -urNp linux-2.4.37.7/fs/jffs2/super.c linux-2.4.37.7/fs/jffs2/super.c
--- linux-2.4.37.7/fs/jffs2/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs2/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -60,8 +60,7 @@ static int jffs2_statfs (struct super_bl
 int jffs2_remount_fs (struct super_block *, int *, char *);
 extern void jffs2_clear_inode (struct inode *);
 
-static struct super_operations jffs2_super_operations =
-{
+static const struct super_operations jffs2_super_operations = {
 	read_inode:	jffs2_read_inode,
 //	delete_inode:	jffs2_delete_inode,
 	put_super:	jffs2_put_super,
diff -urNp linux-2.4.37.7/fs/jffs2/symlink.c linux-2.4.37.7/fs/jffs2/symlink.c
--- linux-2.4.37.7/fs/jffs2/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jffs2/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,8 +45,7 @@
 int jffs2_readlink(struct dentry *dentry, char *buffer, int buflen);
 int jffs2_follow_link(struct dentry *dentry, struct nameidata *nd);
 
-struct inode_operations jffs2_symlink_inode_operations =
-{	
+const struct inode_operations jffs2_symlink_inode_operations = {	
 	readlink:	jffs2_readlink,
 	follow_link:	jffs2_follow_link,
 	setattr:	jffs2_setattr
diff -urNp linux-2.4.37.7/fs/jfs/file.c linux-2.4.37.7/fs/jfs/file.c
--- linux-2.4.37.7/fs/jfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -96,7 +96,7 @@ static int jfs_release(struct inode *ino
 	return 0;
 }
 
-struct inode_operations jfs_file_inode_operations = {
+const struct inode_operations jfs_file_inode_operations = {
 	.truncate	= jfs_truncate,
 	.setxattr	= jfs_setxattr,
 	.getxattr	= jfs_getxattr,
@@ -104,7 +104,7 @@ struct inode_operations jfs_file_inode_o
 	.removexattr	= jfs_removexattr,
 };
 
-struct file_operations jfs_file_operations = {
+const struct file_operations jfs_file_operations = {
 	.open		= jfs_open,
 	.llseek		= generic_file_llseek,
 	.write		= generic_file_write,
diff -urNp linux-2.4.37.7/fs/jfs/inode.c linux-2.4.37.7/fs/jfs/inode.c
--- linux-2.4.37.7/fs/jfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,12 +28,12 @@
 #include "jfs_debug.h"
 
 
-extern struct inode_operations jfs_dir_inode_operations;
-extern struct inode_operations jfs_file_inode_operations;
-extern struct inode_operations jfs_symlink_inode_operations;
-extern struct file_operations jfs_dir_operations;
-extern struct file_operations jfs_file_operations;
-struct address_space_operations jfs_aops;
+extern const struct inode_operations jfs_dir_inode_operations;
+extern const struct inode_operations jfs_file_inode_operations;
+extern const struct inode_operations jfs_symlink_inode_operations;
+extern const struct file_operations jfs_dir_operations;
+extern const struct file_operations jfs_file_operations;
+const struct address_space_operations jfs_aops;
 extern int freeZeroLink(struct inode *);
 
 void jfs_clear_inode(struct inode *inode)
@@ -335,7 +335,7 @@ static int jfs_direct_IO(int rw, struct 
 				 blocksize, jfs_get_block);
 }
 
-struct address_space_operations jfs_aops = {
+const struct address_space_operations jfs_aops = {
 	.readpage	= jfs_readpage,
 	.writepage	= jfs_writepage,
 	.sync_page	= block_sync_page,
diff -urNp linux-2.4.37.7/fs/jfs/jfs_imap.c linux-2.4.37.7/fs/jfs/jfs_imap.c
--- linux-2.4.37.7/fs/jfs/jfs_imap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/jfs_imap.c	2009-11-10 19:30:27.000000000 -0500
@@ -68,7 +68,7 @@
 /*
  * external references
  */
-extern struct address_space_operations jfs_aops;
+extern const struct address_space_operations jfs_aops;
 
 /*
  * forward references
diff -urNp linux-2.4.37.7/fs/jfs/namei.c linux-2.4.37.7/fs/jfs/namei.c
--- linux-2.4.37.7/fs/jfs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,10 +28,10 @@
 #include "jfs_xattr.h"
 #include "jfs_debug.h"
 
-extern struct inode_operations jfs_file_inode_operations;
-extern struct inode_operations jfs_symlink_inode_operations;
-extern struct file_operations jfs_file_operations;
-extern struct address_space_operations jfs_aops;
+extern const struct inode_operations jfs_file_inode_operations;
+extern const struct inode_operations jfs_symlink_inode_operations;
+extern const struct file_operations jfs_file_operations;
+extern const struct address_space_operations jfs_aops;
 
 extern int jfs_fsync(struct file *, struct dentry *, int);
 extern void jfs_truncate_nolock(struct inode *, loff_t);
@@ -39,8 +39,8 @@ extern void jfs_truncate_nolock(struct i
 /*
  * forward references
  */
-struct inode_operations jfs_dir_inode_operations;
-struct file_operations jfs_dir_operations;
+const const struct inode_operations jfs_dir_inode_operations;
+const const struct file_operations jfs_dir_operations;
 
 static s64 commitZeroLink(tid_t, struct inode *);
 
@@ -1401,7 +1401,7 @@ static struct dentry *jfs_lookup(struct 
 	return ERR_PTR(0);
 }
 
-struct inode_operations jfs_dir_inode_operations = {
+const struct inode_operations jfs_dir_inode_operations = {
 	.create		= jfs_create,
 	.lookup		= jfs_lookup,
 	.link		= jfs_link,
@@ -1417,7 +1417,7 @@ struct inode_operations jfs_dir_inode_op
 	.removexattr	= jfs_removexattr,
 };
 
-struct file_operations jfs_dir_operations = {
+const struct file_operations jfs_dir_operations = {
 	.read		= generic_read_dir,
 	.readdir	= jfs_readdir,
 	.fsync		= jfs_fsync,
diff -urNp linux-2.4.37.7/fs/jfs/super.c linux-2.4.37.7/fs/jfs/super.c
--- linux-2.4.37.7/fs/jfs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -35,7 +35,7 @@ MODULE_DESCRIPTION("The Journaled Filesy
 MODULE_AUTHOR("Steve Best/Dave Kleikamp/Barry Arndt, IBM");
 MODULE_LICENSE("GPL");
 
-static struct super_operations jfs_super_operations;
+static const struct super_operations jfs_super_operations;
 static struct file_system_type jfs_fs_type;
 
 int jfs_stop_threads;
@@ -452,7 +452,7 @@ static int jfs_sync_fs(struct super_bloc
 	return 0;
 }
 
-static struct super_operations jfs_super_operations = {
+static const struct super_operations jfs_super_operations = {
 	.read_inode	= jfs_read_inode,
 	.dirty_inode	= jfs_dirty_inode,
 	.write_inode	= jfs_write_inode,
diff -urNp linux-2.4.37.7/fs/jfs/symlink.c linux-2.4.37.7/fs/jfs/symlink.c
--- linux-2.4.37.7/fs/jfs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/jfs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -32,7 +32,7 @@ static int jfs_readlink(struct dentry *d
 	return vfs_readlink(dentry, buffer, buflen, s);
 }
 
-struct inode_operations jfs_symlink_inode_operations = {
+const struct inode_operations jfs_symlink_inode_operations = {
 	.readlink	= jfs_readlink,
 	.follow_link	= jfs_follow_link,
 	.setxattr	= jfs_setxattr,
diff -urNp linux-2.4.37.7/fs/Makefile linux-2.4.37.7/fs/Makefile
--- linux-2.4.37.7/fs/Makefile	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/Makefile	2009-11-10 19:30:27.000000000 -0500
@@ -7,7 +7,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o exec.o
 mod-subdirs :=	nls
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
diff -urNp linux-2.4.37.7/fs/minix/dir.c linux-2.4.37.7/fs/minix/dir.c
--- linux-2.4.37.7/fs/minix/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/minix/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -14,7 +14,7 @@ typedef struct minix_dir_entry minix_dir
 
 static int minix_readdir(struct file *, void *, filldir_t);
 
-struct file_operations minix_dir_operations = {
+const struct file_operations minix_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	minix_readdir,
 	fsync:		minix_sync_file,
diff -urNp linux-2.4.37.7/fs/minix/file.c linux-2.4.37.7/fs/minix/file.c
--- linux-2.4.37.7/fs/minix/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/minix/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,7 +15,7 @@
  */
 int minix_sync_file(struct file *, struct dentry *, int);
 
-struct file_operations minix_file_operations = {
+const struct file_operations minix_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		generic_file_write,
@@ -23,7 +23,7 @@ struct file_operations minix_file_operat
 	fsync:		minix_sync_file,
 };
 
-struct inode_operations minix_file_inode_operations = {
+const struct inode_operations minix_file_inode_operations = {
 	truncate:	minix_truncate,
 };
 
diff -urNp linux-2.4.37.7/fs/minix/inode.c linux-2.4.37.7/fs/minix/inode.c
--- linux-2.4.37.7/fs/minix/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/minix/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -75,7 +75,7 @@ static void minix_put_super(struct super
 	return;
 }
 
-static struct super_operations minix_sops = {
+static const struct super_operations minix_sops = {
 	read_inode:	minix_read_inode,
 	write_inode:	minix_write_inode,
 	delete_inode:	minix_delete_inode,
@@ -317,7 +317,7 @@ static int minix_bmap(struct address_spa
 {
 	return generic_block_bmap(mapping,block,minix_get_block);
 }
-static struct address_space_operations minix_aops = {
+static const struct address_space_operations minix_aops = {
 	readpage: minix_readpage,
 	writepage: minix_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/minix/namei.c linux-2.4.37.7/fs/minix/namei.c
--- linux-2.4.37.7/fs/minix/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/minix/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -52,7 +52,7 @@ static int minix_hash(struct dentry *den
 	return 0;
 }
 
-struct dentry_operations minix_dentry_operations = {
+const struct dentry_operations minix_dentry_operations = {
 	d_hash:		minix_hash,
 };
 
@@ -302,7 +302,7 @@ out:
 /*
  * directories can handle most operations...
  */
-struct inode_operations minix_dir_inode_operations = {
+const struct inode_operations minix_dir_inode_operations = {
 	create:		minix_create,
 	lookup:		minix_lookup,
 	link:		minix_link,
diff -urNp linux-2.4.37.7/fs/msdos/namei.c linux-2.4.37.7/fs/msdos/namei.c
--- linux-2.4.37.7/fs/msdos/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/msdos/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -198,7 +198,7 @@ old_compare:
 }
 
 
-static struct dentry_operations msdos_dentry_operations = {
+static const struct dentry_operations msdos_dentry_operations = {
 	d_hash:		msdos_hash,
 	d_compare:	msdos_cmp,
 };
@@ -578,7 +578,7 @@ rename_done:
 
 
 /* The public inode operations for the msdos fs */
-struct inode_operations msdos_dir_inode_operations = {
+const struct inode_operations msdos_dir_inode_operations = {
 	create:		msdos_create,
 	lookup:		msdos_lookup,
 	unlink:		msdos_unlink,
diff -urNp linux-2.4.37.7/fs/namei.c linux-2.4.37.7/fs/namei.c
--- linux-2.4.37.7/fs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#include <linux/grsecurity.h>
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
@@ -351,6 +352,13 @@ static inline int do_follow_link(struct 
 		current->state = TASK_RUNNING;
 		schedule();
 	}
+
+	if (gr_handle_follow_link(dentry->d_parent->d_inode,
+				  dentry->d_inode, dentry, nd->mnt)) {
+		path_release(nd);
+		return -EACCES;
+	}
+
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
@@ -655,11 +663,18 @@ return_reval:
 			}
 		}
 return_base:
+		if (!gr_acl_handle_hidden_file(nd->dentry, nd->mnt)) {
+			path_release(nd);
+			return -ENOENT;
+		}
 		return 0;
 out_dput:
 		dput(dentry);
 		break;
 	}
+	if (!gr_acl_handle_hidden_file(nd->dentry, nd->mnt))
+		err = -ENOENT;
+
 	path_release(nd);
 return_err:
 	return err;
@@ -1035,7 +1050,19 @@ int open_namei(const char * pathname, in
 		error = path_lookup(pathname, lookup_flags(flag), nd);
 		if (error)
 			return error;
+
+		if (gr_handle_rawio(nd->dentry->d_inode)) {
+			error = -EPERM;
+			goto exit;
+		}
+	
+		if (!gr_acl_handle_open(nd->dentry, nd->mnt, flag)) {
+			error = -EACCES;
+			goto exit;
+		}
+
 		dentry = nd->dentry;
+
 		goto ok;
 	}
 
@@ -1068,8 +1095,22 @@ do_last:
 
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
+		if (gr_handle_chroot_chmod(dentry, nd->mnt, mode)) {
+			error = -EACCES;
+			up(&dir->d_inode->i_sem);
+			goto exit_dput;
+		}
+		if (!gr_acl_handle_creat(dentry, nd->dentry, nd->mnt, flag, mode)) {
+			error = -EACCES;
+			up(&dir->d_inode->i_sem);
+			goto exit_dput;
+		}
+
 		error = vfs_create(dir->d_inode, dentry,
 				   mode & ~current->fs->umask);
+		if (!error)
+			gr_handle_create(dentry, nd->mnt);
+
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
 		nd->dentry = dentry;
@@ -1084,6 +1125,27 @@ do_last:
 	/*
 	 * It already exists.
 	 */
+
+	if (gr_handle_rawio(dentry->d_inode)) {
+		error = -EPERM;
+		up(&dir->d_inode->i_sem);
+		goto exit_dput;
+	}
+
+	if (!gr_acl_handle_open(dentry, nd->mnt, flag)) {
+		error = -EACCES;
+		up(&dir->d_inode->i_sem);
+		goto exit_dput;
+	}
+
+	inode = dentry->d_inode;
+
+	if (gr_handle_fifo(dentry, nd->mnt, dir, flag, acc_mode)) {
+		up(&dir->d_inode->i_sem);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	up(&dir->d_inode->i_sem);
 
 	error = -EEXIST;
@@ -1173,7 +1235,7 @@ ok:
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry,0,nd->mnt);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1204,6 +1266,13 @@ do_link:
 	 * stored in nd->last.name and we will have to putname() it when we
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
+
+	if (gr_handle_follow_link(dentry->d_parent->d_inode, dentry->d_inode,
+				  dentry, nd->mnt)) {
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	UPDATE_ATIME(dentry->d_inode);
 	mnt = mntget(nd->mnt);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
@@ -1304,6 +1373,19 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		if (gr_handle_chroot_mknod(dentry, nd.mnt, mode) ||
+		    gr_handle_chroot_chmod(dentry, nd.mnt, mode)) {
+			error = -EPERM;
+			dput(dentry);
+			goto out_dput;
+		}
+
+		if (!gr_acl_handle_mknod(dentry, nd.dentry, nd.mnt, mode)) {
+			error = -EACCES;
+			dput(dentry);
+			goto out_dput;
+		}
+	
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
@@ -1317,8 +1399,13 @@ asmlinkage long sys_mknod(const char * f
 		default:
 			error = -EINVAL;
 		}
+
+		if(!error)
+			gr_handle_create(dentry, nd.mnt);
+
 		dput(dentry);
 	}
+out_dput:
 	up(&nd.dentry->d_inode->i_sem);
 	path_release(&nd);
 out:
@@ -1370,8 +1457,17 @@ asmlinkage long sys_mkdir(const char * p
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_mkdir(nd.dentry->d_inode, dentry,
+			error = 0;
+
+			if (!gr_acl_handle_mkdir(dentry, nd.dentry, nd.mnt))
+				error = -EACCES;
+
+			if(!error)
+				error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
+			if(!error)
+				gr_handle_create(dentry, nd.mnt);
+			
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1455,6 +1551,8 @@ asmlinkage long sys_rmdir(const char * p
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1479,7 +1577,22 @@ asmlinkage long sys_rmdir(const char * p
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
-		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		error = 0;
+		if (dentry->d_inode) {
+			if (dentry->d_inode->i_nlink <= 1) {
+				saved_ino = dentry->d_inode->i_ino;
+				saved_dev = dentry->d_inode->i_dev;
+			}
+
+			if (!gr_acl_handle_rmdir(dentry, nd.mnt))
+				error = -EACCES;
+		}
+
+		if (!error)
+			error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		if (!error && (saved_dev || saved_ino))
+			gr_handle_delete(saved_ino,saved_dev);
+
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1530,6 +1643,8 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1548,7 +1663,21 @@ asmlinkage long sys_unlink(const char * 
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
-		error = vfs_unlink(nd.dentry->d_inode, dentry);
+		error = 0;
+		if (dentry->d_inode) {
+			if (dentry->d_inode->i_nlink <= 1) {
+				saved_ino = dentry->d_inode->i_ino;
+				saved_dev = dentry->d_inode->i_dev;
+			}
+
+			if (!gr_acl_handle_unlink(dentry, nd.mnt))
+				error = -EACCES;
+		}
+
+		if (!error)
+			error = vfs_unlink(nd.dentry->d_inode, dentry);
+		if (!error && (saved_ino || saved_dev))
+			gr_handle_delete(saved_ino,saved_dev);
 	exit2:
 		dput(dentry);
 	}
@@ -1612,7 +1741,15 @@ asmlinkage long sys_symlink(const char *
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
+			error = 0;
+
+			if (!gr_acl_handle_symlink(dentry, nd.dentry, nd.mnt, from))
+				error = -EACCES;
+
+			if(!error)	
+				error = vfs_symlink(nd.dentry->d_inode, dentry, from);
+			if (!error)
+				gr_handle_create(dentry, nd.mnt);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1698,7 +1835,27 @@ asmlinkage long sys_link(const char * ol
 		new_dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
-			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+			error = 0;
+
+			if (gr_handle_hardlink(old_nd.dentry, old_nd.mnt,
+					       old_nd.dentry->d_inode,
+					       old_nd.dentry->d_inode->i_mode, to)) {
+				error = -EPERM;
+				goto out_error;
+			}
+
+			if (!gr_acl_handle_link(new_dentry, nd.dentry, nd.mnt,
+						 old_nd.dentry, old_nd.mnt, to)) {
+				error = -EACCES;
+				goto out_error;
+			}
+
+			error = vfs_link(old_nd.dentry, 
+					nd.dentry->d_inode, new_dentry);
+
+			if (!error)
+				gr_handle_create(new_dentry, nd.mnt);
+out_error:
 			dput(new_dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1929,10 +2086,15 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
-	lock_kernel();
-	error = vfs_rename(old_dir->d_inode, old_dentry,
+	error = gr_acl_handle_rename(new_dentry, newnd.dentry, newnd.mnt,
+				     old_dentry, old_dir->d_inode, oldnd.mnt, newname);
+
+	if (error == 1) {
+		lock_kernel();
+		error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
-	unlock_kernel();
+		unlock_kernel();
+	}
 
 	dput(new_dentry);
 exit4:
@@ -2071,7 +2233,7 @@ int page_follow_link(struct dentry *dent
 	return res;
 }
 
-struct inode_operations page_symlink_inode_operations = {
+const struct inode_operations page_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/namespace.c linux-2.4.37.7/fs/namespace.c
--- linux-2.4.37.7/fs/namespace.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/namespace.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,6 +15,7 @@
 #include <linux/quotaops.h>
 #include <linux/acct.h>
 #include <linux/module.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -241,7 +242,7 @@ static int show_vfsmnt(struct seq_file *
 	return err;
 }
 
-struct seq_operations mounts_op = {
+const struct seq_operations mounts_op = {
 	start:	m_start,
 	next:	m_next,
 	stop:	m_stop,
@@ -325,6 +326,8 @@ static int do_umount(struct vfsmount *mn
 			lock_kernel();
 			retval = do_remount_sb(sb, MS_RDONLY, 0);
 			unlock_kernel();
+
+			gr_log_remount(mnt->mnt_devname, retval);
 		}
 		up_write(&sb->s_umount);
 		return retval;
@@ -350,6 +353,9 @@ static int do_umount(struct vfsmount *mn
 	}
 	spin_unlock(&dcache_lock);
 	up_write(&current->namespace->sem);
+
+	gr_log_unmount(mnt->mnt_devname, retval);
+
 	return retval;
 }
 
@@ -732,6 +738,12 @@ long do_mount(char * dev_name, char * di
 	if (retval)
 		return retval;
 
+	if (gr_handle_chroot_mount(nd.dentry, nd.mnt, dev_name)) {
+		retval = -EPERM;
+		path_release(&nd);
+		return retval;
+	}
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -743,6 +755,9 @@ long do_mount(char * dev_name, char * di
 		retval = do_add_mount(&nd, type_page, flags, mnt_flags,
 				      dev_name, data_page);
 	path_release(&nd);
+
+	gr_log_mount(dev_name, dir_name, retval);
+
 	return retval;
 }
 
@@ -912,6 +927,9 @@ asmlinkage long sys_pivot_root(const cha
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	if (gr_handle_chroot_pivot())
+		return -EPERM;
+
 	lock_kernel();
 
 	error = __user_walk(new_root, LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
diff -urNp linux-2.4.37.7/fs/ncpfs/dir.c linux-2.4.37.7/fs/ncpfs/dir.c
--- linux-2.4.37.7/fs/ncpfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ncpfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,15 +45,13 @@ static int ncp_rename(struct inode *, st
 extern int ncp_symlink(struct inode *, struct dentry *, const char *);
 #endif
 		      
-struct file_operations ncp_dir_operations =
-{
+const struct file_operations ncp_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	ncp_readdir,
 	ioctl:		ncp_ioctl,
 };
 
-struct inode_operations ncp_dir_inode_operations =
-{
+const struct inode_operations ncp_dir_inode_operations = {
 	create:		ncp_create,
 	lookup:		ncp_lookup,
 	unlink:		ncp_unlink,
@@ -74,16 +72,14 @@ static int ncp_hash_dentry(struct dentry
 static int ncp_compare_dentry (struct dentry *, struct qstr *, struct qstr *);
 static int ncp_delete_dentry(struct dentry *);
 
-static struct dentry_operations ncp_dentry_operations =
-{
+static const struct dentry_operations ncp_dentry_operations = {
 	d_revalidate:	ncp_lookup_validate,
 	d_hash:		ncp_hash_dentry,
 	d_compare:	ncp_compare_dentry,
 	d_delete:	ncp_delete_dentry,
 };
 
-struct dentry_operations ncp_root_dentry_operations =
-{
+const struct dentry_operations ncp_root_dentry_operations = {
 	d_hash:		ncp_hash_dentry,
 	d_compare:	ncp_compare_dentry,
 	d_delete:	ncp_delete_dentry,
diff -urNp linux-2.4.37.7/fs/ncpfs/file.c linux-2.4.37.7/fs/ncpfs/file.c
--- linux-2.4.37.7/fs/ncpfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ncpfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -279,8 +279,7 @@ static int ncp_release(struct inode *ino
 	return 0;
 }
 
-struct file_operations ncp_file_operations =
-{
+const struct file_operations ncp_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		ncp_file_read,
 	write:		ncp_file_write,
@@ -290,7 +289,6 @@ struct file_operations ncp_file_operatio
 	fsync:		ncp_fsync,
 };
 
-struct inode_operations ncp_file_inode_operations =
-{
+const struct inode_operations ncp_file_inode_operations = {
 	setattr:	ncp_notify_change,
 };
diff -urNp linux-2.4.37.7/fs/ncpfs/inode.c linux-2.4.37.7/fs/ncpfs/inode.c
--- linux-2.4.37.7/fs/ncpfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ncpfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -36,17 +36,16 @@ static void ncp_delete_inode(struct inod
 static void ncp_put_super(struct super_block *);
 static int  ncp_statfs(struct super_block *, struct statfs *);
 
-static struct super_operations ncp_sops =
-{
+static const struct super_operations ncp_sops = {
 	put_inode:	force_delete,
 	delete_inode:	ncp_delete_inode,
 	put_super:	ncp_put_super,
 	statfs:		ncp_statfs,
 };
 
-extern struct dentry_operations ncp_root_dentry_operations;
+extern const struct dentry_operations ncp_root_dentry_operations;
 #ifdef CONFIG_NCPFS_EXTRAS
-extern struct address_space_operations ncp_symlink_aops;
+extern const struct address_space_operations ncp_symlink_aops;
 extern int ncp_symlink(struct inode*, struct dentry*, const char*);
 #endif
 
@@ -195,7 +194,7 @@ static void ncp_set_attr(struct inode *i
 	ncp_update_inode(inode, nwinfo);
 }
 
-static struct inode_operations ncp_symlink_inode_operations = {
+static const struct inode_operations ncp_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 	setattr:	ncp_notify_change,
diff -urNp linux-2.4.37.7/fs/ncpfs/mmap.c linux-2.4.37.7/fs/ncpfs/mmap.c
--- linux-2.4.37.7/fs/ncpfs/mmap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ncpfs/mmap.c	2009-11-10 19:30:27.000000000 -0500
@@ -85,8 +85,7 @@ static struct page* ncp_file_mmap_nopage
 	return page;
 }
 
-static struct vm_operations_struct ncp_file_mmap =
-{
+static const struct vm_operations_struct ncp_file_mmap = {
 	nopage:	ncp_file_mmap_nopage,
 };
 
diff -urNp linux-2.4.37.7/fs/ncpfs/symlink.c linux-2.4.37.7/fs/ncpfs/symlink.c
--- linux-2.4.37.7/fs/ncpfs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ncpfs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -97,7 +97,7 @@ fail:
 /*
  * symlinks can't do much...
  */
-struct address_space_operations ncp_symlink_aops = {
+const struct address_space_operations ncp_symlink_aops = {
 	readpage:	ncp_symlink_readpage,
 };
 	
diff -urNp linux-2.4.37.7/fs/nfs/dir.c linux-2.4.37.7/fs/nfs/dir.c
--- linux-2.4.37.7/fs/nfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -47,7 +47,7 @@ static int nfs_rename(struct inode *, st
 		      struct inode *, struct dentry *);
 static int nfs_fsync_dir(struct file *, struct dentry *, int);
 
-struct file_operations nfs_dir_operations = {
+const struct file_operations nfs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	nfs_readdir,
 	open:		nfs_open,
@@ -55,7 +55,7 @@ struct file_operations nfs_dir_operation
 	fsync:		nfs_fsync_dir
 };
 
-struct inode_operations nfs_dir_inode_operations = {
+const struct inode_operations nfs_dir_inode_operations = {
 	create:		nfs_create,
 	lookup:		nfs_lookup,
 	link:		nfs_link,
@@ -570,7 +570,7 @@ static void nfs_dentry_iput(struct dentr
 	iput(inode);
 }
 
-struct dentry_operations nfs_dentry_operations = {
+const struct dentry_operations nfs_dentry_operations = {
 	d_revalidate:	nfs_lookup_revalidate,
 	d_delete:	nfs_dentry_delete,
 	d_iput:		nfs_dentry_iput,
diff -urNp linux-2.4.37.7/fs/nfs/file.c linux-2.4.37.7/fs/nfs/file.c
--- linux-2.4.37.7/fs/nfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -41,7 +41,7 @@ static ssize_t nfs_file_write(struct fil
 static int  nfs_file_flush(struct file *);
 static int  nfs_fsync(struct file *, struct dentry *dentry, int datasync);
 
-struct file_operations nfs_file_operations = {
+const struct file_operations nfs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		nfs_file_read,
 	write:		nfs_file_write,
@@ -53,7 +53,7 @@ struct file_operations nfs_file_operatio
 	lock:		nfs_lock,
 };
 
-struct inode_operations nfs_file_inode_operations = {
+const struct inode_operations nfs_file_inode_operations = {
 	permission:	nfs_permission,
 	revalidate:	nfs_revalidate,
 	setattr:	nfs_notify_change,
@@ -196,7 +196,7 @@ static int nfs_sync_page(struct page *pa
 	return 0;
 }
 
-struct address_space_operations nfs_file_aops = {
+const struct address_space_operations nfs_file_aops = {
 	readpage: nfs_readpage,
 	sync_page: nfs_sync_page,
 	writepage: nfs_writepage,
diff -urNp linux-2.4.37.7/fs/nfs/inode.c linux-2.4.37.7/fs/nfs/inode.c
--- linux-2.4.37.7/fs/nfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -54,7 +54,7 @@ static void nfs_umount_begin(struct supe
 static int  nfs_statfs(struct super_block *, struct statfs *);
 static int  nfs_show_options(struct seq_file *, struct vfsmount *);
 
-static struct super_operations nfs_sops = { 
+static const struct super_operations nfs_sops = { 
 	read_inode:	nfs_read_inode,
 	write_inode:	nfs_write_inode,
 	delete_inode:	nfs_delete_inode,
diff -urNp linux-2.4.37.7/fs/nfs/symlink.c linux-2.4.37.7/fs/nfs/symlink.c
--- linux-2.4.37.7/fs/nfs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -100,7 +100,7 @@ static int nfs_follow_link(struct dentry
 /*
  * symlinks can't do much...
  */
-struct inode_operations nfs_symlink_inode_operations = {
+const struct inode_operations nfs_symlink_inode_operations = {
 	readlink:	nfs_readlink,
 	follow_link:	nfs_follow_link,
 	revalidate:	nfs_revalidate,
diff -urNp linux-2.4.37.7/fs/nfsd/export.c linux-2.4.37.7/fs/nfsd/export.c
--- linux-2.4.37.7/fs/nfsd/export.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfsd/export.c	2009-11-10 19:30:27.000000000 -0500
@@ -715,7 +715,7 @@ static int e_show(struct seq_file *m, vo
 	return 0;
 }
 
-struct seq_operations nfs_exports_op = {
+const struct seq_operations nfs_exports_op = {
 	start:	e_start,
 	next:	e_next,
 	stop:	e_stop,
diff -urNp linux-2.4.37.7/fs/nfsd/nfsctl.c linux-2.4.37.7/fs/nfsd/nfsctl.c
--- linux-2.4.37.7/fs/nfsd/nfsctl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfsd/nfsctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -46,12 +46,12 @@ static int	nfsctl_getfs(struct nfsctl_fs
 static int	nfsctl_ugidupdate(struct nfsctl_ugidmap *data);
 #endif
 
-extern struct seq_operations nfs_exports_op;
+extern const struct seq_operations nfs_exports_op;
 static int exports_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &nfs_exports_op);
 }
-static struct file_operations exports_operations = {
+static const struct file_operations exports_operations = {
 	open:		exports_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
diff -urNp linux-2.4.37.7/fs/nfsd/vfs.c linux-2.4.37.7/fs/nfsd/vfs.c
--- linux-2.4.37.7/fs/nfsd/vfs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/nfsd/vfs.c	2009-11-10 19:30:27.000000000 -0500
@@ -526,7 +526,7 @@ nfsd_close(struct file *filp)
  * after it.
  */
 inline void nfsd_dosync(struct file *filp, struct dentry *dp, 
-			struct file_operations *fop)
+			const struct file_operations *fop)
 {
 	struct inode *inode = dp->d_inode;
 	int (*fsync) (struct file *, struct dentry *, int);
diff -urNp linux-2.4.37.7/fs/ntfs/fs.c linux-2.4.37.7/fs/ntfs/fs.c
--- linux-2.4.37.7/fs/ntfs/fs.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ntfs/fs.c	2009-11-10 19:30:27.000000000 -0500
@@ -33,8 +33,8 @@
 #include <linux/ntfs_fs.h>
 
 /* Forward declarations. */
-static struct inode_operations ntfs_dir_inode_operations;
-static struct file_operations ntfs_dir_operations;
+static const struct inode_operations ntfs_dir_inode_operations;
+static const struct file_operations ntfs_dir_operations;
 
 #define ITEM_SIZE 2040
 
@@ -557,7 +557,7 @@ err_ret:
 	return ERR_PTR(err);
 }
 
-static struct file_operations ntfs_file_operations = {
+static const struct file_operations ntfs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		ntfs_read,
 #ifdef CONFIG_NTFS_RW
@@ -566,7 +566,7 @@ static struct file_operations ntfs_file_
 	open:		generic_file_open,
 };
 
-static struct inode_operations ntfs_inode_operations;
+static const struct inode_operations ntfs_inode_operations;
 
 #ifdef CONFIG_NTFS_RW
 static int ntfs_create(struct inode* dir, struct dentry *d, int mode)
@@ -680,12 +680,12 @@ static int _linux_ntfs_mkdir(struct inod
 }
 #endif
 
-static struct file_operations ntfs_dir_operations = {
+static const struct file_operations ntfs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	ntfs_readdir,
 };
 
-static struct inode_operations ntfs_dir_inode_operations = {
+static const struct inode_operations ntfs_dir_inode_operations = {
 	lookup:		ntfs_lookup,
 #ifdef CONFIG_NTFS_RW
 	create:		ntfs_create,
@@ -915,7 +915,7 @@ static int ntfs_remount_fs(struct super_
 }
 
 /* Define the super block operation that are implemented */
-static struct super_operations ntfs_super_operations = {
+static const struct super_operations ntfs_super_operations = {
 	read_inode:	ntfs_read_inode,
 #ifdef CONFIG_NTFS_RW
 	write_inode:	ntfs_write_inode,
diff -urNp linux-2.4.37.7/fs/open.c linux-2.4.37.7/fs/open.c
--- linux-2.4.37.7/fs/open.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/open.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/iobuf.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -95,7 +96,7 @@ void fd_install(unsigned int fd, struct 
 	write_unlock(&files->file_lock);
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, struct vfsmount *mnt)
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
@@ -105,6 +106,9 @@ int do_truncate(struct dentry *dentry, l
 	if (length < 0)
 		return -EINVAL;
 
+	if (!gr_acl_handle_truncate(dentry, mnt))
+		return -EACCES;
+
 	down_write(&inode->i_alloc_sem);
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
@@ -167,7 +171,7 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		error = do_truncate(nd.dentry, length, nd.mnt);
 	}
 	put_write_access(inode);
 
@@ -219,7 +223,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, file->f_vfsmnt);
 out_putf:
 	fput(file);
 out:
@@ -294,6 +298,12 @@ asmlinkage long sys_utime(char * filenam
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
+	if (!gr_acl_handle_utime(nd.dentry, nd.mnt)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -346,6 +356,12 @@ asmlinkage long sys_utimes(char * filena
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
+	if (!gr_acl_handle_utime(nd.dentry, nd.mnt)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -388,6 +404,10 @@ asmlinkage long sys_access(const char * 
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		
+		if (!res && !gr_acl_handle_access(nd.dentry, nd.mnt, mode))
+			res =  -EACCES;
+
 		path_release(&nd);
 	}
 
@@ -411,6 +431,8 @@ asmlinkage long sys_chdir(const char * f
 	if (error)
 		goto dput_and_out;
 
+	gr_log_chdir(nd.dentry, nd.mnt);
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -441,6 +463,13 @@ asmlinkage long sys_fchdir(unsigned int 
 		goto out_putf;
 
 	error = permission(inode, MAY_EXEC);
+
+	if (!error && !gr_chroot_fchdir(dentry, mnt))
+		error = -EPERM;
+
+	if (!error)
+		gr_log_chdir(dentry, mnt);
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -467,8 +496,16 @@ asmlinkage long sys_chroot(const char * 
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+	if (gr_handle_chroot_chroot(nd.dentry, nd.mnt))
+		goto dput_and_out;
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
+
+	gr_handle_chroot_caps(current);
+
+	gr_handle_chroot_chdir(nd.dentry, nd.mnt);
+
 	error = 0;
 dput_and_out:
 	path_release(&nd);
@@ -497,8 +534,20 @@ asmlinkage long sys_fchmod(unsigned int 
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+	if (!gr_acl_handle_fchmod(dentry, file->f_vfsmnt, mode)) {
+		err = -EACCES;
+		goto out_putf;
+	}
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (gr_handle_chroot_chmod(dentry, file->f_vfsmnt, mode)) {
+		err = -EPERM;
+		goto out_putf;
+	}	    
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	err = notify_change(dentry, &newattrs);
@@ -529,8 +578,19 @@ asmlinkage long sys_chmod(const char * f
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+	if (!gr_acl_handle_chmod(nd.dentry, nd.mnt, mode)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (gr_handle_chroot_chmod(nd.dentry, nd.mnt, mode)) {
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	error = notify_change(nd.dentry, &newattrs);
@@ -541,7 +601,7 @@ out:
 	return error;
 }
 
-static int chown_common(struct dentry * dentry, uid_t user, gid_t group)
+static int chown_common(struct dentry * dentry, uid_t user, gid_t group, struct vfsmount *mnt)
 {
 	struct inode * inode;
 	int error;
@@ -558,6 +618,12 @@ static int chown_common(struct dentry * 
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+
+	if (!gr_acl_handle_chown(dentry, mnt)) {
+		error = -EACCES;
+		goto out;
+	}
+
 	if (user == (uid_t) -1)
 		user = inode->i_uid;
 	if (group == (gid_t) -1)
@@ -608,7 +674,7 @@ asmlinkage long sys_chown(const char * f
 
 	error = user_path_walk(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -621,7 +687,7 @@ asmlinkage long sys_lchown(const char * 
 
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -635,7 +701,8 @@ asmlinkage long sys_fchown(unsigned int 
 
 	file = fget(fd);
 	if (file) {
-		error = chown_common(file->f_dentry, user, group);
+		error = chown_common(file->f_dentry, user,
+				group, file->f_vfsmnt);
 		fput(file);
 	}
 	return error;
@@ -755,6 +822,7 @@ repeat:
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
+	gr_learn_resource(current, RLIMIT_NOFILE, fd, 0);
 	if (fd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
diff -urNp linux-2.4.37.7/fs/openpromfs/inode.c linux-2.4.37.7/fs/openpromfs/inode.c
--- linux-2.4.37.7/fs/openpromfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/openpromfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -594,28 +594,28 @@ int property_release (struct inode *inod
 	return 0;
 }
 
-static struct file_operations openpromfs_prop_ops = {
+static const struct file_operations openpromfs_prop_ops = {
 	read:		property_read,
 	write:		property_write,
 	release:	property_release,
 };
 
-static struct file_operations openpromfs_nodenum_ops = {
+static const struct file_operations openpromfs_nodenum_ops = {
 	read:		nodenum_read,
 };
 
-static struct file_operations openprom_operations = {
+static const struct file_operations openprom_operations = {
 	read:		generic_read_dir,
 	readdir:	openpromfs_readdir,
 };
 
-static struct inode_operations openprom_alias_inode_operations = {
+static const struct inode_operations openprom_alias_inode_operations = {
 	create:		openpromfs_create,
 	lookup:		openpromfs_lookup,
 	unlink:		openpromfs_unlink,
 };
 
-static struct inode_operations openprom_inode_operations = {
+static const struct inode_operations openprom_inode_operations = {
 	lookup:		openpromfs_lookup,
 };
 
@@ -1032,7 +1032,7 @@ static int openprom_statfs(struct super_
 	return 0;
 }
 
-static struct super_operations openprom_sops = { 
+static const struct super_operations openprom_sops = { 
 	read_inode:	openprom_read_inode,
 	statfs:		openprom_statfs,
 };
diff -urNp linux-2.4.37.7/fs/pipe.c linux-2.4.37.7/fs/pipe.c
--- linux-2.4.37.7/fs/pipe.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/pipe.c	2009-11-10 19:30:27.000000000 -0500
@@ -388,7 +388,7 @@ pipe_rdwr_open(struct inode *inode, stru
  * The file_operations structs are not static because they
  * are also used in linux/fs/fifo.c to do operations on FIFOs.
  */
-struct file_operations read_fifo_fops = {
+const struct file_operations read_fifo_fops = {
 	llseek:		no_llseek,
 	read:		pipe_read,
 	write:		bad_pipe_w,
@@ -398,7 +398,7 @@ struct file_operations read_fifo_fops = 
 	release:	pipe_read_release,
 };
 
-struct file_operations write_fifo_fops = {
+const struct file_operations write_fifo_fops = {
 	llseek:		no_llseek,
 	read:		bad_pipe_r,
 	write:		pipe_write,
@@ -408,7 +408,7 @@ struct file_operations write_fifo_fops =
 	release:	pipe_write_release,
 };
 
-struct file_operations rdwr_fifo_fops = {
+const struct file_operations rdwr_fifo_fops = {
 	llseek:		no_llseek,
 	read:		pipe_read,
 	write:		pipe_write,
@@ -418,7 +418,7 @@ struct file_operations rdwr_fifo_fops = 
 	release:	pipe_rdwr_release,
 };
 
-struct file_operations read_pipe_fops = {
+const struct file_operations read_pipe_fops = {
 	llseek:		no_llseek,
 	read:		pipe_read,
 	write:		bad_pipe_w,
@@ -428,7 +428,7 @@ struct file_operations read_pipe_fops = 
 	release:	pipe_read_release,
 };
 
-struct file_operations write_pipe_fops = {
+const struct file_operations write_pipe_fops = {
 	llseek:		no_llseek,
 	read:		bad_pipe_r,
 	write:		pipe_write,
@@ -438,7 +438,7 @@ struct file_operations write_pipe_fops =
 	release:	pipe_write_release,
 };
 
-struct file_operations rdwr_pipe_fops = {
+const struct file_operations rdwr_pipe_fops = {
 	llseek:		no_llseek,
 	read:		pipe_read,
 	write:		pipe_write,
@@ -473,12 +473,12 @@ fail_page:
 	return NULL;
 }
 
-static struct vfsmount *pipe_mnt;
+struct vfsmount *pipe_mnt;
 static int pipefs_delete_dentry(struct dentry *dentry)
 {
 	return 1;
 }
-static struct dentry_operations pipefs_dentry_operations = {
+static const struct dentry_operations pipefs_dentry_operations = {
 	d_delete:	pipefs_delete_dentry,
 };
 
@@ -610,7 +610,7 @@ static int pipefs_statfs(struct super_bl
 	return 0;
 }
 
-static struct super_operations pipefs_ops = {
+static const struct super_operations pipefs_ops = {
 	statfs:		pipefs_statfs,
 };
 
diff -urNp linux-2.4.37.7/fs/proc/array.c linux-2.4.37.7/fs/proc/array.c
--- linux-2.4.37.7/fs/proc/array.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/array.c	2009-11-10 19:30:27.000000000 -0500
@@ -276,6 +276,20 @@ static inline char *task_cap(struct task
 			    cap_t(p->cap_effective));
 }
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline char *task_pax(struct task_struct *p, char *buffer)
+{
+	if (p->mm)
+		return buffer + sprintf(buffer, "PaX:\t%c%c%c%c%c\n",
+					p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+					p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+					p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+					p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+					p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+	else
+		return buffer + sprintf(buffer, "PaX:\t------\n");
+}
+#endif
 
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
@@ -298,9 +312,20 @@ int proc_pid_status(struct task_struct *
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	buffer = task_pax(task, buffer);
+#endif
+
 	return buffer - orig;
 }
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+#define PAX_RAND_FLAGS(_mm) (_mm != NULL && _mm != current->mm && \
+			    (_mm->pax_flags & MF_PAX_RANDMMAP || \
+		             _mm->pax_flags & MF_PAX_SEGMEXEC))
+#endif
+
 int proc_pid_stat(struct task_struct *task, char * buffer)
 {
 	unsigned long vsize, eip, esp, wchan = ~0UL;
@@ -349,6 +374,19 @@ int proc_pid_stat(struct task_struct *ta
 	if (permitted)
 		wchan = get_wchan(task);
 
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+	if (PAX_RAND_FLAGS(mm)) {
+		eip = 0;
+		esp = 0;
+		wchan = 0;
+	}
+#endif
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	wchan = 0;
+	eip = 0;
+	esp = 0;
+#endif
+
 	collect_sigign_sigcatch(task, &sigign, &sigcatch);
 
 	/* scale priority and nice values from timeslices to -20..20 */
@@ -388,9 +426,15 @@ int proc_pid_stat(struct task_struct *ta
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
 		task->rlim[RLIMIT_RSS].rlim_cur,
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+		PAX_RAND_FLAGS(mm) ? 1 : (mm ? mm->start_code : 0),
+		PAX_RAND_FLAGS(mm) ? 1 : (mm ? mm->end_code : 0),
+		PAX_RAND_FLAGS(mm) ? 0 : ((permitted && mm) ? mm->start_stack : 0),
+#else
 		mm ? mm->start_code : 0,
 		mm ? mm->end_code : 0,
 		(permitted && mm) ? mm->start_stack : 0,
+#endif
 		esp,
 		eip,
 		/* The signal information here is obsolete.
@@ -542,13 +586,22 @@ static int show_map(struct seq_file *m, 
 	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+			PAX_RAND_FLAGS(map->vm_mm) ? 0UL : map->vm_start,
+			PAX_RAND_FLAGS(map->vm_mm) ? 0UL : map->vm_end,
+#else
 			map->vm_start,
 			map->vm_end,
+#endif
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
 			flags & VM_MAYSHARE ? 's' : 'p',
+#ifdef CONFIG_GRKERNSEC_PROC_MEMMAP
+			PAX_RAND_FLAGS(map->vm_mm) ? 0UL : map->vm_pgoff << PAGE_SHIFT,
+#else
 			map->vm_pgoff << PAGE_SHIFT,
+#endif
 			MAJOR(dev), MINOR(dev), ino, &len);
 
 	if (map->vm_file) {
@@ -615,13 +668,23 @@ static void *m_next(struct seq_file *m, 
 	return NULL;
 }
 
-struct seq_operations proc_pid_maps_op = {
+const struct seq_operations proc_pid_maps_op = {
 	.start	= m_start,
 	.next	= m_next,
 	.stop	= m_stop,
 	.show	= show_map
 };
 
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR	 
+int proc_pid_ipaddr(struct task_struct *task, char * buffer)	 
+{	 
+	int len;	 
+
+	len = sprintf(buffer, "%u.%u.%u.%u\n", NIPQUAD(task->curr_ip));	 
+	return len;	 
+}	 
+#endif
+
 #ifdef CONFIG_SMP
 int proc_pid_cpu(struct task_struct *task, char * buffer)
 {
diff -urNp linux-2.4.37.7/fs/proc/base.c linux-2.4.37.7/fs/proc/base.c
--- linux-2.4.37.7/fs/proc/base.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/base.c	2009-11-10 19:30:27.000000000 -0500
@@ -25,6 +25,7 @@
 #include <linux/string.h>
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
+#include <linux/grsecurity.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -40,6 +41,9 @@ int proc_pid_stat(struct task_struct*,ch
 int proc_pid_status(struct task_struct*,char*);
 int proc_pid_statm(struct task_struct*,char*);
 int proc_pid_cpu(struct task_struct*,char*);
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+int proc_pid_ipaddr(struct task_struct*,char*);
+#endif
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
 {
@@ -126,7 +130,8 @@ static int proc_root_link(struct inode *
 #define MAY_PTRACE(task) \
 	(task == current || \
 	(task->p_pptr == current && \
-	(task->ptrace & PT_PTRACED) && task->state == TASK_STOPPED))
+	(task->ptrace & PT_PTRACED) && task->state == TASK_STOPPED && \
+	!gr_handle_proc_ptrace(task)))
 
 static int may_ptrace_attach(struct task_struct *task)
 {
@@ -145,6 +150,8 @@ static int may_ptrace_attach(struct task
 	rmb();
 	if (!is_dumpable(task) && !capable(CAP_SYS_PTRACE))
 		goto out;
+	if (gr_handle_proc_ptrace(task))
+		goto out;
 
 	retval = 1;
 
@@ -158,6 +165,9 @@ static int proc_pid_environ(struct task_
 	struct mm_struct *mm;
 	int res = 0;
 
+	if (gr_acl_handle_procpidmem(task))
+		return -ESRCH;
+
 	if (!may_ptrace_attach(task))
 		return -ESRCH;
 
@@ -185,6 +195,10 @@ static int proc_pid_cmdline(struct task_
 	int res = 0;
 	task_lock(task);
 	mm = task->mm;
+
+	if (gr_acl_handle_procpidmem(task))
+		mm = NULL;
+
 	if (mm) {
 		if (mm->arg_end)
 			atomic_inc(&mm->mm_users);
@@ -267,12 +281,25 @@ out:
 
 static int proc_permission(struct inode *inode, int mask)
 {
+	int ret;
+	struct task_struct *task;
+
 	if (vfs_permission(inode, mask) != 0)
 		return -EACCES;
-	return proc_check_root(inode);
+	ret = proc_check_root(inode);
+
+	if (ret)
+		return ret;
+
+	task = inode->u.proc_i.task;
+
+	if (!task)
+		return 0;
+
+	return gr_acl_handle_procpidmem(task);
 }
 
-extern struct seq_operations proc_pid_maps_op;
+extern const struct seq_operations proc_pid_maps_op;
 static int maps_open(struct inode *inode, struct file *file)
 {
 	struct task_struct *task = inode->u.proc_i.task;
@@ -284,14 +311,14 @@ static int maps_open(struct inode *inode
 	return ret;
 }
 
-static struct file_operations proc_maps_operations = {
+static const struct file_operations proc_maps_operations = {
 	.open		= maps_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= seq_release,
 };
 
-extern struct seq_operations mounts_op;
+extern const struct seq_operations mounts_op;
 static int mounts_open(struct inode *inode, struct file *file)
 {
 	struct task_struct *task = inode->u.proc_i.task;
@@ -324,7 +351,7 @@ static int mounts_release(struct inode *
 	return seq_release(inode, file);
 }
 
-static struct file_operations proc_mounts_operations = {
+static const struct file_operations proc_mounts_operations = {
 	open:		mounts_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -368,7 +395,7 @@ static ssize_t proc_info_read(struct fil
 	return count;
 }
 
-static struct file_operations proc_info_file_operations = {
+static const struct file_operations proc_info_file_operations = {
 	read:		proc_info_read,
 };
 
@@ -497,14 +524,14 @@ static loff_t mem_lseek(struct file * fi
 	return file->f_pos;
 }
 
-static struct file_operations proc_mem_operations = {
+static const struct file_operations proc_mem_operations = {
 	llseek:		mem_lseek,
 	read:		mem_read,
 	write:		mem_write,
 	open:		mem_open,
 };
 
-static struct inode_operations proc_mem_inode_operations = {
+static const struct inode_operations proc_mem_inode_operations = {
 	permission:	proc_permission,
 };
 
@@ -577,7 +604,7 @@ out:
 	return error;
 }
 
-static struct inode_operations proc_pid_link_inode_operations = {
+static const struct inode_operations proc_pid_link_inode_operations = {
 	readlink:	proc_pid_readlink,
 	follow_link:	proc_pid_follow_link
 };
@@ -603,6 +630,9 @@ enum pid_directory_inos {
 	PROC_PID_STATM,
 	PROC_PID_MAPS,
 	PROC_PID_CPU,
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+	PROC_PID_IPADDR,
+#endif
 	PROC_PID_MOUNTS,
 	PROC_PID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 };
@@ -618,6 +648,9 @@ static struct pid_entry base_stuff[] = {
 #ifdef CONFIG_SMP
   E(PROC_PID_CPU,	"cpu",		S_IFREG|S_IRUGO),
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+  E(PROC_PID_IPADDR,	"ipaddr",	S_IFREG|S_IRUSR),
+#endif
   E(PROC_PID_MAPS,	"maps",		S_IFREG|S_IRUGO),
   E(PROC_PID_MEM,	"mem",		S_IFREG|S_IRUSR|S_IWUSR),
   E(PROC_PID_CWD,	"cwd",		S_IFLNK|S_IRWXUGO),
@@ -771,10 +804,17 @@ static struct inode *proc_pid_make_inode
 	get_task_struct(task);
 	inode->u.proc_i.task = task;
 	inode->i_uid = 0;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 	inode->i_gid = 0;
+#endif
+
 	if (ino == PROC_PID_INO || task_dumpable(task)) {
 		inode->i_uid = task->euid;
+#ifndef CONFIG_GRKERNSEC_PROC_USERGROUP
 		inode->i_gid = task->egid;
+#endif
 	}
 
 out:
@@ -811,19 +851,16 @@ static int pid_delete_dentry(struct dent
 	return 1;
 }
 
-static struct dentry_operations pid_fd_dentry_operations =
-{
+static const struct dentry_operations pid_fd_dentry_operations = {
 	d_revalidate:	pid_fd_revalidate,
 	d_delete:	pid_delete_dentry,
 };
 
-static struct dentry_operations pid_dentry_operations =
-{
+static const struct dentry_operations pid_dentry_operations = {
 	d_delete:	pid_delete_dentry,
 };
 
-static struct dentry_operations pid_base_dentry_operations =
-{
+static const struct dentry_operations pid_base_dentry_operations = {
 	d_revalidate:	pid_base_revalidate,
 	d_delete:	pid_delete_dentry,
 };
@@ -894,7 +931,7 @@ out:
 	return ERR_PTR(-ENOENT);
 }
 
-static struct file_operations proc_fd_operations = {
+static const struct file_operations proc_fd_operations = {
 	read:		generic_read_dir,
 	readdir:	proc_readfd,
 };
@@ -902,7 +939,7 @@ static struct file_operations proc_fd_op
 /*
  * proc directories can do almost nothing..
  */
-static struct inode_operations proc_fd_inode_operations = {
+static const struct inode_operations proc_fd_inode_operations = {
 	lookup:		proc_lookupfd,
 	permission:	proc_permission,
 };
@@ -983,6 +1020,12 @@ static struct dentry *proc_base_lookup(s
 			inode->u.proc_i.op.proc_read = proc_pid_cpu;
 			break;
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_IPADDR
+		case PROC_PID_IPADDR:
+			inode->i_fop = &proc_info_file_operations;
+			inode->u.proc_i.op.proc_read = proc_pid_ipaddr;
+			break;
+#endif
 		case PROC_PID_MEM:
 			inode->i_op = &proc_mem_inode_operations;
 			inode->i_fop = &proc_mem_operations;
@@ -1003,12 +1046,12 @@ out:
 	return ERR_PTR(error);
 }
 
-static struct file_operations proc_base_operations = {
+static const struct file_operations proc_base_operations = {
 	read:		generic_read_dir,
 	readdir:	proc_base_readdir,
 };
 
-static struct inode_operations proc_base_inode_operations = {
+static const struct inode_operations proc_base_inode_operations = {
 	lookup:		proc_base_lookup,
 };
 
@@ -1029,7 +1072,7 @@ static int proc_self_follow_link(struct 
 	return vfs_follow_link(nd,tmp);
 }	
 
-static struct inode_operations proc_self_inode_operations = {
+static const struct inode_operations proc_self_inode_operations = {
 	readlink:	proc_self_readlink,
 	follow_link:	proc_self_follow_link,
 };
@@ -1081,13 +1124,35 @@ struct dentry *proc_pid_lookup(struct in
 	if (!task)
 		goto out;
 
+	if(gr_check_hidden_task(task)) {
+		free_task_struct(task);
+		goto out;
+	}
+	
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+	if (current->uid && (task->uid != current->uid)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+	    && !in_group_p(CONFIG_GRKERNSEC_PROC_GID)
+#endif
+	) {
+		free_task_struct(task);
+		goto out;
+	}	
+#endif
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
 
 	free_task_struct(task);
 
 	if (!inode)
 		goto out;
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP;
+	inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
+#endif
 	inode->i_op = &proc_base_inode_operations;
 	inode->i_fop = &proc_base_operations;
 	inode->i_nlink = 3;
@@ -1127,6 +1192,18 @@ static int get_pid_list(int index, unsig
 		int pid = p->pid;
 		if (!pid)
 			continue;
+		if(gr_pid_is_chrooted(p))
+			continue;
+		if(gr_check_hidden_task(p)) 
+			continue;
+#if defined(CONFIG_GRKERNSEC_PROC_USER) || defined(CONFIG_GRKERNSEC_PROC_USERGROUP)
+		if (current->uid && (p->uid != current->uid)
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+	    		&& !in_group_p(CONFIG_GRKERNSEC_PROC_GID)
+#endif
+		)
+			continue;	
+#endif
 		if (--index >= 0)
 			continue;
 		pids[nr_pids] = pid;
diff -urNp linux-2.4.37.7/fs/proc/generic.c linux-2.4.37.7/fs/proc/generic.c
--- linux-2.4.37.7/fs/proc/generic.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/generic.c	2009-11-10 19:30:27.000000000 -0500
@@ -33,7 +33,7 @@ int proc_match(int len, const char *name
 	return !memcmp(name, de->name, len);
 }
 
-static struct file_operations proc_file_operations = {
+static const struct file_operations proc_file_operations = {
 	llseek:		proc_file_lseek,
 	read:		proc_file_read,
 	write:		proc_file_write,
@@ -229,7 +229,7 @@ static int proc_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
-static struct inode_operations proc_link_inode_operations = {
+static const struct inode_operations proc_link_inode_operations = {
 	readlink:	proc_readlink,
 	follow_link:	proc_follow_link,
 };
@@ -245,8 +245,7 @@ static int proc_delete_dentry(struct den
 	return 1;
 }
 
-static struct dentry_operations proc_dentry_operations =
-{
+static const struct dentry_operations proc_dentry_operations = {
 	d_delete:	proc_delete_dentry,
 };
 
@@ -351,7 +350,7 @@ int proc_readdir(struct file * filp,
  * use the in-memory "struct proc_dir_entry" tree to parse
  * the /proc directory.
  */
-static struct file_operations proc_dir_operations = {
+static const struct file_operations proc_dir_operations = {
 	read:			generic_read_dir,
 	readdir:		proc_readdir,
 };
@@ -359,7 +358,7 @@ static struct file_operations proc_dir_o
 /*
  * proc directories can do almost nothing..
  */
-static struct inode_operations proc_dir_inode_operations = {
+static const struct inode_operations proc_dir_inode_operations = {
 	lookup:		proc_lookup,
 };
 
@@ -406,7 +405,7 @@ static void proc_kill_inodes(struct proc
 		struct file * filp = list_entry(p, struct file, f_list);
 		struct dentry * dentry = filp->f_dentry;
 		struct inode * inode;
-		struct file_operations *fops;
+		const struct file_operations *fops;
 
 		if (dentry->d_op != &proc_dentry_operations)
 			continue;
diff -urNp linux-2.4.37.7/fs/proc/inode.c linux-2.4.37.7/fs/proc/inode.c
--- linux-2.4.37.7/fs/proc/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -91,7 +91,7 @@ static int proc_statfs(struct super_bloc
 	return 0;
 }
 
-static struct super_operations proc_sops = { 
+static const struct super_operations proc_sops = { 
 	read_inode:	proc_read_inode,
 	put_inode:	force_delete,
 	delete_inode:	proc_delete_inode,
@@ -152,7 +152,11 @@ printk("proc_iget: using deleted entry %
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+			inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 			inode->i_gid = de->gid;
+#endif			
 		}
 		if (de->size)
 			inode->i_size = de->size;
diff -urNp linux-2.4.37.7/fs/proc/kcore.c linux-2.4.37.7/fs/proc/kcore.c
--- linux-2.4.37.7/fs/proc/kcore.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/kcore.c	2009-11-10 19:30:27.000000000 -0500
@@ -31,7 +31,7 @@ static loff_t lseek_kcore(struct file * 
 
 static ssize_t read_kcore(struct file *, char *, size_t, loff_t *);
 
-struct file_operations proc_kcore_operations = {
+const struct file_operations proc_kcore_operations = {
 	read:		read_kcore,
 	open:		open_kcore,
 	llseek:		lseek_kcore,
diff -urNp linux-2.4.37.7/fs/proc/kmsg.c linux-2.4.37.7/fs/proc/kmsg.c
--- linux-2.4.37.7/fs/proc/kmsg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/kmsg.c	2009-11-10 19:30:27.000000000 -0500
@@ -44,7 +44,7 @@ static unsigned int kmsg_poll(struct fil
 }
 
 
-struct file_operations proc_kmsg_operations = {
+const struct file_operations proc_kmsg_operations = {
 	read:		kmsg_read,
 	poll:		kmsg_poll,
 	open:		kmsg_open,
diff -urNp linux-2.4.37.7/fs/proc/proc_misc.c linux-2.4.37.7/fs/proc/proc_misc.c
--- linux-2.4.37.7/fs/proc/proc_misc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/proc_misc.c	2009-11-10 19:30:27.000000000 -0500
@@ -226,12 +226,12 @@ static int version_read_proc(char *page,
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
-extern struct seq_operations cpuinfo_op;
+extern const struct seq_operations cpuinfo_op;
 static int cpuinfo_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &cpuinfo_op);
 }
-static struct file_operations proc_cpuinfo_operations = {
+static const struct file_operations proc_cpuinfo_operations = {
 	open:		cpuinfo_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -256,12 +256,12 @@ static int stram_read_proc(char *page, c
 }
 #endif
 
-extern struct seq_operations partitions_op;
+extern const struct seq_operations partitions_op;
 static int partitions_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &partitions_op);
 }
-static struct file_operations proc_partitions_operations = {
+static const struct file_operations proc_partitions_operations = {
 	open:		partitions_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -276,12 +276,12 @@ static int modules_read_proc(char *page,
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
-extern struct seq_operations ksyms_op;
+extern const struct seq_operations ksyms_op;
 static int ksyms_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &ksyms_op);
 }
-static struct file_operations proc_ksyms_operations = {
+static const struct file_operations proc_ksyms_operations = {
 	open:		ksyms_open,
 	read:		seq_read,
 	llseek:		seq_lseek,
@@ -289,13 +289,13 @@ static struct file_operations proc_ksyms
 };
 #endif
 
-extern struct seq_operations slabinfo_op;
+extern const struct seq_operations slabinfo_op;
 extern ssize_t slabinfo_write(struct file *, const char *, size_t, loff_t *);
 static int slabinfo_open(struct inode *inode, struct file *file)
 {
 	return seq_open(file, &slabinfo_op);
 }
-static struct file_operations proc_slabinfo_operations = {
+static const struct file_operations proc_slabinfo_operations = {
 	open:		slabinfo_open,
 	read:		seq_read,
 	write:		slabinfo_write,
@@ -422,7 +422,7 @@ static int interrupts_open(struct inode 
 		kfree(buf);
 	return res;
 }
-static struct file_operations proc_interrupts_operations = {
+static const struct file_operations proc_interrupts_operations = {
 	.open		= interrupts_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
@@ -430,8 +430,8 @@ static struct file_operations proc_inter
 };
 #endif /* !CONFIG_X86 */
 
-extern struct file_operations proc_ioports_operations;
-extern struct file_operations proc_iomem_operations;
+extern const struct file_operations proc_ioports_operations;
+extern const struct file_operations proc_iomem_operations;
 
 static int filesystems_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
@@ -551,7 +551,7 @@ static ssize_t write_profile(struct file
 	return count;
 }
 
-static struct file_operations proc_profile_operations = {
+static const struct file_operations proc_profile_operations = {
 	read:		read_profile,
 	write:		write_profile,
 };
@@ -573,14 +573,14 @@ static ssize_t write_sysrq_trigger(struc
 	return count;
 }
 
-static struct file_operations proc_sysrq_trigger_operations = {
+static const struct file_operations proc_sysrq_trigger_operations = {
 	.write		= write_sysrq_trigger,
 };
 #endif
 
 struct proc_dir_entry *proc_root_kcore;
 
-static void create_seq_entry(char *name, mode_t mode, struct file_operations *f)
+static void create_seq_entry(char *name, mode_t mode, const struct file_operations *f)
 {
 	struct proc_dir_entry *entry;
 	entry = create_proc_entry(name, mode, NULL);
@@ -591,6 +591,7 @@ static void create_seq_entry(char *name,
 void __init proc_misc_init(void)
 {
 	struct proc_dir_entry *entry;
+	int gr_mode = 0;
 	static struct {
 		char *name;
 		int (*read_proc)(char*,char**,off_t,int,int*,void*);
@@ -605,17 +606,21 @@ void __init proc_misc_init(void)
 #ifdef CONFIG_STRAM_PROC
 		{"stram",	stram_read_proc},
 #endif
-#ifdef CONFIG_MODULES
+#if defined(CONFIG_MODULES) && !defined(CONFIG_GRKERNSEC_PROC)
 		{"modules",	modules_read_proc},
 #endif
 		{"stat",	kstat_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"devices",	devices_read_proc},
-#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_X86)
+#endif
+#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_X86) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 		{"interrupts",	interrupts_read_proc},
 #endif
 		{"filesystems",	filesystems_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"dma",		dma_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#endif
 #ifdef CONFIG_SGI_DS1286
 		{"rtc",		ds1286_read_proc},
 #endif
@@ -627,6 +632,23 @@ void __init proc_misc_init(void)
 	for (p = simple_ones; p->name; p++)
 		create_proc_read_entry(p->name, 0, NULL, p->read_proc, NULL);
 
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	gr_mode = S_IRUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	gr_mode = S_IRUSR | S_IRGRP;
+#endif
+#if defined(CONFIG_GRKERNSEC_PROC) && defined(CONFIG_MODULES)
+	create_proc_read_entry("modules", gr_mode, NULL, &modules_read_proc, NULL);
+#endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_proc_read_entry("devices", gr_mode, NULL, &devices_read_proc, NULL);
+	create_proc_read_entry("dma", gr_mode, NULL, &dma_read_proc, NULL);
+	create_proc_read_entry("cmdline", gr_mode, NULL, &cmdline_read_proc, NULL);
+#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_X86)
+	create_proc_read_entry("interrupts", gr_mode, NULL, &interrupts_read_proc, NULL);
+#endif
+#endif
+
 	proc_symlink("mounts", NULL, "self/mounts");
 
 	/* And now for trickier ones */
@@ -634,22 +656,32 @@ void __init proc_misc_init(void)
 	if (entry)
 		entry->proc_fops = &proc_kmsg_operations;
 	create_seq_entry("cpuinfo", 0, &proc_cpuinfo_operations);
-#if defined(CONFIG_X86)
+#if defined(CONFIG_X86) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 	create_seq_entry("interrupts", 0, &proc_interrupts_operations);
+#elif defined(CONFIG_X86)
+	create_seq_entry("interrupts", gr_mode, &proc_interrupts_operations);
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_seq_entry("ioports", gr_mode, &proc_ioports_operations);
+	create_seq_entry("iomem", gr_mode, &proc_iomem_operations);
+	create_seq_entry("slabinfo",gr_mode,&proc_slabinfo_operations);
+#else
 	create_seq_entry("ioports", 0, &proc_ioports_operations);
 	create_seq_entry("iomem", 0, &proc_iomem_operations);
-	create_seq_entry("partitions", 0, &proc_partitions_operations);
 	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
+#endif
+	create_seq_entry("partitions", 0, &proc_partitions_operations);
 #ifdef CONFIG_MODULES
-	create_seq_entry("ksyms", 0, &proc_ksyms_operations);
+	create_seq_entry("ksyms", gr_mode, &proc_ksyms_operations);
 #endif
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 	proc_root_kcore = create_proc_entry("kcore", S_IRUSR, NULL);
 	if (proc_root_kcore) {
 		proc_root_kcore->proc_fops = &proc_kcore_operations;
 		proc_root_kcore->size =
 				(size_t)high_memory - PAGE_OFFSET + PAGE_SIZE;
 	}
+#endif
 	if (prof_shift) {
 		entry = create_proc_entry("profile", S_IWUSR | S_IRUGO, NULL);
 		if (entry) {
@@ -664,7 +696,7 @@ void __init proc_misc_init(void)
 #endif
 #ifdef CONFIG_PPC32
 	{
-		extern struct file_operations ppc_htab_operations;
+		extern const struct file_operations ppc_htab_operations;
 		entry = create_proc_entry("ppc_htab", S_IRUGO|S_IWUSR, NULL);
 		if (entry)
 			entry->proc_fops = &ppc_htab_operations;
diff -urNp linux-2.4.37.7/fs/proc/root.c linux-2.4.37.7/fs/proc/root.c
--- linux-2.4.37.7/fs/proc/root.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/proc/root.c	2009-11-10 19:30:27.000000000 -0500
@@ -37,7 +37,13 @@ void __init proc_root_init(void)
 		return;
 	}
 	proc_misc_init();
-	proc_net = proc_mkdir("net", 0);
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_net = proc_mkdir_mode("net", S_IRUSR | S_IXUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_net = proc_mkdir_mode("net", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+#else
+	proc_net = proc_mkdir("net", NULL);
+#endif
 	proc_net_stat = proc_mkdir("net/stat", NULL);
 
 #ifdef CONFIG_SYSVIPC
@@ -69,7 +75,16 @@ void __init proc_root_init(void)
 #ifdef CONFIG_PPC_RTAS
 	proc_rtas_init();
 #endif
-	proc_bus = proc_mkdir("bus", 0);
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_bus = proc_mkdir_mode("bus", S_IRUSR | S_IXUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_bus = proc_mkdir_mode("bus", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+#endif
+#else
+	proc_bus = proc_mkdir("bus", NULL);
+#endif
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry)
@@ -108,7 +123,7 @@ static int proc_root_readdir(struct file
  * <pid> directories. Thus we don't use the generic
  * directory handling functions for that..
  */
-static struct file_operations proc_root_operations = {
+static const struct file_operations proc_root_operations = {
 	read:		 generic_read_dir,
 	readdir:	 proc_root_readdir,
 };
@@ -116,7 +131,7 @@ static struct file_operations proc_root_
 /*
  * proc root can do almost nothing..
  */
-static struct inode_operations proc_root_inode_operations = {
+static const struct inode_operations proc_root_inode_operations = {
 	lookup:		proc_root_lookup,
 };
 
diff -urNp linux-2.4.37.7/fs/qnx4/dir.c linux-2.4.37.7/fs/qnx4/dir.c
--- linux-2.4.37.7/fs/qnx4/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/qnx4/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -78,15 +78,13 @@ static int qnx4_readdir(struct file *fil
 	return 0;
 }
 
-struct file_operations qnx4_dir_operations =
-{
+const struct file_operations qnx4_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	qnx4_readdir,
 	fsync:		file_fsync,
 };
 
-struct inode_operations qnx4_dir_inode_operations =
-{
+const struct inode_operations qnx4_dir_inode_operations = {
 	lookup:		qnx4_lookup,
 #ifdef CONFIG_QNX4FS_RW
 	create:		qnx4_create,
diff -urNp linux-2.4.37.7/fs/qnx4/file.c linux-2.4.37.7/fs/qnx4/file.c
--- linux-2.4.37.7/fs/qnx4/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/qnx4/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,8 +22,7 @@
  * We have mostly NULL's here: the current defaults are ok for
  * the qnx4 filesystem.
  */
-struct file_operations qnx4_file_operations =
-{
+const struct file_operations qnx4_file_operations = {
 	llseek:			generic_file_llseek,
 	read:			generic_file_read,
 #ifdef CONFIG_QNX4FS_RW
@@ -35,8 +34,7 @@ struct file_operations qnx4_file_operati
 #endif
 };
 
-struct inode_operations qnx4_file_inode_operations =
-{
+const struct inode_operations qnx4_file_inode_operations = {
 #ifdef CONFIG_QNX4FS_RW
 	truncate:		qnx4_truncate,
 #endif
diff -urNp linux-2.4.37.7/fs/qnx4/inode.c linux-2.4.37.7/fs/qnx4/inode.c
--- linux-2.4.37.7/fs/qnx4/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/qnx4/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -30,7 +30,7 @@
 #define QNX4_VERSION  4
 #define QNX4_BMNAME   ".bitmap"
 
-static struct super_operations qnx4_sops;
+static const struct super_operations qnx4_sops;
 
 #ifdef CONFIG_QNX4FS_RW
 
@@ -125,8 +125,7 @@ static void qnx4_read_inode(struct inode
 static int qnx4_remount(struct super_block *sb, int *flags, char *data);
 static int qnx4_statfs(struct super_block *, struct statfs *);
 
-static struct super_operations qnx4_sops =
-{
+static const struct super_operations qnx4_sops = {
 	read_inode:	qnx4_read_inode,
 #ifdef CONFIG_QNX4FS_RW
 	write_inode:	qnx4_write_inode,
@@ -428,7 +427,7 @@ static int qnx4_bmap(struct address_spac
 {
 	return generic_block_bmap(mapping,block,qnx4_get_block);
 }
-struct address_space_operations qnx4_aops = {
+const struct address_space_operations qnx4_aops = {
 	readpage: qnx4_readpage,
 	writepage: qnx4_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/ramfs/inode.c linux-2.4.37.7/fs/ramfs/inode.c
--- linux-2.4.37.7/fs/ramfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ramfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -35,10 +35,10 @@
 /* some random number */
 #define RAMFS_MAGIC	0x858458f6
 
-static struct super_operations ramfs_ops;
-static struct address_space_operations ramfs_aops;
-static struct file_operations ramfs_file_operations;
-static struct inode_operations ramfs_dir_inode_operations;
+static const struct super_operations ramfs_ops;
+static const struct address_space_operations ramfs_aops;
+static const struct file_operations ramfs_file_operations;
+static const struct inode_operations ramfs_dir_inode_operations;
 
 static int ramfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -271,21 +271,21 @@ static int ramfs_sync_file(struct file *
 	return 0;
 }
 
-static struct address_space_operations ramfs_aops = {
+static const struct address_space_operations ramfs_aops = {
 	readpage:	ramfs_readpage,
 	writepage:	fail_writepage,
 	prepare_write:	ramfs_prepare_write,
 	commit_write:	ramfs_commit_write
 };
 
-static struct file_operations ramfs_file_operations = {
+static const struct file_operations ramfs_file_operations = {
 	read:		generic_file_read,
 	write:		generic_file_write,
 	mmap:		generic_file_mmap,
 	fsync:		ramfs_sync_file,
 };
 
-static struct inode_operations ramfs_dir_inode_operations = {
+static const struct inode_operations ramfs_dir_inode_operations = {
 	create:		ramfs_create,
 	lookup:		ramfs_lookup,
 	link:		ramfs_link,
@@ -297,7 +297,7 @@ static struct inode_operations ramfs_dir
 	rename:		ramfs_rename,
 };
 
-static struct super_operations ramfs_ops = {
+static const struct super_operations ramfs_ops = {
 	statfs:		ramfs_statfs,
 	put_inode:	force_delete,
 };
diff -urNp linux-2.4.37.7/fs/readdir.c linux-2.4.37.7/fs/readdir.c
--- linux-2.4.37.7/fs/readdir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/readdir.c	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/file.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -150,7 +151,7 @@ int dcache_readdir(struct file * filp, v
 	return 0;
 }
 
-struct file_operations dcache_dir_ops = {
+const struct file_operations dcache_dir_ops = {
 	open:		dcache_dir_open,
 	release:	dcache_dir_close,
 	llseek:		dcache_dir_lseek,
@@ -181,6 +182,7 @@ struct old_linux_dirent {
 
 struct readdir_callback {
 	struct old_linux_dirent * dirent;
+	struct file * file;
 	int count;
 };
 
@@ -192,6 +194,10 @@ static int fillonedir(void * __buf, cons
 
 	if (buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+	    
 	buf->count++;
 	dirent = buf->dirent;
 	put_user(ino, &dirent->d_ino);
@@ -214,6 +220,7 @@ asmlinkage int old_readdir(unsigned int 
 		goto out;
 
 	buf.count = 0;
+	buf.file = file;
 	buf.dirent = dirent;
 
 	error = vfs_readdir(file, fillonedir, &buf);
@@ -241,6 +248,7 @@ struct linux_dirent {
 struct getdents_callback {
 	struct linux_dirent * current_dir;
 	struct linux_dirent * previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -255,6 +263,10 @@ static int filldir(void * __buf, const c
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+
 	dirent = buf->previous;
 	if (dirent)
 		put_user(offset, &dirent->d_off);
@@ -284,6 +296,7 @@ asmlinkage long sys_getdents(unsigned in
 
 	buf.current_dir = (struct linux_dirent *) dirent;
 	buf.previous = NULL;
+	buf.file = file;
 	buf.count = count;
 	buf.error = 0;
 
@@ -319,6 +332,7 @@ struct linux_dirent64 {
 struct getdents_callback64 {
 	struct linux_dirent64 * current_dir;
 	struct linux_dirent64 * previous;
+	struct file * file;
 	int count;
 	int error;
 };
@@ -333,6 +347,10 @@ static int filldir64(void * __buf, const
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+	
 	dirent = buf->previous;
 	if (dirent) {
 		d.d_off = offset;
@@ -367,6 +385,7 @@ asmlinkage long sys_getdents64(unsigned 
 
 	buf.current_dir = (struct linux_dirent64 *) dirent;
 	buf.previous = NULL;
+	buf.file = file;
 	buf.count = count;
 	buf.error = 0;
 
diff -urNp linux-2.4.37.7/fs/read_write.c linux-2.4.37.7/fs/read_write.c
--- linux-2.4.37.7/fs/read_write.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/read_write.c	2009-11-10 19:30:27.000000000 -0500
@@ -29,7 +29,7 @@
 
 #include <asm/uaccess.h>
 
-struct file_operations generic_ro_fops = {
+const struct file_operations generic_ro_fops = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	mmap:		generic_file_mmap,
diff -urNp linux-2.4.37.7/fs/reiserfs/dir.c linux-2.4.37.7/fs/reiserfs/dir.c
--- linux-2.4.37.7/fs/reiserfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/reiserfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -16,7 +16,7 @@ extern struct key  MIN_KEY;
 static int reiserfs_readdir (struct file *, void *, filldir_t);
 int reiserfs_dir_fsync(struct file *filp, struct dentry *dentry, int datasync) ;
 
-struct file_operations reiserfs_dir_operations = {
+const struct file_operations reiserfs_dir_operations = {
     read:	generic_read_dir,
     readdir:	reiserfs_readdir,
     fsync:	reiserfs_dir_fsync,
diff -urNp linux-2.4.37.7/fs/reiserfs/file.c linux-2.4.37.7/fs/reiserfs/file.c
--- linux-2.4.37.7/fs/reiserfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/reiserfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -129,7 +129,7 @@ static int reiserfs_setattr(struct dentr
     return error ;
 }
 
-struct file_operations reiserfs_file_operations = {
+const struct file_operations reiserfs_file_operations = {
     read:	generic_file_read,
     write:	generic_file_write,
     ioctl:	reiserfs_ioctl,
@@ -139,7 +139,7 @@ struct file_operations reiserfs_file_ope
 };
 
 
-struct  inode_operations reiserfs_file_inode_operations = {
+const struct inode_operations reiserfs_file_inode_operations = {
     truncate:	reiserfs_vfs_truncate_file,
     setattr:    reiserfs_setattr,
 };
diff -urNp linux-2.4.37.7/fs/reiserfs/inode.c linux-2.4.37.7/fs/reiserfs/inode.c
--- linux-2.4.37.7/fs/reiserfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/reiserfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -2229,7 +2229,7 @@ static int reiserfs_direct_io(int rw, st
                              reiserfs_get_block_direct_io) ;
 }
 
-struct address_space_operations reiserfs_address_space_operations = {
+const struct address_space_operations reiserfs_address_space_operations = {
     writepage: reiserfs_writepage,
     readpage: reiserfs_readpage, 
     sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/reiserfs/namei.c linux-2.4.37.7/fs/reiserfs/namei.c
--- linux-2.4.37.7/fs/reiserfs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/reiserfs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -1266,7 +1266,7 @@ static int reiserfs_rename (struct inode
 /*
  * directories can handle most operations...
  */
-struct inode_operations reiserfs_dir_inode_operations = {
+const struct inode_operations reiserfs_dir_inode_operations = {
   //&reiserfs_dir_operations,	/* default_file_ops */
     create:	reiserfs_create,
     lookup:	reiserfs_lookup,
diff -urNp linux-2.4.37.7/fs/reiserfs/super.c linux-2.4.37.7/fs/reiserfs/super.c
--- linux-2.4.37.7/fs/reiserfs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/reiserfs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -408,8 +408,7 @@ static void reiserfs_dirty_inode (struct
     unlock_kernel() ;
 }
 
-struct super_operations reiserfs_sops = 
-{
+const struct super_operations reiserfs_sops = {
   read_inode: reiserfs_read_inode,
   read_inode2: reiserfs_read_inode2,
   write_inode: reiserfs_write_inode,
diff -urNp linux-2.4.37.7/fs/romfs/inode.c linux-2.4.37.7/fs/romfs/inode.c
--- linux-2.4.37.7/fs/romfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/romfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -90,7 +90,7 @@ romfs_checksum(void *data, int size)
 	return sum;
 }
 
-static struct super_operations romfs_ops;
+static const struct super_operations romfs_ops;
 
 static struct super_block *
 romfs_read_super(struct super_block *s, void *data, int silent)
@@ -435,16 +435,16 @@ err_out:
 
 /* Mapping from our types to the kernel */
 
-static struct address_space_operations romfs_aops = {
+static const struct address_space_operations romfs_aops = {
 	readpage: romfs_readpage
 };
 
-static struct file_operations romfs_dir_operations = {
+static const struct file_operations romfs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	romfs_readdir,
 };
 
-static struct inode_operations romfs_dir_inode_operations = {
+static const struct inode_operations romfs_dir_inode_operations = {
 	lookup:		romfs_lookup,
 };
 
@@ -525,7 +525,7 @@ romfs_read_inode(struct inode *i)
 	}
 }
 
-static struct super_operations romfs_ops = {
+static const struct super_operations romfs_ops = {
 	read_inode:	romfs_read_inode,
 	statfs:		romfs_statfs,
 };
diff -urNp linux-2.4.37.7/fs/seq_file.c linux-2.4.37.7/fs/seq_file.c
--- linux-2.4.37.7/fs/seq_file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/seq_file.c	2009-11-10 19:30:27.000000000 -0500
@@ -25,7 +25,7 @@
  *	ERR_PTR(error).  In the end of sequence they return %NULL. ->show()
  *	returns 0 in case of success and negative number in case of error.
  */
-int seq_open(struct file *file, struct seq_operations *op)
+int seq_open(struct file *file, const struct seq_operations *op)
 {
 	struct seq_file *p = kmalloc(sizeof(*p), GFP_KERNEL);
 	if (!p)
@@ -364,7 +364,7 @@ int single_open(struct file *file, int (
 
 int single_release(struct inode *inode, struct file *file)
 {
-	struct seq_operations *op = ((struct seq_file *)file->private_data)->op;
+	struct seq_operations *op = (struct seq_operations *)((struct seq_file *)file->private_data)->op;
 	int res = seq_release(inode, file);
 	kfree(op);
 	return res;
diff -urNp linux-2.4.37.7/fs/smbfs/dir.c linux-2.4.37.7/fs/smbfs/dir.c
--- linux-2.4.37.7/fs/smbfs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/smbfs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -33,16 +33,14 @@ static int smb_rename(struct inode *, st
 static int smb_make_node(struct inode *,struct dentry *, int, int);
 static int smb_link(struct dentry *, struct inode *, struct dentry *);
 
-struct file_operations smb_dir_operations =
-{
+const struct file_operations smb_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	smb_readdir,
 	ioctl:		smb_ioctl,
 	open:		smb_dir_open,
 };
 
-struct inode_operations smb_dir_inode_operations =
-{
+const struct inode_operations smb_dir_inode_operations = {
 	create:		smb_create,
 	lookup:		smb_lookup,
 	unlink:		smb_unlink,
@@ -53,8 +51,7 @@ struct inode_operations smb_dir_inode_op
 	setattr:	smb_notify_change,
 };
 
-struct inode_operations smb_dir_inode_operations_unix =
-{
+const struct inode_operations smb_dir_inode_operations_unix = {
 	create:		smb_create,
 	lookup:		smb_lookup,
 	unlink:		smb_unlink,
@@ -269,16 +266,14 @@ static int smb_hash_dentry(struct dentry
 static int smb_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
 static int smb_delete_dentry(struct dentry *);
 
-static struct dentry_operations smbfs_dentry_operations =
-{
+static const struct dentry_operations smbfs_dentry_operations = {
 	d_revalidate:	smb_lookup_validate,
 	d_hash:		smb_hash_dentry,
 	d_compare:	smb_compare_dentry,
 	d_delete:	smb_delete_dentry,
 };
 
-static struct dentry_operations smbfs_dentry_operations_case =
-{
+static const struct dentry_operations smbfs_dentry_operations_case = {
 	d_revalidate:	smb_lookup_validate,
 	d_delete:	smb_delete_dentry,
 };
diff -urNp linux-2.4.37.7/fs/smbfs/file.c linux-2.4.37.7/fs/smbfs/file.c
--- linux-2.4.37.7/fs/smbfs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/smbfs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -288,7 +288,7 @@ static int smb_commit_write(struct file 
 	return status;
 }
 
-struct address_space_operations smb_file_aops = {
+const struct address_space_operations smb_file_aops = {
 	readpage: smb_readpage,
 	writepage: smb_writepage,
 	prepare_write: smb_prepare_write,
@@ -382,8 +382,7 @@ smb_file_permission(struct inode *inode,
 	return error;
 }
 
-struct file_operations smb_file_operations =
-{
+const struct file_operations smb_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		smb_file_read,
 	write:		smb_file_write,
@@ -394,8 +393,7 @@ struct file_operations smb_file_operatio
 	fsync:		smb_fsync,
 };
 
-struct inode_operations smb_file_inode_operations =
-{
+const struct inode_operations smb_file_inode_operations = {
 	permission:	smb_file_permission,
 	revalidate:	smb_revalidate_inode,
 	setattr:	smb_notify_change,
diff -urNp linux-2.4.37.7/fs/smbfs/inode.c linux-2.4.37.7/fs/smbfs/inode.c
--- linux-2.4.37.7/fs/smbfs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/smbfs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,8 +50,7 @@ static void smb_put_super(struct super_b
 static int  smb_statfs(struct super_block *, struct statfs *);
 static int  smb_show_options(struct seq_file *, struct vfsmount *);
 
-static struct super_operations smb_sops =
-{
+static const struct super_operations smb_sops = {
 	put_inode:	force_delete,
 	delete_inode:	smb_delete_inode,
 	put_super:	smb_put_super,
diff -urNp linux-2.4.37.7/fs/smbfs/proto.h linux-2.4.37.7/fs/smbfs/proto.h
--- linux-2.4.37.7/fs/smbfs/proto.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/smbfs/proto.h	2009-11-10 19:30:27.000000000 -0500
@@ -32,9 +32,9 @@ extern int smb_proc_symlink(struct smb_s
 extern int smb_proc_link(struct smb_sb_info *server, struct dentry *dentry, struct dentry *new_dentry);
 extern void smb_install_null_ops(struct smb_ops *ops);
 /* dir.c */
-extern struct file_operations smb_dir_operations;
-extern struct inode_operations smb_dir_inode_operations;
-extern struct inode_operations smb_dir_inode_operations_unix;
+extern const struct file_operations smb_dir_operations;
+extern const struct inode_operations smb_dir_inode_operations;
+extern const struct inode_operations smb_dir_inode_operations_unix;
 extern void smb_new_dentry(struct dentry *dentry);
 extern void smb_renew_times(struct dentry *dentry);
 /* cache.c */
@@ -59,13 +59,13 @@ extern int smb_revalidate_inode(struct d
 extern struct super_block *smb_read_super(struct super_block *sb, void *raw_data, int silent);
 extern int smb_notify_change(struct dentry *dentry, struct iattr *attr);
 /* file.c */
-extern struct address_space_operations smb_file_aops;
-extern struct file_operations smb_file_operations;
-extern struct inode_operations smb_file_inode_operations;
+extern const struct address_space_operations smb_file_aops;
+extern const struct file_operations smb_file_operations;
+extern const struct inode_operations smb_file_inode_operations;
 /* ioctl.c */
 extern int smb_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
 /* symlink.c */
 extern int smb_read_link(struct dentry *dentry, char *buffer, int len);
 extern int smb_symlink(struct inode *inode, struct dentry *dentry, const char *oldname);
 extern int smb_follow_link(struct dentry *dentry, struct nameidata *nd);
-extern struct inode_operations smb_link_inode_operations;
+extern const struct inode_operations smb_link_inode_operations;
diff -urNp linux-2.4.37.7/fs/smbfs/symlink.c linux-2.4.37.7/fs/smbfs/symlink.c
--- linux-2.4.37.7/fs/smbfs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/smbfs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -83,8 +83,7 @@ out:
 	return result;
 }
 
-struct inode_operations smb_link_inode_operations =
-{
+const struct inode_operations smb_link_inode_operations = {
 	.readlink	= smb_read_link,
 	.follow_link	= smb_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/super.c linux-2.4.37.7/fs/super.c
--- linux-2.4.37.7/fs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -263,7 +263,7 @@ struct file_system_type *get_fs_type(con
  */
 static struct super_block *alloc_super(void)
 {
-	static struct super_operations empty_sops = {};
+	static const struct super_operations empty_sops = {};
 	struct super_block *s = kmalloc(sizeof(struct super_block),  GFP_USER);
 	if (s) {
 		memset(s, 0, sizeof(struct super_block));
@@ -828,7 +828,7 @@ void kill_super(struct super_block *sb)
 {
 	struct dentry *root = sb->s_root;
 	struct file_system_type *fs = sb->s_type;
-	struct super_operations *sop = sb->s_op;
+	const struct super_operations *sop = sb->s_op;
 
 	if (!deactivate_super(sb))
 		return;
diff -urNp linux-2.4.37.7/fs/sysv/dir.c linux-2.4.37.7/fs/sysv/dir.c
--- linux-2.4.37.7/fs/sysv/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -19,7 +19,7 @@
 
 static int sysv_readdir(struct file *, void *, filldir_t);
 
-struct file_operations sysv_dir_operations = {
+const struct file_operations sysv_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	sysv_readdir,
 	fsync:		sysv_sync_file,
diff -urNp linux-2.4.37.7/fs/sysv/file.c linux-2.4.37.7/fs/sysv/file.c
--- linux-2.4.37.7/fs/sysv/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -20,7 +20,7 @@
  * We have mostly NULLs here: the current defaults are OK for
  * the coh filesystem.
  */
-struct file_operations sysv_file_operations = {
+const struct file_operations sysv_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		generic_file_write,
@@ -28,7 +28,7 @@ struct file_operations sysv_file_operati
 	fsync:		sysv_sync_file,
 };
 
-struct inode_operations sysv_file_inode_operations = {
+const struct inode_operations sysv_file_inode_operations = {
 	truncate:	sysv_truncate,
 };
 
diff -urNp linux-2.4.37.7/fs/sysv/inode.c linux-2.4.37.7/fs/sysv/inode.c
--- linux-2.4.37.7/fs/sysv/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -114,7 +114,7 @@ static inline void write3byte(struct sup
 	}
 }
 
-static struct inode_operations sysv_symlink_inode_operations = {
+static const struct inode_operations sysv_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 };
@@ -261,7 +261,7 @@ static void sysv_delete_inode(struct ino
 	unlock_kernel();
 }
 
-struct super_operations sysv_sops = {
+const struct super_operations sysv_sops = {
 	read_inode:	sysv_read_inode,
 	write_inode:	sysv_write_inode,
 	delete_inode:	sysv_delete_inode,
diff -urNp linux-2.4.37.7/fs/sysv/itree.c linux-2.4.37.7/fs/sysv/itree.c
--- linux-2.4.37.7/fs/sysv/itree.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/itree.c	2009-11-10 19:30:27.000000000 -0500
@@ -429,7 +429,7 @@ static int sysv_bmap(struct address_spac
 {
 	return generic_block_bmap(mapping,block,get_block);
 }
-struct address_space_operations sysv_aops = {
+const struct address_space_operations sysv_aops = {
 	readpage: sysv_readpage,
 	writepage: sysv_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/sysv/namei.c linux-2.4.37.7/fs/sysv/namei.c
--- linux-2.4.37.7/fs/sysv/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -60,7 +60,7 @@ static int sysv_hash(struct dentry *dent
 	return 0;
 }
 
-struct dentry_operations sysv_dentry_operations = {
+const struct dentry_operations sysv_dentry_operations = {
 	d_hash:		sysv_hash,
 };
 
@@ -310,7 +310,7 @@ out:
 /*
  * directories can handle most operations...
  */
-struct inode_operations sysv_dir_inode_operations = {
+const struct inode_operations sysv_dir_inode_operations = {
 	create:		sysv_create,
 	lookup:		sysv_lookup,
 	link:		sysv_link,
diff -urNp linux-2.4.37.7/fs/sysv/symlink.c linux-2.4.37.7/fs/sysv/symlink.c
--- linux-2.4.37.7/fs/sysv/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/sysv/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -19,7 +19,7 @@ static int sysv_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
-struct inode_operations sysv_fast_symlink_inode_operations = {
+const struct inode_operations sysv_fast_symlink_inode_operations = {
 	readlink:	sysv_readlink,
 	follow_link:	sysv_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/udf/dir.c linux-2.4.37.7/fs/udf/dir.c
--- linux-2.4.37.7/fs/udf/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,7 +45,7 @@ static int do_udf_readdir(struct inode *
 
 /* readdir and lookup functions */
 
-struct file_operations udf_dir_operations = {
+const struct file_operations udf_dir_operations = {
 	read:			generic_read_dir,
 	readdir:		udf_readdir,
 	ioctl:			udf_ioctl,
diff -urNp linux-2.4.37.7/fs/udf/file.c linux-2.4.37.7/fs/udf/file.c
--- linux-2.4.37.7/fs/udf/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -142,7 +142,7 @@ out:
 	return err;
 }
 
-struct address_space_operations udf_adinicb_aops = {
+const struct address_space_operations udf_adinicb_aops = {
 	readpage:		udf_adinicb_readpage,
 	writepage:		udf_adinicb_writepage,
 	sync_page:		block_sync_page,
@@ -360,7 +360,7 @@ static int udf_open_file(struct inode * 
 	return 0;
 }
 
-struct file_operations udf_file_operations = {
+const struct file_operations udf_file_operations = {
 	read:			generic_file_read,
 	ioctl:			udf_ioctl,
 	open:			udf_open_file,
@@ -370,6 +370,6 @@ struct file_operations udf_file_operatio
 	fsync:			udf_fsync_file,
 };
 
-struct inode_operations udf_file_inode_operations = {
+const struct inode_operations udf_file_inode_operations = {
 	truncate:		udf_truncate,
 };
diff -urNp linux-2.4.37.7/fs/udf/inode.c linux-2.4.37.7/fs/udf/inode.c
--- linux-2.4.37.7/fs/udf/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -151,7 +151,7 @@ static int udf_bmap(struct address_space
 	return generic_block_bmap(mapping,block,udf_get_block);
 }
 
-struct address_space_operations udf_aops = {
+const struct address_space_operations udf_aops = {
 	readpage:		udf_readpage,
 	writepage:		udf_writepage,
 	sync_page:		block_sync_page,
diff -urNp linux-2.4.37.7/fs/udf/namei.c linux-2.4.37.7/fs/udf/namei.c
--- linux-2.4.37.7/fs/udf/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -1287,7 +1287,7 @@ end_rename:
 	return retval;
 }
 
-struct inode_operations udf_dir_inode_operations = {
+const struct inode_operations udf_dir_inode_operations = {
 	lookup:				udf_lookup,
 	create:				udf_create,
 	link:				udf_link,
diff -urNp linux-2.4.37.7/fs/udf/super.c linux-2.4.37.7/fs/udf/super.c
--- linux-2.4.37.7/fs/udf/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -99,7 +99,7 @@ static int udf_statfs(struct super_block
 static DECLARE_FSTYPE_DEV(udf_fstype, "udf", udf_read_super);
 
 /* Superblock operations */
-static struct super_operations udf_sb_ops = {
+static const struct super_operations udf_sb_ops = {
 	read_inode:		udf_read_inode,
 	write_inode:		udf_write_inode,
 	put_inode:		udf_put_inode,
diff -urNp linux-2.4.37.7/fs/udf/symlink.c linux-2.4.37.7/fs/udf/symlink.c
--- linux-2.4.37.7/fs/udf/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -124,6 +124,6 @@ out:
 /*
  * symlinks can't do much...
  */
-struct address_space_operations udf_symlink_aops = {
+const struct address_space_operations udf_symlink_aops = {
 	readpage:		udf_symlink_filler,
 };
diff -urNp linux-2.4.37.7/fs/udf/udfdecl.h linux-2.4.37.7/fs/udf/udfdecl.h
--- linux-2.4.37.7/fs/udf/udfdecl.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/udf/udfdecl.h	2009-11-10 19:30:27.000000000 -0500
@@ -50,13 +50,13 @@ struct task_struct;
 struct buffer_head;
 struct super_block;
 
-extern struct inode_operations udf_dir_inode_operations;
-extern struct file_operations udf_dir_operations;
-extern struct inode_operations udf_file_inode_operations;
-extern struct file_operations udf_file_operations;
-extern struct address_space_operations udf_aops;
-extern struct address_space_operations udf_adinicb_aops;
-extern struct address_space_operations udf_symlink_aops;
+extern const struct inode_operations udf_dir_inode_operations;
+extern const struct file_operations udf_dir_operations;
+extern const struct inode_operations udf_file_inode_operations;
+extern const struct file_operations udf_file_operations;
+extern const struct address_space_operations udf_aops;
+extern const struct address_space_operations udf_adinicb_aops;
+extern const struct address_space_operations udf_symlink_aops;
 
 struct udf_fileident_bh
 {
diff -urNp linux-2.4.37.7/fs/ufs/dir.c linux-2.4.37.7/fs/ufs/dir.c
--- linux-2.4.37.7/fs/ufs/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -615,7 +615,7 @@ int ufs_empty_dir (struct inode * inode)
 	return 1;
 }
 
-struct file_operations ufs_dir_operations = {
+const struct file_operations ufs_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	ufs_readdir,
 	fsync:		file_fsync,
diff -urNp linux-2.4.37.7/fs/ufs/file.c linux-2.4.37.7/fs/ufs/file.c
--- linux-2.4.37.7/fs/ufs/file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/file.c	2009-11-10 19:30:27.000000000 -0500
@@ -41,7 +41,7 @@
  * the ufs filesystem.
  */
  
-struct file_operations ufs_file_operations = {
+const struct file_operations ufs_file_operations = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
 	write:		generic_file_write,
@@ -49,6 +49,6 @@ struct file_operations ufs_file_operatio
 	open:           generic_file_open,
 };
 
-struct inode_operations ufs_file_inode_operations = {
+const struct inode_operations ufs_file_inode_operations = {
 	truncate:	ufs_truncate,
 };
diff -urNp linux-2.4.37.7/fs/ufs/inode.c linux-2.4.37.7/fs/ufs/inode.c
--- linux-2.4.37.7/fs/ufs/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -467,7 +467,7 @@ static int ufs_bmap(struct address_space
 {
 	return generic_block_bmap(mapping,block,ufs_getfrag_block);
 }
-struct address_space_operations ufs_aops = {
+const struct address_space_operations ufs_aops = {
 	readpage: ufs_readpage,
 	writepage: ufs_writepage,
 	sync_page: block_sync_page,
diff -urNp linux-2.4.37.7/fs/ufs/namei.c linux-2.4.37.7/fs/ufs/namei.c
--- linux-2.4.37.7/fs/ufs/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -324,7 +324,7 @@ out:
 	return err;
 }
 
-struct inode_operations ufs_dir_inode_operations = {
+const struct inode_operations ufs_dir_inode_operations = {
 	create:		ufs_create,
 	lookup:		ufs_lookup,
 	link:		ufs_link,
diff -urNp linux-2.4.37.7/fs/ufs/super.c linux-2.4.37.7/fs/ufs/super.c
--- linux-2.4.37.7/fs/ufs/super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/super.c	2009-11-10 19:30:27.000000000 -0500
@@ -177,7 +177,7 @@ void ufs_print_cylinder_stuff(struct sup
 }
 #endif /* UFS_SUPER_DEBUG_MORE */
 
-static struct super_operations ufs_super_ops;
+static const struct super_operations ufs_super_ops;
 
 static char error_buf[1024];
 
@@ -980,7 +980,7 @@ int ufs_statfs (struct super_block * sb,
 	return 0;
 }
 
-static struct super_operations ufs_super_ops = {
+static const struct super_operations ufs_super_ops = {
 	read_inode:	ufs_read_inode,
 	write_inode:	ufs_write_inode,
 	delete_inode:	ufs_delete_inode,
diff -urNp linux-2.4.37.7/fs/ufs/symlink.c linux-2.4.37.7/fs/ufs/symlink.c
--- linux-2.4.37.7/fs/ufs/symlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/ufs/symlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -39,7 +39,7 @@ static int ufs_follow_link(struct dentry
 	return vfs_follow_link(nd, s);
 }
 
-struct inode_operations ufs_fast_symlink_inode_operations = {
+const struct inode_operations ufs_fast_symlink_inode_operations = {
 	readlink:	ufs_readlink,
 	follow_link:	ufs_follow_link,
 };
diff -urNp linux-2.4.37.7/fs/umsdos/dir.c linux-2.4.37.7/fs/umsdos/dir.c
--- linux-2.4.37.7/fs/umsdos/dir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/umsdos/dir.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,8 +45,7 @@ static int umsdos_dentry_dput(struct den
 	return 0;
 }
 
-struct dentry_operations umsdos_dentry_operations =
-{
+const struct dentry_operations umsdos_dentry_operations = {
 	d_revalidate:	umsdos_dentry_validate,
 	d_delete:	umsdos_dentry_dput,
 };
@@ -787,15 +786,13 @@ out_release:
 }	
 
 
-struct file_operations umsdos_dir_operations =
-{
+const struct file_operations umsdos_dir_operations = {
 	read:		generic_read_dir,
 	readdir:	UMSDOS_readdir,
 	ioctl:		UMSDOS_ioctl_dir,
 };
 
-struct inode_operations umsdos_dir_inode_operations =
-{
+const struct inode_operations umsdos_dir_inode_operations = {
 	create:		UMSDOS_create,
 	lookup:		UMSDOS_lookup,
 	link:		UMSDOS_link,
diff -urNp linux-2.4.37.7/fs/umsdos/inode.c linux-2.4.37.7/fs/umsdos/inode.c
--- linux-2.4.37.7/fs/umsdos/inode.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/umsdos/inode.c	2009-11-10 19:30:27.000000000 -0500
@@ -20,7 +20,7 @@
 #include <linux/list.h>
 #include <linux/pagemap.h>
 
-extern struct dentry_operations umsdos_dentry_operations;
+extern const struct dentry_operations umsdos_dentry_operations;
 
 struct dentry *saved_root;	/* Original root if changed */
 struct inode *pseudo_root;	/* Useful to simulate the pseudo DOS */
@@ -106,12 +106,12 @@ void umsdos_set_dirinfo_new (struct dent
 	return;
 }
 
-static struct inode_operations umsdos_file_inode_operations = {
+static const struct inode_operations umsdos_file_inode_operations = {
 	truncate:	fat_truncate,
 	setattr:	UMSDOS_notify_change,
 };
 
-static struct inode_operations umsdos_symlink_inode_operations = {
+static const struct inode_operations umsdos_symlink_inode_operations = {
 	readlink:	page_readlink,
 	follow_link:	page_follow_link,
 	setattr:	UMSDOS_notify_change,
@@ -331,8 +331,7 @@ void UMSDOS_write_inode (struct inode *i
 }
 
 
-static struct super_operations umsdos_sops =
-{
+static const struct super_operations umsdos_sops = {
 	write_inode:	UMSDOS_write_inode,
 	put_inode:	UMSDOS_put_inode,
 	delete_inode:	fat_delete_inode,
diff -urNp linux-2.4.37.7/fs/umsdos/rdir.c linux-2.4.37.7/fs/umsdos/rdir.c
--- linux-2.4.37.7/fs/umsdos/rdir.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/umsdos/rdir.c	2009-11-10 19:30:27.000000000 -0500
@@ -21,7 +21,7 @@
 
 extern struct dentry *saved_root;
 extern struct inode *pseudo_root;
-extern struct dentry_operations umsdos_dentry_operations;
+extern const struct dentry_operations umsdos_dentry_operations;
 
 struct RDIR_FILLDIR {
 	void *dirbuf;
@@ -224,15 +224,13 @@ out:
  * have a "r" prefix (r for real) such as UMSDOS_rlookup, to differentiate
  * from the one with full UMSDOS semantics.
  */
-struct file_operations umsdos_rdir_operations =
-{
+const struct file_operations umsdos_rdir_operations = {
 	read:		generic_read_dir,
 	readdir:	UMSDOS_rreaddir,
 	ioctl:		UMSDOS_ioctl_dir,
 };
 
-struct inode_operations umsdos_rdir_inode_operations =
-{
+const struct inode_operations umsdos_rdir_inode_operations = {
 	create:		msdos_create,
 	lookup:		UMSDOS_rlookup,
 	unlink:		msdos_unlink,
diff -urNp linux-2.4.37.7/fs/vfat/namei.c linux-2.4.37.7/fs/vfat/namei.c
--- linux-2.4.37.7/fs/vfat/namei.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/vfat/namei.c	2009-11-10 19:30:27.000000000 -0500
@@ -51,7 +51,7 @@ static int vfat_cmpi(struct dentry *dent
 static int vfat_cmp(struct dentry *dentry, struct qstr *a, struct qstr *b);
 static int vfat_revalidate(struct dentry *dentry, int);
 
-static struct dentry_operations vfat_dentry_ops[4] = {
+static const struct dentry_operations vfat_dentry_ops[4] = {
 	{
 		d_hash:		vfat_hashi,
 		d_compare:	vfat_cmpi,
@@ -1251,7 +1251,7 @@ rename_done:
 
 
 /* Public inode operations for the VFAT fs */
-struct inode_operations vfat_dir_inode_operations = {
+const struct inode_operations vfat_dir_inode_operations = {
 	create:		vfat_create,
 	lookup:		vfat_lookup,
 	unlink:		vfat_unlink,
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_aops.c linux-2.4.37.7/fs/xfs/linux-2.4/xfs_aops.c
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_aops.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_aops.c	2009-11-10 19:30:27.000000000 -0500
@@ -1287,7 +1287,7 @@ linvfs_direct_IO(
 }
 
 
-struct address_space_operations linvfs_aops = {
+const struct address_space_operations linvfs_aops = {
 	.readpage		= linvfs_readpage,
 	.writepage		= linvfs_writepage,
 	.sync_page		= block_sync_page,
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_buf.c linux-2.4.37.7/fs/xfs/linux-2.4/xfs_buf.c
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_buf.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_buf.c	2009-11-10 19:30:27.000000000 -0500
@@ -1508,7 +1508,7 @@ xfs_mapping_buftarg(
 	kdev_t			kdev;
 	struct inode		*inode;
 	struct address_space	*mapping;
-	static struct address_space_operations mapping_aops = {
+	static const struct address_space_operations mapping_aops = {
 		.sync_page = block_sync_page,
 	};
 
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_file.c linux-2.4.37.7/fs/xfs/linux-2.4/xfs_file.c
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_file.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_file.c	2009-11-10 19:30:27.000000000 -0500
@@ -57,7 +57,7 @@
 #include <linux/smp_lock.h>
 #include <linux/mman.h> /* for PROT_WRITE */
 
-static struct vm_operations_struct linvfs_file_vm_ops;
+static const struct vm_operations_struct linvfs_file_vm_ops;
 
 STATIC inline ssize_t
 __linvfs_read(
@@ -330,6 +330,11 @@ linvfs_file_mmap(
 			return error;
 	}
 
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	vma->vm_ops = &linvfs_file_vm_ops;
 
 	VOP_SETATTR(vp, &va, XFS_AT_UPDATIME, NULL, error);
@@ -409,7 +414,7 @@ linvfs_mprotect(
 #endif /* HAVE_VMOP_MPROTECT */
 
 
-struct file_operations linvfs_file_operations = {
+const struct file_operations linvfs_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= linvfs_read,
 	.write		= linvfs_write,
@@ -420,7 +425,7 @@ struct file_operations linvfs_file_opera
 	.fsync		= linvfs_fsync,
 };
 
-struct file_operations linvfs_invis_file_operations = {
+const struct file_operations linvfs_invis_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= linvfs_read_invis,
 	.write		= linvfs_write_invis,
@@ -432,14 +437,14 @@ struct file_operations linvfs_invis_file
 };
 
 
-struct file_operations linvfs_dir_operations = {
+const struct file_operations linvfs_dir_operations = {
 	.read		= generic_read_dir,
 	.readdir	= linvfs_readdir,
 	.ioctl		= linvfs_ioctl,
 	.fsync		= linvfs_fsync,
 };
 
-static struct vm_operations_struct linvfs_file_vm_ops = {
+static const struct vm_operations_struct linvfs_file_vm_ops = {
 	.nopage		= filemap_nopage,
 #ifdef HAVE_VMOP_MPROTECT
 	.mprotect	= linvfs_mprotect,
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.c linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.c
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.c	2009-11-10 19:30:27.000000000 -0500
@@ -647,7 +647,7 @@ linvfs_removexattr(
 }
 
 
-struct inode_operations linvfs_file_inode_operations = {
+const struct inode_operations linvfs_file_inode_operations = {
 	.permission		= linvfs_permission,
 	.truncate		= linvfs_truncate,
 	.revalidate		= linvfs_revalidate,
@@ -658,7 +658,7 @@ struct inode_operations linvfs_file_inod
 	.removexattr		= linvfs_removexattr,
 };
 
-struct inode_operations linvfs_dir_inode_operations = {
+const struct inode_operations linvfs_dir_inode_operations = {
 	.create			= linvfs_create,
 	.lookup			= linvfs_lookup,
 	.link			= linvfs_link,
@@ -677,7 +677,7 @@ struct inode_operations linvfs_dir_inode
 	.removexattr		= linvfs_removexattr,
 };
 
-struct inode_operations linvfs_symlink_inode_operations = {
+const struct inode_operations linvfs_symlink_inode_operations = {
 	.readlink		= linvfs_readlink,
 	.follow_link		= linvfs_follow_link,
 	.permission		= linvfs_permission,
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.h linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.h
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_iops.h	2009-11-10 19:30:27.000000000 -0500
@@ -32,15 +32,15 @@
 #ifndef __XFS_IOPS_H__
 #define __XFS_IOPS_H__
 
-extern struct inode_operations linvfs_file_inode_operations;
-extern struct inode_operations linvfs_dir_inode_operations;
-extern struct inode_operations linvfs_symlink_inode_operations;
-
-extern struct file_operations linvfs_file_operations;
-extern struct file_operations linvfs_invis_file_operations;
-extern struct file_operations linvfs_dir_operations;
+extern const struct inode_operations linvfs_file_inode_operations;
+extern const struct inode_operations linvfs_dir_inode_operations;
+extern const struct inode_operations linvfs_symlink_inode_operations;
+
+extern const struct file_operations linvfs_file_operations;
+extern const struct file_operations linvfs_invis_file_operations;
+extern const struct file_operations linvfs_dir_operations;
 
-extern struct address_space_operations linvfs_aops;
+extern const struct address_space_operations linvfs_aops;
 
 extern int linvfs_get_block(struct inode *, long, struct buffer_head *, int);
 extern void linvfs_unwritten_done(struct buffer_head *, int);
diff -urNp linux-2.4.37.7/fs/xfs/linux-2.4/xfs_super.c linux-2.4.37.7/fs/xfs/linux-2.4/xfs_super.c
--- linux-2.4.37.7/fs/xfs/linux-2.4/xfs_super.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/fs/xfs/linux-2.4/xfs_super.c	2009-11-10 19:30:27.000000000 -0500
@@ -70,7 +70,7 @@
 #include <linux/init.h>
 
 STATIC struct quotactl_ops linvfs_qops;
-STATIC struct super_operations linvfs_sops;
+STATIC const struct super_operations linvfs_sops;
 STATIC kmem_zone_t *linvfs_inode_zone;
 STATIC kmem_shaker_t xfs_inode_shaker;
 
@@ -958,7 +958,7 @@ fail_vfsop:
 }
 
 
-STATIC struct super_operations linvfs_sops = {
+STATIC const struct super_operations linvfs_sops = {
 	.alloc_inode		= linvfs_alloc_inode,
 	.destroy_inode		= linvfs_destroy_inode,
 	.write_inode		= linvfs_write_inode,
diff -urNp linux-2.4.37.7/grsecurity/Config.in linux-2.4.37.7/grsecurity/Config.in
--- linux-2.4.37.7/grsecurity/Config.in	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/Config.in	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,443 @@
+define_bool CONFIG_CRYPTO y
+define_bool CONFIG_CRYPTO_SHA256 y
+choice 'Security level' \
+        "Low		CONFIG_GRKERNSEC_LOW \
+         Medium		CONFIG_GRKERNSEC_MID \
+         High		CONFIG_GRKERNSEC_HI \
+	  Customized	CONFIG_GRKERNSEC_CUSTOM" Customized
+if [ "$CONFIG_GRKERNSEC_LOW" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_FORKFAIL n
+define_bool CONFIG_GRKERNSEC_TIME n
+define_bool CONFIG_GRKERNSEC_SIGNAL n
+define_bool CONFIG_GRKERNSEC_CHROOT_SHMAT n
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR n
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE n
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT n
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD n
+define_bool CONFIG_GRKERNSEC_PROC n
+define_bool CONFIG_GRKERNSEC_PROC_IPADDR n
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP n
+define_bool CONFIG_GRKERNSEC_HIDESYM n
+define_bool CONFIG_GRKERNSEC_BRUTE n
+define_bool CONFIG_GRKERNSEC_SHM n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+define_bool CONFIG_GRKERNSEC_CHROOT_SYSCTL n
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP n
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK n
+define_bool CONFIG_PAX_RANDUSTACK n
+define_bool CONFIG_PAX_ASLR n
+define_bool CONFIG_PAX_RANDMMAP n
+define_bool CONFIG_PAX_NOEXEC n
+define_bool CONFIG_PAX_PAGEEXEC n
+define_bool CONFIG_PAX_NOELFRELOCS n
+define_bool CONFIG_PAX_ETEXECRELOCS n
+define_bool CONFIG_PAX_MPROTECT n
+define_bool CONFIG_PAX_SOFTMODE n
+define_bool CONFIG_PAX_EI_PAX n
+define_bool CONFIG_PAX_PT_PAX_FLAGS n
+define_bool CONFIG_PAX_NO_ACL_FLAGS n
+define_bool CONFIG_PAX_EMUTRAMP n
+define_bool CONFIG_PAX_EMUSIGRT n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_PAX_RANDKSTACK n
+define_bool CONFIG_PAX_KERNEXEC n
+define_bool CONFIG_GRKERNSEC_IO n
+define_bool CONFIG_PAX_SEGMEXEC n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_ACL_HIDEKERN n
+define_bool CONFIG_GRKERNSEC_RESLOG n
+define_int CONFIG_GRKERNSEC_ACL_MAXTRIES 3
+define_int CONFIG_GRKERNSEC_ACL_TIMEOUT 30
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 10
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_RANDNET y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_KHEAP y
+if [ "$CONFIG_MODULES" != "n" ]; then
+define_bool CONFIG_GRKERNSEC_MODSTOP y
+fi
+fi
+if [ "$CONFIG_GRKERNSEC_MID" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_PROC_IPADDR n
+define_bool CONFIG_GRKERNSEC_HIDESYM n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK n
+define_bool CONFIG_PAX_NOEXEC n
+define_bool CONFIG_PAX_PAGEEXEC n
+define_bool CONFIG_PAX_NOELFRELOCS n
+define_bool CONFIG_PAX_ETEXECRELOCS n
+define_bool CONFIG_PAX_MPROTECT n
+define_bool CONFIG_PAX_SOFTMODE n
+define_bool CONFIG_PAX_EI_PAX y
+define_bool CONFIG_PAX_PT_PAX_FLAGS y
+define_bool CONFIG_PAX_HAVE_ACL_FLAGS y
+define_bool CONFIG_PAX_EMUTRAMP n
+define_bool CONFIG_PAX_EMUSIGRT n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_IO n
+define_bool CONFIG_PAX_SEGMEXEC n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR n
+define_bool CONFIG_GRKERNSEC_ACL_HIDEKERN n
+define_bool CONFIG_GRKERNSEC_RESLOG n
+define_int CONFIG_GRKERNSEC_ACL_MAXTRIES 3
+define_int CONFIG_GRKERNSEC_ACL_TIMEOUT 30
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 10
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_KHEAP y
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP y
+define_bool CONFIG_GRKERNSEC_CHROOT_SYSCTL y
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDNET y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_SHMAT n
+define_bool CONFIG_GRKERNSEC_CHROOT_UNIX y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+define_bool CONFIG_PAX_RANDUSTACK y
+define_bool CONFIG_PAX_RANDKSTACK n
+define_bool CONFIG_PAX_KERNEXEC n
+define_bool CONFIG_PAX_ASLR y
+define_bool CONFIG_PAX_RANDMMAP y
+define_bool CONFIG_GRKERNSEC_BRUTE n
+define_bool CONFIG_GRKERNSEC_SHM n
+if [ "$CONFIG_MODULES" != "n" ]; then
+define_bool CONFIG_GRKERNSEC_MODSTOP y
+fi
+fi
+if [ "$CONFIG_GRKERNSEC_HI" = "y" ]; then
+define_int CONFIG_GRKERNSEC_FLOODTIME 10
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+if [ "$CONFIG_MODULES" != "n" ]; then
+define_bool CONFIG_GRKERNSEC_MODSTOP y
+fi
+define_bool CONFIG_GRKERNSEC_KHEAP y
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SHM y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT_SHMAT y
+define_bool CONFIG_GRKERNSEC_CHROOT_UNIX y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS y
+define_bool CONFIG_GRKERNSEC_CHROOT_SYSCTL y
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_IPADDR n
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP y
+define_bool CONFIG_GRKERNSEC_HIDESYM y
+define_bool CONFIG_GRKERNSEC_BRUTE y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+define_bool CONFIG_GRKERNSEC_KMEM y
+define_bool CONFIG_GRKERNSEC_RESLOG y
+define_bool CONFIG_GRKERNSEC_RANDNET y
+
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_ACL_HIDEKERN n
+define_int CONFIG_GRKERNSEC_ACL_MAXTRIES 3
+define_int CONFIG_GRKERNSEC_ACL_TIMEOUT 30
+
+define_bool CONFIG_GRKERNSEC_PROC_ADD y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE y
+define_bool CONFIG_PAX_RANDUSTACK y
+define_bool CONFIG_PAX_ASLR y
+define_bool CONFIG_PAX_RANDMMAP y
+define_bool CONFIG_PAX_NOEXEC y
+define_bool CONFIG_PAX_NOELFRELOCS n
+define_bool CONFIG_PAX_MPROTECT y
+define_bool CONFIG_PAX_ETEXECRELOCS n
+define_bool CONFIG_PAX_SOFTMODE n
+define_bool CONFIG_PAX_EI_PAX y
+define_bool CONFIG_PAX_PT_PAX_FLAGS y
+define_bool CONFIG_PAX_HAVE_ACL_FLAGS y
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_IO n
+if [ "$CONFIG_MODULES" != "y" -a "$CONFIG_X86_WP_WORKS_OK" = "y" ]; then
+define_bool CONFIG_PAX_KERNEXEC y
+fi
+if [ "$CONFIG_X86_TSC" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+define_bool CONFIG_PAX_RANDKSTACK y
+else
+define_bool CONFIG_PAX_RANDKSTACK n
+fi
+if [ "$CONFIG_X86_64" = "y"]; then
+define_bool CONFIG_PAX_PAGEEXEC y
+define_bool CONFIG_PAX_SEGMEXEC n
+else
+define_bool CONFIG_PAX_SEGMEXEC y
+define_bool CONFIG_PAX_PAGEEXEC n
+fi
+define_bool CONFIG_PAX_EMUTRAMP n
+define_bool CONFIG_PAX_EMUSIGRT n
+else
+define_bool CONFIG_PAX_PAGEEXEC y
+define_bool CONFIG_PAX_SEGMEXEC n
+fi
+if [ "$CONFIG_ALPHA" = "y" -o "$CONFIG_PARISC" = "y" ]; then
+define_bool CONFIG_PAX_ETEXECRELOCS y
+fi
+if [ "$CONFIG_ALPHA" = "y" -o "$CONFIG_PARISC" = "y" -o "$CONFIG_SPARC32" = "y" -o "$CONFIG_SPARC64" = "y" -o "$CONFIG_PPC32" = "y" ]; then
+define_bool CONFIG_PAX_EMUPLT y
+fi
+if [ "$CONFIG_PARISC" = "y" ]; then
+define_bool CONFIG_PAX_EMUTRAMP y
+define_bool CONFIG_PAX_EMUSIGRT y
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT y
+fi
+if [ "$CONFIG_GRKERNSEC_CUSTOM" = "y" ]; then
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" direct
+endmenu
+mainmenu_option next_comment
+comment 'Address Space Protection'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce Non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+	if [ "$CONFIG_X86" != "y" -o \
+	     "$CONFIG_M586" = "y" -o \
+	     "$CONFIG_M586TSC" = "y" -o \
+	     "$CONFIG_M586MMX" = "y" -o \
+	     "$CONFIG_M686" = "y" -o \
+	     "$CONFIG_MPENTIUMIII" = "y" -o \
+	     "$CONFIG_MPENTIUM4" = "y" -o \
+	     "$CONFIG_MK7" = "y" -o \
+	     "$CONFIG_MK8" = "y" -o \
+	     "$CONFIG_MWINCHIPC6" = "y" -o \
+	     "$CONFIG_MWINCHIP2" = "y" -o \
+	     "$CONFIG_MWINCHIP3D" = "y" -o \
+	     "$CONFIG_MVIAC3_2" = "y" ]; then
+	   bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+	fi
+     if [ "$CONFIG_X86" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+       bool 'Segmentation based non-executable pages' CONFIG_PAX_SEGMEXEC
+     fi
+     if [ "$CONFIG_X86" = "y" -o "$CONFIG_PARISC" = "y" -o "$CONFIG_PPC32" = "y" ]; then
+       if [ "$CONFIG_PAX_PAGEEXEC" = "y" -o "$CONFIG_PAX_SEGMEXEC" = "y" ]; then
+         bool '   Emulate trampolines' CONFIG_PAX_EMUTRAMP
+         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+           bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+         fi
+       fi
+     fi
+     bool '   Restrict mprotect()' CONFIG_PAX_MPROTECT
+     if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+       if [ "$CONFIG_X86" = "y" ]; then
+         bool '    Disallow ELF text relocations (DANGEROUS)' CONFIG_PAX_NOELFRELOCS
+       else
+       if [ "$CONFIG_ALPHA" = "y" -o "$CONFIG_PARISC" = "y" ]; then
+         bool '    Allow ELF ET_EXEC text relocations' CONFIG_PAX_ETEXECRELOCS
+       fi
+       if [ "$CONFIG_PPC32" = "y" ]; then
+         define_bool CONFIG_PAX_SYSCALL y
+       fi
+       if [ "$CONFIG_ALPHA" = "y" -o "$CONFIG_PARISC" = "y" -o "$CONFIG_SPARC32" = "y" -o "$CONFIG_SPARC64" = "y" -o "$CONFIG_PPC32" = "y" ]; then
+         bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+        if [ "$CONFIG_PAX_EMUPLT" = "y" ]; then
+           if [ "$CONFIG_SPARC32" = "y" -o "$CONFIG_SPARC64" = "y" ]; then
+       	     define_bool CONFIG_PAX_DLRESOLVE y
+           fi
+        fi
+       fi
+       fi
+     fi
+   fi
+   if [ "$CONFIG_X86" = "y" -a \
+     "$CONFIG_MODULES" != "y" -a "$CONFIG_X86_WP_WORKS_OK" = "y" ]; then
+     bool 'Enforce non-executable kernel pages' CONFIG_PAX_KERNEXEC
+   fi
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+     if [ "$CONFIG_X86_TSC" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+       bool '  Randomize kernel stack base' CONFIG_PAX_RANDKSTACK
+     fi
+     bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+     bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+if [ "$CONFIG_X86" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+   bool 'Prevent invalid userland pointer dereference' CONFIG_PAX_MEMORY_UDEREF
+fi
+bool 'Harden kernel heap management' CONFIG_GRKERNSEC_KHEAP
+bool 'Deny writing to /dev/kmem, /dev/mem, and /dev/port' CONFIG_GRKERNSEC_KMEM
+if [ "$CONFIG_X86" = "y" ]; then
+  bool 'Disable privileged I/O' CONFIG_GRKERNSEC_IO
+  if [ "$CONFIG_GRKERNSEC_IO" = "y" ]; then
+    define_bool CONFIG_RTC y
+  fi
+fi
+if [ "$CONFIG_PAX_NOEXEC" = "y" -o "$CONFIG_PAX_ASLR" = "y" ]; then
+bool 'Remove addresses from /proc/pid/[maps|stat]' CONFIG_GRKERNSEC_PROC_MEMMAP
+fi
+bool 'Deter exploit bruteforcing' CONFIG_GRKERNSEC_BRUTE
+if [ "$CONFIG_MODULES" != "n" ]; then
+ bool 'Runtime module disabling' CONFIG_GRKERNSEC_MODSTOP
+fi
+bool 'Hide kernel symbols' CONFIG_GRKERNSEC_HIDESYM
+endmenu
+mainmenu_option next_comment
+comment 'Role Based Access Control Options'
+bool 'Disable RBAC system' CONFIG_GRKERNSEC_NO_RBAC
+bool 'Hide kernel processes' CONFIG_GRKERNSEC_ACL_HIDEKERN
+int 'Maximum tries before password lockout' CONFIG_GRKERNSEC_ACL_MAXTRIES 3
+int 'Time to wait after max password tries, in seconds' CONFIG_GRKERNSEC_ACL_TIMEOUT 30
+endmenu
+mainmenu_option next_comment
+comment 'Filesystem Protections'
+bool 'Proc restrictions' CONFIG_GRKERNSEC_PROC
+if [ "$CONFIG_GRKERNSEC_PROC" != "n" ]; then
+ bool '   Restrict to user only' CONFIG_GRKERNSEC_PROC_USER
+ if [ "$CONFIG_GRKERNSEC_PROC_USER" != "y" ]; then
+  bool '   Allow special group' CONFIG_GRKERNSEC_PROC_USERGROUP
+  if [ "$CONFIG_GRKERNSEC_PROC_USERGROUP" != "n" ]; then
+   int  '   GID for special group' CONFIG_GRKERNSEC_PROC_GID 1001
+  fi
+ fi
+ if [ "$CONFIG_GRKERNSEC_PROC_USER" != "n" -o "$CONFIG_GRKERNSEC_PROC_USERGROUP" != "n" ]; then
+  bool '   Additional restrictions' CONFIG_GRKERNSEC_PROC_ADD
+ fi
+fi
+bool 'Linking restrictions' CONFIG_GRKERNSEC_LINK
+bool 'FIFO restrictions' CONFIG_GRKERNSEC_FIFO
+bool 'Chroot jail restrictions' CONFIG_GRKERNSEC_CHROOT
+if [ "$CONFIG_GRKERNSEC_CHROOT" != "n" ]; then
+bool '   Deny mounts' CONFIG_GRKERNSEC_CHROOT_MOUNT
+bool '   Deny double-chroots' CONFIG_GRKERNSEC_CHROOT_DOUBLE
+bool '   Deny pivot_root in chroot' CONFIG_GRKERNSEC_CHROOT_PIVOT
+bool '   Enforce chdir("/") on all chroots' CONFIG_GRKERNSEC_CHROOT_CHDIR
+bool '   Deny (f)chmod +s' CONFIG_GRKERNSEC_CHROOT_CHMOD
+bool '   Deny fchdir out of chroot' CONFIG_GRKERNSEC_CHROOT_FCHDIR
+bool '   Deny mknod' CONFIG_GRKERNSEC_CHROOT_MKNOD
+bool '   Deny shmat() out of chroot' CONFIG_GRKERNSEC_CHROOT_SHMAT
+bool '   Deny access to abstract AF_UNIX sockets out of chroot' CONFIG_GRKERNSEC_CHROOT_UNIX
+bool '   Protect outside processes' CONFIG_GRKERNSEC_CHROOT_FINDTASK
+bool '   Restrict priority changes' CONFIG_GRKERNSEC_CHROOT_NICE
+bool '   Deny sysctl writes in chroot' CONFIG_GRKERNSEC_CHROOT_SYSCTL
+bool '   Capability restrictions within chroot' CONFIG_GRKERNSEC_CHROOT_CAPS
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Kernel Auditing'
+bool 'Single group for auditing' CONFIG_GRKERNSEC_AUDIT_GROUP
+if [ "$CONFIG_GRKERNSEC_AUDIT_GROUP" != "n" ]; then
+int  '   GID for auditing' CONFIG_GRKERNSEC_AUDIT_GID 1007
+fi
+bool 'Exec logging' CONFIG_GRKERNSEC_EXECLOG
+bool 'Resource logging' CONFIG_GRKERNSEC_RESLOG
+bool 'Log execs within chroot' CONFIG_GRKERNSEC_CHROOT_EXECLOG
+bool 'Chdir logging' CONFIG_GRKERNSEC_AUDIT_CHDIR
+bool '(Un)Mount logging' CONFIG_GRKERNSEC_AUDIT_MOUNT
+bool 'IPC logging' CONFIG_GRKERNSEC_AUDIT_IPC
+bool 'Signal logging' CONFIG_GRKERNSEC_SIGNAL
+bool 'Fork failure logging' CONFIG_GRKERNSEC_FORKFAIL
+bool 'Time change logging' CONFIG_GRKERNSEC_TIME
+bool '/proc/<pid>/ipaddr support' CONFIG_GRKERNSEC_PROC_IPADDR
+if [ "$CONFIG_PAX_MPROTECT" != "n" ]; then
+  bool 'ELF text relocations logging (READ HELP)' CONFIG_GRKERNSEC_AUDIT_TEXTREL
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Executable Protections'
+bool 'Enforce RLIMIT_NPROC on execs' CONFIG_GRKERNSEC_EXECVE
+if [ "$CONFIG_SYSVIPC" = "y" ]; then
+  bool 'Destroy unused shared memory' CONFIG_GRKERNSEC_SHM
+fi
+bool 'Dmesg(8) restriction' CONFIG_GRKERNSEC_DMESG
+bool 'Trusted path execution' CONFIG_GRKERNSEC_TPE
+if [ "$CONFIG_GRKERNSEC_TPE" != "n" ]; then
+  bool '   Partially restrict non-root users' CONFIG_GRKERNSEC_TPE_ALL
+  bool '   Invert GID option' CONFIG_GRKERNSEC_TPE_INVERT
+  if [ "$CONFIG_GRKERNSEC_TPE_INVERT" != "n" ]; then
+    int  '   GID for trusted users:' CONFIG_GRKERNSEC_TPE_GID 1005
+  else
+    int  '   GID for untrusted users:' CONFIG_GRKERNSEC_TPE_GID 1005
+  fi
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Network Protections'
+bool 'Larger entropy pools' CONFIG_GRKERNSEC_RANDNET
+bool 'TCP/UDP blackhole' CONFIG_GRKERNSEC_BLACKHOLE
+bool 'Socket restrictions' CONFIG_GRKERNSEC_SOCKET
+if [ "$CONFIG_GRKERNSEC_SOCKET" != "n" ]; then
+bool '  Deny any sockets to group' CONFIG_GRKERNSEC_SOCKET_ALL
+if [ "$CONFIG_GRKERNSEC_SOCKET_ALL" != "n" ]; then
+int  '   GID to deny all sockets for:' CONFIG_GRKERNSEC_SOCKET_ALL_GID 1004
+fi
+bool '  Deny client sockets to group' CONFIG_GRKERNSEC_SOCKET_CLIENT
+if [ "$CONFIG_GRKERNSEC_SOCKET_CLIENT" != "n" ]; then
+int  '   GID to deny client sockets for:' CONFIG_GRKERNSEC_SOCKET_CLIENT_GID 1003
+fi
+bool '  Deny server sockets to group' CONFIG_GRKERNSEC_SOCKET_SERVER
+if [ "$CONFIG_GRKERNSEC_SOCKET_SERVER" != "n" ]; then
+int  '   GID to deny server sockets for:' CONFIG_GRKERNSEC_SOCKET_SERVER_GID 1002
+fi
+fi
+endmenu
+if [ "$CONFIG_SYSCTL" != "n" ]; then
+mainmenu_option next_comment
+comment 'Sysctl support'
+bool 'Sysctl support' CONFIG_GRKERNSEC_SYSCTL
+if [ "$CONFIG_GRKERNSEC_SYSCTL" != "n" ]; then
+  bool '  Turn on features by default' CONFIG_GRKERNSEC_SYSCTL_ON
+fi
+endmenu
+fi
+mainmenu_option next_comment
+comment 'Logging options'
+int 'Seconds in between log messages (minimum)' CONFIG_GRKERNSEC_FLOODTIME 10
+int 'Number of messages in a burst (maximum)' CONFIG_GRKERNSEC_FLOODBURST 4
+endmenu
+fi
diff -urNp linux-2.4.37.7/grsecurity/gracl_alloc.c linux-2.4.37.7/grsecurity/gracl_alloc.c
--- linux-2.4.37.7/grsecurity/gracl_alloc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_alloc.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,105 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+
+static unsigned long alloc_stack_next = 1;
+static unsigned long alloc_stack_size = 1;
+static void **alloc_stack;
+
+static __inline__ int
+alloc_pop(void)
+{
+	if (alloc_stack_next == 1)
+		return 0;
+
+	kfree(alloc_stack[alloc_stack_next - 2]);
+
+	alloc_stack_next--;
+
+	return 1;
+}
+
+static __inline__ int
+alloc_push(void *buf)
+{
+	if (alloc_stack_next >= alloc_stack_size)
+		return 1;
+
+	alloc_stack[alloc_stack_next - 1] = buf;
+
+	alloc_stack_next++;
+
+	return 0;
+}
+
+void *
+acl_alloc(unsigned long len)
+{
+	void *ret = NULL;
+
+	if (!len || len > PAGE_SIZE)
+		goto out;
+
+	ret = kmalloc(len, GFP_KERNEL);
+
+	if (ret) {
+		if (alloc_push(ret)) {
+			kfree(ret);
+			ret = NULL;
+		}
+	}
+
+out:
+	return ret;
+}
+
+void *
+acl_alloc_num(unsigned long num, unsigned long len)
+{
+	if (!len || (num > (PAGE_SIZE / len)))
+		return NULL;
+
+	return acl_alloc(num * len);
+}
+
+void
+acl_free_all(void)
+{
+	if (gr_acl_is_enabled() || !alloc_stack)
+		return;
+
+	while (alloc_pop()) ;
+
+	if (alloc_stack) {
+		if ((alloc_stack_size * sizeof (void *)) <= PAGE_SIZE)
+			kfree(alloc_stack);
+		else
+			vfree(alloc_stack);
+	}
+
+	alloc_stack = NULL;
+	alloc_stack_size = 1;
+	alloc_stack_next = 1;
+
+	return;
+}
+
+int
+acl_alloc_stack_init(unsigned long size)
+{
+	if ((size * sizeof (void *)) <= PAGE_SIZE)
+		alloc_stack =
+		    (void **) kmalloc(size * sizeof (void *), GFP_KERNEL);
+	else
+		alloc_stack = (void **) vmalloc(size * sizeof (void *));
+
+	alloc_stack_size = size;
+
+	if (!alloc_stack)
+		return 0;
+	else
+		return 1;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl.c linux-2.4.37.7/grsecurity/gracl.c
--- linux-2.4.37.7/grsecurity/gracl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,3653 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/sysctl.h>
+#include <linux/netdevice.h>
+#include <linux/gracl.h>
+#include <linux/gralloc.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+
+static struct acl_role_db acl_role_set;
+static struct name_db name_set;
+static struct inodev_db inodev_set;
+
+/* for keeping track of userspace pointers used for subjects, so we
+   can share references in the kernel as well
+*/
+
+static struct dentry *real_root;
+static struct vfsmount *real_root_mnt;
+
+static struct acl_subj_map_db subj_map_set;
+
+static struct acl_role_label *default_role;
+
+static u16 acl_sp_role_value;
+
+static DECLARE_MUTEX(gr_dev_sem);
+rwlock_t gr_inode_lock = RW_LOCK_UNLOCKED;
+
+extern char *gr_shared_page[4][NR_CPUS];
+struct gr_arg *gr_usermode;
+
+static unsigned int gr_status = GR_STATUS_INIT;
+
+extern int chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum);
+extern void gr_clear_learn_entries(void);
+
+#ifdef CONFIG_GRKERNSEC_RESLOG
+extern void gr_log_resource(const struct task_struct *task,
+			    const int res, const unsigned long wanted, const int gt);
+#endif
+
+unsigned char *gr_system_salt;
+unsigned char *gr_system_sum;
+
+static struct sprole_pw **acl_special_roles = NULL;
+static __u16 num_sprole_pws = 0;
+
+static struct acl_role_label *kernel_role = NULL;
+
+static unsigned int gr_auth_attempts = 0;
+static unsigned long gr_auth_expires = 0UL;
+
+extern struct vfsmount *sock_mnt;
+extern struct vfsmount *pipe_mnt;
+extern struct vfsmount *shm_mnt;
+static struct acl_object_label *fakefs_obj;
+
+extern int gr_init_uidset(void);
+extern void gr_free_uidset(void);
+extern void gr_remove_uid(uid_t uid);
+extern int gr_find_uid(uid_t uid);
+
+__inline__ int
+gr_acl_is_enabled(void)
+{
+	return (gr_status & GR_READY);
+}
+
+char gr_roletype_to_char(void)
+{
+	switch (current->role->roletype &
+		(GR_ROLE_DEFAULT | GR_ROLE_USER | GR_ROLE_GROUP |
+		 GR_ROLE_SPECIAL)) {
+	case GR_ROLE_DEFAULT:
+		return 'D';
+	case GR_ROLE_USER:
+		return 'U';
+	case GR_ROLE_GROUP:
+		return 'G';
+	case GR_ROLE_SPECIAL:
+		return 'S';
+	}
+
+	return 'X';
+}
+
+__inline__ int
+gr_acl_tpe_check(void)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+	if (current->role->roletype & GR_ROLE_TPE)
+		return 1;
+	else
+		return 0;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (inode && S_ISBLK(inode->i_mode) &&
+	    grsec_enable_chroot_caps && proc_is_chrooted(current) &&
+	    !capable(CAP_SYS_RAWIO))
+		return 1;
+#endif
+	return 0;
+}
+
+
+static int
+gr_streq(const char *a, const char *b, const unsigned int lena, const unsigned int lenb)
+{
+	int i;
+	unsigned long *l1;
+	unsigned long *l2;
+	unsigned char *c1;
+	unsigned char *c2;
+	int num_longs;
+
+	if (likely(lena != lenb))
+		return 0;
+
+	l1 = (unsigned long *)a;
+	l2 = (unsigned long *)b;
+
+	num_longs = lena / sizeof(unsigned long);
+
+	for (i = num_longs; i--; l1++, l2++) {
+		if (unlikely(*l1 != *l2))
+			return 0;
+	}
+
+	c1 = (unsigned char *) l1;
+	c2 = (unsigned char *) l2;
+
+	i = lena - (num_longs * sizeof(unsigned long));	
+
+	for (; i--; c1++, c2++) {
+		if (unlikely(*c1 != *c2))
+			return 0;
+	}
+
+	return 1;
+}
+
+static char *__our_d_path(struct dentry *dentry, struct vfsmount *vfsmnt,
+			  struct dentry *root, struct vfsmount *rootmnt,
+			  char *buffer, int buflen)
+{
+	char * end = buffer+buflen;
+	char * retval;
+	int namelen;
+
+	*--end = '\0';
+	buflen--;
+	
+	/* Get '/' right */
+	retval = end-1;
+	*retval = '/';
+
+	for (;;) {
+		struct dentry * parent;
+
+		if (dentry == root && vfsmnt == rootmnt)
+			break;
+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			/* Global root? */
+			if (vfsmnt->mnt_parent == vfsmnt)
+				goto global_root;
+			dentry = vfsmnt->mnt_mountpoint;
+			vfsmnt = vfsmnt->mnt_parent;
+			continue;
+		}
+		parent = dentry->d_parent;
+		namelen = dentry->d_name.len;
+		buflen -= namelen + 1;
+		if (buflen < 0)
+			return ERR_PTR(-ENAMETOOLONG);
+		end -= namelen;
+		memcpy(end, dentry->d_name.name, namelen);
+		*--end = '/';
+		retval = end;
+		dentry = parent;
+	}
+
+	return retval;
+
+global_root:
+	namelen = dentry->d_name.len;
+	buflen -= namelen;
+	if (buflen >= 0) {
+		retval -= namelen-1;	/* hit the slash */
+		memcpy(retval, dentry->d_name.name, namelen);
+	} else
+		retval = ERR_PTR(-ENAMETOOLONG);
+	return retval;
+}
+
+static char *
+gen_full_path(struct dentry *dentry, struct vfsmount *vfsmnt,
+	      struct dentry *root, struct vfsmount *rootmnt, char *buf, int buflen)
+{
+	char *retval;
+
+	retval = __our_d_path(dentry, vfsmnt, root, rootmnt, buf, buflen);
+	if (unlikely(IS_ERR(retval)))
+		retval = strcpy(buf, "<path too long>");
+	else if (unlikely(retval[1] == '/' && retval[2] == '\0'))
+		retval[1] = '\0';
+
+	return retval;
+}
+
+static char *
+d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+	    char *buf, int buflen)
+{
+	char *res;
+	struct dentry *root;
+	struct vfsmount *rootmnt;
+
+	/* we can't use real_root, real_root_mnt, because they belong only to the RBAC system */
+	read_lock(&child_reaper->fs->lock);
+	root = dget(child_reaper->fs->root);
+	rootmnt = mntget(child_reaper->fs->rootmnt);
+	read_unlock(&child_reaper->fs->lock);
+
+	spin_lock(&dcache_lock);
+	res = gen_full_path((struct dentry *)dentry, (struct vfsmount *)vfsmnt, root, rootmnt, buf, buflen);
+	spin_unlock(&dcache_lock);
+	dput(root);
+	mntput(rootmnt);
+	return res;
+}
+
+static __inline__ char *
+__d_real_path(const struct dentry *dentry, const struct vfsmount *vfsmnt,
+	    char *buf, int buflen)
+{
+	char *res;
+
+	/* we can use real_root, real_root_mnt, because this is only called
+	   by the RBAC system */
+	res = gen_full_path((struct dentry *)dentry, (struct vfsmount *)vfsmnt, real_root, real_root_mnt, buf, buflen);
+
+	return res;
+}
+
+static char *
+gr_to_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	char *ret;
+
+	spin_lock(&dcache_lock);
+	ret = __d_real_path(dentry, mnt, gr_shared_page[0][smp_processor_id()],
+			     PAGE_SIZE);
+	spin_unlock(&dcache_lock);
+	return ret;
+}
+
+char *
+gr_to_filename_nolock(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return __d_real_path(dentry, mnt, gr_shared_page[0][smp_processor_id()],
+			     PAGE_SIZE);
+}
+
+char *
+gr_to_filename(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, gr_shared_page[0][smp_processor_id()],
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename1(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, gr_shared_page[1][smp_processor_id()],
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename2(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, gr_shared_page[2][smp_processor_id()],
+			   PAGE_SIZE);
+}
+
+char *
+gr_to_filename3(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return d_real_path(dentry, mnt, gr_shared_page[3][smp_processor_id()],
+			   PAGE_SIZE);
+}
+
+__inline__ __u32
+to_gr_audit(const __u32 reqmode)
+{
+	/* masks off auditable permission flags, then shifts them to create
+	   auditing flags, and adds the special case of append auditing if
+	   we're requesting write */
+	return (((reqmode & ~GR_AUDITS) << 10) | ((reqmode & GR_WRITE) ? GR_AUDIT_APPEND : 0));
+}
+
+struct acl_subject_label *
+lookup_subject_map(const struct acl_subject_label *userp)
+{
+	unsigned int index = shash(userp, subj_map_set.s_size);
+	struct subject_map *match;
+
+	match = subj_map_set.s_hash[index];
+
+	while (match && match->user != userp)
+		match = match->next;
+
+	if (match != NULL)
+		return match->kernel;
+	else
+		return NULL;
+}
+
+static void
+insert_subj_map_entry(struct subject_map *subjmap)
+{
+	unsigned int index = shash(subjmap->user, subj_map_set.s_size);
+	struct subject_map **curr;
+
+	subjmap->prev = NULL;
+
+	curr = &subj_map_set.s_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = subjmap;
+
+	subjmap->next = *curr;
+	*curr = subjmap;
+
+	return;
+}
+
+static struct acl_role_label *
+lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
+		      const gid_t gid)
+{
+	unsigned int index = rhash(uid, GR_ROLE_USER, acl_role_set.r_size);
+	struct acl_role_label *match;
+	struct role_allowed_ip *ipp;
+	unsigned int x;
+
+	match = acl_role_set.r_hash[index];
+
+	while (match) {
+		if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_USER)) == (GR_ROLE_DOMAIN | GR_ROLE_USER)) {
+			for (x = 0; x < match->domain_child_num; x++) {
+				if (match->domain_children[x] == uid)
+					goto found;
+			}
+		} else if (match->uidgid == uid && match->roletype & GR_ROLE_USER)
+			break;
+		match = match->next;
+	}
+found:
+	if (match == NULL) {
+	      try_group:
+		index = rhash(gid, GR_ROLE_GROUP, acl_role_set.r_size);
+		match = acl_role_set.r_hash[index];
+
+		while (match) {
+			if ((match->roletype & (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) == (GR_ROLE_DOMAIN | GR_ROLE_GROUP)) {
+				for (x = 0; x < match->domain_child_num; x++) {
+					if (match->domain_children[x] == gid)
+						goto found2;
+				}
+			} else if (match->uidgid == gid && match->roletype & GR_ROLE_GROUP)
+				break;
+			match = match->next;
+		}
+found2:
+		if (match == NULL)
+			match = default_role;
+		if (match->allowed_ips == NULL)
+			return match;
+		else {
+			for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+				if (likely
+				    ((ntohl(task->curr_ip) & ipp->netmask) ==
+				     (ntohl(ipp->addr) & ipp->netmask)))
+					return match;
+			}
+			match = default_role;
+		}
+	} else if (match->allowed_ips == NULL) {
+		return match;
+	} else {
+		for (ipp = match->allowed_ips; ipp; ipp = ipp->next) {
+			if (likely
+			    ((ntohl(task->curr_ip) & ipp->netmask) ==
+			     (ntohl(ipp->addr) & ipp->netmask)))
+				return match;
+		}
+		goto try_group;
+	}
+
+	return match;
+}
+
+struct acl_subject_label *
+lookup_acl_subj_label(const ino_t ino, const __u32 dev,
+		      const struct acl_role_label *role)
+{
+	unsigned int index = fhash(ino, dev, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+struct acl_subject_label *
+lookup_acl_subj_label_deleted(const ino_t ino, const __u32 dev,
+			      const struct acl_role_label *role)
+{
+	unsigned int index = fhash(ino, dev, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       !(match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && (match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label(const ino_t ino, const __u32 dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct acl_object_label *
+lookup_acl_obj_label_create(const ino_t ino, const __u32 dev,
+		     const struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(ino, dev, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       !(match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && (match->mode & GR_DELETED))
+		return match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != ino || match->device != dev ||
+	       (match->mode & GR_DELETED))) {
+		match = match->next;
+	}
+
+	if (match && !(match->mode & GR_DELETED))
+		return match;
+	else
+		return NULL;
+}
+
+static struct name_entry *
+lookup_name_entry(const char *name)
+{
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(name, len);
+	unsigned int index = key % name_set.n_size;
+	struct name_entry *match;
+
+	match = name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len)))
+		match = match->next;
+
+	return match;
+}
+
+static struct name_entry *
+lookup_name_entry_create(const char *name)
+{
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(name, len);
+	unsigned int index = key % name_set.n_size;
+	struct name_entry *match;
+
+	match = name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len) ||
+			 !match->deleted))
+		match = match->next;
+
+	if (match && match->deleted)
+		return match;
+
+	match = name_set.n_hash[index];
+
+	while (match && (match->key != key || !gr_streq(match->name, name, match->len, len) ||
+			 match->deleted))
+		match = match->next;
+
+	if (match && !match->deleted)
+		return match;
+	else
+		return NULL;
+}
+
+static struct inodev_entry *
+lookup_inodev_entry(const ino_t ino, const __u32 dev)
+{
+	unsigned int index = fhash(ino, dev, inodev_set.i_size);
+	struct inodev_entry *match;
+
+	match = inodev_set.i_hash[index];
+
+	while (match && (match->nentry->inode != ino || match->nentry->device != dev))
+		match = match->next;
+
+	return match;
+}
+
+static void
+insert_inodev_entry(struct inodev_entry *entry)
+{
+	unsigned int index = fhash(entry->nentry->inode, entry->nentry->device,
+				    inodev_set.i_size);
+	struct inodev_entry **curr;
+
+	entry->prev = NULL;
+
+	curr = &inodev_set.i_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = entry;
+	
+	entry->next = *curr;
+	*curr = entry;
+
+	return;
+}
+
+static void
+__insert_acl_role_label(struct acl_role_label *role, uid_t uidgid)
+{
+	unsigned int index =
+	    rhash(uidgid, role->roletype & (GR_ROLE_USER | GR_ROLE_GROUP), acl_role_set.r_size);
+	struct acl_role_label **curr;
+
+	role->prev = NULL;
+
+	curr = &acl_role_set.r_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = role;
+
+	role->next = *curr;
+	*curr = role;
+
+	return;
+}
+
+static void
+insert_acl_role_label(struct acl_role_label *role)
+{
+	int i;
+
+	if (role->roletype & GR_ROLE_DOMAIN) {
+		for (i = 0; i < role->domain_child_num; i++)
+			__insert_acl_role_label(role, role->domain_children[i]);
+	} else
+		__insert_acl_role_label(role, role->uidgid);
+}
+					
+static int
+insert_name_entry(char *name, const ino_t inode, const __u32 device, __u8 deleted)
+{
+	struct name_entry **curr, *nentry;
+	struct inodev_entry *ientry;
+	unsigned int len = strlen(name);
+	unsigned int key = full_name_hash(name, len);
+	unsigned int index = key % name_set.n_size;
+
+	curr = &name_set.n_hash[index];
+
+	while (*curr && ((*curr)->key != key || !gr_streq((*curr)->name, name, (*curr)->len, len)))
+		curr = &((*curr)->next);
+
+	if (*curr != NULL)
+		return 1;
+
+	nentry = acl_alloc(sizeof (struct name_entry));
+	if (nentry == NULL)
+		return 0;
+
+	ientry = acl_alloc(sizeof (struct inodev_entry));
+	if (ientry == NULL)
+		return 0;
+	ientry->nentry = nentry;
+
+	nentry->key = key;
+	nentry->name = name;
+	nentry->inode = inode;
+	nentry->device = device;
+	nentry->len = len;
+	nentry->deleted = deleted;
+
+	nentry->prev = NULL;
+	curr = &name_set.n_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = nentry;
+	nentry->next = *curr;
+	*curr = nentry;
+
+	/* insert us into the table searchable by inode/dev */
+	insert_inodev_entry(ientry);
+
+	return 1;
+}
+
+static void
+insert_acl_obj_label(struct acl_object_label *obj,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index =
+	    fhash(obj->inode, obj->device, subj->obj_hash_size);
+	struct acl_object_label **curr;
+
+	
+	obj->prev = NULL;
+
+	curr = &subj->obj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+static void
+insert_acl_subj_label(struct acl_subject_label *obj,
+		      struct acl_role_label *role)
+{
+	unsigned int index = fhash(obj->inode, obj->device, role->subj_hash_size);
+	struct acl_subject_label **curr;
+
+	obj->prev = NULL;
+
+	curr = &role->subj_hash[index];
+	if (*curr != NULL)
+		(*curr)->prev = obj;
+
+	obj->next = *curr;
+	*curr = obj;
+
+	return;
+}
+
+/* allocating chained hash tables, so optimal size is where lambda ~ 1 */
+
+static void *
+create_table(__u32 * len, int elementsize)
+{
+	unsigned int table_sizes[] = {
+		7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
+		32749, 65521, 131071, 262139, 524287, 1048573, 2097143,
+		4194301, 8388593, 16777213, 33554393, 67108859
+	};
+	void *newtable = NULL;
+	unsigned int pwr = 0;
+
+	while ((pwr < ((sizeof (table_sizes) / sizeof (table_sizes[0])) - 1)) &&
+	       table_sizes[pwr] <= *len)
+		pwr++;
+
+	if (table_sizes[pwr] <= *len || (table_sizes[pwr] > (ULONG_MAX / elementsize)))
+		return newtable;
+
+	if ((table_sizes[pwr] * elementsize) <= PAGE_SIZE)
+		newtable =
+		    kmalloc(table_sizes[pwr] * elementsize, GFP_KERNEL);
+	else
+		newtable = vmalloc(table_sizes[pwr] * elementsize);
+
+	*len = table_sizes[pwr];
+
+	return newtable;
+}
+
+static int
+init_variables(const struct gr_arg *arg)
+{
+	unsigned int stacksize;
+
+	subj_map_set.s_size = arg->role_db.num_subjects;
+	acl_role_set.r_size = arg->role_db.num_roles + arg->role_db.num_domain_children;
+	name_set.n_size = arg->role_db.num_objects;
+	inodev_set.i_size = arg->role_db.num_objects;
+
+	if (!subj_map_set.s_size || !acl_role_set.r_size || 
+	    !name_set.n_size || !inodev_set.i_size)
+		return 1;
+
+	if (!gr_init_uidset())
+		return 1;
+
+	/* set up the stack that holds allocation info */
+
+	stacksize = arg->role_db.num_pointers + 6;
+
+	if (!acl_alloc_stack_init(stacksize))
+		return 1;
+
+	/* grab reference for the real root dentry and vfsmount */
+	read_lock(&child_reaper->fs->lock);
+	real_root_mnt = mntget(child_reaper->fs->rootmnt);
+	real_root = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+	
+	fakefs_obj = acl_alloc(sizeof(struct acl_object_label));
+	if (fakefs_obj == NULL)
+		return 1;
+	fakefs_obj->mode = GR_FIND | GR_READ | GR_WRITE | GR_EXEC;
+
+	subj_map_set.s_hash =
+	    (struct subject_map **) create_table(&subj_map_set.s_size, sizeof(void *));
+	acl_role_set.r_hash =
+	    (struct acl_role_label **) create_table(&acl_role_set.r_size, sizeof(void *));
+	name_set.n_hash = (struct name_entry **) create_table(&name_set.n_size, sizeof(void *));
+	inodev_set.i_hash =
+	    (struct inodev_entry **) create_table(&inodev_set.i_size, sizeof(void *));
+
+	if (!subj_map_set.s_hash || !acl_role_set.r_hash || 
+	    !name_set.n_hash || !inodev_set.i_hash)
+		return 1;
+
+	memset(subj_map_set.s_hash, 0,
+	       sizeof(struct subject_map *) * subj_map_set.s_size);
+	memset(acl_role_set.r_hash, 0,
+	       sizeof (struct acl_role_label *) * acl_role_set.r_size);
+	memset(name_set.n_hash, 0,
+	       sizeof (struct name_entry *) * name_set.n_size);
+	memset(inodev_set.i_hash, 0,
+	       sizeof (struct inodev_entry *) * inodev_set.i_size);
+
+	return 0;
+}
+
+/* free information not needed after startup
+   currently contains user->kernel pointer mappings for subjects
+*/
+
+static void
+free_init_variables(void)
+{
+	__u32 i;
+
+	if (subj_map_set.s_hash) {
+		for (i = 0; i < subj_map_set.s_size; i++) {
+			if (subj_map_set.s_hash[i]) {
+				kfree(subj_map_set.s_hash[i]);
+				subj_map_set.s_hash[i] = NULL;
+			}
+		}
+
+		if ((subj_map_set.s_size * sizeof (struct subject_map *)) <=
+		    PAGE_SIZE)
+			kfree(subj_map_set.s_hash);
+		else
+			vfree(subj_map_set.s_hash);
+	}
+
+	return;
+}
+
+static void
+free_variables(void)
+{
+	struct acl_subject_label *s;
+	struct acl_role_label *r;
+	struct task_struct *task;
+	unsigned int i, x;
+
+	gr_clear_learn_entries();
+
+	read_lock(&tasklist_lock);
+	for_each_task(task) {
+		task->acl_sp_role = 0;
+		task->acl_role_id = 0;
+		task->acl = NULL;
+		task->role = NULL;
+	}
+	read_unlock(&tasklist_lock);
+
+	/* release the reference to the real root dentry and vfsmount */
+	if (real_root)
+		dput(real_root);
+	real_root = NULL;
+	if (real_root_mnt)
+		mntput(real_root_mnt);
+	real_root_mnt = NULL;
+
+	/* free all object hash tables */
+
+	FOR_EACH_ROLE_START(r, i)
+		if (r->subj_hash == NULL)
+			break;
+		FOR_EACH_SUBJECT_START(r, s, x)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_SUBJECT_END(s, x)
+		FOR_EACH_NESTED_SUBJECT_START(r, s)
+			if (s->obj_hash == NULL)
+				break;
+			if ((s->obj_hash_size * sizeof (struct acl_object_label *)) <= PAGE_SIZE)
+				kfree(s->obj_hash);
+			else
+				vfree(s->obj_hash);
+		FOR_EACH_NESTED_SUBJECT_END(s)
+		if ((r->subj_hash_size * sizeof (struct acl_subject_label *)) <= PAGE_SIZE)
+			kfree(r->subj_hash);
+		else
+			vfree(r->subj_hash);
+		r->subj_hash = NULL;
+	FOR_EACH_ROLE_END(r,i)
+
+	acl_free_all();
+
+	if (acl_role_set.r_hash) {
+		if ((acl_role_set.r_size * sizeof (struct acl_role_label *)) <=
+		    PAGE_SIZE)
+			kfree(acl_role_set.r_hash);
+		else
+			vfree(acl_role_set.r_hash);
+	}
+	if (name_set.n_hash) {
+		if ((name_set.n_size * sizeof (struct name_entry *)) <=
+		    PAGE_SIZE)
+			kfree(name_set.n_hash);
+		else
+			vfree(name_set.n_hash);
+	}
+
+	if (inodev_set.i_hash) {
+		if ((inodev_set.i_size * sizeof (struct inodev_entry *)) <=
+		    PAGE_SIZE)
+			kfree(inodev_set.i_hash);
+		else
+			vfree(inodev_set.i_hash);
+	}
+
+	gr_free_uidset();
+
+	memset(&name_set, 0, sizeof (struct name_db));
+	memset(&inodev_set, 0, sizeof (struct inodev_db));
+	memset(&acl_role_set, 0, sizeof (struct acl_role_db));
+	memset(&subj_map_set, 0, sizeof (struct acl_subj_map_db));
+
+	default_role = NULL;
+
+	return;
+}
+
+static __u32
+count_user_objs(struct acl_object_label *userp)
+{
+	struct acl_object_label o_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_from_user(&o_tmp, userp,
+				   sizeof (struct acl_object_label)))
+			break;
+
+		userp = o_tmp.prev;
+		num++;
+	}
+
+	return num;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role);
+
+static int
+copy_user_glob(struct acl_object_label *obj)
+{
+	struct acl_object_label *g_tmp, **guser;
+	unsigned int len;
+	char *tmp;
+
+	if (obj->globbed == NULL)
+		return 0;
+
+	guser = &obj->globbed;
+	while (*guser) {
+		g_tmp = (struct acl_object_label *)
+			acl_alloc(sizeof (struct acl_object_label));
+		if (g_tmp == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(g_tmp, *guser,
+				   sizeof (struct acl_object_label)))
+			return -EFAULT;
+
+		len = strnlen_user(g_tmp->filename, PATH_MAX);
+
+		if (!len || len >= PATH_MAX)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, g_tmp->filename, len))
+			return -EFAULT;
+
+		g_tmp->filename = tmp;
+
+		*guser = g_tmp;
+		guser = &(g_tmp->next);
+	}
+		
+	return 0;
+}
+
+static int
+copy_user_objs(struct acl_object_label *userp, struct acl_subject_label *subj,
+	       struct acl_role_label *role)
+{
+	struct acl_object_label *o_tmp;
+	unsigned int len;
+	int ret;
+	char *tmp;
+
+	while (userp) {
+		if ((o_tmp = (struct acl_object_label *)
+		     acl_alloc(sizeof (struct acl_object_label))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(o_tmp, userp,
+				   sizeof (struct acl_object_label)))
+			return -EFAULT;
+
+		userp = o_tmp->prev;
+
+		len = strnlen_user(o_tmp->filename, PATH_MAX);
+
+		if (!len || len >= PATH_MAX)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, o_tmp->filename, len))
+			return -EFAULT;
+
+		o_tmp->filename = tmp;
+
+		insert_acl_obj_label(o_tmp, subj);
+		if (!insert_name_entry(o_tmp->filename, o_tmp->inode,
+				       o_tmp->device, (o_tmp->mode & GR_DELETED) ? 1 : 0))
+			return -ENOMEM;
+
+		ret = copy_user_glob(o_tmp);
+		if (ret)
+			return ret;
+
+		if (o_tmp->nested) {
+			o_tmp->nested = do_copy_user_subj(o_tmp->nested, role);
+			if (IS_ERR(o_tmp->nested))
+				return PTR_ERR(o_tmp->nested);
+
+			/* insert into nested subject list */
+			o_tmp->nested->next = role->hash->first;
+			role->hash->first = o_tmp->nested;
+		}
+	}
+
+	return 0;
+}
+
+static __u32
+count_user_subjs(struct acl_subject_label *userp)
+{
+	struct acl_subject_label s_tmp;
+	__u32 num = 0;
+
+	while (userp) {
+		if (copy_from_user(&s_tmp, userp,
+				   sizeof (struct acl_subject_label)))
+			break;
+
+		userp = s_tmp.prev;
+		/* do not count nested subjects against this count, since
+		   they are not included in the hash table, but are
+		   attached to objects.  We have already counted
+		   the subjects in userspace for the allocation 
+		   stack
+		*/
+		if (!(s_tmp.mode & GR_NESTED))
+			num++;
+	}
+
+	return num;
+}
+
+static int
+copy_user_allowedips(struct acl_role_label *rolep)
+{
+	struct role_allowed_ip *ruserip, *rtmp = NULL, *rlast;
+
+	ruserip = rolep->allowed_ips;
+
+	while (ruserip) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_allowed_ip *)
+		     acl_alloc(sizeof (struct role_allowed_ip))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(rtmp, ruserip,
+				   sizeof (struct role_allowed_ip)))
+			return -EFAULT;
+
+		ruserip = rtmp->prev;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->allowed_ips = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!ruserip)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_transitions(struct acl_role_label *rolep)
+{
+	struct role_transition *rusertp, *rtmp = NULL, *rlast;
+	unsigned int len;
+	char *tmp;
+
+	rusertp = rolep->transitions;
+
+	while (rusertp) {
+		rlast = rtmp;
+
+		if ((rtmp = (struct role_transition *)
+		     acl_alloc(sizeof (struct role_transition))) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(rtmp, rusertp,
+				   sizeof (struct role_transition)))
+			return -EFAULT;
+
+		rusertp = rtmp->prev;
+
+		len = strnlen_user(rtmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= GR_SPROLE_LEN)
+			return -EINVAL;
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, rtmp->rolename, len))
+			return -EFAULT;
+
+		rtmp->rolename = tmp;
+
+		if (!rlast) {
+			rtmp->prev = NULL;
+			rolep->transitions = rtmp;
+		} else {
+			rlast->next = rtmp;
+			rtmp->prev = rlast;
+		}
+
+		if (!rusertp)
+			rtmp->next = NULL;
+	}
+
+	return 0;
+}
+
+static struct acl_subject_label *
+do_copy_user_subj(struct acl_subject_label *userp, struct acl_role_label *role)
+{
+	struct acl_subject_label *s_tmp = NULL, *s_tmp2;
+	unsigned int len;
+	char *tmp;
+	__u32 num_objs;
+	struct acl_ip_label **i_tmp, *i_utmp2;
+	struct gr_hash_struct ghash;
+	struct subject_map *subjmap;
+	unsigned int i_num;
+	int err;
+
+	s_tmp = lookup_subject_map(userp);
+
+	/* we've already copied this subject into the kernel, just return
+	   the reference to it, and don't copy it over again
+	*/
+	if (s_tmp)
+		return(s_tmp);
+
+	if ((s_tmp = (struct acl_subject_label *)
+	    acl_alloc(sizeof (struct acl_subject_label))) == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap = (struct subject_map *)kmalloc(sizeof (struct subject_map), GFP_KERNEL);
+	if (subjmap == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	subjmap->user = userp;
+	subjmap->kernel = s_tmp;
+	insert_subj_map_entry(subjmap);
+
+	if (copy_from_user(s_tmp, userp,
+			   sizeof (struct acl_subject_label)))
+		return ERR_PTR(-EFAULT);
+
+	len = strnlen_user(s_tmp->filename, PATH_MAX);
+
+	if (!len || len >= PATH_MAX)
+		return ERR_PTR(-EINVAL);
+
+	if ((tmp = (char *) acl_alloc(len)) == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	if (copy_from_user(tmp, s_tmp->filename, len))
+		return ERR_PTR(-EFAULT);
+
+	s_tmp->filename = tmp;
+
+	if (!strcmp(s_tmp->filename, "/"))
+		role->root_label = s_tmp;
+
+	if (copy_from_user(&ghash, s_tmp->hash, sizeof(struct gr_hash_struct)))
+		return ERR_PTR(-EFAULT);
+
+	/* copy user and group transition tables */
+
+	if (s_tmp->user_trans_num) {
+		uid_t *uidlist;
+
+		uidlist = (uid_t *)acl_alloc_num(s_tmp->user_trans_num, sizeof(uid_t));
+		if (uidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(uidlist, s_tmp->user_transitions, s_tmp->user_trans_num * sizeof(uid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->user_transitions = uidlist;
+	}
+
+	if (s_tmp->group_trans_num) {
+		gid_t *gidlist;
+
+		gidlist = (gid_t *)acl_alloc_num(s_tmp->group_trans_num, sizeof(gid_t));
+		if (gidlist == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(gidlist, s_tmp->group_transitions, s_tmp->group_trans_num * sizeof(gid_t)))
+			return ERR_PTR(-EFAULT);
+
+		s_tmp->group_transitions = gidlist;
+	}
+
+	/* set up object hash table */
+	num_objs = count_user_objs(ghash.first);
+
+	s_tmp->obj_hash_size = num_objs;
+	s_tmp->obj_hash =
+	    (struct acl_object_label **)
+	    create_table(&(s_tmp->obj_hash_size), sizeof(void *));
+
+	if (!s_tmp->obj_hash)
+		return ERR_PTR(-ENOMEM);
+
+	memset(s_tmp->obj_hash, 0,
+	       s_tmp->obj_hash_size *
+	       sizeof (struct acl_object_label *));
+
+	/* add in objects */
+	err = copy_user_objs(ghash.first, s_tmp, role);
+
+	if (err)
+		return ERR_PTR(err);
+
+	/* set pointer for parent subject */
+	if (s_tmp->parent_subject) {
+		s_tmp2 = do_copy_user_subj(s_tmp->parent_subject, role);
+
+		if (IS_ERR(s_tmp2))
+			return s_tmp2;
+
+		s_tmp->parent_subject = s_tmp2;
+	}
+
+	/* add in ip acls */
+
+	if (!s_tmp->ip_num) {
+		s_tmp->ips = NULL;
+		goto insert;
+	}
+
+	i_tmp =
+	    (struct acl_ip_label **) acl_alloc_num(s_tmp->ip_num,
+					       sizeof (struct acl_ip_label *));
+
+	if (!i_tmp)
+		return ERR_PTR(-ENOMEM);
+
+	for (i_num = 0; i_num < s_tmp->ip_num; i_num++) {
+		*(i_tmp + i_num) =
+		    (struct acl_ip_label *)
+		    acl_alloc(sizeof (struct acl_ip_label));
+		if (!*(i_tmp + i_num))
+			return ERR_PTR(-ENOMEM);
+
+		if (copy_from_user
+		    (&i_utmp2, s_tmp->ips + i_num,
+		     sizeof (struct acl_ip_label *)))
+			return ERR_PTR(-EFAULT);
+
+		if (copy_from_user
+		    (*(i_tmp + i_num), i_utmp2,
+		     sizeof (struct acl_ip_label)))
+			return ERR_PTR(-EFAULT);
+		
+		if ((*(i_tmp + i_num))->iface == NULL)
+			continue;
+
+		len = strnlen_user((*(i_tmp + i_num))->iface, IFNAMSIZ);
+		if (!len || len >= IFNAMSIZ)
+			return ERR_PTR(-EINVAL);
+		tmp = acl_alloc(len);
+		if (tmp == NULL)
+			return ERR_PTR(-ENOMEM);
+		if (copy_from_user(tmp, (*(i_tmp + i_num))->iface, len))
+			return ERR_PTR(-EFAULT);
+		(*(i_tmp + i_num))->iface = tmp;
+	}
+
+	s_tmp->ips = i_tmp;
+
+insert:
+	if (!insert_name_entry(s_tmp->filename, s_tmp->inode,
+			       s_tmp->device, (s_tmp->mode & GR_DELETED) ? 1 : 0))
+		return ERR_PTR(-ENOMEM);
+
+	return s_tmp;
+}
+
+static int
+copy_user_subjs(struct acl_subject_label *userp, struct acl_role_label *role)
+{
+	struct acl_subject_label s_pre;
+	struct acl_subject_label * ret;
+	int err;
+
+	while (userp) {
+		if (copy_from_user(&s_pre, userp,
+				   sizeof (struct acl_subject_label)))
+			return -EFAULT;
+		
+		/* do not add nested subjects here, add
+		   while parsing objects
+		*/
+
+		if (s_pre.mode & GR_NESTED) {
+			userp = s_pre.prev;
+			continue;
+		}
+
+		ret = do_copy_user_subj(userp, role);
+
+		err = PTR_ERR(ret);
+		if (IS_ERR(ret))
+			return err;
+
+		insert_acl_subj_label(ret, role);
+
+		userp = s_pre.prev;
+	}
+
+	return 0;
+}
+
+static int
+copy_user_acl(struct gr_arg *arg)
+{
+	struct acl_role_label *r_tmp = NULL, **r_utmp, *r_utmp2;
+	struct sprole_pw *sptmp;
+	struct gr_hash_struct *ghash;
+	uid_t *domainlist;
+	unsigned int r_num;
+	unsigned int len;
+	char *tmp;
+	int err = 0;
+	__u16 i;
+	__u32 num_subjs;
+
+	/* we need a default and kernel role */
+	if (arg->role_db.num_roles < 2)
+		return -EINVAL;
+
+	/* copy special role authentication info from userspace */
+
+	num_sprole_pws = arg->num_sprole_pws;
+	acl_special_roles = (struct sprole_pw **) acl_alloc_num(num_sprole_pws, sizeof(struct sprole_pw *));
+
+	if (!acl_special_roles) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+
+	for (i = 0; i < num_sprole_pws; i++) {
+		sptmp = (struct sprole_pw *) acl_alloc(sizeof(struct sprole_pw));
+		if (!sptmp) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(sptmp, arg->sprole_pws + i,
+				   sizeof (struct sprole_pw))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		len =
+		    strnlen_user(sptmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= GR_SPROLE_LEN) {
+			err = -EINVAL;
+			goto cleanup;
+		}
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		if (copy_from_user(tmp, sptmp->rolename, len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+		printk(KERN_ALERT "Copying special role %s\n", tmp);
+#endif
+		sptmp->rolename = tmp;
+		acl_special_roles[i] = sptmp;
+	}
+
+	r_utmp = (struct acl_role_label **) arg->role_db.r_table;
+
+	for (r_num = 0; r_num < arg->role_db.num_roles; r_num++) {
+		r_tmp = acl_alloc(sizeof (struct acl_role_label));
+
+		if (!r_tmp) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		if (copy_from_user(&r_utmp2, r_utmp + r_num,
+				   sizeof (struct acl_role_label *))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		if (copy_from_user(r_tmp, r_utmp2,
+				   sizeof (struct acl_role_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		len = strnlen_user(r_tmp->rolename, GR_SPROLE_LEN);
+
+		if (!len || len >= PATH_MAX) {
+			err = -EINVAL;
+			goto cleanup;
+		}
+
+		if ((tmp = (char *) acl_alloc(len)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(tmp, r_tmp->rolename, len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		r_tmp->rolename = tmp;
+
+		if (!strcmp(r_tmp->rolename, "default")
+		    && (r_tmp->roletype & GR_ROLE_DEFAULT)) {
+			default_role = r_tmp;
+		} else if (!strcmp(r_tmp->rolename, ":::kernel:::")) {
+			kernel_role = r_tmp;
+		}
+
+		if ((ghash = (struct gr_hash_struct *) acl_alloc(sizeof(struct gr_hash_struct))) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(ghash, r_tmp->hash, sizeof(struct gr_hash_struct))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+
+		r_tmp->hash = ghash;
+
+		num_subjs = count_user_subjs(r_tmp->hash->first);
+
+		r_tmp->subj_hash_size = num_subjs;
+		r_tmp->subj_hash =
+		    (struct acl_subject_label **)
+		    create_table(&(r_tmp->subj_hash_size), sizeof(void *));
+
+		if (!r_tmp->subj_hash) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		err = copy_user_allowedips(r_tmp);
+		if (err)
+			goto cleanup;
+
+		/* copy domain info */
+		if (r_tmp->domain_children != NULL) {
+			domainlist = acl_alloc_num(r_tmp->domain_child_num, sizeof(uid_t));
+			if (domainlist == NULL) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			if (copy_from_user(domainlist, r_tmp->domain_children, r_tmp->domain_child_num * sizeof(uid_t))) {
+				err = -EFAULT;
+				goto cleanup;
+			}
+			r_tmp->domain_children = domainlist;
+		}
+
+		err = copy_user_transitions(r_tmp);
+		if (err)
+			goto cleanup;
+
+		memset(r_tmp->subj_hash, 0,
+		       r_tmp->subj_hash_size *
+		       sizeof (struct acl_subject_label *));
+
+		err = copy_user_subjs(r_tmp->hash->first, r_tmp);
+
+		if (err)
+			goto cleanup;
+
+		/* set nested subject list to null */
+		r_tmp->hash->first = NULL;
+
+		insert_acl_role_label(r_tmp);
+	}
+
+      cleanup:
+	return err;
+
+}
+
+static int
+gracl_init(struct gr_arg *args)
+{
+	int error = 0;
+
+	memcpy(gr_system_salt, args->salt, GR_SALT_LEN);
+	memcpy(gr_system_sum, args->sum, GR_SHA_LEN);
+
+	if (init_variables(args)) {
+		gr_log_str(GR_DONT_AUDIT_GOOD, GR_INITF_ACL_MSG, GR_VERSION);
+		error = -ENOMEM;
+		free_variables();
+		goto out;
+	}
+
+	error = copy_user_acl(args);
+	free_init_variables();
+	if (error) {
+		free_variables();
+		goto out;
+	}
+
+	if ((error = gr_set_acls(0))) {
+		free_variables();
+		goto out;
+	}
+
+	gr_status |= GR_READY;
+      out:
+	return error;
+}
+
+/* derived from glibc fnmatch() 0: match, 1: no match*/
+
+static int
+glob_match(const char *p, const char *n)
+{
+	char c;
+
+	while ((c = *p++) != '\0') {
+	switch (c) {
+		case '?':
+			if (*n == '\0')
+				return 1;
+			else if (*n == '/')
+				return 1;
+			break;
+		case '\\':
+			if (*n != c)
+				return 1;
+			break;
+		case '*':
+			for (c = *p++; c == '?' || c == '*'; c = *p++) {
+				if (*n == '/')
+					return 1;
+				else if (c == '?') {
+					if (*n == '\0')
+						return 1;
+					else
+						++n;
+				}
+			}
+			if (c == '\0') {
+				return 0;
+			} else {
+				const char *endp;
+
+				if ((endp = strchr(n, '/')) == NULL)
+					endp = n + strlen(n);
+
+				if (c == '[') {
+					for (--p; n < endp; ++n)
+						if (!glob_match(p, n))
+							return 0;
+				} else if (c == '/') {
+					while (*n != '\0' && *n != '/')
+						++n;
+					if (*n == '/' && !glob_match(p, n + 1))
+						return 0;
+				} else {
+					for (--p; n < endp; ++n)
+						if (*n == c && !glob_match(p, n))
+							return 0;
+				}
+
+				return 1;
+			}
+		case '[':
+			{
+			int not;
+			char cold;
+
+			if (*n == '\0' || *n == '/')
+				return 1;
+
+			not = (*p == '!' || *p == '^');
+			if (not)
+				++p;
+
+			c = *p++;
+			for (;;) {
+				unsigned char fn = (unsigned char)*n;
+
+				if (c == '\0')
+					return 1;
+				else {
+					if (c == fn)
+						goto matched;
+					cold = c;
+					c = *p++;
+
+					if (c == '-' && *p != ']') {
+						unsigned char cend = *p++;
+
+						if (cend == '\0')
+							return 1;
+
+						if (cold <= fn && fn <= cend)
+							goto matched;
+
+						c = *p++;
+					}
+				}
+
+				if (c == ']')
+					break;
+			}
+			if (!not)
+				return 1;
+			break;
+		matched:
+			while (c != ']') {
+				if (c == '\0')
+					return 1;
+
+				c = *p++;
+			}
+			if (not)
+				return 1;
+		}
+		break;
+	default:
+		if (c != *n)
+			return 1;
+	}
+
+	++n;
+	}
+				
+	if (*n == '\0')
+		return 0;
+
+	if (*n == '/')
+		return 0;
+
+	return 1;
+}
+
+static struct acl_object_label *
+chk_glob_label(struct acl_object_label *globbed,
+		struct dentry *dentry, struct vfsmount *mnt, char **path)
+{
+	struct acl_object_label *tmp;
+
+	if (*path == NULL)
+		*path = gr_to_filename_nolock(dentry, mnt);
+
+	tmp = globbed;
+
+	while (tmp) {
+		if (!glob_match(tmp->filename, *path))
+			return tmp;
+		tmp = tmp->next;
+	}
+
+	return NULL;
+}
+
+static struct acl_object_label *
+__full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    ino_t curr_ino, dev_t curr_dev,
+	    const struct acl_subject_label *subj, char **path, const int checkglob)
+{
+	struct acl_subject_label *tmpsubj;
+	struct acl_object_label *retval;
+	struct acl_object_label *retval2;
+
+	tmpsubj = (struct acl_subject_label *) subj;
+	read_lock(&gr_inode_lock);
+	do {
+		retval =
+		    	lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
+		if (retval) {
+			if (checkglob && retval->globbed) {
+				retval2 = chk_glob_label(retval->globbed, (struct dentry *)orig_dentry,
+						  (struct vfsmount *)orig_mnt, path);
+				if (retval2)
+					retval = retval2;
+			}
+			break;
+		}
+	} while ((tmpsubj = tmpsubj->parent_subject));
+	read_unlock(&gr_inode_lock);
+
+	return retval;
+}
+
+static struct acl_object_label *
+full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
+	    const struct dentry *curr_dentry,
+	    const struct acl_subject_label *subj, char **path, const int checkglob)
+{
+	return __full_lookup(orig_dentry, orig_mnt, curr_dentry->d_inode->i_ino,
+			     curr_dentry->d_inode->i_dev, subj, path, checkglob);
+}
+
+static struct acl_object_label *
+__chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj, char *path, const int checkglob)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct acl_object_label *retval;
+
+	spin_lock(&dcache_lock);
+
+	if (unlikely(mnt == shm_mnt || mnt == pipe_mnt || mnt == sock_mnt)) {
+		retval = fakefs_obj;
+		goto out;
+	}
+
+	for (;;) {
+		if (dentry == real_root && mnt == real_root_mnt)
+			break;
+
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (mnt->mnt_parent == mnt)
+				break;
+
+			retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+			if (retval != NULL)
+				goto out;
+
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+
+		retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+		if (retval != NULL)
+			goto out;
+
+		dentry = dentry->d_parent;
+	}
+
+	retval = full_lookup(l_dentry, l_mnt, dentry, subj, &path, checkglob);
+
+	if (retval == NULL)
+		retval = full_lookup(l_dentry, l_mnt, real_root, subj, &path, checkglob);
+out:
+	spin_unlock(&dcache_lock);
+	return retval;
+}
+
+static __inline__ struct acl_object_label *
+chk_obj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj)
+{
+	char *path = NULL;
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, 1);
+}
+
+static __inline__ struct acl_object_label *
+chk_obj_label_noglob(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj)
+{
+	char *path = NULL;
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, 0);
+}
+
+static __inline__ struct acl_object_label *
+chk_obj_create_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	      const struct acl_subject_label *subj, char *path)
+{
+	return __chk_obj_label(l_dentry, l_mnt, subj, path, 1);
+}
+
+static struct acl_subject_label *
+chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
+	       const struct acl_role_label *role)
+{
+	struct dentry *dentry = (struct dentry *) l_dentry;
+	struct vfsmount *mnt = (struct vfsmount *) l_mnt;
+	struct acl_subject_label *retval;
+
+	spin_lock(&dcache_lock);
+
+	for (;;) {
+		if (dentry == real_root && mnt == real_root_mnt)
+			break;
+
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (mnt->mnt_parent == mnt)
+				break;
+
+			read_lock(&gr_inode_lock);
+			retval =
+			    lookup_acl_subj_label(dentry->d_inode->i_ino,
+						  dentry->d_inode->i_dev, role);
+			read_unlock(&gr_inode_lock);
+			if (retval != NULL)
+				goto out;
+
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+
+		read_lock(&gr_inode_lock);
+		retval =
+		    lookup_acl_subj_label(dentry->d_inode->i_ino,
+					  dentry->d_inode->i_dev, role);
+		read_unlock(&gr_inode_lock);
+		if (retval != NULL)
+			goto out;
+
+		dentry = dentry->d_parent;
+	}
+
+	read_lock(&gr_inode_lock);
+	retval =
+	    lookup_acl_subj_label(dentry->d_inode->i_ino,
+				  dentry->d_inode->i_dev, role);
+	read_unlock(&gr_inode_lock);
+
+	if (unlikely(retval == NULL)) {
+		read_lock(&gr_inode_lock);
+		retval =
+		    lookup_acl_subj_label(real_root->d_inode->i_ino,
+					  real_root->d_inode->i_dev, role);
+		read_unlock(&gr_inode_lock);
+	}
+out:
+	spin_unlock(&dcache_lock);
+
+	return retval;
+}
+
+static void
+gr_log_learn(const struct task_struct *task, const char *pathname, const __u32 mode)
+{
+	security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename, task->role->roletype,
+		       task->uid, task->gid, task->exec_file ? gr_to_filename1(task->exec_file->f_dentry,
+		       task->exec_file->f_vfsmnt) : task->acl->filename, task->acl->filename,
+		       1UL, 1UL, pathname, (unsigned long) mode, NIPQUAD(task->curr_ip));
+
+	return;
+}
+
+static void
+gr_log_learn_id_change(const struct task_struct *task, const char type, const unsigned int real, 
+		       const unsigned int effective, const unsigned int fs)
+{
+	security_learn(GR_ID_LEARN_MSG, task->role->rolename, task->role->roletype,
+		       task->uid, task->gid, task->exec_file ? gr_to_filename1(task->exec_file->f_dentry,
+		       task->exec_file->f_vfsmnt) : task->acl->filename, task->acl->filename,
+		       type, real, effective, fs, NIPQUAD(task->curr_ip));
+
+	return;
+}
+
+__u32
+gr_check_link(const struct dentry * new_dentry,
+	      const struct dentry * parent_dentry,
+	      const struct vfsmount * parent_mnt,
+	      const struct dentry * old_dentry, const struct vfsmount * old_mnt)
+{
+	struct acl_object_label *obj;
+	__u32 oldmode, newmode;
+	__u32 needmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (GR_CREATE | GR_LINK);
+
+	obj = chk_obj_label(old_dentry, old_mnt, current->acl);
+	oldmode = obj->mode;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		oldmode |= (GR_CREATE | GR_LINK);
+
+	needmode = GR_CREATE | GR_AUDIT_CREATE | GR_SUPPRESS;
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID))
+		needmode |= GR_SETID | GR_AUDIT_SETID;
+
+	newmode =
+	    gr_check_create(new_dentry, parent_dentry, parent_mnt,
+			    oldmode | needmode);
+
+	needmode = newmode & (GR_FIND | GR_APPEND | GR_WRITE | GR_EXEC |
+			      GR_SETID | GR_READ | GR_FIND | GR_DELETE 
+			      | GR_INHERIT | GR_AUDIT_INHERIT);
+
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID) && !(newmode & GR_SETID))
+		goto bad;
+
+	if ((oldmode & needmode) != needmode)
+		goto bad;
+
+	needmode = oldmode & (GR_NOPTRACE | GR_PTRACERD | GR_INHERIT | GR_AUDITS);
+	if ((newmode & needmode) != needmode)
+		goto bad;
+
+	if ((newmode & (GR_CREATE | GR_LINK)) == (GR_CREATE | GR_LINK))
+		return newmode;
+bad:
+	needmode = oldmode;
+	if (old_dentry->d_inode->i_mode & (S_ISUID | S_ISGID))
+		needmode |= GR_SETID;
+	
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		gr_log_learn(current, gr_to_filename(old_dentry, old_mnt), needmode);
+		return (GR_CREATE | GR_LINK);
+	} else if (newmode & GR_SUPPRESS)
+		return GR_SUPPRESS;
+	else
+		return 0;
+}
+
+__u32
+gr_search_file(const struct dentry * dentry, const __u32 mode,
+	       const struct vfsmount * mnt)
+{
+	__u32 retval = mode;
+	struct acl_subject_label *curracl;
+	struct acl_object_label *currobj;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	curracl = current->acl;
+
+	currobj = chk_obj_label(dentry, mnt, curracl);
+	retval = currobj->mode & mode;
+
+	if (unlikely
+	    ((curracl->mode & (GR_LEARN | GR_INHERITLEARN)) && !(mode & GR_NOPTRACE)
+	     && (retval != (mode & ~(GR_AUDITS | GR_SUPPRESS))))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		retval = new_mode;
+
+		if (new_mode & GR_EXEC && curracl->mode & GR_INHERITLEARN)
+			new_mode |= GR_INHERIT;
+
+		if (!(mode & GR_NOLEARN))
+			gr_log_learn(current, gr_to_filename(dentry, mnt), new_mode);
+	}
+
+	return retval;
+}
+
+__u32
+gr_check_create(const struct dentry * new_dentry, const struct dentry * parent,
+		const struct vfsmount * mnt, const __u32 mode)
+{
+	struct name_entry *match;
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *curracl;
+	char *path;
+	__u32 retval;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return (mode & ~GR_AUDITS);
+
+	path = gr_to_filename_rbac(new_dentry, mnt);
+	match = lookup_name_entry_create(path);
+
+	if (!match)
+		goto check_parent;
+
+	curracl = current->acl;
+
+	read_lock(&gr_inode_lock);
+	matchpo = lookup_acl_obj_label_create(match->inode, match->device, curracl);
+	read_unlock(&gr_inode_lock);
+
+	if (matchpo) {
+		if ((matchpo->mode & mode) !=
+		    (mode & ~(GR_AUDITS | GR_SUPPRESS))
+		    && curracl->mode & (GR_LEARN | GR_INHERITLEARN)) {
+			__u32 new_mode = mode;
+
+			new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+			gr_log_learn(current, gr_to_filename(new_dentry, mnt), new_mode);
+
+			return new_mode;
+		}
+		return (matchpo->mode & mode);
+	}
+
+      check_parent:
+	curracl = current->acl;
+
+	matchpo = chk_obj_create_label(parent, mnt, curracl, path);
+	retval = matchpo->mode & mode;
+
+	if ((retval != (mode & ~(GR_AUDITS | GR_SUPPRESS)))
+	    && (curracl->mode & (GR_LEARN | GR_INHERITLEARN))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		gr_log_learn(current, gr_to_filename(new_dentry, mnt), new_mode);
+		return new_mode;
+	}
+
+	return retval;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (!(task->acl->mode & GR_PROCFIND) && !(current->acl->mode & GR_VIEW))
+		return 1;
+
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	if (unlikely(!(gr_status & GR_READY) || !task))
+		return 0;
+
+	if ((task->acl->mode & GR_PROTECTED) && !(current->acl->mode & GR_KILL) &&
+	    task->acl != current->acl)
+		return 1;
+
+	return 0;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	tsk->used_accept = 0;
+	tsk->acl_sp_role = 0;
+	tsk->acl_role_id = current->acl_role_id;
+	tsk->acl = current->acl;
+	tsk->role = current->role;
+	tsk->curr_ip = current->curr_ip;
+	if (current->exec_file)
+		get_file(current->exec_file);
+	tsk->exec_file = current->exec_file;
+	tsk->is_writable = current->is_writable;
+	if (unlikely(current->used_accept))
+		current->curr_ip = 0;
+
+	return;
+}
+
+static void
+gr_set_proc_res(struct task_struct *task)
+{
+	struct acl_subject_label *proc;
+	unsigned short i;
+
+	proc = task->acl;
+
+	if (proc->mode & (GR_LEARN | GR_INHERITLEARN))
+		return;
+
+	for (i = 0; i < RLIM_NLIMITS; i++) {
+		if (!(proc->resmask & (1 << i)))
+			continue;
+
+		task->rlim[i].rlim_cur = proc->res[i].rlim_cur;
+		task->rlim[i].rlim_max = proc->res[i].rlim_max;
+	}
+
+	return;
+}
+
+#if defined(CONFIG_PAX_HAVE_ACL_FLAGS) && (defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ALSR))
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	struct task_struct *task = current;
+	struct acl_subject_label *proc;
+	unsigned long flags;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	flags = pax_get_flags(task);
+
+	proc = task->acl;
+
+	if (proc->pax_flags & GR_PAX_DISABLE_PAGEEXEC)
+		flags &= ~MF_PAX_PAGEEXEC;
+	if (proc->pax_flags & GR_PAX_DISABLE_SEGMEXEC)
+		flags &= ~MF_PAX_SEGMEXEC;
+	if (proc->pax_flags & GR_PAX_DISABLE_RANDMMAP)
+		flags &= ~MF_PAX_RANDMMAP;
+	if (proc->pax_flags & GR_PAX_DISABLE_EMUTRAMP)
+		flags &= ~MF_PAX_EMUTRAMP;
+	if (proc->pax_flags & GR_PAX_DISABLE_MPROTECT)
+		flags &= ~MF_PAX_MPROTECT;
+
+	if (proc->pax_flags & GR_PAX_ENABLE_PAGEEXEC)
+		flags |= MF_PAX_PAGEEXEC;
+	if (proc->pax_flags & GR_PAX_ENABLE_SEGMEXEC)
+		flags |= MF_PAX_SEGMEXEC;
+	if (proc->pax_flags & GR_PAX_ENABLE_RANDMMAP)
+		flags |= MF_PAX_RANDMMAP;
+	if (proc->pax_flags & GR_PAX_ENABLE_EMUTRAMP)
+		flags |= MF_PAX_EMUTRAMP;
+	if (proc->pax_flags & GR_PAX_ENABLE_MPROTECT)
+		flags |= MF_PAX_MPROTECT;
+
+	pax_set_flags(task, flags);
+
+	return;
+}
+#endif
+
+int
+gr_check_user_change(int real, int effective, int fs)
+{
+	unsigned int i;
+	__u16 num;
+	uid_t *uidlist;
+	int curuid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_id_change(current, 'u', real, effective, fs);
+
+	num = current->acl->user_trans_num;
+	uidlist = current->acl->user_transitions;
+
+	if (uidlist == NULL)
+		return 0;
+
+	if (real == -1)
+		realok = 1;
+	if (effective == -1)
+		effectiveok = 1;
+	if (fs == -1)
+		fsok = 1;
+
+	if (current->acl->user_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curuid = (int)uidlist[i];
+			if (real == curuid)
+				realok = 1;
+			if (effective == curuid)
+				effectiveok = 1;
+			if (fs == curuid)
+				fsok = 1;
+		}
+	} else if (current->acl->user_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curuid = (int)uidlist[i];
+			if (real == curuid)
+				break;
+			if (effective == curuid)
+				break;
+			if (fs == curuid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_USRCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : fs) : effective) : real);
+		return 1;
+	}
+}
+
+int
+gr_check_group_change(int real, int effective, int fs)
+{
+	unsigned int i;
+	__u16 num;
+	gid_t *gidlist;
+	int curgid;
+	int realok = 0;
+	int effectiveok = 0;
+	int fsok = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		gr_log_learn_id_change(current, 'g', real, effective, fs);
+
+	num = current->acl->group_trans_num;
+	gidlist = current->acl->group_transitions;
+
+	if (gidlist == NULL)
+		return 0;
+
+	if (real == -1)
+		realok = 1;
+	if (effective == -1)
+		effectiveok = 1;
+	if (fs == -1)
+		fsok = 1;
+
+	if (current->acl->group_trans_type & GR_ID_ALLOW) {
+		for (i = 0; i < num; i++) {
+			curgid = (int)gidlist[i];
+			if (real == curgid)
+				realok = 1;
+			if (effective == curgid)
+				effectiveok = 1;
+			if (fs == curgid)
+				fsok = 1;
+		}
+	} else if (current->acl->group_trans_type & GR_ID_DENY) {
+		for (i = 0; i < num; i++) {
+			curgid = (int)gidlist[i];
+			if (real == curgid)
+				break;
+			if (effective == curgid)
+				break;
+			if (fs == curgid)
+				break;
+		}
+		/* not in deny list */
+		if (i == num) {
+			realok = 1;
+			effectiveok = 1;
+			fsok = 1;
+		}
+	}
+
+	if (realok && effectiveok && fsok)
+		return 0;
+	else {
+		gr_log_int(GR_DONT_AUDIT, GR_GRPCHANGE_ACL_MSG, realok ? (effectiveok ? (fsok ? 0 : fs) : effective) : real);
+		return 1;
+	}
+}
+
+void
+gr_set_role_label(struct task_struct *task, const uid_t uid, const uid_t gid)
+{
+	struct acl_role_label *role = task->role;
+	struct acl_subject_label *subj = NULL;
+	struct acl_object_label *obj;
+	struct file *filp;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	filp = task->exec_file;
+
+	/* kernel process, we'll give them the kernel role */
+	if (unlikely(!filp)) {
+		task->role = kernel_role;
+		task->acl = kernel_role->root_label;
+		return;
+	} else if (!task->role || !(task->role->roletype & GR_ROLE_SPECIAL))
+		role = lookup_acl_role_label(task, uid, gid);
+
+	/* perform subject lookup in possibly new role
+	   we can use this result below in the case where role == task->role
+	*/
+	subj = chk_subj_label(filp->f_dentry, filp->f_vfsmnt, role);
+
+	/* if we changed uid/gid, but result in the same role
+	   and are using inheritance, don't lose the inherited subject
+	   if current subject is other than what normal lookup
+	   would result in, we arrived via inheritance, don't
+	   lose subject
+	*/
+	if (role != task->role || (!(task->acl->mode & GR_INHERITLEARN) &&
+				   (subj == task->acl)))
+		task->acl = subj;
+
+	task->role = role;
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Set role label for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+
+	gr_set_proc_res(task);
+
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	struct task_struct *task = current;
+	struct acl_subject_label *newacl;
+	struct acl_object_label *obj;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	newacl = chk_subj_label(dentry, mnt, task->role);
+	obj = chk_obj_label(dentry, mnt, task->acl);
+	retmode = obj->mode & (GR_INHERIT | GR_AUDIT_INHERIT);
+
+	task_lock(task);
+	if ((
+	     (task->ptrace & PT_PTRACED) &&
+	     !(task->acl->mode & GR_POVERRIDE) &&
+	     (task->acl != newacl || obj->nested) && 
+	     !(task->role->roletype & GR_ROLE_GOD) && 
+	     !gr_search_file(dentry, GR_PTRACERD, mnt) &&
+	     !(task->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+	    ) ||
+	    (atomic_read(&task->fs->count) > 1 ||
+	     atomic_read(&task->files->count) > 1 ||
+	     atomic_read(&task->sig->count) > 1
+	    )) {
+		task_unlock(task);
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_PTRACE_EXEC_ACL_MSG, dentry, mnt);
+		return -EACCES;
+	}
+	task_unlock(task);
+
+	if (!(task->acl->mode & GR_INHERITLEARN) &&
+	    ((newacl->mode & GR_LEARN) || !(retmode & GR_INHERIT))) {
+		if (obj->nested)
+			task->acl = obj->nested;
+		else
+			task->acl = newacl;
+	} else if (retmode & GR_INHERIT && retmode & GR_AUDIT_INHERIT)
+		gr_log_str_fs(GR_DO_AUDIT, GR_INHERIT_ACL_MSG, task->acl->filename, dentry, mnt);
+
+	task->is_writable = 0;
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(dentry, mnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+	obj = chk_obj_label(dentry, mnt, task->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		task->is_writable = 1;
+
+	gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Set subject label for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+	return 0;
+}
+
+/* always called with valid inodev ptr */
+static void
+do_handle_delete(struct inodev_entry *inodev, const ino_t ino, const __u32 dev)
+{
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *matchps;
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int i, x;
+
+	FOR_EACH_ROLE_START(role, i)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			if ((matchpo = lookup_acl_obj_label(ino, dev, subj)) != NULL)
+				matchpo->mode |= GR_DELETED;
+		FOR_EACH_SUBJECT_END(subj,x)
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			if (subj->inode == ino && subj->device == dev)
+				subj->mode |= GR_DELETED;
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		if ((matchps = lookup_acl_subj_label(ino, dev, role)) != NULL)
+			matchps->mode |= GR_DELETED;
+	FOR_EACH_ROLE_END(role,i)
+
+	inodev->nentry->deleted = 1;
+
+	return;
+}
+
+void
+gr_handle_delete(const ino_t ino, const __u32 dev)
+{
+	struct inodev_entry *inodev;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	write_lock(&gr_inode_lock);
+	inodev = lookup_inodev_entry(ino, dev);
+	if (inodev != NULL)
+		do_handle_delete(inodev, ino, dev);
+	write_unlock(&gr_inode_lock);
+
+	return;
+}
+
+static void
+update_acl_obj_label(const ino_t oldinode, const __u32 olddevice,
+		     const ino_t newinode, const __u32 newdevice,
+		     struct acl_subject_label *subj)
+{
+	unsigned int index = fhash(oldinode, olddevice, subj->obj_hash_size);
+	struct acl_object_label *match;
+
+	match = subj->obj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			subj->obj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_obj_label(match, subj);
+	}
+
+	return;
+}
+
+static void
+update_acl_subj_label(const ino_t oldinode, const __u32 olddevice,
+		      const ino_t newinode, const __u32 newdevice,
+		      struct acl_role_label *role)
+{
+	unsigned int index = fhash(oldinode, olddevice, role->subj_hash_size);
+	struct acl_subject_label *match;
+
+	match = role->subj_hash[index];
+
+	while (match && (match->inode != oldinode ||
+	       match->device != olddevice ||
+	       !(match->mode & GR_DELETED)))
+		match = match->next;
+
+	if (match && (match->inode == oldinode)
+	    && (match->device == olddevice)
+	    && (match->mode & GR_DELETED)) {
+		if (match->prev == NULL) {
+			role->subj_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->inode = newinode;
+		match->device = newdevice;
+		match->mode &= ~GR_DELETED;
+
+		insert_acl_subj_label(match, role);
+	}
+
+	return;
+}
+
+static void
+update_inodev_entry(const ino_t oldinode, const __u32 olddevice,
+		    const ino_t newinode, const __u32 newdevice)
+{
+	unsigned int index = fhash(oldinode, olddevice, inodev_set.i_size);
+	struct inodev_entry *match;
+
+	match = inodev_set.i_hash[index];
+
+	while (match && (match->nentry->inode != oldinode ||
+	       match->nentry->device != olddevice || !match->nentry->deleted))
+		match = match->next;
+
+	if (match && (match->nentry->inode == oldinode)
+	    && (match->nentry->device == olddevice) &&
+	    match->nentry->deleted) {
+		if (match->prev == NULL) {
+			inodev_set.i_hash[index] = match->next;
+			if (match->next != NULL)
+				match->next->prev = NULL;
+		} else {
+			match->prev->next = match->next;
+			if (match->next != NULL)
+				match->next->prev = match->prev;
+		}
+		match->prev = NULL;
+		match->next = NULL;
+		match->nentry->inode = newinode;
+		match->nentry->device = newdevice;
+		match->nentry->deleted = 0;
+
+		insert_inodev_entry(match);
+	}
+
+	return;
+}
+
+static void
+do_handle_create(const struct name_entry *matchn, const struct dentry *dentry,
+		 const struct vfsmount *mnt)
+{
+	struct acl_subject_label *subj;
+	struct acl_role_label *role;
+	unsigned int i, x;
+
+	FOR_EACH_ROLE_START(role, i)
+		update_acl_subj_label(matchn->inode, matchn->device,
+				      dentry->d_inode->i_ino,
+				      dentry->d_inode->i_dev, role);
+
+		FOR_EACH_NESTED_SUBJECT_START(role, subj)
+			if ((subj->inode == dentry->d_inode->i_ino) &&
+			   (subj->device == dentry->d_inode->i_dev)) {
+				subj->inode = dentry->d_inode->i_ino;
+				subj->device = dentry->d_inode->i_dev;
+			}
+		FOR_EACH_NESTED_SUBJECT_END(subj)
+		FOR_EACH_SUBJECT_START(role, subj, x)
+			update_acl_obj_label(matchn->inode, matchn->device,
+					     dentry->d_inode->i_ino,
+					     dentry->d_inode->i_dev, subj);
+
+		FOR_EACH_SUBJECT_END(subj,x)
+	FOR_EACH_ROLE_END(role,i)
+
+	update_inodev_entry(matchn->inode, matchn->device,
+			    dentry->d_inode->i_ino, dentry->d_inode->i_dev);
+
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	struct name_entry *matchn;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	matchn = lookup_name_entry(gr_to_filename_rbac(dentry, mnt));
+
+	if (unlikely((unsigned long)matchn)) {
+		write_lock(&gr_inode_lock);
+		do_handle_create(matchn, dentry, mnt);
+		write_unlock(&gr_inode_lock);
+	}
+
+	return;
+}
+
+int
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace)
+{
+	struct name_entry *matchn;
+	struct inodev_entry *inodev;
+	int error = 0;
+
+	matchn = lookup_name_entry(gr_to_filename_rbac(new_dentry, mnt));
+
+	lock_kernel();
+	error = vfs_rename(old_dir, old_dentry, new_dir, new_dentry);
+	unlock_kernel();
+
+	if (unlikely(error))
+		return error;
+
+	/* we wouldn't have to check d_inode if it weren't for
+	   NFS silly-renaming
+	 */
+
+	write_lock(&gr_inode_lock);
+	if (unlikely(replace && new_dentry->d_inode)) {
+		inodev = lookup_inodev_entry(new_dentry->d_inode->i_ino,
+					     new_dentry->d_inode->i_dev);
+		
+		if (inodev != NULL && (new_dentry->d_inode->i_nlink <= 1))
+			do_handle_delete(inodev, new_dentry->d_inode->i_ino,
+					 new_dentry->d_inode->i_dev);
+	}
+
+	inodev = lookup_inodev_entry(old_dentry->d_inode->i_ino,
+				     old_dentry->d_inode->i_dev);
+		
+	if (inodev != NULL && (old_dentry->d_inode->i_nlink <= 1))
+		do_handle_delete(inodev, old_dentry->d_inode->i_ino,
+				 old_dentry->d_inode->i_dev);
+
+	if (unlikely((unsigned long)matchn))
+		do_handle_create(matchn, old_dentry, mnt);
+
+	write_unlock(&gr_inode_lock);
+
+	return error;
+}
+
+static int
+lookup_special_role_auth(__u16 mode, const char *rolename, unsigned char **salt,
+			 unsigned char **sum)
+{
+	struct acl_role_label *r;
+	struct role_allowed_ip *ipp;
+	struct role_transition *trans;
+	unsigned int i;
+	int found = 0;
+
+	/* check transition table */
+
+	for (trans = current->role->transitions; trans; trans = trans->next) {
+		if (!strcmp(rolename, trans->rolename)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return 0;
+
+	/* handle special roles that do not require authentication 
+	   and check ip */
+
+	FOR_EACH_ROLE_START(r, i)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL)) {
+			found = 0;
+			if (r->allowed_ips != NULL) {
+				for (ipp = r->allowed_ips; ipp; ipp = ipp->next) {
+					if ((ntohl(current->curr_ip) & ipp->netmask) ==
+					     (ntohl(ipp->addr) & ipp->netmask))
+						found = 1;
+				}
+			} else
+				found = 2;
+			if (!found)
+				return 0;
+
+			if (((mode == GR_SPROLEPAM) &&
+			     (r->roletype & GR_ROLE_PAM)) ||
+			    ((mode == GR_SPROLE) &&
+			     (r->roletype & GR_ROLE_NOPW))) {
+				*salt = NULL;
+				*sum = NULL;
+				return 1;
+			}
+		}
+	FOR_EACH_ROLE_END(r,i)
+
+	for (i = 0; i < num_sprole_pws; i++) {
+		if (!strcmp(rolename, acl_special_roles[i]->rolename)) {
+			*salt = acl_special_roles[i]->salt;
+			*sum = acl_special_roles[i]->sum;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+assign_special_role(char *rolename)
+{
+	struct acl_object_label *obj;
+	struct acl_role_label *r;
+	struct acl_role_label *assigned = NULL;
+	struct task_struct *tsk;
+	struct file *filp;
+	unsigned int i;
+
+	FOR_EACH_ROLE_START(r, i)
+		if (!strcmp(rolename, r->rolename) &&
+		    (r->roletype & GR_ROLE_SPECIAL))
+			assigned = r;
+	FOR_EACH_ROLE_END(r,i)
+
+	if (!assigned)
+		return;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	tsk = current->p_pptr;
+	if (tsk == NULL)
+		goto out_unlock;
+
+	filp = tsk->exec_file;
+	if (filp == NULL)
+		goto out_unlock;
+
+	tsk->is_writable = 0;
+
+	tsk->acl_sp_role = 1;
+	tsk->acl_role_id = ++acl_sp_role_value;
+	tsk->role = assigned;
+	tsk->acl = chk_subj_label(filp->f_dentry, filp->f_vfsmnt, tsk->role);
+
+	/* ignore additional mmap checks for processes that are writable 
+	   by the default ACL */
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+	obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, tsk->role->root_label);
+	if (unlikely(obj->mode & GR_WRITE))
+		tsk->is_writable = 1;
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+	printk(KERN_ALERT "Assigning special role:%s subject:%s to process (%s:%d)\n", tsk->role->rolename, tsk->acl->filename, tsk->comm, tsk->pid);
+#endif
+
+out_unlock:
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	return;
+}
+
+int gr_check_secure_terminal(struct task_struct *task)
+{
+	struct task_struct *p, *p2;
+	struct files_struct *files;
+	struct file *our_file = NULL, *file;
+	int i;
+
+	if (task->tty == NULL)
+		return 1;
+
+	task_lock(task);
+	files = task->files;
+	if (files != NULL) {
+		read_lock(&files->file_lock);
+		for (i=0; i < files->max_fds; i++) {
+			file = fcheck_files(files, i);
+			if (file && (our_file == NULL) && (file->private_data == task->tty)) {
+				get_file(file);
+				our_file = file;
+			}
+		}
+		read_unlock(&files->file_lock);
+	}
+	task_unlock(task);
+
+	if (our_file == NULL)
+		return 1;
+
+	read_lock(&tasklist_lock);
+	for_each_task(p) {
+		task_lock(p);
+		files = p->files;
+		if (files == NULL || p->tty == task->tty) {
+			task_unlock(p);
+			continue;
+		}
+		read_lock(&files->file_lock);
+		for (i=0; i < files->max_fds; i++) {
+			file = fcheck_files(files, i);
+			if (file && S_ISCHR(file->f_dentry->d_inode->i_mode) &&
+			    file->f_dentry->d_inode->i_rdev == our_file->f_dentry->d_inode->i_rdev) {
+				p2 = task;
+				while (p2->pid > 0) {
+					if (p2 == p)
+						break;
+					p2 = p2->p_pptr;
+				}
+				if (p2 == p)
+					break;
+				gr_log_ttysniff(GR_DONT_AUDIT_GOOD, GR_TTYSNIFF_ACL_MSG, p);
+				gr_handle_alertkill(p);
+				read_unlock(&files->file_lock);
+				task_unlock(p);
+				read_unlock(&tasklist_lock);
+				fput(our_file);
+				return 0;
+			}
+		}
+		read_unlock(&files->file_lock);
+		task_unlock(p);
+	}
+	read_unlock(&tasklist_lock);
+
+	fput(our_file);
+	return 1;
+}
+
+ssize_t
+write_grsec_handler(struct file *file, const char * buf, size_t count, loff_t *ppos)
+{
+	struct gr_arg_wrapper uwrap;
+	unsigned char *sprole_salt;
+	unsigned char *sprole_sum;
+	int error = sizeof (struct gr_arg_wrapper);
+	int error2 = 0;
+
+	down(&gr_dev_sem);
+
+	if ((gr_status & GR_READY) && !(current->acl->mode & GR_KERNELAUTH)) {
+		error = -EPERM;
+		goto out;
+	}
+
+	if (count != sizeof (struct gr_arg_wrapper)) {
+		gr_log_int_int(GR_DONT_AUDIT_GOOD, GR_DEV_ACL_MSG, (int)count, (int)sizeof(struct gr_arg_wrapper));
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (gr_auth_expires && time_after_eq(jiffies, gr_auth_expires)) {
+		gr_auth_expires = 0;
+		gr_auth_attempts = 0;
+	}
+
+	if (copy_from_user(&uwrap, buf, sizeof (struct gr_arg_wrapper))) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	if ((uwrap.version != GRSECURITY_VERSION) || (uwrap.size != sizeof(struct gr_arg))) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (copy_from_user(gr_usermode, uwrap.arg, sizeof (struct gr_arg))) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	if (gr_usermode->mode != GR_SPROLE &&
+	    gr_usermode->mode != GR_SPROLEPAM &&
+	    gr_auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+	    time_after(gr_auth_expires, jiffies)) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	/* if non-root trying to do anything other than use a special role,
+	   do not attempt authentication, do not count towards authentication
+	   locking
+	 */
+
+	if (gr_usermode->mode != GR_SPROLE && gr_usermode->mode != GR_STATUS &&
+	    gr_usermode->mode != GR_UNSPROLE && gr_usermode->mode != GR_SPROLEPAM &&
+	    current->uid) {
+		error = -EPERM;
+		goto out;
+	}
+
+	/* ensure pw and special role name are null terminated */
+
+	gr_usermode->pw[GR_PW_LEN - 1] = '\0';
+	gr_usermode->sp_role[GR_SPROLE_LEN - 1] = '\0';
+
+	/* Okay. 
+	 * We have our enough of the argument structure..(we have yet
+	 * to copy_from_user the tables themselves) . Copy the tables
+	 * only if we need them, i.e. for loading operations. */
+
+	switch (gr_usermode->mode) {
+	case GR_STATUS:
+			if (gr_status & GR_READY) {
+				error = 1;
+				if (!gr_check_secure_terminal(current))
+					error = 3;
+			} else
+				error = 2;
+			goto out;
+	case GR_SHUTDOWN:
+		if ((gr_status & GR_READY)
+		    && !(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			gr_status &= ~GR_READY;
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTS_ACL_MSG);
+			free_variables();
+			memset(gr_usermode, 0, sizeof (struct gr_arg));
+			memset(gr_system_salt, 0, GR_SALT_LEN);
+			memset(gr_system_sum, 0, GR_SHA_LEN);
+		} else if (gr_status & GR_READY) {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHUTF_ACL_MSG);
+			error = -EPERM;
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTI_ACL_MSG);
+			error = -EAGAIN;
+		}
+		break;
+	case GR_ENABLE:
+		if (!(gr_status & GR_READY) && !(error2 = gracl_init(gr_usermode)))
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_ENABLE_ACL_MSG, GR_VERSION);
+		else {
+			if (gr_status & GR_READY)
+				error = -EAGAIN;
+			else
+				error = error2;
+			gr_log_str(GR_DONT_AUDIT, GR_ENABLEF_ACL_MSG, GR_VERSION);
+		}
+		break;
+	case GR_RELOAD:
+		if (!(gr_status & GR_READY)) {
+			gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOADI_ACL_MSG, GR_VERSION);
+			error = -EAGAIN;
+		} else if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			lock_kernel();
+			gr_status &= ~GR_READY;
+			free_variables();
+			if (!(error2 = gracl_init(gr_usermode))) {
+				unlock_kernel();
+				gr_log_str(GR_DONT_AUDIT_GOOD, GR_RELOAD_ACL_MSG, GR_VERSION);
+			} else {
+				unlock_kernel();
+				error = error2;
+				gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+			}
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_RELOADF_ACL_MSG, GR_VERSION);
+			error = -EPERM;
+		}
+		break;
+	case GR_SEGVMOD:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (!(chkpw(gr_usermode, gr_system_salt, gr_system_sum))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODS_ACL_MSG);
+			if (gr_usermode->segv_device && gr_usermode->segv_inode) {
+				struct acl_subject_label *segvacl;
+				segvacl =
+				    lookup_acl_subj_label(gr_usermode->segv_inode,
+							  gr_usermode->segv_device,
+							  current->role);
+				if (segvacl) {
+					segvacl->crashes = 0;
+					segvacl->expires = 0;
+				}
+			} else if (gr_find_uid(gr_usermode->segv_uid) >= 0) {
+				gr_remove_uid(gr_usermode->segv_uid);
+			}
+		} else {
+			gr_log_noargs(GR_DONT_AUDIT, GR_SEGVMODF_ACL_MSG);
+			error = -EPERM;
+		}
+		break;
+	case GR_SPROLE:
+	case GR_SPROLEPAM:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->expires && time_after_eq(jiffies, current->role->expires)) {
+			current->role->expires = 0;
+			current->role->auth_attempts = 0;
+		}
+
+		if (current->role->auth_attempts >= CONFIG_GRKERNSEC_ACL_MAXTRIES &&
+		    time_after(current->role->expires, jiffies)) {
+			error = -EBUSY;
+			goto out;
+		}
+
+		if (lookup_special_role_auth
+		    (gr_usermode->mode, gr_usermode->sp_role, 
+		     &sprole_salt, &sprole_sum)
+		    && ((!sprole_salt && !sprole_sum)
+			|| !(chkpw(gr_usermode, sprole_salt, sprole_sum)))) {
+			char *p = "";
+			assign_special_role(gr_usermode->sp_role);
+			read_lock(&tasklist_lock);
+			if (current->p_pptr)
+				p = current->p_pptr->role->rolename;
+			read_unlock(&tasklist_lock);
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLES_ACL_MSG,
+					p, acl_sp_role_value);
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_SPROLEF_ACL_MSG, gr_usermode->sp_role);
+			error = -EPERM;
+			if(!(current->role->auth_attempts++))
+				current->role->expires = jiffies + CONFIG_GRKERNSEC_ACL_TIMEOUT * HZ;
+
+			goto out;
+		}
+		break;
+	case GR_UNSPROLE:
+		if (unlikely(!(gr_status & GR_READY))) {
+			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_UNSPROLEI_ACL_MSG);
+			error = -EAGAIN;
+			break;
+		}
+
+		if (current->role->roletype & GR_ROLE_SPECIAL) {
+			char *p = "";
+			int i = 0;
+
+			read_lock(&tasklist_lock);
+			if (current->p_pptr) {
+				p = current->p_pptr->role->rolename;
+				i = current->p_pptr->acl_role_id;
+			}
+			read_unlock(&tasklist_lock);
+
+			gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_UNSPROLES_ACL_MSG, p, i);
+			gr_set_acls(1);
+		} else {
+			gr_log_str(GR_DONT_AUDIT, GR_UNSPROLEF_ACL_MSG, current->role->rolename);
+			error = -EPERM;
+			goto out;
+		}
+		break;
+	default:
+		gr_log_int(GR_DONT_AUDIT, GR_INVMODE_ACL_MSG, gr_usermode->mode);
+		error = -EINVAL;
+		break;
+	}
+
+	if (error != -EPERM)
+		goto out;
+
+	if(!(gr_auth_attempts++))
+		gr_auth_expires = jiffies + CONFIG_GRKERNSEC_ACL_TIMEOUT * HZ;
+
+      out:
+	up(&gr_dev_sem);
+	return error;
+}
+
+int
+gr_set_acls(const int type)
+{
+	struct acl_object_label *obj;
+	struct task_struct *task;
+	struct file *filp;
+	struct acl_role_label *role = current->role;
+	__u16 acl_role_id = current->acl_role_id;
+	char *tmpname;
+	struct name_entry *nmatch;
+	struct acl_subject_label *tmpsubj;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	for_each_task(task) {
+		/* check to see if we're called from the exit handler,
+		   if so, only replace ACLs that have inherited the admin
+		   ACL */
+
+		if (type && (task->role != role ||
+			     task->acl_role_id != acl_role_id))
+			continue;
+
+		task->acl_role_id = 0;
+		task->acl_sp_role = 0;
+
+		if ((filp = task->exec_file)) {
+			task->role = lookup_acl_role_label(task, task->uid, task->gid);
+
+			/* the following is to apply the correct subject
+			   on binaries running when the RBAC system
+			   is enabled, when the binaries have been
+			   replaced or deleted since their execution
+			   -----
+			   when the RBAC system starts, the inode/dev
+			   from exec_file will be one the RBAC system
+			   is unaware of.  It only knows the inode/dev
+			   of the present file on disk, or the absence
+			   of it.
+			*/
+			tmpname = gr_to_filename_rbac(filp->f_dentry, filp->f_vfsmnt);
+			nmatch = lookup_name_entry(tmpname);
+			tmpsubj = NULL;
+			if (nmatch) {
+				if (nmatch->deleted)
+					tmpsubj = lookup_acl_subj_label_deleted(nmatch->inode, nmatch->device, task->role);
+				else
+					tmpsubj = lookup_acl_subj_label(nmatch->inode, nmatch->device, task->role);
+				if (tmpsubj != NULL)
+					task->acl = tmpsubj;
+			}
+			if (tmpsubj == NULL)
+				task->acl = chk_subj_label(filp->f_dentry, filp->f_vfsmnt,
+							   task->role);
+			if (task->acl) {
+				struct acl_subject_label *curr;
+				curr = task->acl;
+
+				task->is_writable = 0;
+				/* ignore additional mmap checks for processes that are writable 
+				   by the default ACL */
+				obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+				if (unlikely(obj->mode & GR_WRITE))
+					task->is_writable = 1;
+				obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, task->role->root_label);
+				if (unlikely(obj->mode & GR_WRITE))
+					task->is_writable = 1;
+
+				gr_set_proc_res(task);
+
+#ifdef CONFIG_GRKERNSEC_ACL_DEBUG
+				printk(KERN_ALERT "gr_set_acls for (%s:%d): role:%s, subject:%s\n", task->comm, task->pid, task->role->rolename, task->acl->filename);
+#endif
+			} else {
+				read_unlock(&grsec_exec_file_lock);
+				read_unlock(&tasklist_lock);
+				gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_DEFACL_MSG, task->comm, task->pid);
+				return 1;
+			}
+		} else {
+			// it's a kernel process
+			task->role = kernel_role;
+			task->acl = kernel_role->root_label;
+#ifdef CONFIG_GRKERNSEC_ACL_HIDEKERN
+			task->acl->mode &= ~GR_PROCFIND;
+#endif
+		}
+	}
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+void
+gr_learn_resource(const struct task_struct *task,
+		  const int res, const unsigned long wanted, const int gt)
+{
+	struct acl_subject_label *acl;
+
+	if (unlikely((gr_status & GR_READY) &&
+		     task->acl && (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))))
+		goto skip_reslog;
+
+#ifdef CONFIG_GRKERNSEC_RESLOG
+	gr_log_resource(task, res, wanted, gt);
+#endif
+      skip_reslog:
+
+	if (unlikely(!(gr_status & GR_READY) || !wanted || res >= GR_NLIMITS))
+		return;
+
+	acl = task->acl;
+
+	if (likely(!acl || !(acl->mode & (GR_LEARN | GR_INHERITLEARN)) ||
+		   !(acl->resmask & (1 << (unsigned short) res))))
+		return;
+
+	if (wanted >= acl->res[res].rlim_cur) {
+		unsigned long res_add;
+
+		res_add = wanted;
+		switch (res) {
+		case RLIMIT_CPU:
+			res_add += GR_RLIM_CPU_BUMP;
+			break;
+		case RLIMIT_FSIZE:
+			res_add += GR_RLIM_FSIZE_BUMP;
+			break;
+		case RLIMIT_DATA:
+			res_add += GR_RLIM_DATA_BUMP;
+			break;
+		case RLIMIT_STACK:
+			res_add += GR_RLIM_STACK_BUMP;
+			break;
+		case RLIMIT_CORE:
+			res_add += GR_RLIM_CORE_BUMP;
+			break;
+		case RLIMIT_RSS:
+			res_add += GR_RLIM_RSS_BUMP;
+			break;
+		case RLIMIT_NPROC:
+			res_add += GR_RLIM_NPROC_BUMP;
+			break;
+		case RLIMIT_NOFILE:
+			res_add += GR_RLIM_NOFILE_BUMP;
+			break;
+		case RLIMIT_MEMLOCK:
+			res_add += GR_RLIM_MEMLOCK_BUMP;
+			break;
+		case RLIMIT_AS:
+			res_add += GR_RLIM_AS_BUMP;
+			break;
+		case RLIMIT_LOCKS:
+			res_add += GR_RLIM_LOCKS_BUMP;
+			break;
+		}
+
+		acl->res[res].rlim_cur = res_add;
+
+		if (wanted > acl->res[res].rlim_max)
+			acl->res[res].rlim_max = res_add;
+
+		/* only log the subject filename, since resource logging is supported for
+		   single-subject learning only */
+		security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, task->uid, task->gid, acl->filename,
+			       acl->filename, acl->res[res].rlim_cur, acl->res[res].rlim_max,
+			       "", (unsigned long) res, NIPQUAD(task->curr_ip));
+	}
+
+	return;
+}
+
+#ifdef CONFIG_SYSCTL
+extern struct proc_dir_entry *proc_sys_root;
+
+__u32
+gr_handle_sysctl(const struct ctl_table *table, const void *oldval,
+		 const void *newval)
+{
+	struct proc_dir_entry *tmp;
+	struct nameidata nd;
+	const char *proc_sys = "/proc/sys";
+	char *path = gr_shared_page[0][smp_processor_id()];
+	struct acl_object_label *obj;
+	unsigned short len = 0, pos = 0, depth = 0, i;
+	__u32 err = 0;
+	__u32 mode = 0;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 1;
+
+	if (oldval)
+		mode |= GR_READ;
+	if (newval)
+		mode |= GR_WRITE;
+
+	/* convert the requested sysctl entry into a pathname */
+
+	for (tmp = table->de; tmp != proc_sys_root; tmp = tmp->parent) {
+		len += strlen(tmp->name);
+		len++;
+		depth++;
+	}
+
+	if ((len + depth + strlen(proc_sys) + 1) > PAGE_SIZE)
+		return 0;	// deny
+
+	memset(path, 0, PAGE_SIZE);
+
+	memcpy(path, proc_sys, strlen(proc_sys));
+
+	pos += strlen(proc_sys);
+
+	for (; depth > 0; depth--) {
+		path[pos] = '/';
+		pos++;
+		for (i = 1, tmp = table->de; tmp != proc_sys_root;
+		     tmp = tmp->parent) {
+			if (depth == i) {
+				memcpy(path + pos, tmp->name,
+				       strlen(tmp->name));
+				pos += strlen(tmp->name);
+			}
+			i++;
+		}
+	}
+
+	if (path_init(path, LOOKUP_FOLLOW, &nd))
+		err = path_walk(path, &nd);
+
+	if (err)
+		goto out;
+
+	obj = chk_obj_label(nd.dentry, nd.mnt, current->acl);
+	err = obj->mode & (mode | to_gr_audit(mode) | GR_SUPPRESS);
+
+	if (unlikely((current->acl->mode & (GR_LEARN | GR_INHERITLEARN)) && ((err & mode) != mode))) {
+		__u32 new_mode = mode;
+
+		new_mode &= ~(GR_AUDITS | GR_SUPPRESS);
+
+		err = new_mode;
+		gr_log_learn(current, path, new_mode);
+	} else if ((err & mode) != mode && !(err & GR_SUPPRESS)) {
+		gr_log_str4(GR_DONT_AUDIT, GR_SYSCTL_ACL_MSG, "denied",
+			       path, (mode & GR_READ) ? " reading" : "",
+			       (mode & GR_WRITE) ? " writing" : "");
+		err = 0;
+	} else if ((err & mode) != mode) {
+		err = 0;
+	} else if (((err & mode) == mode) && (err & GR_AUDITS)) {
+		gr_log_str4(GR_DO_AUDIT, GR_SYSCTL_ACL_MSG, "successful",
+			       path, (mode & GR_READ) ? " reading" : "",
+			       (mode & GR_WRITE) ? " writing" : "");
+	}
+
+	path_release(&nd);
+
+      out:
+	return err;
+}
+#endif
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	struct file *filp;
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	filp = task->exec_file;
+
+	while (tmp->pid > 0) {
+		if (tmp == curtemp)
+			break;
+		tmp = tmp->p_pptr;
+	}
+
+	if (!filp || (tmp->pid == 0 && !(current->acl->mode & GR_RELAXPTRACE))) {
+		read_unlock(&grsec_exec_file_lock);
+		read_unlock(&tasklist_lock);
+		return 1;
+	}
+
+	retmode = gr_search_file(filp->f_dentry, GR_NOPTRACE, filp->f_vfsmnt);
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+
+	if (retmode & GR_NOPTRACE)
+		return 1;
+
+	if (!(current->acl->mode & GR_POVERRIDE) && !(current->role->roletype & GR_ROLE_GOD)
+	    && (current->acl != task->acl || (current->acl != current->role->root_label
+	    && current->pid != task->pid)))
+		return 1;
+
+	return 0;
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	struct task_struct *tmp = task;
+	struct task_struct *curtemp = current;
+	__u32 retmode;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 0;
+
+	read_lock(&tasklist_lock);
+	while (tmp->pid > 0) {
+		if (tmp == curtemp)
+			break;
+		tmp = tmp->p_pptr;
+	}
+
+	if (tmp->pid == 0 && !(current->acl->mode & GR_RELAXPTRACE)) {
+		read_unlock(&tasklist_lock);
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+	read_unlock(&tasklist_lock);
+
+	read_lock(&grsec_exec_file_lock);
+	if (unlikely(!task->exec_file)) {
+		read_unlock(&grsec_exec_file_lock);
+		return 0;
+	}
+
+	retmode = gr_search_file(task->exec_file->f_dentry, GR_PTRACERD | GR_NOPTRACE, task->exec_file->f_vfsmnt);
+	read_unlock(&grsec_exec_file_lock);
+
+	if (retmode & GR_NOPTRACE) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+		
+	if (retmode & GR_PTRACERD) {
+		switch (request) {
+		case PTRACE_POKETEXT:
+		case PTRACE_POKEDATA:
+		case PTRACE_POKEUSR:
+#if !defined(CONFIG_PPC32) && !defined(CONFIG_PPC64) && !defined(CONFIG_PARISC) && !defined(CONFIG_ALPHA) && !defined(CONFIG_IA64)
+		case PTRACE_SETREGS:
+		case PTRACE_SETFPREGS:
+#endif
+#ifdef CONFIG_X86
+		case PTRACE_SETFPXREGS:
+#endif
+#ifdef CONFIG_ALTIVEC
+		case PTRACE_SETVRREGS:
+#endif
+			return 1;
+		default:
+			return 0;
+		}
+	} else if (!(current->acl->mode & GR_POVERRIDE) &&
+		   !(current->role->roletype & GR_ROLE_GOD) &&
+		   (current->acl != task->acl)) {
+		gr_log_ptrace(GR_DONT_AUDIT, GR_PTRACE_ACL_MSG, task);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int is_writable_mmap(const struct file *filp)
+{
+	struct task_struct *task = current;
+	struct acl_object_label *obj, *obj2;
+
+	if (gr_status & GR_READY && !(task->acl->mode & GR_OVERRIDE) &&
+	    !task->is_writable && S_ISREG(filp->f_dentry->d_inode->i_mode)) {
+		obj = chk_obj_label(filp->f_dentry, filp->f_vfsmnt, default_role->root_label);
+		obj2 = chk_obj_label(filp->f_dentry, filp->f_vfsmnt,
+			     task->role->root_label);
+		if (unlikely((obj->mode & GR_WRITE) || (obj2->mode & GR_WRITE))) {
+			gr_log_fs_generic(GR_DONT_AUDIT, GR_WRITLIB_ACL_MSG, filp->f_dentry, filp->f_vfsmnt);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_vfsmnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MMAP_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MMAP_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	__u32 mode;
+
+	if (unlikely(!file || !(prot & PROT_EXEC)))
+		return 1;
+
+	if (is_writable_mmap(file))
+		return 0;
+
+	mode =
+	    gr_search_file(file->f_dentry,
+			   GR_EXEC | GR_AUDIT_EXEC | GR_SUPPRESS,
+			   file->f_vfsmnt);
+
+	if (!gr_tpe_allow(file))
+		return 0;
+
+	if (unlikely(!(mode & GR_EXEC) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_MPROTECT_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_EXEC))) {
+		return 0;
+	} else if (unlikely(mode & GR_EXEC && mode & GR_AUDIT_EXEC)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_MPROTECT_ACL_MSG, file->f_dentry, file->f_vfsmnt);
+		return 1;
+	}
+
+	return 1;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	unsigned long runtime;
+	unsigned long cputime;
+	unsigned int wday, cday;
+	__u8 whr, chr;
+	__u8 wmin, cmin;
+	__u8 wsec, csec;
+
+	if (unlikely(!(gr_status & GR_READY) || !task->acl ||
+		     !(task->acl->mode & GR_PROCACCT)))
+		return;
+
+	runtime = (jiffies - task->start_time) / HZ;
+	wday = runtime / (3600 * 24);
+	runtime -= wday * (3600 * 24);
+	whr = runtime / 3600;
+	runtime -= whr * 3600;
+	wmin = runtime / 60;
+	runtime -= wmin * 60;
+	wsec = runtime;
+
+	cputime = (task->times.tms_utime + task->times.tms_stime) / HZ;
+	cday = cputime / (3600 * 24);
+	cputime -= cday * (3600 * 24);
+	chr = cputime / 3600;
+	cputime -= chr * 3600;
+	cmin = cputime / 60;
+	cputime -= cmin * 60;
+	csec = cputime;
+
+	gr_log_procacct(GR_DO_AUDIT, GR_ACL_PROCACCT_MSG, task, wday, whr, wmin, wsec, cday, chr, cmin, csec, code);
+
+	return;
+}
+
+void gr_set_kernel_label(struct task_struct *task)
+{
+	if (gr_status & GR_READY) {
+		task->role = kernel_role;
+		task->acl = kernel_role->root_label;
+	}
+	return;
+}
+
+int gr_acl_handle_filldir(const struct file *file, const char *name, const unsigned int namelen, const ino_t ino)
+{
+	struct task_struct *task = current;
+	struct dentry *dentry = file->f_dentry;
+	struct vfsmount *mnt = file->f_vfsmnt;
+	struct acl_object_label *obj, *tmp;
+	struct acl_subject_label *subj;
+	unsigned int bufsize;
+	int is_not_root;
+	char *path;
+
+	if (unlikely(!(gr_status & GR_READY)))
+		return 1;
+
+	if (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))
+		return 1;
+
+	subj = task->acl;
+	do {
+		obj = lookup_acl_obj_label(ino, dentry->d_inode->i_dev, subj);
+		if (obj != NULL)
+			return (obj->mode & GR_FIND) ? 1 : 0;
+	} while ((subj = subj->parent_subject));
+
+	/* this is purely an optimization since we're looking for an object
+	   for the directory we're doing a readdir on
+	   if it's possible for any globbed object to match the entry we're
+	   filling into the directory, then the object we find here will be
+	   an anchor point with attached globbed objects
+	*/
+	obj = chk_obj_label_noglob(dentry, mnt, task->acl);
+	if (obj->globbed == NULL)
+		return (obj->mode & GR_FIND) ? 1 : 0;
+
+	is_not_root = ((obj->filename[0] == '/') &&
+		   (obj->filename[1] == '\0')) ? 0 : 1;
+	bufsize = PAGE_SIZE - namelen - is_not_root;
+
+	/* check bufsize > PAGE_SIZE || bufsize == 0 */
+	if (unlikely((bufsize - 1) > (PAGE_SIZE - 1)))
+		return 1;
+
+	path = d_real_path(dentry, mnt, gr_shared_page[0][smp_processor_id()],
+			   bufsize);
+
+	bufsize = strlen(path);
+
+	/* if base is "/", don't append an additional slash */
+	if (is_not_root)
+		*(path + bufsize) = '/';
+	memcpy(path + bufsize + is_not_root, name, namelen);
+	*(path + bufsize + namelen + is_not_root) = '\0';
+					
+	tmp = obj->globbed;
+	while (tmp) {
+		if (!glob_match(tmp->filename, path))
+			return (tmp->mode & GR_FIND) ? 1 : 0;
+		tmp = tmp->next;
+	}
+	return (obj->mode & GR_FIND) ? 1 : 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_cap.c linux-2.4.37.7/grsecurity/gracl_cap.c
--- linux-2.4.37.7/grsecurity/gracl_cap.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_cap.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,81 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/capability.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+static const char *captab_log[] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",
+	"CAP_LEASE"
+};
+
+int
+gr_task_is_capable(struct task_struct *task, const int cap)
+{
+	struct acl_subject_label *curracl;
+	__u32 cap_drop = 0, cap_mask = 0;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	curracl = task->acl;
+
+	cap_drop = curracl->cap_lower;
+	cap_mask = curracl->cap_mask;
+
+	while ((curracl = curracl->parent_subject)) {
+		if (!(cap_mask & (1 << cap)) && (curracl->cap_mask & (1 << cap)))
+			cap_drop |= curracl->cap_lower & (1 << cap);
+		cap_mask |= curracl->cap_mask;
+	}
+
+	if (!cap_raised(cap_drop, cap))
+		return 1;
+
+	curracl = task->acl;
+
+	if ((curracl->mode & (GR_LEARN | GR_INHERITLEARN))
+	    && cap_raised(task->cap_effective, cap)) {
+		security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename,
+			       task->role->roletype, task->uid,
+			       task->gid, task->exec_file ?
+			       gr_to_filename(task->exec_file->f_dentry,
+			       task->exec_file->f_vfsmnt) : curracl->filename,
+			       curracl->filename, 0UL,
+			       0UL, "", (unsigned long) cap, NIPQUAD(task->curr_ip));
+		return 1;
+	}
+
+	if ((cap >= 0) && (cap < (sizeof(captab_log)/sizeof(captab_log[0]))) && cap_raised(task->cap_effective, cap))
+		gr_log_cap(GR_DONT_AUDIT, GR_CAP_ACL_MSG, task, captab_log[cap]);
+
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_fs.c linux-2.4.37.7/grsecurity/gracl_fs.c
--- linux-2.4.37.7/grsecurity/gracl_fs.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_fs.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,432 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	__u32 mode;
+
+	if (unlikely(!dentry->d_inode))
+		return GR_FIND;
+
+	mode =
+	    gr_search_file(dentry, GR_FIND | GR_AUDIT_FIND | GR_SUPPRESS, mnt);
+
+	if (unlikely(mode & GR_FIND && mode & GR_AUDIT_FIND)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return mode;
+	} else if (unlikely(!(mode & GR_FIND) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
+		return 0;
+	} else if (unlikely(!(mode & GR_FIND)))
+		return 0;
+
+	return GR_FIND;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   const int fmode)
+{
+	__u32 reqmode = GR_FIND;
+	__u32 mode;
+
+	if (unlikely(!dentry->d_inode))
+		return reqmode;
+
+	if (unlikely(fmode & O_APPEND))
+		reqmode |= GR_APPEND;
+	else if (unlikely(fmode & FMODE_WRITE))
+		reqmode |= GR_WRITE;
+	if (likely((fmode & FMODE_READ) && !(fmode & O_DIRECTORY)))
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, const int fmode,
+		    const int imode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	if (unlikely(fmode & O_APPEND))
+		reqmode |= GR_APPEND;
+	if (unlikely((fmode & FMODE_READ) && !(fmode & O_DIRECTORY)))
+		reqmode |= GR_READ;
+	if (unlikely((fmode & O_CREAT) && (imode & (S_ISUID | S_ISGID))))
+		reqmode |= GR_SETID;
+
+	mode =
+	    gr_check_create(dentry, p_dentry, p_mnt,
+			    reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode2(GR_DONT_AUDIT, GR_CREATE_ACL_MSG, dentry, p_mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : reqmode &
+			       GR_APPEND ? " appending" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry, const struct vfsmount * mnt,
+		     const int fmode)
+{
+	__u32 mode, reqmode = GR_FIND;
+
+	if ((fmode & S_IXOTH) && !S_ISDIR(dentry->d_inode->i_mode))
+		reqmode |= GR_EXEC;
+	if (fmode & S_IWOTH)
+		reqmode |= GR_WRITE;
+	if (fmode & S_IROTH)
+		reqmode |= GR_READ;
+
+	mode =
+	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
+			   mnt);
+
+	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_mode3(GR_DO_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return reqmode;
+	} else
+	    if (unlikely((mode & reqmode) != reqmode && !(mode & GR_SUPPRESS)))
+	{
+		gr_log_fs_rbac_mode3(GR_DONT_AUDIT, GR_ACCESS_ACL_MSG, dentry, mnt,
+			       reqmode & GR_READ ? " reading" : "",
+			       reqmode & GR_WRITE ? " writing" : "",
+			       reqmode & GR_EXEC ? " executing" : "");
+		return 0;
+	} else if (unlikely((mode & reqmode) != reqmode))
+		return 0;
+
+	return reqmode;
+}
+
+static __u32 generic_fs_handler(const struct dentry *dentry, const struct vfsmount *mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS, mnt);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, dentry, mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, dentry, mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_RMDIR_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE | GR_DELETE , GR_UNLINK_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_TRUNCATE_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_ATIME_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_fchmod(const struct dentry *dentry, const struct vfsmount *mnt,
+		     mode_t mode)
+{
+	if (unlikely(dentry->d_inode && S_ISSOCK(dentry->d_inode->i_mode)))
+		return 1;
+
+	if (unlikely((mode != (mode_t)-1) && (mode & (S_ISUID | S_ISGID)))) {
+		return generic_fs_handler(dentry, mnt, GR_WRITE | GR_SETID,
+				   GR_FCHMOD_ACL_MSG);
+	} else {
+		return generic_fs_handler(dentry, mnt, GR_WRITE, GR_FCHMOD_ACL_MSG);
+	}
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry *dentry, const struct vfsmount *mnt,
+		    mode_t mode)
+{
+	if (unlikely((mode != (mode_t)-1) && (mode & (S_ISUID | S_ISGID)))) {
+		return generic_fs_handler(dentry, mnt, GR_WRITE | GR_SETID,
+				   GR_CHMOD_ACL_MSG);
+	} else {
+		return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHMOD_ACL_MSG);
+	}
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_WRITE, GR_CHOWN_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_EXEC, GR_EXEC_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return generic_fs_handler(dentry, mnt, GR_READ | GR_WRITE,
+			   GR_UNIXCONNECT_ACL_MSG);
+}
+
+/* hardlinks require at minimum create permission,
+   any additional privilege required is based on the
+   privilege of the file being linked to
+*/
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const char *to)
+{
+	__u32 mode;
+	__u32 needmode = GR_CREATE | GR_LINK;
+	__u32 needaudit = GR_AUDIT_CREATE | GR_AUDIT_LINK;
+
+	mode =
+	    gr_check_link(new_dentry, parent_dentry, parent_mnt, old_dentry,
+			  old_mnt);
+
+	if (unlikely(((mode & needmode) == needmode) && (mode & needaudit))) {
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_LINK_ACL_MSG, old_dentry, old_mnt, to);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const char *from)
+{
+	__u32 needmode = GR_WRITE | GR_CREATE;
+	__u32 mode;
+
+	mode =
+	    gr_check_create(new_dentry, parent_dentry, parent_mnt,
+			    GR_CREATE | GR_AUDIT_CREATE |
+			    GR_WRITE | GR_AUDIT_WRITE | GR_SUPPRESS);
+
+	if (unlikely(mode & GR_WRITE && mode & GR_AUDITS)) {
+		gr_log_fs_str_rbac(GR_DO_AUDIT, GR_SYMLINK_ACL_MSG, from, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely(((mode & needmode) != needmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_str_rbac(GR_DONT_AUDIT, GR_SYMLINK_ACL_MSG, from, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & needmode) != needmode))
+		return 0;
+
+	return (GR_WRITE | GR_CREATE);
+}
+
+static __u32 generic_fs_create_handler(const struct dentry *new_dentry, const struct dentry *parent_dentry, const struct vfsmount *parent_mnt, __u32 reqmode, const char *fmt)
+{
+	__u32 mode;
+
+	mode = gr_check_create(new_dentry, parent_dentry, parent_mnt, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS);
+
+	if (unlikely(((mode & (reqmode)) == (reqmode)) && mode & GR_AUDITS)) {
+		gr_log_fs_rbac_generic(GR_DO_AUDIT, fmt, new_dentry, parent_mnt);
+		return mode;
+	} else if (unlikely((mode & (reqmode)) != (reqmode) && !(mode & GR_SUPPRESS))) {
+		gr_log_fs_rbac_generic(GR_DONT_AUDIT, fmt, new_dentry, parent_mnt);
+		return 0;
+	} else if (unlikely((mode & (reqmode)) != (reqmode)))
+		return 0;
+
+	return (reqmode);
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	__u32 reqmode = GR_WRITE | GR_CREATE;
+	if (unlikely(mode & (S_ISUID | S_ISGID)))
+		reqmode |= GR_SETID;
+
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  reqmode, GR_MKNOD_ACL_MSG);
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry *new_dentry,
+		    const struct dentry *parent_dentry,
+		    const struct vfsmount *parent_mnt)
+{
+	return generic_fs_create_handler(new_dentry, parent_dentry, parent_mnt,
+				  GR_WRITE | GR_CREATE, GR_MKDIR_ACL_MSG);
+}
+
+#define RENAME_CHECK_SUCCESS(old, new) \
+	(((old & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)) && \
+	 ((new & (GR_WRITE | GR_READ)) == (GR_WRITE | GR_READ)))
+
+int
+gr_acl_handle_rename(struct dentry *new_dentry,
+		     struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     struct dentry *old_dentry,
+		     struct inode *old_parent_inode,
+		     struct vfsmount *old_mnt, const char *newname)
+{
+	__u8 gr_replace = 1;
+	__u32 comp1, comp2;
+	int error = 0;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 1;
+
+	if (!new_dentry->d_inode) {
+		gr_replace = 0;
+
+		comp1 = gr_check_create(new_dentry, parent_dentry, parent_mnt,
+					GR_READ | GR_WRITE | GR_CREATE | GR_AUDIT_READ |
+					GR_AUDIT_WRITE | GR_AUDIT_CREATE | GR_SUPPRESS);
+		comp2 = gr_search_file(old_dentry, GR_READ | GR_WRITE |
+				       GR_DELETE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, old_mnt);
+	} else {
+		comp1 = gr_search_file(new_dentry, GR_READ | GR_WRITE |
+				       GR_CREATE | GR_DELETE |
+				       GR_AUDIT_CREATE | GR_AUDIT_DELETE |
+				       GR_AUDIT_READ | GR_AUDIT_WRITE |
+				       GR_SUPPRESS, parent_mnt);
+		comp2 =
+		    gr_search_file(old_dentry,
+				   GR_READ | GR_WRITE | GR_AUDIT_READ |
+				   GR_DELETE | GR_AUDIT_DELETE |
+				   GR_AUDIT_WRITE | GR_SUPPRESS, old_mnt);
+	}
+
+	if (RENAME_CHECK_SUCCESS(comp1, comp2) &&
+	    ((comp1 & GR_AUDITS) || (comp2 & GR_AUDITS)))
+		gr_log_fs_rbac_str(GR_DO_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname);
+	else if (!RENAME_CHECK_SUCCESS(comp1, comp2) && !(comp1 & GR_SUPPRESS)
+		 && !(comp2 & GR_SUPPRESS)) {
+		gr_log_fs_rbac_str(GR_DONT_AUDIT, GR_RENAME_ACL_MSG, old_dentry, old_mnt, newname);
+		error = -EACCES;
+	} else if (unlikely(!RENAME_CHECK_SUCCESS(comp1, comp2)))
+		error = -EACCES;
+
+	if (error)
+		return error;
+
+	error = gr_handle_rename(old_parent_inode, parent_dentry->d_inode,
+				 old_dentry, new_dentry, old_mnt, gr_replace);
+
+	return error;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	u16 id;
+	char *rolename;
+	struct file *exec_file;
+
+	if (unlikely(current->acl_sp_role && gr_acl_is_enabled())) {
+		id = current->acl_role_id;
+		rolename = current->role->rolename;
+		gr_set_acls(1);
+		gr_log_str_int(GR_DONT_AUDIT_GOOD, GR_SPROLEL_ACL_MSG, rolename, id);
+	}
+
+	write_lock(&grsec_exec_file_lock);
+	exec_file = current->exec_file;
+	current->exec_file = NULL;
+	write_unlock(&grsec_exec_file_lock);
+
+	if (exec_file)
+		fput(exec_file);
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	if (task != current && task->acl->mode & GR_PROTPROCFD)
+		return -EACCES;
+
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_ip.c linux-2.4.37.7/grsecurity/gracl_ip.c
--- linux-2.4.37.7/grsecurity/gracl_ip.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_ip.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,330 @@
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/smp_lock.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+#define GR_BIND			0x01
+#define GR_CONNECT		0x02
+#define GR_INVERT		0x04
+#define GR_BINDOVERRIDE		0x08
+#define GR_CONNECTOVERRIDE	0x10
+
+static const char * gr_protocols[256] = {
+	"ip", "icmp", "igmp", "ggp", "ipencap", "st", "tcp", "cbt",
+	"egp", "igp", "bbn-rcc", "nvp", "pup", "argus", "emcon", "xnet",
+	"chaos", "udp", "mux", "dcn", "hmp", "prm", "xns-idp", "trunk-1",
+	"trunk-2", "leaf-1", "leaf-2", "rdp", "irtp", "iso-tp4", "netblt", "mfe-nsp",
+	"merit-inp", "sep", "3pc", "idpr", "xtp", "ddp", "idpr-cmtp", "tp++",
+	"il", "ipv6", "sdrp", "ipv6-route", "ipv6-frag", "idrp", "rsvp", "gre",
+	"mhrp", "bna", "ipv6-crypt", "ipv6-auth", "i-nlsp", "swipe", "narp", "mobile",
+	"tlsp", "skip", "ipv6-icmp", "ipv6-nonxt", "ipv6-opts", "unknown:61", "cftp", "unknown:63",
+	"sat-expak", "kryptolan", "rvd", "ippc", "unknown:68", "sat-mon", "visa", "ipcv",
+	"cpnx", "cphb", "wsn", "pvp", "br-sat-mon", "sun-nd", "wb-mon", "wb-expak", 
+	"iso-ip", "vmtp", "secure-vmtp", "vines", "ttp", "nfsnet-igp", "dgp", "tcf", 
+	"eigrp", "ospf", "sprite-rpc", "larp", "mtp", "ax.25", "ipip", "micp",
+	"scc-sp", "etherip", "encap", "unknown:99", "gmtp", "ifmp", "pnni", "pim",
+	"aris", "scps", "qnx", "a/n", "ipcomp", "snp", "compaq-peer", "ipx-in-ip",
+	"vrrp", "pgm", "unknown:114", "l2tp", "ddx", "iatp", "stp", "srp",
+	"uti", "smp", "sm", "ptp", "isis", "fire", "crtp", "crdup",
+	"sscopmce", "iplt", "sps", "pipe", "sctp", "fc", "unkown:134", "unknown:135",
+	"unknown:136", "unknown:137", "unknown:138", "unknown:139", "unknown:140", "unknown:141", "unknown:142", "unknown:143",
+	"unknown:144", "unknown:145", "unknown:146", "unknown:147", "unknown:148", "unknown:149", "unknown:150", "unknown:151",
+	"unknown:152", "unknown:153", "unknown:154", "unknown:155", "unknown:156", "unknown:157", "unknown:158", "unknown:159",
+	"unknown:160", "unknown:161", "unknown:162", "unknown:163", "unknown:164", "unknown:165", "unknown:166", "unknown:167",
+	"unknown:168", "unknown:169", "unknown:170", "unknown:171", "unknown:172", "unknown:173", "unknown:174", "unknown:175",
+	"unknown:176", "unknown:177", "unknown:178", "unknown:179", "unknown:180", "unknown:181", "unknown:182", "unknown:183",
+	"unknown:184", "unknown:185", "unknown:186", "unknown:187", "unknown:188", "unknown:189", "unknown:190", "unknown:191",
+	"unknown:192", "unknown:193", "unknown:194", "unknown:195", "unknown:196", "unknown:197", "unknown:198", "unknown:199",
+	"unknown:200", "unknown:201", "unknown:202", "unknown:203", "unknown:204", "unknown:205", "unknown:206", "unknown:207",
+	"unknown:208", "unknown:209", "unknown:210", "unknown:211", "unknown:212", "unknown:213", "unknown:214", "unknown:215",
+	"unknown:216", "unknown:217", "unknown:218", "unknown:219", "unknown:220", "unknown:221", "unknown:222", "unknown:223",
+	"unknown:224", "unknown:225", "unknown:226", "unknown:227", "unknown:228", "unknown:229", "unknown:230", "unknown:231",
+	"unknown:232", "unknown:233", "unknown:234", "unknown:235", "unknown:236", "unknown:237", "unknown:238", "unknown:239",
+	"unknown:240", "unknown:241", "unknown:242", "unknown:243", "unknown:244", "unknown:245", "unknown:246", "unknown:247",
+	"unknown:248", "unknown:249", "unknown:250", "unknown:251", "unknown:252", "unknown:253", "unknown:254", "unknown:255",
+	};
+
+static const char * gr_socktypes[11] = {
+	"unknown:0", "stream", "dgram", "raw", "rdm", "seqpacket", "unknown:6", 
+	"unknown:7", "unknown:8", "unknown:9", "packet"
+	};
+
+const char *
+gr_proto_to_name(unsigned char proto)
+{
+	return gr_protocols[proto];
+}
+
+const char *
+gr_socktype_to_name(unsigned char type)
+{
+	return gr_socktypes[type];
+}
+
+int
+gr_search_socket(const int domain, const int type, const int protocol)
+{
+	struct acl_subject_label *curr;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		goto exit;
+
+	if ((domain < 0) || (type < 0) || (protocol < 0) || (domain != PF_INET)
+	    || (domain >= NPROTO) || (type >= SOCK_MAX) || (protocol > 255))
+		goto exit;	// let the kernel handle it
+
+	curr = current->acl;
+
+	if (!curr->ips)
+		goto exit;
+
+	if ((curr->ip_type & (1 << type)) &&
+	    (curr->ip_proto[protocol / 32] & (1 << (protocol % 32))))
+		goto exit;
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		/* we don't place acls on raw sockets , and sometimes
+		   dgram/ip sockets are opened for ioctl and not
+		   bind/connect, so we'll fake a bind learn log */
+		if (type == SOCK_RAW || type == SOCK_PACKET) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, current->uid,
+				       current->gid, current->exec_file ?
+				       gr_to_filename(current->exec_file->f_dentry,
+				       current->exec_file->f_vfsmnt) :
+				       curr->filename, curr->filename,
+				       NIPQUAD(fakeip), 0, type,
+				       protocol, GR_CONNECT, NIPQUAD(current->curr_ip));
+		} else if ((type == SOCK_DGRAM) && (protocol == IPPROTO_IP)) {
+			__u32 fakeip = 0;
+			security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+				       current->role->roletype, current->uid,
+				       current->gid, current->exec_file ?
+				       gr_to_filename(current->exec_file->f_dentry,
+				       current->exec_file->f_vfsmnt) :
+				       curr->filename, curr->filename,
+				       NIPQUAD(fakeip), 0, type,
+				       protocol, GR_BIND, NIPQUAD(current->curr_ip));
+		}
+		/* we'll log when they use connect or bind */
+		goto exit;
+	}
+
+	gr_log_str3(GR_DONT_AUDIT, GR_SOCK_MSG, "inet", 
+		    gr_socktype_to_name(type), gr_proto_to_name(protocol));
+
+	return 0;
+      exit:
+	return 1;
+}
+
+int check_ip_policy(struct acl_ip_label *ip, __u32 ip_addr, __u16 ip_port, __u8 protocol, const int mode, const int type, __u32 our_addr, __u32 our_netmask)
+{
+	if ((ip->mode & mode) &&
+	    (ip_port >= ip->low) &&
+	    (ip_port <= ip->high) &&
+	    ((ntohl(ip_addr) & our_netmask) ==
+	     (ntohl(our_addr) & our_netmask))
+	    && (ip->proto[protocol / 32] & (1 << (protocol % 32)))
+	    && (ip->type & (1 << type))) {
+		if (ip->mode & GR_INVERT)
+			return 2; // specifically denied
+		else
+			return 1; // allowed
+	}
+
+	return 0; // not specifically allowed, may continue parsing
+}
+
+static int
+gr_search_connectbind(const int full_mode, struct sock *sk,
+		      struct sockaddr_in *addr, const int type)
+{
+	char iface[IFNAMSIZ] = {0};
+	struct acl_subject_label *curr;
+	struct acl_ip_label *ip;
+	struct net_device *dev;
+	struct in_device *idev;
+	unsigned long i;
+	int ret;
+	int mode = full_mode & (GR_BIND | GR_CONNECT);
+	__u32 ip_addr = 0;
+	__u32 our_addr;
+	__u32 our_netmask;
+	char *p;
+	__u16 ip_port = 0;
+
+	if (unlikely(!gr_acl_is_enabled() || sk->family != PF_INET))
+		return 0;
+
+	curr = current->acl;
+
+	/* INADDR_ANY overriding for binds, inaddr_any_override is already in network order */
+	if ((full_mode & GR_BINDOVERRIDE) && addr->sin_addr.s_addr == htonl(INADDR_ANY) && curr->inaddr_any_override != 0)
+		addr->sin_addr.s_addr = curr->inaddr_any_override;
+	if ((full_mode & GR_CONNECTOVERRIDE) && sk->saddr == htonl(INADDR_ANY) && curr->inaddr_any_override != 0) {
+		struct sockaddr_in saddr;
+		int err;
+
+		saddr.sin_family = AF_INET;
+		saddr.sin_addr.s_addr = curr->inaddr_any_override;
+		saddr.sin_port = sk->sport;
+
+		err = sk->socket->ops->bind(sk->socket, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in));
+		if (err)
+			return err;
+	}
+
+	if (!curr->ips)
+		return 0;
+
+	ip_addr = addr->sin_addr.s_addr;
+	ip_port = ntohs(addr->sin_port);
+
+	if (curr->mode & (GR_LEARN | GR_INHERITLEARN)) {
+		security_learn(GR_IP_LEARN_MSG, current->role->rolename,
+			       current->role->roletype, current->uid,
+			       current->gid, current->exec_file ?
+			       gr_to_filename(current->exec_file->f_dentry,
+			       current->exec_file->f_vfsmnt) :
+			       curr->filename, curr->filename,
+			       NIPQUAD(ip_addr), ip_port, type,
+			       sk->protocol, mode, NIPQUAD(current->curr_ip));
+		return 0;
+	}
+
+	for (i = 0; i < curr->ip_num; i++) {
+		ip = *(curr->ips + i);
+		if (ip->iface != NULL) {
+			strncpy(iface, ip->iface, IFNAMSIZ - 1);
+			p = strchr(iface, ':');
+			if (p != NULL)
+				*p = '\0';
+			dev = dev_get_by_name(iface);
+			if (dev == NULL)
+				continue;
+			idev = in_dev_get(dev);
+			if (idev == NULL) {
+				dev_put(dev);
+				continue;
+			}
+			read_lock(&idev->lock);
+			for_ifa(idev) {
+				if (!strcmp(ip->iface, ifa->ifa_label)) {
+					our_addr = ifa->ifa_address;
+					our_netmask = 0xffffffff;
+					ret = check_ip_policy(ip, ip_addr, ip_port, sk->protocol, mode, type, our_addr, our_netmask);
+					if (ret == 1) {
+						read_unlock(&idev->lock);
+						in_dev_put(idev);
+						dev_put(dev);
+						return 0;
+					} else if (ret == 2) {
+						read_unlock(&idev->lock);
+						in_dev_put(idev);
+						dev_put(dev);
+						goto denied;
+					}
+				}
+			} endfor_ifa(idev);
+			read_unlock(&idev->lock);
+			in_dev_put(idev);
+			dev_put(dev);
+		} else {
+			our_addr = ip->addr;
+			our_netmask = ip->netmask;
+			ret = check_ip_policy(ip, ip_addr, ip_port, sk->protocol, mode, type, our_addr, our_netmask);
+			if (ret == 1)
+				return 0;
+			else if (ret == 2)
+				goto denied;
+		}
+	}
+
+denied:
+	if (mode == GR_BIND)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_BIND_ACL_MSG, NIPQUAD(ip_addr), ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->protocol));
+	else if (mode == GR_CONNECT)
+		gr_log_int5_str2(GR_DONT_AUDIT, GR_CONNECT_ACL_MSG, NIPQUAD(ip_addr), ip_port, gr_socktype_to_name(type), gr_proto_to_name(sk->protocol));
+
+	return -EACCES;
+}
+
+int
+gr_search_connect(struct socket *sock, struct sockaddr_in *addr)
+{
+	return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sock->sk, addr, sock->type);
+}
+
+int
+gr_search_bind(struct socket *sock, struct sockaddr_in *addr)
+{
+	return gr_search_connectbind(GR_BIND | GR_BINDOVERRIDE, sock->sk, addr, sock->type);
+}
+
+int gr_search_listen(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = sk->saddr;
+	addr.sin_port = sk->sport;
+
+	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
+}
+
+int gr_search_accept(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_in addr;
+
+	addr.sin_addr.s_addr = sk->saddr;
+	addr.sin_port = sk->sport;
+
+	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
+}
+
+int
+gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr)
+{
+	if (addr)
+		return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, addr, SOCK_DGRAM);
+	else {
+		struct sockaddr_in sin;
+
+		sin.sin_addr.s_addr = sk->daddr;
+		sin.sin_port = sk->dport;
+
+		return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, &sin, SOCK_DGRAM);
+	}
+}
+
+int
+gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb)
+{
+	struct sockaddr_in sin;
+
+	if (unlikely(skb->len < sizeof (struct udphdr)))
+		return 0;	// skip this packet
+
+	sin.sin_addr.s_addr = skb->nh.iph->saddr;
+	sin.sin_port = skb->h.uh->source;
+
+	return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, &sin, SOCK_DGRAM);
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_learn.c linux-2.4.37.7/grsecurity/gracl_learn.c
--- linux-2.4.37.7/grsecurity/gracl_learn.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_learn.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,211 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <linux/string.h>
+#include <linux/file.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/grinternal.h>
+
+extern ssize_t write_grsec_handler(struct file * file, const char * buf,
+				   size_t count, loff_t *ppos);
+extern int gr_acl_is_enabled(void);
+
+static DECLARE_WAIT_QUEUE_HEAD(learn_wait);
+static int gr_learn_attached;
+
+/* use a 512k buffer */
+#define LEARN_BUFFER_SIZE (512 * 1024)
+
+static spinlock_t gr_learn_lock = SPIN_LOCK_UNLOCKED;
+static DECLARE_MUTEX(gr_learn_user_sem);
+
+/* we need to maintain two buffers, so that the kernel context of grlearn
+   uses a semaphore around the userspace copying, and the other kernel contexts
+   use a spinlock when copying into the buffer, since they cannot sleep
+*/
+static char *learn_buffer;
+static char *learn_buffer_user;
+static int learn_buffer_len;
+static int learn_buffer_user_len;
+
+static ssize_t
+read_learn(struct file *file, char * buf, size_t count, loff_t * ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t retval = 0;
+
+	add_wait_queue(&learn_wait, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	do {
+		down(&gr_learn_user_sem);
+		spin_lock(&gr_learn_lock);
+		if (learn_buffer_len)
+			break;
+		spin_unlock(&gr_learn_lock);
+		up(&gr_learn_user_sem);
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			goto out;
+		}
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			goto out;
+		}
+
+		schedule();
+	} while (1);
+
+	memcpy(learn_buffer_user, learn_buffer, learn_buffer_len);
+	learn_buffer_user_len = learn_buffer_len;
+	retval = learn_buffer_len;
+	learn_buffer_len = 0;
+
+	spin_unlock(&gr_learn_lock);
+
+	if (copy_to_user(buf, learn_buffer_user, learn_buffer_user_len))
+		retval = -EFAULT;
+
+	up(&gr_learn_user_sem);
+out:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&learn_wait, &wait);
+	return retval;
+}
+
+static unsigned int
+poll_learn(struct file * file, poll_table * wait)
+{
+	poll_wait(file, &learn_wait, wait);
+
+	if (learn_buffer_len)
+		return (POLLIN | POLLRDNORM);
+
+	return 0;
+}
+
+void
+gr_clear_learn_entries(void)
+{
+	char *tmp;
+
+	down(&gr_learn_user_sem);
+	if (learn_buffer != NULL) {
+		spin_lock(&gr_learn_lock);
+		tmp = learn_buffer;
+		learn_buffer = NULL;
+		spin_unlock(&gr_learn_lock);
+		vfree(learn_buffer);
+	}
+	if (learn_buffer_user != NULL) {
+		vfree(learn_buffer_user);
+		learn_buffer_user = NULL;
+	}
+	learn_buffer_len = 0;
+	up(&gr_learn_user_sem);
+
+	return;
+}
+
+void
+gr_add_learn_entry(const char *fmt, ...)
+{
+	va_list args;
+	unsigned int len;
+
+	if (!gr_learn_attached)
+		return;
+
+	spin_lock(&gr_learn_lock);
+
+	/* leave a gap at the end so we know when it's "full" but don't have to
+	   compute the exact length of the string we're trying to append
+	*/
+	if (learn_buffer_len > LEARN_BUFFER_SIZE - 16384) {
+		spin_unlock(&gr_learn_lock);
+		wake_up_interruptible(&learn_wait);
+		return;
+	}
+	if (learn_buffer == NULL) {
+		spin_unlock(&gr_learn_lock);
+		return;
+	}
+
+	va_start(args, fmt);
+	len = vsnprintf(learn_buffer + learn_buffer_len, LEARN_BUFFER_SIZE - learn_buffer_len, fmt, args);
+	va_end(args);
+
+	learn_buffer_len += len + 1;
+
+	spin_unlock(&gr_learn_lock);
+	wake_up_interruptible(&learn_wait);
+
+	return;
+}
+
+static int
+open_learn(struct inode *inode, struct file *file)
+{
+	if (file->f_mode & FMODE_READ && gr_learn_attached)
+		return -EBUSY;
+	if (file->f_mode & FMODE_READ) {
+		int retval = 0;
+		down(&gr_learn_user_sem);
+		if (learn_buffer == NULL)
+			learn_buffer = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer_user == NULL)
+			learn_buffer_user = vmalloc(LEARN_BUFFER_SIZE);
+		if (learn_buffer == NULL) {
+			retval = -ENOMEM;
+			goto out_error;
+		}
+		if (learn_buffer_user == NULL) {
+			retval = -ENOMEM;
+			goto out_error;
+		}
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 1;
+out_error:
+		up(&gr_learn_user_sem);
+		return retval;
+	}
+	return 0;
+}
+
+static int
+close_learn(struct inode *inode, struct file *file)
+{
+	char *tmp;
+
+	if (file->f_mode & FMODE_READ) {
+		down(&gr_learn_user_sem);
+		if (learn_buffer != NULL) {
+			spin_lock(&gr_learn_lock);
+			tmp = learn_buffer;
+			learn_buffer = NULL;
+			spin_unlock(&gr_learn_lock);
+			vfree(tmp);
+		}
+		if (learn_buffer_user != NULL) {
+			vfree(learn_buffer_user);
+			learn_buffer_user = NULL;
+		}
+		learn_buffer_len = 0;
+		learn_buffer_user_len = 0;
+		gr_learn_attached = 0;
+		up(&gr_learn_user_sem);
+	}
+
+	return 0;
+}
+		
+const struct file_operations grsec_fops = {
+	read:		read_learn,
+	write:		write_grsec_handler,
+	open:		open_learn,
+	release:	close_learn,
+	poll:		poll_learn,
+};
diff -urNp linux-2.4.37.7/grsecurity/gracl_res.c linux-2.4.37.7/grsecurity/gracl_res.c
--- linux-2.4.37.7/grsecurity/gracl_res.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_res.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,40 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grinternal.h>
+
+static const char *restab_log[] = {
+	[RLIMIT_CPU] = "RLIMIT_CPU",
+	[RLIMIT_FSIZE] = "RLIMIT_FSIZE",
+	[RLIMIT_DATA] = "RLIMIT_DATA",
+	[RLIMIT_STACK] = "RLIMIT_STACK",
+	[RLIMIT_CORE] = "RLIMIT_CORE",
+	[RLIMIT_RSS] = "RLIMIT_RSS",
+	[RLIMIT_NPROC] = "RLIMIT_NPROC",
+	[RLIMIT_NOFILE] = "RLIMIT_NOFILE",
+	[RLIMIT_MEMLOCK] = "RLIMIT_MEMLOCK",
+	[RLIMIT_AS] = "RLIMIT_AS",
+	[RLIMIT_LOCKS] = "RLIMIT_LOCKS",
+	[GR_CRASH_RES] = "RLIMIT_CRASH"
+};
+
+void
+gr_log_resource(const struct task_struct *task,
+		const int res, const unsigned long wanted, const int gt)
+{
+	if (unlikely(res == RLIMIT_NPROC && 
+	    (cap_raised(task->cap_effective, CAP_SYS_ADMIN) || 
+	     cap_raised(task->cap_effective, CAP_SYS_RESOURCE))))
+		return;
+
+	// not yet supported resources
+	if (!restab_log[res])
+		return;
+
+	if (unlikely(((gt && wanted > task->rlim[res].rlim_cur) ||
+		      (!gt && wanted >= task->rlim[res].rlim_cur)) &&
+		     task->rlim[res].rlim_cur != RLIM_INFINITY))
+		if (gr_acl_is_enabled() || grsec_resource_logging)
+			gr_log_res_ulong2_str(GR_DONT_AUDIT, GR_RESOURCE_MSG, task, wanted, restab_log[res], task->rlim[res].rlim_cur);
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_segv.c linux-2.4.37.7/grsecurity/gracl_segv.c
--- linux-2.4.37.7/grsecurity/gracl_segv.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_segv.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,296 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+static struct crash_uid *uid_set;
+static unsigned short uid_used;
+static spinlock_t gr_uid_lock = SPIN_LOCK_UNLOCKED;
+extern rwlock_t gr_inode_lock;
+extern struct acl_subject_label *
+	lookup_acl_subj_label(const ino_t inode, const __u32 dev,
+			      struct acl_role_label *role);
+
+int
+gr_init_uidset(void)
+{
+	uid_set =
+	    kmalloc(GR_UIDTABLE_MAX * sizeof (struct crash_uid), GFP_KERNEL);
+	uid_used = 0;
+
+	return uid_set ? 1 : 0;
+}
+
+void
+gr_free_uidset(void)
+{
+	if (uid_set)
+		kfree(uid_set);
+
+	return;
+}
+
+int
+gr_find_uid(const uid_t uid)
+{
+	struct crash_uid *tmp = uid_set;
+	uid_t buid;
+	int low = 0, high = uid_used - 1, mid;
+
+	while (high >= low) {
+		mid = (low + high) >> 1;
+		buid = tmp[mid].uid;
+		if (buid == uid)
+			return mid;
+		if (buid > uid)
+			high = mid - 1;
+		if (buid < uid)
+			low = mid + 1;
+	}
+
+	return -1;
+}
+
+static __inline__ void
+gr_insertsort(void)
+{
+	unsigned short i, j;
+	struct crash_uid index;
+
+	for (i = 1; i < uid_used; i++) {
+		index = uid_set[i];
+		j = i;
+		while ((j > 0) && uid_set[j - 1].uid > index.uid) {
+			uid_set[j] = uid_set[j - 1];
+			j--;
+		}
+		uid_set[j] = index;
+	}
+
+	return;
+}
+
+static __inline__ void
+gr_insert_uid(const uid_t uid, const unsigned long expires)
+{
+	int loc;
+
+	if (uid_used == GR_UIDTABLE_MAX)
+		return;
+
+	loc = gr_find_uid(uid);
+
+	if (loc >= 0) {
+		uid_set[loc].expires = expires;
+		return;
+	}
+
+	uid_set[uid_used].uid = uid;
+	uid_set[uid_used].expires = expires;
+	uid_used++;
+
+	gr_insertsort();
+
+	return;
+}
+
+void
+gr_remove_uid(const unsigned short loc)
+{
+	unsigned short i;
+
+	for (i = loc + 1; i < uid_used; i++)
+		uid_set[i - 1] = uid_set[i];
+
+	uid_used--;
+
+	return;
+}
+
+int
+gr_check_crash_uid(const uid_t uid)
+{
+	int loc;
+	int ret = 0;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	spin_lock(&gr_uid_lock);
+	loc = gr_find_uid(uid);
+
+	if (loc < 0)
+		goto out_unlock;
+
+	if (time_before_eq(uid_set[loc].expires, jiffies))
+		gr_remove_uid(loc);
+	else
+		ret = 1;
+
+out_unlock:
+	spin_unlock(&gr_uid_lock);
+	return ret;
+}
+
+static __inline__ int
+proc_is_setxid(const struct task_struct *task)
+{
+	if (task->uid != task->euid || task->uid != task->suid ||
+	    task->uid != task->fsuid)
+		return 1;
+	if (task->gid != task->egid || task->gid != task->sgid ||
+	    task->gid != task->fsgid)
+		return 1;
+
+	return 0;
+}
+static __inline__ int
+gr_fake_force_sig(int sig, struct task_struct *t)
+{
+	unsigned long int flags;
+
+	spin_lock_irqsave(&t->sigmask_lock, flags);
+	if (t->sig == NULL) {
+		spin_unlock_irqrestore(&t->sigmask_lock, flags);
+		return -ESRCH;
+	}
+
+	if (t->sig->action[sig - 1].sa.sa_handler == SIG_IGN)
+		t->sig->action[sig - 1].sa.sa_handler = SIG_DFL;
+	sigdelset(&t->blocked, sig);
+	recalc_sigpending(t);
+	spin_unlock_irqrestore(&t->sigmask_lock, flags);
+
+	return send_sig_info(sig, (void *) 1L, t);
+}
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	struct acl_subject_label *curr;
+	struct acl_subject_label *curr2;
+	struct task_struct *tsk;
+
+	if (sig != SIGSEGV && sig != SIGKILL && sig != SIGBUS && sig != SIGILL)
+		return;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curr = task->acl;
+
+	if (!(curr->resmask & (1 << GR_CRASH_RES)))
+		return;
+
+	if (time_before_eq(curr->expires, jiffies)) {
+		curr->expires = 0;
+		curr->crashes = 0;
+	}
+
+	curr->crashes++;
+
+	if (!curr->expires)
+		curr->expires = jiffies + curr->res[GR_CRASH_RES].rlim_max;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, jiffies)) {
+		if (task->uid && proc_is_setxid(task)) {
+			gr_log_crash1(GR_DONT_AUDIT, GR_SEGVSTART_ACL_MSG, task, curr->res[GR_CRASH_RES].rlim_max / HZ);
+			spin_lock(&gr_uid_lock);
+			gr_insert_uid(task->uid, curr->expires);
+			spin_unlock(&gr_uid_lock);
+			curr->expires = 0;
+			curr->crashes = 0;
+			read_lock(&tasklist_lock);
+			for_each_task(tsk) {
+				if (tsk != task && tsk->uid == task->uid)
+					gr_fake_force_sig(SIGKILL, tsk);
+			}
+			read_unlock(&tasklist_lock);
+		} else {
+			gr_log_crash2(GR_DONT_AUDIT, GR_SEGVNOSUID_ACL_MSG, task, kdevname(curr->device), curr->inode, curr->res[GR_CRASH_RES].rlim_max / HZ);
+			read_lock(&tasklist_lock);
+			for_each_task(tsk) {
+				if (likely(tsk != task)) {
+					curr2 = tsk->acl;
+
+					if (curr2->device == curr->device &&
+					    curr2->inode == curr->inode)
+						gr_fake_force_sig(SIGKILL, tsk);
+				}
+			}
+			read_unlock(&tasklist_lock);
+		}
+	}
+
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	struct acl_subject_label *curr;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return 0;
+
+	read_lock(&gr_inode_lock);
+	curr = lookup_acl_subj_label(filp->f_dentry->d_inode->i_ino,
+				     filp->f_dentry->d_inode->i_dev,
+				     current->role);
+	read_unlock(&gr_inode_lock);
+
+	if (!curr || !(curr->resmask & (1 << GR_CRASH_RES)) ||
+	    (!curr->crashes && !curr->expires))
+		return 0;
+
+	if ((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) &&
+	    time_after(curr->expires, jiffies))
+		return 1;
+	else if (time_before_eq(curr->expires, jiffies)) {
+		curr->crashes = 0;
+		curr->expires = 0;
+	}
+
+	return 0;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	struct acl_subject_label *curracl;
+	struct task_struct *p;
+	__u32 curr_ip;
+
+	if (unlikely(!gr_acl_is_enabled()))
+		return;
+
+	curracl = task->acl;
+	curr_ip = task->curr_ip;
+
+	if ((curracl->mode & GR_KILLIPPROC) && curr_ip) {
+		read_lock(&tasklist_lock);
+		for_each_task(p) {
+			if (p->curr_ip == curr_ip)
+				gr_fake_force_sig(SIGKILL, p);
+		}
+		read_unlock(&tasklist_lock);
+	} else if (curracl->mode & GR_KILLPROC)
+		gr_fake_force_sig(SIGKILL, task);
+
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/gracl_shm.c linux-2.4.37.7/grsecurity/gracl_shm.c
--- linux-2.4.37.7/grsecurity/gracl_shm.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/gracl_shm.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,37 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/ipc.h>
+#include <linux/gracl.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime, const uid_t cuid, const int shmid)
+{
+	struct task_struct *task;
+
+	if (!gr_acl_is_enabled())
+		return 1;
+
+	read_lock(&tasklist_lock);
+
+	task = find_task_by_pid(shm_cprid);
+
+	if (unlikely(!task))
+		task = find_task_by_pid(shm_lapid);
+
+	if (unlikely(task && (time_before((unsigned long)task->start_time, (unsigned long)shm_createtime) ||
+			      (task->pid == shm_lapid)) &&
+		     (task->acl->mode & GR_PROTSHM) &&
+		     (task->acl != current->acl))) {
+		read_unlock(&tasklist_lock);
+		gr_log_int3(GR_DONT_AUDIT, GR_SHMAT_ACL_MSG, cuid, shm_cprid, shmid);
+		return 0;
+	}
+	read_unlock(&tasklist_lock);
+
+	return 1;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_chdir.c linux-2.4.37.7/grsecurity/grsec_chdir.c
--- linux-2.4.37.7/grsecurity/grsec_chdir.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_chdir.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,19 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_chdir(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	if ((grsec_enable_chdir && grsec_enable_group &&
+	     in_group_p(grsec_audit_gid)) || (grsec_enable_chdir &&
+					      !grsec_enable_group)) {
+		gr_log_fs_generic(GR_DO_AUDIT, GR_CHDIR_AUDIT_MSG, dentry, mnt);
+	}
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_chroot.c linux-2.4.37.7/grsecurity/grsec_chroot.c
--- linux-2.4.37.7/grsecurity/grsec_chroot.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_chroot.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,327 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_chroot_unix(const pid_t pid)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	struct task_struct *p, **htable;
+
+	if (unlikely(!grsec_enable_chroot_unix))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	read_lock(&tasklist_lock);
+
+	htable = &pidhash[pid_hashfn(pid)];
+
+	for (p = *htable; p && p->pid != pid; p = p->pidhash_next) ;
+
+	if (p) {
+		task_lock(p);
+		if (!have_same_root(current, p)) {
+			task_unlock(p);
+			read_unlock(&tasklist_lock);
+			gr_log_noargs(GR_DONT_AUDIT, GR_UNIX_CHROOT_MSG);
+			return 0;
+		}
+		task_unlock(p);
+	}
+
+	read_unlock(&tasklist_lock);
+#endif
+	return 1;
+}
+
+int
+gr_handle_chroot_nice(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_NICE_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_setpriority(const struct task_struct *p, const int niceval)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	if (grsec_enable_chroot_nice && (niceval < p->nice)
+			&& proc_is_chrooted(current)) {
+		gr_log_str_int(GR_DONT_AUDIT, GR_PRIORITY_CHROOT_MSG, p->comm, p->pid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_rawio(const struct inode *inode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(current) && 
+	    inode && S_ISBLK(inode->i_mode) && !capable(CAP_SYS_RAWIO))
+		return 1;
+#endif
+	return 0;
+}
+
+int
+gr_pid_is_chrooted(struct task_struct *p)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || !p)
+		return 0;
+
+	task_lock(p);
+	if ((p->state == TASK_ZOMBIE) || !have_same_root(current, p)) {
+		task_unlock(p);
+		return 1;
+	}
+	task_unlock(p);
+#endif
+	return 0;
+}
+
+#if defined(CONFIG_GRKERNSEC_CHROOT_DOUBLE) || defined(CONFIG_GRKERNSEC_CHROOT_FCHDIR)
+int gr_is_outside_chroot(const struct dentry *u_dentry, const struct vfsmount *u_mnt)
+{
+	struct dentry *dentry = (struct dentry *)u_dentry;
+	struct vfsmount *mnt = (struct vfsmount *)u_mnt;
+	struct dentry *realroot;
+	struct vfsmount *realrootmnt;
+	struct dentry *currentroot;
+	struct vfsmount *currentmnt;
+	int ret = 1;
+
+	read_lock(&child_reaper->fs->lock);
+	realrootmnt = mntget(child_reaper->fs->rootmnt);
+	realroot = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+
+	read_lock(&current->fs->lock);
+	currentmnt = mntget(current->fs->rootmnt);
+	currentroot = dget(current->fs->root);
+	read_unlock(&current->fs->lock);
+
+	spin_lock(&dcache_lock);
+	for (;;) {
+		if (unlikely((dentry == realroot && mnt == realrootmnt)
+		     || (dentry == currentroot && mnt == currentmnt)))
+			break;
+		if (unlikely(dentry == mnt->mnt_root || IS_ROOT(dentry))) {
+			if (mnt->mnt_parent == mnt)
+				break;
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+		dentry = dentry->d_parent;
+	}
+	spin_unlock(&dcache_lock);
+
+	dput(currentroot);
+	mntput(currentmnt);
+
+	/* access is outside of chroot */
+	if (dentry == realroot && mnt == realrootmnt)
+		ret = 0;
+
+	dput(realroot);
+	mntput(realrootmnt);
+
+	return ret;
+}
+#endif
+
+int
+gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	if (!grsec_enable_chroot_fchdir)
+		return 1;
+
+	if (!proc_is_chrooted(current))
+		return 1;
+	else if (!gr_is_outside_chroot(u_dentry, u_mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_FCHDIR_MSG, u_dentry, u_mnt);
+		return 0;
+	}
+#endif
+	return 1;
+}
+
+int
+gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	struct task_struct *p, **htable;
+
+	if (unlikely(!grsec_enable_chroot_shmat))
+		return 1;
+
+	if (likely(!proc_is_chrooted(current)))
+		return 1;
+
+	read_lock(&tasklist_lock);
+
+	htable = &pidhash[pid_hashfn(shm_cprid)];
+
+	for (p = *htable; p && p->pid != shm_cprid; p = p->pidhash_next) ;
+
+	if (p) {
+		task_lock(p);
+		if (!have_same_root(current, p) &&
+		    time_before_eq(p->start_time, shm_createtime)) {
+			task_unlock(p);
+			read_unlock(&tasklist_lock);
+			gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+			return 0;
+		}
+		task_unlock(p);
+	} else {
+		htable = &pidhash[pid_hashfn(shm_lapid)];
+		for (p = *htable; p && p->pid != shm_lapid;
+		     p = p->pidhash_next) ;
+
+		if (p) {
+			task_lock(p);
+			if (!have_same_root(current, p)) {
+				task_unlock(p);
+				read_unlock(&tasklist_lock);
+				gr_log_noargs(GR_DONT_AUDIT, GR_SHMAT_CHROOT_MSG);
+				return 0;
+			}
+			task_unlock(p);
+		}
+	}
+
+	read_unlock(&tasklist_lock);
+#endif
+	return 1;
+}
+
+void
+gr_log_chroot_exec(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	if (grsec_enable_chroot_execlog && proc_is_chrooted(current))
+		gr_log_fs_generic(GR_DO_AUDIT, GR_EXEC_CHROOT_MSG, dentry, mnt);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_mknod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && !S_ISREG(mode) &&
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_MKNOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_mount(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const char *dev_name)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+		gr_log_str_fs(GR_DONT_AUDIT, GR_MOUNT_CHROOT_MSG, dev_name, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_pivot(void)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_PIVOT_CHROOT_MSG);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_chroot_chroot(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	if (grsec_enable_chroot_double && proc_is_chrooted(current) &&
+	    !gr_is_outside_chroot(dentry, mnt)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+void
+gr_handle_chroot_caps(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+		task->cap_permitted =
+		    cap_drop(task->cap_permitted, GR_CHROOT_CAPS);
+		task->cap_inheritable =
+		    cap_drop(task->cap_inheritable, GR_CHROOT_CAPS);
+		task->cap_effective =
+		    cap_drop(task->cap_effective, GR_CHROOT_CAPS);
+	}
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_sysctl(const int op)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	if (grsec_enable_chroot_sysctl && proc_is_chrooted(current)
+	    && (op & 002))
+		return -EACCES;
+#endif
+	return 0;
+}
+
+void
+gr_handle_chroot_chdir(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	if (grsec_enable_chroot_chdir)
+		set_fs_pwd(current->fs, mnt, dentry);
+#endif
+	return;
+}
+
+int
+gr_handle_chroot_chmod(const struct dentry *dentry,
+		       const struct vfsmount *mnt, const int mode)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	if (grsec_enable_chroot_chmod &&
+	    ((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))) &&
+	    proc_is_chrooted(current)) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_CHMOD_CHROOT_MSG, dentry, mnt);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
diff -urNp linux-2.4.37.7/grsecurity/grsec_disabled.c linux-2.4.37.7/grsecurity/grsec_disabled.c
--- linux-2.4.37.7/grsecurity/grsec_disabled.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_disabled.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,401 @@
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/sysctl.h>
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+void
+pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+__u32
+gr_handle_sysctl(const struct ctl_table * table, const void *oldval, const void *newval)
+{
+	return 1;
+}
+#endif
+
+int
+gr_acl_is_enabled(void)
+{
+	return 0;
+}
+
+int
+gr_handle_rawio(const struct inode *inode)
+{
+	return 0;
+}
+
+void
+gr_acl_handle_psacct(struct task_struct *task, const long code)
+{
+	return;
+}
+
+int
+gr_handle_ptrace(struct task_struct *task, const long request)
+{
+	return 0;
+}
+
+int
+gr_handle_proc_ptrace(struct task_struct *task)
+{
+	return 0;
+}
+
+void
+gr_learn_resource(const struct task_struct *task,
+		  const int res, const unsigned long wanted, const int gt)
+{
+	return;
+}
+
+int
+gr_set_acls(const int type)
+{
+	return 0;
+}
+
+int
+gr_check_hidden_task(const struct task_struct *tsk)
+{
+	return 0;
+}
+
+int
+gr_check_protected_task(const struct task_struct *task)
+{
+	return 0;
+}
+
+void
+gr_copy_label(struct task_struct *tsk)
+{
+	return;
+}
+
+void
+gr_set_pax_flags(struct task_struct *task)
+{
+	return;
+}
+
+int
+gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return 0;
+}
+
+void
+gr_handle_delete(const ino_t ino, const __u32 dev)
+{
+	return;
+}
+
+void
+gr_handle_create(const struct dentry *dentry, const struct vfsmount *mnt)
+{
+	return;
+}
+
+void
+gr_handle_crash(struct task_struct *task, const int sig)
+{
+	return;
+}
+
+int
+gr_check_crash_exec(const struct file *filp)
+{
+	return 0;
+}
+
+int
+gr_check_crash_uid(const uid_t uid)
+{
+	return 0;
+}
+
+int
+gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry,
+		 struct dentry *new_dentry,
+		 struct vfsmount *mnt, const __u8 replace)
+{
+	return 0;
+}
+
+int
+gr_search_socket(const int family, const int type, const int protocol)
+{
+	return 1;
+}
+
+int
+gr_search_connectbind(const int mode, const struct socket *sock,
+		      const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+int
+gr_task_is_capable(struct task_struct *task, const int cap)
+{
+	return 1;
+}
+
+void
+gr_handle_alertkill(struct task_struct *task)
+{
+	return;
+}
+
+__u32
+gr_acl_handle_execve(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_hidden_file(const struct dentry * dentry,
+			  const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
+		   const int fmode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_rmdir(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_unlink(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_mmap(const struct file *file, const unsigned long prot,
+		   unsigned int *vm_flags)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_truncate(const struct dentry * dentry,
+		       const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_utime(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_access(const struct dentry * dentry,
+		     const struct vfsmount * mnt, const int fmode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_fchmod(const struct dentry * dentry, const struct vfsmount * mnt,
+		     mode_t mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chmod(const struct dentry * dentry, const struct vfsmount * mnt,
+		    mode_t mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_chown(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+void
+grsecurity_init(void)
+{
+	return;
+}
+
+__u32
+gr_acl_handle_mknod(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt,
+		    const int mode)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_mkdir(const struct dentry * new_dentry,
+		    const struct dentry * parent_dentry,
+		    const struct vfsmount * parent_mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_symlink(const struct dentry * new_dentry,
+		      const struct dentry * parent_dentry,
+		      const struct vfsmount * parent_mnt, const char *from)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_link(const struct dentry * new_dentry,
+		   const struct dentry * parent_dentry,
+		   const struct vfsmount * parent_mnt,
+		   const struct dentry * old_dentry,
+		   const struct vfsmount * old_mnt, const char *to)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_rename(const struct dentry *new_dentry,
+		     const struct dentry *parent_dentry,
+		     const struct vfsmount *parent_mnt,
+		     const struct dentry *old_dentry,
+		     const struct inode *old_parent_inode,
+		     const struct vfsmount *old_mnt, const char *newname)
+{
+	return 1;
+}
+
+int
+gr_acl_handle_filldir(const struct file *file, const char *name,
+		      const int namelen, const ino_t ino)
+{
+	return 1;
+}
+
+int
+gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+		const time_t shm_createtime, const uid_t cuid, const int shmid)
+{
+	return 1;
+}
+
+int
+gr_search_bind(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+int
+gr_search_accept(const struct socket *sock)
+{
+	return 0;
+}
+
+int
+gr_search_listen(const struct socket *sock)
+{
+	return 0;
+}
+
+int
+gr_search_connect(const struct socket *sock, const struct sockaddr_in *addr)
+{
+	return 0;
+}
+
+__u32
+gr_acl_handle_unix(const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	return 1;
+}
+
+__u32
+gr_acl_handle_creat(const struct dentry * dentry,
+		    const struct dentry * p_dentry,
+		    const struct vfsmount * p_mnt, const int fmode,
+		    const int imode)
+{
+	return 1;
+}
+
+void
+gr_acl_handle_exit(void)
+{
+	return;
+}
+
+int
+gr_acl_handle_mprotect(const struct file *file, const unsigned long prot)
+{
+	return 1;
+}
+
+void
+gr_set_role_label(const uid_t uid, const gid_t gid)
+{
+	return;
+}
+
+int
+gr_acl_handle_procpidmem(const struct task_struct *task)
+{
+	return 0;
+}
+
+int
+gr_search_udp_recvmsg(const struct sock *sk, const struct sk_buff *skb)
+{
+	return 1;
+}
+
+int
+gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr)
+{
+	return 1;
+}
+
+void
+gr_set_kernel_label(struct task_struct *task)
+{
+	return;
+}
+
+int
+gr_check_user_change(int real, int effective, int fs)
+{
+	return 0;
+}
+
+int
+gr_check_group_change(int real, int effective, int fs)
+{
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_exec.c linux-2.4.37.7/grsecurity/grsec_exec.c
--- linux-2.4.37.7/grsecurity/grsec_exec.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_exec.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,87 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/grdefs.h>
+#include <linux/grinternal.h>
+#include <linux/capability.h>
+
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+static char gr_exec_arg_buf[132];
+static DECLARE_MUTEX(gr_exec_arg_sem);
+#endif
+
+int
+gr_handle_nproc(void)
+{
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	if (grsec_enable_execve && current->user &&
+	    (atomic_read(&current->user->processes) >
+	     current->rlim[RLIMIT_NPROC].rlim_cur) &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_NPROC_MSG);
+		return -EAGAIN;
+	}
+#endif
+	return 0;
+}
+
+void
+gr_handle_exec_args(struct linux_binprm *bprm, char **argv)
+{
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	char *grarg = gr_exec_arg_buf;
+	unsigned int i, x, execlen = 0;
+	char c;
+
+	if (!((grsec_enable_execlog && grsec_enable_group &&
+	       in_group_p(grsec_audit_gid))
+	      || (grsec_enable_execlog && !grsec_enable_group)))
+		return;
+
+	down(&gr_exec_arg_sem);
+	memset(grarg, 0, sizeof(gr_exec_arg_buf));
+
+	if (unlikely(argv == NULL))
+		goto log;
+
+	for (i = 0; i < bprm->argc && execlen < 128; i++) {
+		char *p;
+		unsigned int len;
+
+		if (copy_from_user(&p, argv + i, sizeof(p)))
+			goto log;
+		if (!p)
+			goto log;
+		len = strnlen_user(p, 128 - execlen);
+		if (len > 128 - execlen)
+			len = 128 - execlen;
+		else if (len > 0)
+			len--;
+		if (copy_from_user(grarg + execlen, p, len))
+			goto log;
+
+		/* rewrite unprintable characters */
+		for (x = 0; x < len; x++) {
+			c = *(grarg + execlen + x);
+			if (c < 32 || c > 126)
+				*(grarg + execlen + x) = ' ';
+		}
+
+		execlen += len;
+		*(grarg + execlen) = ' ';
+		*(grarg + execlen + 1) = '\0';
+		execlen++;
+	}
+
+      log:
+	gr_log_fs_str(GR_DO_AUDIT, GR_EXEC_AUDIT_MSG, bprm->file->f_dentry,
+			bprm->file->f_vfsmnt, grarg);
+	up(&gr_exec_arg_sem);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_fifo.c linux-2.4.37.7/grsecurity/grsec_fifo.c
--- linux-2.4.37.7/grsecurity/grsec_fifo.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_fifo.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,22 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_fifo(const struct dentry *dentry, const struct vfsmount *mnt,
+	       const struct dentry *dir, const int flag, const int acc_mode)
+{
+#ifdef CONFIG_GRKERNSEC_FIFO
+	if (grsec_enable_fifo && S_ISFIFO(dentry->d_inode->i_mode) &&
+	    !(flag & O_EXCL) && (dir->d_inode->i_mode & S_ISVTX) &&
+	    (dentry->d_inode->i_uid != dir->d_inode->i_uid) &&
+	    (current->fsuid != dentry->d_inode->i_uid)) {
+		if (!permission(dentry->d_inode, acc_mode))
+			gr_log_fs_int2(GR_DONT_AUDIT, GR_FIFO_MSG, dentry, mnt, dentry->d_inode->i_uid, dentry->d_inode->i_gid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_fork.c linux-2.4.37.7/grsecurity/grsec_fork.c
--- linux-2.4.37.7/grsecurity/grsec_fork.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_fork.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,14 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_forkfail(const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	if (grsec_enable_forkfail)
+		gr_log_int(GR_DONT_AUDIT, GR_FAILFORK_MSG, retval);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_init.c linux-2.4.37.7/grsecurity/grsec_init.c
--- linux-2.4.37.7/grsecurity/grsec_init.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_init.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,236 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/gracl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+int grsec_enable_shm;
+int grsec_enable_link;
+int grsec_enable_dmesg;
+int grsec_enable_fifo;
+int grsec_enable_execve;
+int grsec_enable_execlog;
+int grsec_enable_signal;
+int grsec_enable_forkfail;
+int grsec_enable_time;
+int grsec_enable_audit_textrel;
+int grsec_enable_group;
+int grsec_audit_gid;
+int grsec_enable_chdir;
+int grsec_enable_audit_ipc;
+int grsec_enable_mount;
+int grsec_enable_chroot_findtask;
+int grsec_enable_chroot_mount;
+int grsec_enable_chroot_shmat;
+int grsec_enable_chroot_fchdir;
+int grsec_enable_chroot_double;
+int grsec_enable_chroot_pivot;
+int grsec_enable_chroot_chdir;
+int grsec_enable_chroot_chmod;
+int grsec_enable_chroot_mknod;
+int grsec_enable_chroot_nice;
+int grsec_enable_chroot_execlog;
+int grsec_enable_chroot_caps;
+int grsec_enable_chroot_sysctl;
+int grsec_enable_chroot_unix;
+int grsec_enable_tpe;
+int grsec_tpe_gid;
+int grsec_enable_tpe_all;
+int grsec_enable_socket_all;
+int grsec_socket_all_gid;
+int grsec_enable_socket_client;
+int grsec_socket_client_gid;
+int grsec_enable_socket_server;
+int grsec_socket_server_gid;
+int grsec_lock;
+int grsec_resource_logging;
+
+spinlock_t grsec_alert_lock = SPIN_LOCK_UNLOCKED;
+unsigned long grsec_alert_wtime = 0;
+unsigned long grsec_alert_fyet = 0;
+
+spinlock_t grsec_audit_lock = SPIN_LOCK_UNLOCKED;
+
+rwlock_t grsec_exec_file_lock = RW_LOCK_UNLOCKED;
+
+char *gr_shared_page[4][NR_CPUS];
+
+char *gr_alert_log_fmt;
+char *gr_audit_log_fmt;
+char *gr_alert_log_buf;
+char *gr_audit_log_buf;
+
+extern struct gr_arg *gr_usermode;
+extern unsigned char *gr_system_salt;
+extern unsigned char *gr_system_sum;
+
+void
+grsecurity_init(void)
+{
+	int i, j;
+
+	/* create the per-cpu shared pages */
+
+#ifdef CONFIG_X86
+	memset((char *)(0x41a + PAGE_OFFSET), 0, 36);
+#endif
+
+	for (j = 0; j < 4; j++) {
+		for (i = 0; i < NR_CPUS; i++) {
+			gr_shared_page[j][i] = (char *) get_zeroed_page(GFP_KERNEL);
+			if (!gr_shared_page[j][i]) {
+				panic("Unable to allocate grsecurity shared page");
+				return;
+			}
+		}
+	}
+
+	/* allocate log buffers */
+	gr_alert_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_alert_log_fmt) {
+		panic("Unable to allocate grsecurity alert log format buffer");
+		return;
+	}
+	gr_audit_log_fmt = kmalloc(512, GFP_KERNEL);
+	if (!gr_audit_log_fmt) {
+		panic("Unable to allocate grsecurity audit log format buffer");
+		return;
+	}
+	gr_alert_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_alert_log_buf) {
+		panic("Unable to allocate grsecurity alert log buffer");
+		return;
+	}
+	gr_audit_log_buf = (char *) get_zeroed_page(GFP_KERNEL);
+	if (!gr_audit_log_buf) {
+		panic("Unable to allocate grsecurity audit log buffer");
+		return;
+	}
+
+	/* allocate memory for authentication structure */
+	gr_usermode = kmalloc(sizeof(struct gr_arg), GFP_KERNEL);
+	gr_system_salt = kmalloc(GR_SALT_LEN, GFP_KERNEL);
+	gr_system_sum = kmalloc(GR_SHA_LEN, GFP_KERNEL);
+
+	if (!gr_usermode || !gr_system_salt || !gr_system_sum) {
+		panic("Unable to allocate grsecurity authentication structure");
+		return;
+	}
+
+#if !defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_SYSCTL_ON)
+#ifndef CONFIG_GRKERNSEC_SYSCTL
+	grsec_lock = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SHM
+	grsec_enable_shm = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	grsec_enable_audit_textrel = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	grsec_enable_group = 1;
+	grsec_audit_gid = CONFIG_GRKERNSEC_AUDIT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	grsec_enable_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	grsec_enable_audit_ipc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	grsec_enable_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+	grsec_enable_link = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	grsec_enable_dmesg = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	grsec_enable_fifo = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	grsec_enable_execve = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	grsec_enable_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	grsec_enable_signal = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	grsec_enable_forkfail = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	grsec_enable_time = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RELOG
+	grsec_resource_logging = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	grsec_enable_chroot_findtask = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	grsec_enable_chroot_unix = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	grsec_enable_chroot_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	grsec_enable_chroot_fchdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	grsec_enable_chroot_shmat = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	grsec_enable_chroot_double = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	grsec_enable_chroot_pivot = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	grsec_enable_chroot_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	grsec_enable_chroot_chmod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	grsec_enable_chroot_mknod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	grsec_enable_chroot_nice = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	grsec_enable_chroot_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	grsec_enable_chroot_caps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	grsec_enable_chroot_sysctl = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	grsec_enable_tpe = 1;
+	grsec_tpe_gid = CONFIG_GRKERNSEC_TPE_GID;
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	grsec_enable_tpe_all = 1;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	grsec_enable_socket_all = 1;
+	grsec_socket_all_gid = CONFIG_GRKERNSEC_SOCKET_ALL_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	grsec_enable_socket_client = 1;
+	grsec_socket_client_gid = CONFIG_GRKERNSEC_SOCKET_CLIENT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	grsec_enable_socket_server = 1;
+	grsec_socket_server_gid = CONFIG_GRKERNSEC_SOCKET_SERVER_GID;
+#endif
+#endif
+
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_ipc.c linux-2.4.37.7/grsecurity/grsec_ipc.c
--- linux-2.4.37.7/grsecurity/grsec_ipc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_ipc.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,81 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/ipc.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_msgget(const int ret, const int msgflg)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (ret >= 0)
+	    && (msgflg & IPC_CREAT))
+		gr_log_noargs(GR_DO_AUDIT, GR_MSGQ_AUDIT_MSG);
+#endif
+	return;
+}
+
+void
+gr_log_msgrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_MSGQR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
+
+void
+gr_log_semget(const int err, const int semflg)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (err >= 0)
+	    && (semflg & IPC_CREAT))
+		gr_log_noargs(GR_DO_AUDIT, GR_SEM_AUDIT_MSG);
+#endif
+	return;
+}
+
+void
+gr_log_semrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_SEMR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
+
+void
+gr_log_shmget(const int err, const int shmflg, const size_t size)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if (((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	      grsec_enable_audit_ipc) || (grsec_enable_audit_ipc &&
+					  !grsec_enable_group)) && (err >= 0)
+	    && (shmflg & IPC_CREAT))
+		gr_log_int(GR_DO_AUDIT, GR_SHM_AUDIT_MSG, size);
+#endif
+	return;
+}
+
+void
+gr_log_shmrm(const uid_t uid, const uid_t cuid)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	if ((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	     grsec_enable_audit_ipc) ||
+	    (grsec_enable_audit_ipc && !grsec_enable_group))
+		gr_log_int_int(GR_DO_AUDIT, GR_SHMR_AUDIT_MSG, uid, cuid);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_link.c linux-2.4.37.7/grsecurity/grsec_link.c
--- linux-2.4.37.7/grsecurity/grsec_link.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_link.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,39 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+
+int
+gr_handle_follow_link(const struct inode *parent,
+		      const struct inode *inode,
+		      const struct dentry *dentry, const struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	if (grsec_enable_link && S_ISLNK(inode->i_mode) &&
+	    (parent->i_mode & S_ISVTX) && (parent->i_uid != inode->i_uid) &&
+	    (parent->i_mode & S_IWOTH) && (current->fsuid != inode->i_uid)) {
+		gr_log_fs_int2(GR_DONT_AUDIT, GR_SYMLINK_MSG, dentry, mnt, inode->i_uid, inode->i_gid);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_hardlink(const struct dentry *dentry,
+		   const struct vfsmount *mnt,
+		   struct inode *inode, const int mode, const char *to)
+{
+#ifdef CONFIG_GRKERNSEC_LINK
+	if (grsec_enable_link && current->fsuid != inode->i_uid &&
+	    (!S_ISREG(mode) || (mode & S_ISUID) ||
+	     ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) ||
+	     (permission(inode, MAY_READ | MAY_WRITE))) &&
+	    !capable(CAP_FOWNER) && current->uid) {
+		gr_log_fs_int2_str(GR_DONT_AUDIT, GR_HARDLINK_MSG, dentry, mnt, inode->i_uid, inode->i_gid, to);
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_log.c linux-2.4.37.7/grsecurity/grsec_log.c
--- linux-2.4.37.7/grsecurity/grsec_log.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_log.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,271 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/grinternal.h>
+
+#define BEGIN_LOCKS(x) \
+	read_lock(&tasklist_lock); \
+	read_lock(&grsec_exec_file_lock); \
+	if (x != GR_DO_AUDIT) \
+		spin_lock(&grsec_alert_lock); \
+	else \
+		spin_lock(&grsec_audit_lock)
+
+#define END_LOCKS(x) \
+	if (x != GR_DO_AUDIT) \
+		spin_unlock(&grsec_alert_lock); \
+	else \
+		spin_unlock(&grsec_audit_lock); \
+	read_unlock(&grsec_exec_file_lock); \
+	read_unlock(&tasklist_lock); \
+	if (x == GR_DONT_AUDIT) \
+		gr_handle_alertkill(current)
+
+enum {
+	FLOODING,
+	NO_FLOODING
+};
+
+extern char *gr_alert_log_fmt;
+extern char *gr_audit_log_fmt;
+extern char *gr_alert_log_buf;
+extern char *gr_audit_log_buf;
+
+static int gr_log_start(int audit)
+{
+	char *loglevel = (audit == GR_DO_AUDIT) ? KERN_INFO : KERN_ALERT;
+	char *fmt = (audit == GR_DO_AUDIT) ? gr_audit_log_fmt : gr_alert_log_fmt;
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+
+	if (audit == GR_DO_AUDIT)
+		goto set_fmt;
+
+	if (!grsec_alert_wtime || jiffies - grsec_alert_wtime > CONFIG_GRKERNSEC_FLOODTIME * HZ) {
+		grsec_alert_wtime = jiffies;
+		grsec_alert_fyet = 0;
+	} else if ((jiffies - grsec_alert_wtime < CONFIG_GRKERNSEC_FLOODTIME * HZ) && (grsec_alert_fyet < CONFIG_GRKERNSEC_FLOODBURST)) {
+		grsec_alert_fyet++;
+	} else if (grsec_alert_fyet == CONFIG_GRKERNSEC_FLOODBURST) {
+		grsec_alert_wtime = jiffies;
+		grsec_alert_fyet++;
+		printk(KERN_ALERT "grsec: more alerts, logging disabled for %d seconds\n", CONFIG_GRKERNSEC_FLOODTIME);
+		return FLOODING;
+	} else return FLOODING;
+
+set_fmt:
+	memset(buf, 0, PAGE_SIZE);
+	if (current->curr_ip && gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %u.%u.%u.%u: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, NIPQUAD(current->curr_ip), current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else if (current->curr_ip) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: From %u.%u.%u.%u: ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, NIPQUAD(current->curr_ip));
+	} else if (gr_acl_is_enabled()) {
+		sprintf(fmt, "%s%s", loglevel, "grsec: (%.64s:%c:%.950s) ");
+		snprintf(buf, PAGE_SIZE - 1, fmt, current->role->rolename, gr_roletype_to_char(), current->acl->filename);
+	} else {
+		sprintf(fmt, "%s%s", loglevel, "grsec: ");
+		strcpy(buf, fmt);
+	}
+
+	return NO_FLOODING;
+}
+
+static void gr_log_middle(int audit, const char *msg, va_list ap)
+	__attribute__ ((format (printf, 2, 0)));
+
+static void gr_log_middle(int audit, const char *msg, va_list ap)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+
+	return;
+}
+static void gr_log_middle_varargs(int audit, const char *msg, ...)
+	__attribute__ ((format (printf, 2, 3)));
+
+static void gr_log_middle_varargs(int audit, const char *msg, ...)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+	va_list ap;
+
+	va_start(ap, msg);
+	vsnprintf(buf + len, PAGE_SIZE - len - 1, msg, ap);
+	va_end(ap);
+
+	return;
+}
+
+static void gr_log_end(int audit)
+{
+	char *buf = (audit == GR_DO_AUDIT) ? gr_audit_log_buf : gr_alert_log_buf;
+	unsigned int len = strlen(buf);
+
+	snprintf(buf + len, PAGE_SIZE - len - 1, DEFAULTSECMSG, DEFAULTSECARGS(current));
+	printk("%s\n", buf);
+
+	return;
+}
+
+void gr_log_varargs(int audit, const char *msg, int argtypes, ...)
+{
+	int logtype;
+	char *result = (audit == GR_DO_AUDIT) ? "successful" : "denied";
+	char *str1, *str2, *str3;
+	int num1, num2;
+	unsigned long ulong1, ulong2;
+	struct dentry *dentry;
+	struct vfsmount *mnt;
+	struct file *file;
+	struct task_struct *task;
+	va_list ap;
+
+	BEGIN_LOCKS(audit);
+	logtype = gr_log_start(audit);
+	if (logtype == FLOODING) {
+		END_LOCKS(audit);
+		return;
+	}
+	va_start(ap, argtypes);
+	switch (argtypes) {
+	case GR_TTYSNIFF:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, NIPQUAD(task->curr_ip), gr_task_fullpath0(task), task->comm, task->pid, gr_parent_task_fullpath0(task), task->p_pptr->comm, task->p_pptr->pid);
+		break;
+	case GR_RBAC:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_STR_RBAC:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, result, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_RBAC_MODE2:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2);
+		break;
+	case GR_RBAC_MODE3:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		str2 = va_arg(ap, char *);
+		str3 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, result, gr_to_filename(dentry, mnt), str1, str2, str3);
+		break;
+	case GR_FILENAME:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt));
+		break;
+	case GR_STR_FILENAME:
+		str1 = va_arg(ap, char *);
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		gr_log_middle_varargs(audit, msg, str1, gr_to_filename(dentry, mnt));
+		break;
+	case GR_FILENAME_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), str1);
+		break;
+	case GR_FILENAME_TWO_INT:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2);
+		break;
+	case GR_FILENAME_TWO_INT_STR:
+		dentry = va_arg(ap, struct dentry *);
+		mnt = va_arg(ap, struct vfsmount *);
+		num1 = va_arg(ap, int);
+		num2 = va_arg(ap, int);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, gr_to_filename(dentry, mnt), num1, num2, str1);
+		break;
+	case GR_TEXTREL:
+		file = va_arg(ap, struct file *);
+		ulong1 = va_arg(ap, unsigned long);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, file ? gr_to_filename(file->f_dentry, file->f_vfsmnt) : "<anonymous mapping>", ulong1, ulong2);
+		break;
+	case GR_PTRACE:
+		task = va_arg(ap, struct task_struct *);
+		gr_log_middle_varargs(audit, msg, task->exec_file ? gr_to_filename(task->exec_file->f_dentry, task->exec_file->f_vfsmnt) : "(none)", task->comm, task->pid);
+		break;
+	case GR_RESOURCE:
+		task = va_arg(ap, struct task_struct *);
+		ulong1 = va_arg(ap, unsigned long);
+		str1 = va_arg(ap, char *);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, ulong1, str1, ulong2, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->p_pptr->comm, task->p_pptr->pid, task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid);
+		break;
+	case GR_CAP:
+		task = va_arg(ap, struct task_struct *);
+		str1 = va_arg(ap, char *);
+		gr_log_middle_varargs(audit, msg, str1, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->p_pptr->comm, task->p_pptr->pid, task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid);
+		break;
+	case GR_SIG:
+		task = va_arg(ap, struct task_struct *);
+		num1 = va_arg(ap, int);
+		gr_log_middle_varargs(audit, msg, num1, gr_task_fullpath0(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath0(task), task->p_pptr->comm, task->p_pptr->pid, task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid);
+		break;
+	case GR_CRASH1:
+		task = va_arg(ap, struct task_struct *);
+		ulong1 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->p_pptr->comm, task->p_pptr->pid, task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid, task->uid, ulong1);
+		break;
+	case GR_CRASH2:
+		task = va_arg(ap, struct task_struct *);
+		str1 = va_arg(ap, char *);
+		ulong1 = va_arg(ap, unsigned long);
+		ulong2 = va_arg(ap, unsigned long);
+		gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, task->uid, task->euid, task->gid, task->egid, gr_parent_task_fullpath(task), task->p_pptr->comm, task->p_pptr->pid, task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid, task->uid, str1, ulong1, ulong2);
+		break;
+	case GR_PSACCT:
+		{
+			unsigned int wday, cday;
+			__u8 whr, chr;
+			__u8 wmin, cmin;
+			__u8 wsec, csec;
+			char cur_tty[64] = { 0 };
+			char parent_tty[64] = { 0 };
+
+			task = va_arg(ap, struct task_struct *);
+			wday = va_arg(ap, unsigned int);
+			cday = va_arg(ap, unsigned int);
+			whr = va_arg(ap, int);
+			chr = va_arg(ap, int);
+			wmin = va_arg(ap, int);
+			cmin = va_arg(ap, int);
+			wsec = va_arg(ap, int);
+			csec = va_arg(ap, int);
+			ulong1 = va_arg(ap, unsigned long);
+
+			gr_log_middle_varargs(audit, msg, gr_task_fullpath(task), task->comm, task->pid, NIPQUAD(task->curr_ip), tty_name(task->tty, cur_tty), task->uid, task->euid, task->gid, task->egid, wday, whr, wmin, wsec, cday, chr, cmin, csec, (task->flags & PF_SIGNALED) ? "killed by signal" : "exited", ulong1, gr_parent_task_fullpath(task), task->p_pptr->comm, task->p_pptr->pid, NIPQUAD(task->p_pptr->curr_ip), tty_name(task->p_pptr->tty, parent_tty), task->p_pptr->uid, task->p_pptr->euid, task->p_pptr->gid, task->p_pptr->egid);
+		}
+		break;
+	default:
+		gr_log_middle(audit, msg, ap);
+	}
+	va_end(ap);
+	gr_log_end(audit);
+	END_LOCKS(audit);
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_mem.c linux-2.4.37.7/grsecurity/grsec_mem.c
--- linux-2.4.37.7/grsecurity/grsec_mem.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_mem.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,70 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/grinternal.h>
+
+void
+gr_handle_ioperm(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPERM_MSG);
+	return;
+}
+
+void
+gr_handle_iopl(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_IOPL_MSG);
+	return;
+}
+
+void
+gr_handle_mem_write(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_MEM_WRITE_MSG);
+	return;
+}
+
+void
+gr_handle_kmem_write(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_KMEM_MSG);
+	return;
+}
+
+void
+gr_handle_open_port(void)
+{
+	gr_log_noargs(GR_DONT_AUDIT, GR_PORT_OPEN_MSG);
+	return;
+}
+
+int
+gr_handle_mem_mmap(const unsigned long offset, struct vm_area_struct *vma)
+{
+	unsigned long start, end;
+
+	start = offset;
+	end = start + vma->vm_end - vma->vm_start;
+
+	if (start > end) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_MEM_MMAP_MSG);
+		return -EPERM;
+	}
+
+	/* allowed ranges : ISA I/O BIOS */
+	if ((start >= __pa(high_memory))
+#ifdef CONFIG_X86
+	    || (start >= 0x000a0000 && end <= 0x00100000)
+	    || (start >= 0x00000000 && end <= 0x00001000)
+#endif
+	)
+		return 0;
+
+	if (vma->vm_flags & VM_WRITE) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_MEM_MMAP_MSG);
+		return -EPERM;
+	} else
+		vma->vm_flags &= ~VM_MAYWRITE;
+
+	return 0;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_mount.c linux-2.4.37.7/grsecurity/grsec_mount.c
--- linux-2.4.37.7/grsecurity/grsec_mount.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_mount.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,34 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_remount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_REMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_unmount(const char *devname, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str(GR_DO_AUDIT, GR_UNMOUNT_AUDIT_MSG, devname ? devname : "none");
+#endif
+	return;
+}
+
+void
+gr_log_mount(const char *from, const char *to, const int retval)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	if (grsec_enable_mount && (retval >= 0))
+		gr_log_str_str(GR_DO_AUDIT, GR_MOUNT_AUDIT_MSG, from, to);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_sig.c linux-2.4.37.7/grsecurity/grsec_sig.c
--- linux-2.4.37.7/grsecurity/grsec_sig.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_sig.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,58 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_signal(const int sig, const struct task_struct *t)
+{
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	if (grsec_enable_signal && ((sig == SIGSEGV) || (sig == SIGILL) ||
+				    (sig == SIGABRT) || (sig == SIGBUS))) {
+		if (t->pid == current->pid) {
+			gr_log_int(GR_DONT_AUDIT_GOOD, GR_UNISIGLOG_MSG, sig);
+		} else {
+			gr_log_sig(GR_DONT_AUDIT_GOOD, GR_DUALSIGLOG_MSG, t, sig);
+		}
+	}
+#endif
+	return;
+}
+
+int
+gr_handle_signal(const struct task_struct *p, const int sig)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (current->pid > 1 && sig != SIGCHLD && gr_check_protected_task(p)) {
+		gr_log_sig(GR_DONT_AUDIT, GR_SIG_ACL_MSG, p, sig);
+		return -EPERM;
+	} else if (gr_pid_is_chrooted((struct task_struct *)p)) {
+		return -EPERM;
+	}
+#endif
+	return 0;
+}
+
+void gr_handle_brute_attach(struct task_struct *p)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	read_lock(&tasklist_lock);
+	read_lock(&grsec_exec_file_lock);
+	if (p->p_pptr && p->p_pptr->exec_file == p->exec_file)
+		p->p_pptr->brute = 1;
+	read_unlock(&grsec_exec_file_lock);
+	read_unlock(&tasklist_lock);
+#endif
+	return;
+}
+
+void gr_handle_brute_check(void)
+{
+#ifdef CONFIG_GRKERNSEC_BRUTE
+	if (current->brute) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(30 * HZ);
+	}	
+#endif
+	return;
+}
+
diff -urNp linux-2.4.37.7/grsecurity/grsec_sock.c linux-2.4.37.7/grsecurity/grsec_sock.c
--- linux-2.4.37.7/grsecurity/grsec_sock.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_sock.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,238 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <net/sock.h>
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+#include <linux/gracl.h>
+
+#ifdef CONFIG_GRKERNSEC
+#define gr_conn_table_size 32749
+struct conn_table_entry {
+	struct conn_table_entry *next;
+	struct task_struct *task;
+};
+
+struct conn_table_entry *gr_conn_table[gr_conn_table_size];
+spinlock_t gr_conn_table_lock = SPIN_LOCK_UNLOCKED;
+
+extern const char * gr_socktype_to_name(unsigned char type);
+extern const char * gr_proto_to_name(unsigned char proto);
+
+static __inline__ int 
+conn_hash(__u32 saddr, __u32 daddr, __u16 sport, __u16 dport, unsigned int size)
+{
+	return ((daddr + saddr + (sport << 8) + (dport << 16)) % size);
+}
+
+static __inline__ int
+conn_match(const struct task_struct *task, __u32 saddr, __u32 daddr, 
+	   __u16 sport, __u16 dport)
+{
+	if (unlikely(task->gr_saddr == saddr && task->gr_daddr == daddr &&
+		     task->gr_sport == sport && task->gr_dport == dport))
+		return 1;
+	else
+		return 0;
+}
+
+static void gr_add_to_task_ip_table_nolock(struct task_struct *task, struct conn_table_entry *newent)
+{
+	struct conn_table_entry **match;
+	unsigned int index;
+
+	index = conn_hash(task->gr_saddr, task->gr_daddr,
+			  task->gr_sport, task->gr_dport, 
+			  gr_conn_table_size);
+
+
+	newent->task = task;
+
+	match = &gr_conn_table[index];
+	newent->next = *match;
+	*match = newent;
+
+	return;
+}
+
+void gr_del_task_from_ip_table_nolock(struct task_struct *task)
+{
+	struct conn_table_entry *match, *last = NULL;
+	unsigned int index;
+
+	index = conn_hash(task->gr_saddr, task->gr_daddr, 
+			  task->gr_sport, task->gr_dport, 
+			  gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->task, 
+		task->gr_saddr, task->gr_daddr, task->gr_sport, 
+		task->gr_dport)) {
+		last = match;
+		match = match->next;
+	}
+
+	if (match) {
+		if (last)
+			last->next = match->next;
+		else
+			gr_conn_table[index] = NULL;
+		kfree(match);
+	}
+
+	return;
+}
+
+struct task_struct * gr_lookup_task_ip_table(__u32 saddr, __u32 daddr,
+					     __u16 sport, __u16 dport)
+{
+	struct conn_table_entry *match;
+	unsigned int index;
+
+	index = conn_hash(saddr, daddr, sport, dport, gr_conn_table_size);
+
+	match = gr_conn_table[index];
+	while (match && !conn_match(match->task, saddr, daddr, sport, dport))
+		match = match->next;
+
+	if (match)
+		return match->task;
+	else
+		return NULL;
+}
+
+#endif
+
+void gr_update_task_in_ip_table(struct task_struct *task, const struct sock *sk)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct conn_table_entry *newent;
+
+	newent = kmalloc(sizeof(struct conn_table_entry), GFP_ATOMIC);
+	if (newent == NULL)
+		return;
+	/* no bh lock needed since we are called with bh disabled */
+	spin_lock(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(task);
+	task->gr_saddr = sk->rcv_saddr;
+	task->gr_daddr = sk->daddr;
+	task->gr_sport = sk->sport;
+	task->gr_dport = sk->dport;
+	gr_add_to_task_ip_table_nolock(task, newent);
+	spin_unlock(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void gr_del_task_from_ip_table(struct task_struct *task)
+{
+#ifdef CONFIG_GRKERNSEC
+	spin_lock_bh(&gr_conn_table_lock);
+	gr_del_task_from_ip_table_nolock(task);
+	spin_unlock_bh(&gr_conn_table_lock);
+#endif
+	return;
+}
+
+void
+gr_attach_curr_ip(const struct sock *sk)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct task_struct *p;
+
+	if (unlikely(sk->protocol != IPPROTO_TCP))
+		return;
+
+	spin_lock_bh(&gr_conn_table_lock);
+	p = gr_lookup_task_ip_table(sk->daddr, sk->rcv_saddr,
+				    sk->dport, sk->sport);
+	if (unlikely(p != NULL)) {
+		current->curr_ip = p->curr_ip;
+		current->used_accept = 1;
+		gr_del_task_from_ip_table_nolock(p);
+		spin_unlock_bh(&gr_conn_table_lock);
+		return;
+	}
+	spin_unlock_bh(&gr_conn_table_lock);
+
+	current->curr_ip = sk->daddr;
+	current->used_accept = 1;
+#endif
+	return;
+}
+
+int
+gr_handle_sock_all(const int family, const int type, const int protocol)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	if (grsec_enable_socket_all && in_group_p(grsec_socket_all_gid) &&
+	    (family != AF_UNIX) && (family != AF_LOCAL) && (type < SOCK_MAX)) {
+		gr_log_int_str2(GR_DONT_AUDIT, GR_SOCK2_MSG, family, gr_socktype_to_name(type), gr_proto_to_name(protocol));
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_server_other(const struct sock *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	if (grsec_enable_socket_server &&
+	    in_group_p(grsec_socket_server_gid) &&
+	    sck && (sck->family != AF_UNIX) &&
+	    (sck->family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_BIND_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+int
+gr_handle_sock_client(const struct sockaddr *sck)
+{
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	if (grsec_enable_socket_client && in_group_p(grsec_socket_client_gid) &&
+	    sck && (sck->sa_family != AF_UNIX) &&
+	    (sck->sa_family != AF_LOCAL)) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_CONNECT_MSG);
+		return -EACCES;
+	}
+#endif
+	return 0;
+}
+
+__u32
+gr_cap_rtnetlink(void)
+{
+#ifdef CONFIG_GRKERNSEC
+	if (!gr_acl_is_enabled())
+		return current->cap_effective;
+	else if (cap_raised(current->cap_effective, CAP_NET_ADMIN) &&
+		 gr_task_is_capable(current, CAP_NET_ADMIN))
+		return current->cap_effective;
+	else {
+		printk("Returning 0 for rtnetlink!\n");
+		return 0;
+	}
+#else
+	return current->cap_effective;
+#endif
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_sysctl.c linux-2.4.37.7/grsecurity/grsec_sysctl.c
--- linux-2.4.37.7/grsecurity/grsec_sysctl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_sysctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,39 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/sysctl.h>
+#include <linux/grinternal.h>
+
+#ifdef CONFIG_GRKERNSEC_MODSTOP
+int grsec_modstop;
+#endif
+
+int
+gr_handle_sysctl_mod(const char *dirname, const char *name, const int op)
+{
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+	if (!strcmp(dirname, "grsecurity") && grsec_lock && (op & 002)) {
+		gr_log_str(GR_DONT_AUDIT, GR_SYSCTL_MSG, name);
+		return -EACCES;
+	}
+#endif
+#ifdef CONFIG_GRKERNSEC_MODSTOP
+	if (!strcmp(dirname, "grsecurity") && !strcmp(name, "disable_modules") &&
+	    grsec_modstop && (op & 002)) {
+		gr_log_str(GR_DONT_AUDIT, GR_SYSCTL_MSG, name);
+		return -EACCES;
+	}
+#endif
+		
+	return 0;
+}
+
+int gr_check_modstop(void)
+{
+#ifdef CONFIG_GRKERNSEC_MODSTOP
+	if (grsec_modstop != 0) {
+		gr_log_noargs(GR_DONT_AUDIT, GR_STOPMOD_MSG);
+		return 1;
+	}
+#endif
+	return 0;
+}	
diff -urNp linux-2.4.37.7/grsecurity/grsec_textrel.c linux-2.4.37.7/grsecurity/grsec_textrel.c
--- linux-2.4.37.7/grsecurity/grsec_textrel.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_textrel.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,16 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/grinternal.h>
+#include <linux/grsecurity.h>
+
+void
+gr_log_textrel(struct vm_area_struct * vma)
+{
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	if (grsec_enable_audit_textrel)
+		gr_log_textrel_ulong_ulong(GR_DO_AUDIT, GR_TEXTREL_AUDIT_MSG, vma->vm_file, vma->vm_start, vma->vm_pgoff);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_time.c linux-2.4.37.7/grsecurity/grsec_time.c
--- linux-2.4.37.7/grsecurity/grsec_time.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_time.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,13 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/grinternal.h>
+
+void
+gr_log_timechange(void)
+{
+#ifdef CONFIG_GRKERNSEC_TIME
+	if (grsec_enable_time)
+		gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_TIME_MSG);
+#endif
+	return;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsec_tpe.c linux-2.4.37.7/grsecurity/grsec_tpe.c
--- linux-2.4.37.7/grsecurity/grsec_tpe.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsec_tpe.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,37 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/grinternal.h>
+
+extern int gr_acl_tpe_check(void);
+
+int
+gr_tpe_allow(const struct file *file)
+{
+#ifdef CONFIG_GRKERNSEC
+	struct inode *inode = file->f_dentry->d_parent->d_inode;
+
+	if (current->uid && ((grsec_enable_tpe &&
+#ifdef CONFIG_GRKERNSEC_TPE_INVERT
+	    !in_group_p(grsec_tpe_gid)
+#else
+	    in_group_p(grsec_tpe_gid)
+#endif
+	    ) || gr_acl_tpe_check()) &&
+	    (inode->i_uid || (!inode->i_uid && ((inode->i_mode & S_IWGRP) ||
+						(inode->i_mode & S_IWOTH))))) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	}
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	if (current->uid && grsec_enable_tpe && grsec_enable_tpe_all &&
+	    ((inode->i_uid && (inode->i_uid != current->uid)) ||
+	     (inode->i_mode & S_IWGRP) || (inode->i_mode & S_IWOTH))) {
+		gr_log_fs_generic(GR_DONT_AUDIT, GR_EXEC_TPE_MSG, file->f_dentry, file->f_vfsmnt);
+		return 0;
+	}
+#endif
+#endif
+	return 1;
+}
diff -urNp linux-2.4.37.7/grsecurity/grsum.c linux-2.4.37.7/grsecurity/grsum.c
--- linux-2.4.37.7/grsecurity/grsum.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/grsum.c	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,59 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+#include <linux/crypto.h>
+#include <linux/gracl.h>
+
+
+#if !defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE) || !defined(CONFIG_CRYPTO_SHA256) || defined(CONFIG_CRYPTO_SHA256_MODULE)
+#error "crypto and sha256 must be built into the kernel"
+#endif
+
+int
+chkpw(struct gr_arg *entry, unsigned char *salt, unsigned char *sum)
+{
+	char *p;
+	struct crypto_tfm *tfm;
+	unsigned char temp_sum[GR_SHA_LEN];
+	struct scatterlist sg[2];
+	volatile int retval = 0;
+	volatile int dummy = 0;
+	unsigned int i;
+
+	tfm = crypto_alloc_tfm("sha256", 0);
+	if (tfm == NULL) {
+		/* should never happen, since sha256 should be built in */
+		return 1;
+	}
+
+	crypto_digest_init(tfm);
+
+	p = salt;
+	sg[0].page = virt_to_page(p);
+	sg[0].offset = ((long) p & ~PAGE_MASK);
+	sg[0].length = GR_SALT_LEN;
+	
+	crypto_digest_update(tfm, sg, 1);
+
+	p = entry->pw;
+	sg[0].page = virt_to_page(p);
+	sg[0].offset = ((long) p & ~PAGE_MASK);
+	sg[0].length = strlen(entry->pw);
+
+	crypto_digest_update(tfm, sg, 1);
+
+	crypto_digest_final(tfm, temp_sum);
+
+	memset(entry->pw, 0, GR_PW_LEN);
+
+	for (i = 0; i < GR_SHA_LEN; i++)
+		if (sum[i] != temp_sum[i])
+			retval = 1;
+		else
+			dummy = 1;	// waste a cycle
+
+	crypto_free_tfm(tfm);
+
+	return retval;
+}
diff -urNp linux-2.4.37.7/grsecurity/Makefile linux-2.4.37.7/grsecurity/Makefile
--- linux-2.4.37.7/grsecurity/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/grsecurity/Makefile	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,24 @@
+# grsecurity's ACL system was originally written in 2001 by Michael Dalton
+# during 2001-2005 it has been completely redesigned by Brad Spengler
+# into an RBAC system
+#
+# All code in this directory and various hooks inserted throughout the kernel
+# are copyright Brad Spengler - Open Source Security, Inc., and released 
+# under the GPL v2 or higher
+
+O_TARGET := grsec.o
+
+obj-y = grsec_chdir.o grsec_chroot.o grsec_exec.o grsec_fifo.o grsec_fork.o \
+	grsec_mount.o grsec_sig.o grsec_sock.o grsec_sysctl.o \
+	grsec_time.o grsec_tpe.o grsec_ipc.o grsec_link.o
+
+ifeq ($(CONFIG_GRKERNSEC),y)
+obj-y += grsec_init.o grsum.o gracl.o gracl_ip.o gracl_segv.o \
+	gracl_cap.o gracl_alloc.o gracl_shm.o grsec_mem.o gracl_fs.o \
+	gracl_learn.o grsec_textrel.o grsec_log.o
+obj-$(CONFIG_GRKERNSEC_RESLOG) += gracl_res.o
+else
+obj-y += grsec_disabled.o
+endif
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-2.4.37.7/include/asm-alpha/a.out.h linux-2.4.37.7/include/asm-alpha/a.out.h
--- linux-2.4.37.7/include/asm-alpha/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-alpha/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -98,7 +98,7 @@ struct exec
 	set_personality (((BFPM->sh_bang || EX.ah.entry < 0x100000000 \
 			   ? ADDR_LIMIT_32BIT : 0) | PER_OSF4))
 
-#define STACK_TOP \
+#define __STACK_TOP \
   (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
 
 #endif
diff -urNp linux-2.4.37.7/include/asm-alpha/elf.h linux-2.4.37.7/include/asm-alpha/elf.h
--- linux-2.4.37.7/include/asm-alpha/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-alpha/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -41,6 +41,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x1000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality & ADDR_LIMIT_32BIT ? 0x10000 : 0x120000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_STACK_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 19)
+#endif
+
 /* $0 is set by ld.so to a pointer to a function which might be 
    registered using atexit.  This provides a mean for the dynamic
    linker to call DT_FINI functions for shared libraries that have
diff -urNp linux-2.4.37.7/include/asm-alpha/kmap_types.h linux-2.4.37.7/include/asm-alpha/kmap_types.h
--- linux-2.4.37.7/include/asm-alpha/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-alpha/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-alpha/page.h linux-2.4.37.7/include/asm-alpha/page.h
--- linux-2.4.37.7/include/asm-alpha/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-alpha/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -101,6 +101,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS		(VM_READ | VM_WRITE | VM_EXEC | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _ALPHA_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-alpha/pgtable.h linux-2.4.37.7/include/asm-alpha/pgtable.h
--- linux-2.4.37.7/include/asm-alpha/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-alpha/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -96,6 +96,17 @@
 #define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)
 #define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
 #define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOE)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)
 
 #define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))
diff -urNp linux-2.4.37.7/include/asm-i386/a.out.h linux-2.4.37.7/include/asm-i386/a.out.h
--- linux-2.4.37.7/include/asm-i386/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -19,7 +19,11 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#ifdef CONFIG_PAX_SEGMEXEC
+#define __STACK_TOP ((current->mm->pax_flags & MF_PAX_SEGMEXEC)?TASK_SIZE/2:TASK_SIZE)
+#else
+#define __STACK_TOP TASK_SIZE
+#endif
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-i386/checksum.h linux-2.4.37.7/include/asm-i386/checksum.h
--- linux-2.4.37.7/include/asm-i386/checksum.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/checksum.h	2009-11-10 19:30:27.000000000 -0500
@@ -27,6 +27,12 @@ asmlinkage unsigned int csum_partial(con
 asmlinkage unsigned int csum_partial_copy_generic( const char *src, char *dst, int len, int sum,
 						   int *src_err_ptr, int *dst_err_ptr);
 
+asmlinkage unsigned int csum_partial_copy_generic_to_user( const char *src, char *dst, int len, int sum,
+						   int *src_err_ptr, int *dst_err_ptr);
+
+asmlinkage unsigned int csum_partial_copy_generic_from_user( const char *src, char *dst, int len, int sum,
+						   int *src_err_ptr, int *dst_err_ptr);
+
 /*
  *	Note: when you get a NULL pointer exception here this means someone
  *	passed in an incorrect kernel address to one of these functions.
@@ -45,7 +51,7 @@ static __inline__
 unsigned int csum_partial_copy_from_user ( const char *src, char *dst,
 						int len, int sum, int *err_ptr)
 {
-	return csum_partial_copy_generic ( src, dst, len, sum, err_ptr, NULL);
+	return csum_partial_copy_generic_from_user ( src, dst, len, sum, err_ptr, NULL);
 }
 
 /*
@@ -185,7 +191,7 @@ static __inline__ unsigned int csum_and_
 				    int len, int sum, int *err_ptr)
 {
 	if (access_ok(VERIFY_WRITE, dst, len))
-		return csum_partial_copy_generic(src, dst, len, sum, NULL, err_ptr);
+		return csum_partial_copy_generic_to_user(src, dst, len, sum, NULL, err_ptr);
 
 	if (len)
 		*err_ptr = -EFAULT;
diff -urNp linux-2.4.37.7/include/asm-i386/desc.h linux-2.4.37.7/include/asm-i386/desc.h
--- linux-2.4.37.7/include/asm-i386/desc.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/desc.h	2009-11-10 19:30:27.000000000 -0500
@@ -46,7 +46,8 @@ struct desc_struct {
 };
 
 extern struct desc_struct gdt_table[];
-extern struct desc_struct *idt, *gdt;
+extern struct desc_struct gdt_table2[];
+extern struct desc_struct *idt, *gdt, *gdt2;
 
 struct Xgt_desc_struct {
 	unsigned short size;
@@ -55,6 +56,7 @@ struct Xgt_desc_struct {
 
 #define idt_descr (*(struct Xgt_desc_struct *)((char *)&idt - 2))
 #define gdt_descr (*(struct Xgt_desc_struct *)((char *)&gdt - 2))
+#define gdt_descr2 (*(struct Xgt_desc_struct *)((char *)&gdt2 - 2))
 
 #define load_TR(n) __asm__ __volatile__("ltr %%ax"::"a" (__TSS(n)<<3))
 
@@ -64,10 +66,10 @@ struct Xgt_desc_struct {
  * This is the ldt that every process will get unless we need
  * something other than this.
  */
-extern struct desc_struct default_ldt[];
-extern void set_intr_gate(unsigned int irq, void * addr);
-extern void set_ldt_desc(unsigned int n, void *addr, unsigned int size);
-extern void set_tss_desc(unsigned int n, void *addr);
+extern const struct desc_struct default_ldt[];
+extern void set_intr_gate(unsigned int irq, const void * addr);
+extern void set_ldt_desc(unsigned int n, const void *addr, unsigned int size);
+extern void set_tss_desc(unsigned int n, const void *addr);
 
 static inline void clear_LDT(void)
 {
@@ -82,7 +84,7 @@ static inline void clear_LDT(void)
 static inline void load_LDT (mm_context_t *pc)
 {
 	int cpu = smp_processor_id();
-	void *segments = pc->ldt;
+	const void *segments = pc->ldt;
 	int count = pc->size;
 
 	if (!count) {
@@ -94,6 +96,17 @@ static inline void load_LDT (mm_context_
 	__load_LDT(cpu);
 }
 
+#define pax_open_kernel(cr0)		\
+do {					\
+	cr0 = read_cr0();		\
+	write_cr0(cr0 & ~0x10000UL);	\
+} while(0)
+
+#define pax_close_kernel(cr0)		\
+do {					\
+	write_cr0(cr0);			\
+} while(0)
+
 #endif /* !__ASSEMBLY__ */
 
 #endif
diff -urNp linux-2.4.37.7/include/asm-i386/elf.h linux-2.4.37.7/include/asm-i386/elf.h
--- linux-2.4.37.7/include/asm-i386/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -55,7 +55,18 @@ typedef struct user_fxsr_struct elf_fpxr
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE		((current->mm->pax_flags & MF_PAX_SEGMEXEC)?SEGMEXEC_TASK_SIZE/3*2:TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x08048000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#endif
 
 /* Wow, the "main" arch needs arch dependent functions too.. :) */
 
@@ -70,17 +81,17 @@ typedef struct user_fxsr_struct elf_fpxr
 	pr_reg[4] = regs->edi;				\
 	pr_reg[5] = regs->ebp;				\
 	pr_reg[6] = regs->eax;				\
-	pr_reg[7] = regs->xds;				\
-	pr_reg[8] = regs->xes;				\
+	pr_reg[7] = regs->xds & 0xffff;			\
+	pr_reg[8] = regs->xes & 0xffff;			\
 	/* fake once used fs and gs selectors? */	\
-	pr_reg[9] = regs->xds;	/* was fs and __fs */	\
-	pr_reg[10] = regs->xds;	/* was gs and __gs */	\
+	pr_reg[9] = regs->xds & 0xffff;	/* was fs and __fs */\
+	pr_reg[10] = regs->xds & 0xffff;/* was gs and __gs */\
 	pr_reg[11] = regs->orig_eax;			\
 	pr_reg[12] = regs->eip;				\
-	pr_reg[13] = regs->xcs;				\
+	pr_reg[13] = regs->xcs & 0xffff;		\
 	pr_reg[14] = regs->eflags;			\
 	pr_reg[15] = regs->esp;				\
-	pr_reg[16] = regs->xss;
+	pr_reg[16] = regs->xss & 0xffff;
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
diff -urNp linux-2.4.37.7/include/asm-i386/hw_irq.h linux-2.4.37.7/include/asm-i386/hw_irq.h
--- linux-2.4.37.7/include/asm-i386/hw_irq.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/hw_irq.h	2009-11-10 19:30:27.000000000 -0500
@@ -95,7 +95,7 @@ extern char _stext, _etext;
 #define __STR(x) #x
 #define STR(x) __STR(x)
 
-#define SAVE_ALL \
+#define __SAVE_ALL \
 	"cld\n\t" \
 	"pushl %es\n\t" \
 	"pushl %ds\n\t" \
@@ -110,6 +110,18 @@ extern char _stext, _etext;
 	"movl %edx,%ds\n\t" \
 	"movl %edx,%es\n\t"
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL \
+	"movl %cr0,%edx\n\t" \
+	"movl %edx,%ebp\n\t" \
+	"orl $0x10000,%edx\n\t" \
+	"xorl %edx,%ebp\n\t" \
+	"movl %edx,%cr0\n\t"
+#else
+#define SAVE_ALL __SAVE_ALL
+#endif
+
 #define IRQ_NAME2(nr) nr##_interrupt(void)
 #define IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)
 
@@ -128,6 +140,7 @@ extern char _stext, _etext;
 asmlinkage void x(void); \
 asmlinkage void call_##x(void); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
 	"pushl $"#v"-256\n\t" \
@@ -141,6 +154,7 @@ SYMBOL_NAME_STR(x) ":\n\t" \
 asmlinkage void x(struct pt_regs * regs); \
 asmlinkage void call_##x(void); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
 	"pushl $"#v"-256\n\t" \
@@ -155,6 +169,7 @@ SYMBOL_NAME_STR(x) ":\n\t" \
 #define BUILD_COMMON_IRQ() \
 asmlinkage void call_do_IRQ(void); \
 __asm__( \
+	"\n .text" \
 	"\n" __ALIGN_STR"\n" \
 	"common_interrupt:\n\t" \
 	SAVE_ALL \
@@ -175,6 +190,7 @@ __asm__( \
 #define BUILD_IRQ(nr) \
 asmlinkage void IRQ_NAME(nr); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(IRQ) #nr "_interrupt:\n\t" \
 	"pushl $"#nr"-256\n\t" \
diff -urNp linux-2.4.37.7/include/asm-i386/kmap_types.h linux-2.4.37.7/include/asm-i386/kmap_types.h
--- linux-2.4.37.7/include/asm-i386/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-i386/mman.h linux-2.4.37.7/include/asm-i386/mman.h
--- linux-2.4.37.7/include/asm-i386/mman.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/mman.h	2009-11-10 19:30:27.000000000 -0500
@@ -18,6 +18,10 @@
 #define MAP_LOCKED	0x2000		/* pages are locked */
 #define MAP_NORESERVE	0x4000		/* don't check for reservations */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define MAP_MIRROR	0x8000
+#endif
+
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
diff -urNp linux-2.4.37.7/include/asm-i386/page.h linux-2.4.37.7/include/asm-i386/page.h
--- linux-2.4.37.7/include/asm-i386/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -81,6 +81,12 @@ typedef struct { unsigned long pgprot; }
 
 #define __PAGE_OFFSET		(0xC0000000)
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define __KERNEL_TEXT_OFFSET	(0xC0400000)
+#else
+#define __KERNEL_TEXT_OFFSET	(0)
+#endif
+
 /*
  * This much address space is reserved for vmalloc() and iomap()
  * as well as fixmap mappings.
@@ -98,7 +104,7 @@ typedef struct { unsigned long pgprot; }
 
 #if 1	/* Set to zero for a slightly smaller kernel */
 #define BUG()				\
- __asm__ __volatile__(	"ud2\n"		\
+ __asm__ __volatile__( "ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
 			 : : "i" (__LINE__), "i" (__FILE__))
@@ -138,6 +144,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _I386_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-i386/pgalloc.h linux-2.4.37.7/include/asm-i386/pgalloc.h
--- linux-2.4.37.7/include/asm-i386/pgalloc.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/pgalloc.h	2009-11-10 19:30:27.000000000 -0500
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #include <asm/processor.h>
 #include <asm/fixmap.h>
+#include <asm/desc.h>
 #include <linux/threads.h>
 
 #define pgd_quicklist (current_cpu_data.pgd_quick)
@@ -14,6 +15,9 @@
 #define pmd_populate(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
 
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte)))
+
 /*
  * Allocate and free page tables.
  */
diff -urNp linux-2.4.37.7/include/asm-i386/pgtable-2level.h linux-2.4.37.7/include/asm-i386/pgtable-2level.h
--- linux-2.4.37.7/include/asm-i386/pgtable-2level.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/pgtable-2level.h	2009-11-10 19:30:27.000000000 -0500
@@ -46,8 +46,25 @@ static inline int pgd_present(pgd_t pgd)
  * (pmds are folded into pgds so this doesnt get actually called,
  * but the define is needed for a generic inline function.)
  */
+#ifdef CONFIG_PAX_KERNEXEC
+#define set_pmd(pmdptr,pmdval) \
+({ \
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*(pmdptr) = pmdval; \
+	pax_close_kernel(cr0); \
+})
+#define set_pgd(pgdptr, pgdval) \
+({ \
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*(pgdptr) = pgdval; \
+	pax_close_kernel(cr0); \
+})
+#else
 #define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
 #define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+#endif
 
 #define pgd_page(pgd) \
 ((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
diff -urNp linux-2.4.37.7/include/asm-i386/pgtable-3level.h linux-2.4.37.7/include/asm-i386/pgtable-3level.h
--- linux-2.4.37.7/include/asm-i386/pgtable-3level.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/pgtable-3level.h	2009-11-10 19:30:27.000000000 -0500
@@ -49,10 +49,28 @@ static inline void set_pte(pte_t *ptep, 
 	smp_wmb();
 	ptep->pte_low = pte.pte_low;
 }
+
+#ifdef CONFIG_PAX_KERNEXEC
+#define set_pmd(pmdptr,pmdval) \
+({ \
+		unsigned long cr0; \
+		pax_open_kernel(cr0); \
+		set_64bit((unsigned long long *)(pmdptr),pmd_val(pmdval)); \
+		pax_close_kernel(cr0); \
+})
+#define set_pgd(pgdptr,pgdval) \
+({ \
+		unsigned long cr0; \
+		pax_open_kernel(cr0); \
+		set_64bit((unsigned long long *)(pgdptr),pgd_val(pgdval)); \
+		pax_close_kernel(cr0); \
+})
+#else
 #define set_pmd(pmdptr,pmdval) \
 		set_64bit((unsigned long long *)(pmdptr),pmd_val(pmdval))
 #define set_pgd(pgdptr,pgdval) \
 		set_64bit((unsigned long long *)(pgdptr),pgd_val(pgdval))
+#endif
 #define set_pte_atomic(pteptr,pteval) \
 		set_64bit((unsigned long long *)(pteptr),pte_val(pteval))
 
diff -urNp linux-2.4.37.7/include/asm-i386/pgtable.h linux-2.4.37.7/include/asm-i386/pgtable.h
--- linux-2.4.37.7/include/asm-i386/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -21,7 +21,6 @@
 #include <asm/bitops.h>
 #endif
 
-extern pgd_t swapper_pg_dir[1024];
 extern void paging_init(void);
 
 /* Caches aren't brain-dead on the intel. */
@@ -104,14 +103,11 @@ extern unsigned long pgkern_mask;
 extern unsigned long empty_zero_page[1024];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 
-#endif /* !__ASSEMBLY__ */
-
 /*
  * The Linux x86 paging architecture is 'compile-time dual-mode', it
  * implements both the traditional 2-level x86 page tables and the
  * newer 3-level PAE-mode page tables.
  */
-#ifndef __ASSEMBLY__
 #if CONFIG_X86_PAE
 # include <asm/pgtable-3level.h>
 
@@ -129,8 +125,16 @@ extern void pgtable_cache_init(void);
 #define pgtable_cache_init()	do { } while (0)
 
 #endif
+
+#ifdef CONFIG_X86_PAE
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern pmd_t swapper_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+#else
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 #endif
 
+#endif /* !__ASSEMBLY__ */
+
 #define __beep() asm("movb $0x3,%al; outb %al,$0x61")
 
 #define PMD_SIZE	(1UL << PMD_SHIFT)
@@ -144,9 +148,13 @@ extern void pgtable_cache_init(void);
 #define USER_PGD_PTRS (PAGE_OFFSET >> PGDIR_SHIFT)
 #define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
 
-#define TWOLEVEL_PGDIR_SHIFT	22
-#define BOOT_USER_PGD_PTRS (__PAGE_OFFSET >> TWOLEVEL_PGDIR_SHIFT)
+#ifdef CONFIG_X86_PAE
+#define BOOT_USER_PMD_PTRS (__PAGE_OFFSET >> 21)
+#define BOOT_KERNEL_PMD_PTRS (2048-BOOT_USER_PMD_PTRS)
+#else
+#define BOOT_USER_PGD_PTRS (__PAGE_OFFSET >> 22)
 #define BOOT_KERNEL_PGD_PTRS (1024-BOOT_USER_PGD_PTRS)
+#endif
 
 
 #ifndef __ASSEMBLY__
@@ -205,6 +213,16 @@ extern void pgtable_cache_init(void);
 #define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define __PAGE_KERNEL_NOCACHE \
@@ -237,18 +255,18 @@ extern void pgtable_cache_init(void);
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
 #define __P100	PAGE_READONLY
 #define __P101	PAGE_READONLY
 #define __P110	PAGE_COPY
 #define __P111	PAGE_COPY
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
 #define __S100	PAGE_READONLY
 #define __S101	PAGE_READONLY
 #define __S110	PAGE_SHARED
@@ -324,7 +342,7 @@ static inline pte_t pte_modify(pte_t pte
 ((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
 
 /* to find an entry in a page-table-directory. */
-#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 
 #define __pgd_offset(address) pgd_index(address)
 
diff -urNp linux-2.4.37.7/include/asm-i386/processor.h linux-2.4.37.7/include/asm-i386/processor.h
--- linux-2.4.37.7/include/asm-i386/processor.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/processor.h	2009-11-10 19:30:27.000000000 -0500
@@ -261,10 +261,19 @@ extern unsigned int mca_pentium_flag;
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_SIZE	(TASK_SIZE / 2)
+#endif
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+#define TASK_UNMAPPED_BASE	((current->mm->pax_flags & MF_PAX_SEGMEXEC)?SEGMEXEC_TASK_SIZE/3:TASK_SIZE/3)
+#else
 #define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#endif
 
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
@@ -392,7 +401,7 @@ struct thread_struct {
 
 #define INIT_TSS  {						\
 	0,0, /* back_link, __blh */				\
-	sizeof(init_stack) + (long) &init_stack, /* esp0 */	\
+	sizeof(init_stack) + (long) &init_stack - 8, /* esp0 */	\
 	__KERNEL_DS, 0, /* ss0 */				\
 	0,0,0,0,0,0, /* stack1, stack2 */			\
 	0, /* cr3 */						\
@@ -440,12 +449,20 @@ static inline void release_segments(stru
  */
 static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
-	return ((unsigned long *)t->esp)[3];
+	return t->eip;
 }
 
 unsigned long get_wchan(struct task_struct *p);
-#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
-#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1022])
+
+#define task_pt_regs(task)						\
+({									\
+	struct pt_regs *__regs__;					\
+	__regs__ = (struct pt_regs *)((task)->thread.esp0);		\
+	__regs__ - 1;							\
+})
+
+#define KSTK_EIP(tsk)  (task_pt_regs(tsk)->eip)
+#define KSTK_ESP(tsk)  (task_pt_regs(tsk)->esp)
 
 #define THREAD_SIZE (2*PAGE_SIZE)
 #define alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
diff -urNp linux-2.4.37.7/include/asm-i386/segment.h linux-2.4.37.7/include/asm-i386/segment.h
--- linux-2.4.37.7/include/asm-i386/segment.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/segment.h	2009-11-10 19:30:27.000000000 -0500
@@ -7,4 +7,7 @@
 #define __USER_CS	0x23
 #define __USER_DS	0x2B
 
+#define __PCIBIOS_CS	0x30
+#define __PCIBIOS_DS	0x38
+
 #endif
diff -urNp linux-2.4.37.7/include/asm-i386/system.h linux-2.4.37.7/include/asm-i386/system.h
--- linux-2.4.37.7/include/asm-i386/system.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/system.h	2009-11-10 19:30:27.000000000 -0500
@@ -12,6 +12,8 @@
 struct task_struct;	/* one of the stranger aspects of C forward declarations.. */
 extern void FASTCALL(__switch_to(struct task_struct *prev, struct task_struct *next));
 
+void pax_switch_segments(struct task_struct *);
+
 #define prepare_to_switch()	do { } while(0)
 #define switch_to(prev,next,last) do {					\
 	asm volatile("pushl %%esi\n\t"					\
diff -urNp linux-2.4.37.7/include/asm-i386/uaccess.h linux-2.4.37.7/include/asm-i386/uaccess.h
--- linux-2.4.37.7/include/asm-i386/uaccess.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-i386/uaccess.h	2009-11-10 19:30:27.000000000 -0500
@@ -8,6 +8,7 @@
 #include <linux/sched.h>
 #include <linux/prefetch.h>
 #include <asm/page.h>
+#include <asm/segment.h>
 
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
@@ -277,9 +278,12 @@ extern void __put_user_bad(void);
 
 #define __put_user_u64(x, addr, err)				\
 	__asm__ __volatile__(					\
-		"1:	movl %%eax,0(%2)\n"			\
-		"2:	movl %%edx,4(%2)\n"			\
+		"	movw %w5,%%ds\n"			\
+		"1:	movl %%eax,%%ds:0(%2)\n"		\
+		"2:	movl %%edx,%%ds:4(%2)\n"		\
 		"3:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"4:	movl %3,%0\n"				\
 		"	jmp 3b\n"				\
@@ -290,7 +294,8 @@ extern void __put_user_bad(void);
 		"	.long 2b,4b\n"				\
 		".previous"					\
 		: "=r"(err)					\
-		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
+		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err),	\
+		  "r"(__USER_DS))
 
 #define __put_user_size(x,ptr,size,retval)				\
 do {									\
@@ -314,8 +319,11 @@ struct __large_struct { unsigned long bu
  */
 #define __put_user_asm(x, addr, err, itype, rtype, ltype)	\
 	__asm__ __volatile__(					\
-		"1:	mov"itype" %"rtype"1,%2\n"		\
+		"	movw %w5,%%ds\n"			\
+		"1:	mov"itype" %"rtype"1,%%ds:%2\n"		\
 		"2:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"3:	movl %3,%0\n"				\
 		"	jmp 2b\n"				\
@@ -325,7 +333,8 @@ struct __large_struct { unsigned long bu
 		"	.long 1b,3b\n"				\
 		".previous"					\
 		: "=r"(err)					\
-		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err))
+		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err), \
+		  "r"(__USER_DS))
 
 
 #define __get_user_nocheck(x,ptr,size)				\
@@ -351,8 +360,11 @@ do {									\
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype)	\
 	__asm__ __volatile__(					\
-		"1:	mov"itype" %2,%"rtype"1\n"		\
+		"	movw %w5,%%ds\n"			\
+		"1:	mov"itype" %%ds:%2,%"rtype"1\n"		\
 		"2:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"3:	movl %3,%0\n"				\
 		"	xor"itype" %"rtype"1,%"rtype"1\n"	\
@@ -363,7 +375,7 @@ do {									\
 		"	.long 1b,3b\n"				\
 		".previous"					\
 		: "=r"(err), ltype (x)				\
-		: "m"(__m(addr)), "i"(-EFAULT), "0"(err))
+		: "m"(__m(addr)), "i"(-EFAULT), "0"(err), "r"(__USER_DS))
 
 
 /*
@@ -375,10 +387,13 @@ do {									\
 do {									\
 	int __d0, __d1;							\
 	__asm__ __volatile__(						\
+		"	movw %w7,%%es\n"				\
 		"0:	rep; movsl\n"					\
 		"	movl %3,%0\n"					\
 		"1:	rep; movsb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%es\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%3,%0,4),%0\n"				\
 		"	jmp 2b\n"					\
@@ -389,7 +404,8 @@ do {									\
 		"	.long 1b,2b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
-		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
+		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from),	\
+		  "r"(__USER_DS)					\
 		: "memory");						\
 } while (0)
 
@@ -397,10 +413,13 @@ do {									\
 do {									\
 	int __d0, __d1;							\
 	__asm__ __volatile__(						\
+		"	movw %w7,%%ds\n"				\
 		"0:	rep; movsl\n"					\
 		"	movl %3,%0\n"					\
 		"1:	rep; movsb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%ds\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%3,%0,4),%0\n"				\
 		"4:	pushl %0\n"					\
@@ -417,7 +436,8 @@ do {									\
 		"	.long 1b,4b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
-		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
+		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from),	\
+		  "r"(__USER_DS)					\
 		: "memory");						\
 } while (0)
 
@@ -446,8 +466,11 @@ do {								\
 	switch (size & 3) {					\
 	default:						\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"2:	shl $2,%0\n"			\
 			"	jmp 1b\n"			\
@@ -457,14 +480,18 @@ do {								\
 			"	.long 0b,2b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 1:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsb\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	shl $2,%0\n"			\
 			"4:	incl %0\n"			\
@@ -476,14 +503,18 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 2:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	shl $2,%0\n"			\
 			"4:	addl $2,%0\n"			\
@@ -495,15 +526,19 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 3:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:	movsb\n"			\
 			"3:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"4:	shl $2,%0\n"			\
 			"5:	addl $2,%0\n"			\
@@ -517,7 +552,8 @@ do {								\
 			"	.long 2b,6b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	}							\
@@ -530,8 +566,11 @@ do {								\
 	switch (size & 3) {					\
 	default:						\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"2:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -547,14 +586,18 @@ do {								\
 			"	.long 0b,2b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 1:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsb\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -579,14 +622,18 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 2:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -611,15 +658,19 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 3:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:	movsb\n"			\
 			"3:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"4:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -653,7 +704,8 @@ do {								\
 			"	.long 2b,6b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	}							\
diff -urNp linux-2.4.37.7/include/asm-ia64/elf.h linux-2.4.37.7/include/asm-ia64/elf.h
--- linux-2.4.37.7/include/asm-ia64/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -41,6 +41,12 @@
  */
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x800000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
 
 /*
  * We use (abuse?) this macro to insert the (empty) vm_area that is
diff -urNp linux-2.4.37.7/include/asm-ia64/ia32.h linux-2.4.37.7/include/asm-ia64/ia32.h
--- linux-2.4.37.7/include/asm-ia64/ia32.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/ia32.h	2009-11-10 19:30:27.000000000 -0500
@@ -367,7 +367,14 @@ struct old_linux32_dirent {
 #define ELF_ARCH	EM_386
 
 #define IA32_PAGE_OFFSET	0xc0000000
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
+
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK (current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK 0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
 
 /*
  * The system segments (GDT, TSS, LDT) have to be mapped below 4GB so the IA-32 engine can
diff -urNp linux-2.4.37.7/include/asm-ia64/kmap_types.h linux-2.4.37.7/include/asm-ia64/kmap_types.h
--- linux-2.4.37.7/include/asm-ia64/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -23,7 +23,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -urNp linux-2.4.37.7/include/asm-ia64/page.h linux-2.4.37.7/include/asm-ia64/page.h
--- linux-2.4.37.7/include/asm-ia64/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -190,4 +190,13 @@ get_order (unsigned long size)
 					 (((current->thread.flags & IA64_THREAD_XSTACK) != 0)	\
 					  ? VM_EXEC : 0))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* _ASM_IA64_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-ia64/pgtable.h linux-2.4.37.7/include/asm-ia64/pgtable.h
--- linux-2.4.37.7/include/asm-ia64/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -115,6 +115,17 @@
 #define PAGE_SHARED	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
 #define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
+# define PAGE_READONLY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+# define PAGE_COPY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+#endif
+
 #define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)
 #define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)
 #define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)
diff -urNp linux-2.4.37.7/include/asm-ia64/ustack.h linux-2.4.37.7/include/asm-ia64/ustack.h
--- linux-2.4.37.7/include/asm-ia64/ustack.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ia64/ustack.h	2009-11-10 19:30:27.000000000 -0500
@@ -11,6 +11,6 @@
 #define MAX_USER_STACK_SIZE	(RGN_MAP_LIMIT/2)
 /* Make a default stack size of 2GB */
 #define DEFAULT_USER_STACK_SIZE	(1UL << 31)
-#define STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
+#define __STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
 
 #endif /* _ASM_IA64_USTACK_H */
diff -urNp linux-2.4.37.7/include/asm-m68k/kmap_types.h linux-2.4.37.7/include/asm-m68k/kmap_types.h
--- linux-2.4.37.7/include/asm-m68k/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-m68k/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-mips/a.out.h linux-2.4.37.7/include/asm-mips/a.out.h
--- linux-2.4.37.7/include/asm-mips/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -19,7 +19,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-mips/elf.h linux-2.4.37.7/include/asm-mips/elf.h
--- linux-2.4.37.7/include/asm-mips/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -107,6 +107,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x00400000UL
+
+#define PAX_DELTA_MMAP_LEN	(27 - PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(27 - PAGE_SHIFT)
+#endif
+
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
 #endif
diff -urNp linux-2.4.37.7/include/asm-mips/kmap_types.h linux-2.4.37.7/include/asm-mips/kmap_types.h
--- linux-2.4.37.7/include/asm-mips/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-mips/page.h linux-2.4.37.7/include/asm-mips/page.h
--- linux-2.4.37.7/include/asm-mips/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -77,7 +77,7 @@ static inline void copy_user_page(void *
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-    #define __pte(x)	({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+    #define __pte(x)	({ pte_t __pte = {(x), (x) >> 32}; __pte; })
   #else
     typedef struct { unsigned long long pte_low; } pte_t;
     #define pte_val(x)    ((x).pte_low)
@@ -137,6 +137,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS  (VM_READ | VM_WRITE | VM_EXEC | \
 				VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
diff -urNp linux-2.4.37.7/include/asm-mips64/a.out.h linux-2.4.37.7/include/asm-mips64/a.out.h
--- linux-2.4.37.7/include/asm-mips64/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips64/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -26,7 +26,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP (current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
+#define __STACK_TOP (current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-mips64/elf.h linux-2.4.37.7/include/asm-mips64/elf.h
--- linux-2.4.37.7/include/asm-mips64/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips64/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -107,6 +107,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2)			\
 do {	current->thread.mflags &= ~MF_ABI_MASK;		\
diff -urNp linux-2.4.37.7/include/asm-mips64/kmap_types.h linux-2.4.37.7/include/asm-mips64/kmap_types.h
--- linux-2.4.37.7/include/asm-mips64/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips64/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-mips64/page.h linux-2.4.37.7/include/asm-mips64/page.h
--- linux-2.4.37.7/include/asm-mips64/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-mips64/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -148,6 +148,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* defined (__KERNEL__) */
 
 #endif /* _ASM_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-parisc/a.out.h linux-2.4.37.7/include/asm-parisc/a.out.h
--- linux-2.4.37.7/include/asm-parisc/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-parisc/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -22,7 +22,7 @@ struct exec
 /* XXX: STACK_TOP actually should be STACK_BOTTOM for parisc.
  * prumpf */
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-parisc/elf.h linux-2.4.37.7/include/asm-parisc/elf.h
--- linux-2.4.37.7/include/asm-parisc/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-parisc/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -135,6 +135,13 @@ struct pt_regs;	/* forward declaration..
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE + 0x01000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
    but it's not easy, and we've already done it here.  */
diff -urNp linux-2.4.37.7/include/asm-parisc/page.h linux-2.4.37.7/include/asm-parisc/page.h
--- linux-2.4.37.7/include/asm-parisc/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-parisc/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -117,6 +117,15 @@ extern int npmem_ranges;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _PARISC_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-parisc/pgtable.h linux-2.4.37.7/include/asm-parisc/pgtable.h
--- linux-2.4.37.7/include/asm-parisc/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-parisc/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -167,6 +167,17 @@ extern  void *vmalloc_start;
 #define PAGE_EXECREAD   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_EXEC |_PAGE_ACCESSED)
 #define PAGE_COPY       PAGE_EXECREAD
 #define PAGE_RWX        __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_EXEC |_PAGE_ACCESSED)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define PAGE_KERNEL_UNC	__pgprot(_PAGE_KERNEL | _PAGE_NO_CACHE)
diff -urNp linux-2.4.37.7/include/asm-ppc/a.out.h linux-2.4.37.7/include/asm-ppc/a.out.h
--- linux-2.4.37.7/include/asm-ppc/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -2,7 +2,7 @@
 #define __PPC_A_OUT_H__
 
 /* grabbed from the intel stuff  */
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 
 
 struct exec
diff -urNp linux-2.4.37.7/include/asm-ppc/elf.h linux-2.4.37.7/include/asm-ppc/elf.h
--- linux-2.4.37.7/include/asm-ppc/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -46,6 +46,13 @@ typedef elf_vrreg_t elf_vrregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE         (0x08000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000000UL
+
+#define PAX_DELTA_MMAP_LEN	15
+#define PAX_DELTA_STACK_LEN	15
+#endif
+
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
 
diff -urNp linux-2.4.37.7/include/asm-ppc/kmap_types.h linux-2.4.37.7/include/asm-ppc/kmap_types.h
--- linux-2.4.37.7/include/asm-ppc/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-ppc/page.h linux-2.4.37.7/include/asm-ppc/page.h
--- linux-2.4.37.7/include/asm-ppc/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -171,5 +171,14 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _PPC_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-ppc/pgtable.h linux-2.4.37.7/include/asm-ppc/pgtable.h
--- linux-2.4.37.7/include/asm-ppc/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -394,11 +394,21 @@ extern unsigned long vmalloc_start;
 
 #define PAGE_NONE	__pgprot(_PAGE_BASE)
 #define PAGE_READONLY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_SHARED	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW)
-#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC)
+#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_COPY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
+
+#if defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_40x) && !defined(CONFIG_44x)
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_GUARDED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
 
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_BASE | _PAGE_SHARED)
@@ -411,21 +421,21 @@ extern unsigned long vmalloc_start;
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY_X
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY_X
-#define __P100	PAGE_READONLY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
+#define __P100	PAGE_READONLY_X
 #define __P101	PAGE_READONLY_X
-#define __P110	PAGE_COPY
+#define __P110	PAGE_COPY_X
 #define __P111	PAGE_COPY_X
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY_X
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED_X
-#define __S100	PAGE_READONLY
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
+#define __S100	PAGE_READONLY_X
 #define __S101	PAGE_READONLY_X
-#define __S110	PAGE_SHARED
+#define __S110	PAGE_SHARED_X
 #define __S111	PAGE_SHARED_X
 
 #ifndef __ASSEMBLY__
diff -urNp linux-2.4.37.7/include/asm-ppc64/kmap_types.h linux-2.4.37.7/include/asm-ppc64/kmap_types.h
--- linux-2.4.37.7/include/asm-ppc64/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-ppc64/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -15,7 +15,8 @@ enum km_type {
 	KM_IRQ0,
 	KM_IRQ1,
 	KM_SOFTIRQ0,
-	KM_SOFTIRQ1,	
+	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-s390/kmap_types.h linux-2.4.37.7/include/asm-s390/kmap_types.h
--- linux-2.4.37.7/include/asm-s390/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-s390/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-s390x/kmap_types.h linux-2.4.37.7/include/asm-s390x/kmap_types.h
--- linux-2.4.37.7/include/asm-s390x/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-s390x/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-sparc/a.out.h linux-2.4.37.7/include/asm-sparc/a.out.h
--- linux-2.4.37.7/include/asm-sparc/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -91,7 +91,7 @@ struct relocation_info /* used when head
 
 #include <asm/page.h>
 
-#define STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
+#define __STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
 
 #endif /* __KERNEL__ */
 
diff -urNp linux-2.4.37.7/include/asm-sparc/elf.h linux-2.4.37.7/include/asm-sparc/elf.h
--- linux-2.4.37.7/include/asm-sparc/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -83,6 +83,13 @@ typedef struct {
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This can NOT be done in userspace
    on Sparc.  */
diff -urNp linux-2.4.37.7/include/asm-sparc/kmap_types.h linux-2.4.37.7/include/asm-sparc/kmap_types.h
--- linux-2.4.37.7/include/asm-sparc/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-sparc/page.h linux-2.4.37.7/include/asm-sparc/page.h
--- linux-2.4.37.7/include/asm-sparc/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -182,6 +182,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			 ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _SPARC_PAGE_H */
diff -urNp linux-2.4.37.7/include/asm-sparc/pgtable.h linux-2.4.37.7/include/asm-sparc/pgtable.h
--- linux-2.4.37.7/include/asm-sparc/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -97,6 +97,13 @@ BTFIXUPDEF_INT(page_none)
 BTFIXUPDEF_INT(page_shared)
 BTFIXUPDEF_INT(page_copy)
 BTFIXUPDEF_INT(page_readonly)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+BTFIXUPDEF_INT(page_shared_noexec)
+BTFIXUPDEF_INT(page_copy_noexec)
+BTFIXUPDEF_INT(page_readonly_noexec)
+#endif
+
 BTFIXUPDEF_INT(page_kernel)
 
 #define PMD_SHIFT       	BTFIXUP_SIMM13(pmd_shift)
@@ -118,6 +125,16 @@ BTFIXUPDEF_INT(page_kernel)
 #define PAGE_COPY      __pgprot(BTFIXUP_INT(page_copy))
 #define PAGE_READONLY  __pgprot(BTFIXUP_INT(page_readonly))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(BTFIXUP_INT(page_shared_noexec))
+# define PAGE_COPY_NOEXEC	__pgprot(BTFIXUP_INT(page_copy_noexec))
+# define PAGE_READONLY_NOEXEC	__pgprot(BTFIXUP_INT(page_readonly_noexec))
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 extern unsigned long page_kernel;
 
 #ifdef MODULE
diff -urNp linux-2.4.37.7/include/asm-sparc/pgtsrmmu.h linux-2.4.37.7/include/asm-sparc/pgtsrmmu.h
--- linux-2.4.37.7/include/asm-sparc/pgtsrmmu.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/pgtsrmmu.h	2009-11-10 19:30:27.000000000 -0500
@@ -76,6 +76,16 @@
 				    SRMMU_EXEC | SRMMU_REF)
 #define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
 				    SRMMU_EXEC | SRMMU_REF)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define SRMMU_PAGE_SHARED_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_WRITE | SRMMU_REF)
+#define SRMMU_PAGE_COPY_NOEXEC    __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#define SRMMU_PAGE_RDONLY_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#endif
+
 #define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \
 				    SRMMU_DIRTY | SRMMU_REF)
 
diff -urNp linux-2.4.37.7/include/asm-sparc/uaccess.h linux-2.4.37.7/include/asm-sparc/uaccess.h
--- linux-2.4.37.7/include/asm-sparc/uaccess.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc/uaccess.h	2009-11-10 19:30:27.000000000 -0500
@@ -39,7 +39,7 @@
  * No one can read/write anything from userland in the kernel space by setting
  * large size and address near to PAGE_OFFSET - a fault will break his intentions.
  */
-#define __user_ok(addr,size) ((addr) < STACK_TOP)
+#define __user_ok(addr,size) ((addr) < __STACK_TOP)
 #define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
diff -urNp linux-2.4.37.7/include/asm-sparc64/a.out.h linux-2.4.37.7/include/asm-sparc64/a.out.h
--- linux-2.4.37.7/include/asm-sparc64/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc64/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -95,7 +95,7 @@ struct relocation_info /* used when head
 
 #ifdef __KERNEL__
 
-#define STACK_TOP (current->thread.flags & SPARC_FLAG_32BIT ? 0xf0000000 : 0x80000000000L)
+#define __STACK_TOP (current->thread.flags & SPARC_FLAG_32BIT ? 0xf0000000 : 0x80000000000L)
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-sparc64/elf.h linux-2.4.37.7/include/asm-sparc64/elf.h
--- linux-2.4.37.7/include/asm-sparc64/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc64/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -82,6 +82,12 @@ typedef struct {
 #define ELF_ET_DYN_BASE         0x0000010000000000UL
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->thread.flags & SPARC_FLAG_32BIT ? 0x10000UL : 0x100000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->thread.flags & SPARC_FLAG_32BIT ? 14 : 28 )
+#define PAX_DELTA_STACK_LEN	(current->thread.flags & SPARC_FLAG_32BIT ? 15 : 29 )
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  */
diff -urNp linux-2.4.37.7/include/asm-sparc64/kmap_types.h linux-2.4.37.7/include/asm-sparc64/kmap_types.h
--- linux-2.4.37.7/include/asm-sparc64/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc64/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -14,6 +14,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-sparc64/page.h linux-2.4.37.7/include/asm-sparc64/page.h
--- linux-2.4.37.7/include/asm-sparc64/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-sparc64/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -160,6 +160,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* !(__KERNEL__) */
 
 #endif /* !(_SPARC64_PAGE_H) */
diff -urNp linux-2.4.37.7/include/asm-x86_64/a.out.h linux-2.4.37.7/include/asm-x86_64/a.out.h
--- linux-2.4.37.7/include/asm-x86_64/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -23,7 +23,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -urNp linux-2.4.37.7/include/asm-x86_64/elf.h linux-2.4.37.7/include/asm-x86_64/elf.h
--- linux-2.4.37.7/include/asm-x86_64/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -68,6 +68,13 @@ typedef struct user_fxsr_struct elf_fpxr
 
 #define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->thread.flags & THREAD_IA32 ? 0x08048000UL : 0x400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->thread.flags & THREAD_IA32 ? 16 : 24)
+#define PAX_DELTA_STACK_LEN	(current->thread.flags & THREAD_IA32 ? 16 : 24)
+#endif
+
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different). Assumes current is the process
    getting dumped. */
diff -urNp linux-2.4.37.7/include/asm-x86_64/kmap_types.h linux-2.4.37.7/include/asm-x86_64/kmap_types.h
--- linux-2.4.37.7/include/asm-x86_64/kmap_types.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/kmap_types.h	2009-11-10 19:30:27.000000000 -0500
@@ -9,6 +9,7 @@ enum km_type {
 	KM_USER1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -urNp linux-2.4.37.7/include/asm-x86_64/page.h linux-2.4.37.7/include/asm-x86_64/page.h
--- linux-2.4.37.7/include/asm-x86_64/page.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/page.h	2009-11-10 19:30:27.000000000 -0500
@@ -142,6 +142,16 @@ extern __inline__ int get_order(unsigned
 
 #define __VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define VM_DATA_DEFAULT_FLAGS __VM_DATA_DEFAULT_FLAGS
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#else
 #define __VM_STACK_FLAGS 	(VM_GROWSDOWN | VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
@@ -149,6 +159,7 @@ extern __inline__ int get_order(unsigned
 	((current->thread.flags & THREAD_IA32) ? vm_data_default_flags32 : \
 	  vm_data_default_flags) 
 #define VM_STACK_FLAGS	vm_stack_flags
+#endif
 
 #endif /* __KERNEL__ */
 
diff -urNp linux-2.4.37.7/include/asm-x86_64/pgalloc.h linux-2.4.37.7/include/asm-x86_64/pgalloc.h
--- linux-2.4.37.7/include/asm-x86_64/pgalloc.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/pgalloc.h	2009-11-10 19:30:27.000000000 -0500
@@ -14,6 +14,8 @@
 
 #define pmd_populate(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE | __pa(pte)))
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(pte)))
 #define pgd_populate(mm, pgd, pmd) \
 		set_pgd(pgd, __pgd(_PAGE_TABLE | __pa(pmd)))
 
diff -urNp linux-2.4.37.7/include/asm-x86_64/pgtable.h linux-2.4.37.7/include/asm-x86_64/pgtable.h
--- linux-2.4.37.7/include/asm-x86_64/pgtable.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/asm-x86_64/pgtable.h	2009-11-10 19:30:27.000000000 -0500
@@ -240,6 +240,8 @@ extern inline void pgd_clear (pgd_t * pg
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_EXECONLY PAGE_READONLY_EXEC
 
+#define PAGE_READONLY_NOEXEC	PAGE_READONLY
+
 #define PAGE_LARGE (_PAGE_PSE|_PAGE_PRESENT) 
 
 #define __PAGE_KERNEL \
diff -urNp linux-2.4.37.7/include/linux/affs_fs.h linux-2.4.37.7/include/linux/affs_fs.h
--- linux-2.4.37.7/include/linux/affs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/affs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -78,17 +78,17 @@ extern void   affs_dir_truncate(struct i
 
 /* jump tables */
 
-extern struct inode_operations	 affs_file_inode_operations;
-extern struct inode_operations	 affs_dir_inode_operations;
-extern struct inode_operations   affs_symlink_inode_operations;
-extern struct file_operations	 affs_file_operations;
-extern struct file_operations	 affs_file_operations_ofs;
-extern struct file_operations	 affs_dir_operations;
-extern struct address_space_operations	 affs_symlink_aops;
-extern struct address_space_operations	 affs_aops;
-extern struct address_space_operations	 affs_aops_ofs;
+extern const struct inode_operations	 affs_file_inode_operations;
+extern const struct inode_operations	 affs_dir_inode_operations;
+extern const struct inode_operations   affs_symlink_inode_operations;
+extern const struct file_operations	 affs_file_operations;
+extern const struct file_operations	 affs_file_operations_ofs;
+extern const struct file_operations	 affs_dir_operations;
+extern const struct address_space_operations	 affs_symlink_aops;
+extern const struct address_space_operations	 affs_aops;
+extern const struct address_space_operations	 affs_aops_ofs;
 
-extern struct dentry_operations	 affs_dentry_operations;
-extern struct dentry_operations	 affs_dentry_operations_intl;
+extern const struct dentry_operations	 affs_dentry_operations;
+extern const struct dentry_operations	 affs_dentry_operations_intl;
 
 #endif
diff -urNp linux-2.4.37.7/include/linux/a.out.h linux-2.4.37.7/include/linux/a.out.h
--- linux-2.4.37.7/include/linux/a.out.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/a.out.h	2009-11-10 19:30:27.000000000 -0500
@@ -7,6 +7,16 @@
 
 #include <asm/a.out.h>
 
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __DELTA_STACK (current->mm->delta_stack)
+#else
+#define __DELTA_STACK 0UL
+#endif
+
+#ifndef STACK_TOP
+#define STACK_TOP	(__STACK_TOP - __DELTA_STACK)
+#endif
+
 #endif /* __STRUCT_EXEC_OVERRIDE__ */
 
 /* these go in the N_MACHTYPE field */
@@ -37,6 +47,14 @@ enum machine_type {
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC	1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP	2	/* Emulate trampolines */
+#define F_PAX_MPROTECT	4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP	8	/* Randomize mmap() base */
+/*#define F_PAX_RANDEXEC	16*/	/* Randomize ET_EXEC base */
+#define F_PAX_SEGMEXEC	32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -urNp linux-2.4.37.7/include/linux/bfs_fs.h linux-2.4.37.7/include/linux/bfs_fs.h
--- linux-2.4.37.7/include/linux/bfs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/bfs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -79,13 +79,13 @@ struct bfs_super_block {
 #ifdef __KERNEL__
 
 /* file.c */
-extern struct inode_operations bfs_file_inops;
-extern struct file_operations bfs_file_operations;
-extern struct address_space_operations bfs_aops;
+extern const struct inode_operations bfs_file_inops;
+extern const struct file_operations bfs_file_operations;
+extern const struct address_space_operations bfs_aops;
 
 /* dir.c */
-extern struct inode_operations bfs_dir_inops;
-extern struct file_operations bfs_dir_operations;
+extern const struct inode_operations bfs_dir_inops;
+extern const struct file_operations bfs_dir_operations;
 
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_BFS_FS_H */
diff -urNp linux-2.4.37.7/include/linux/binfmts.h linux-2.4.37.7/include/linux/binfmts.h
--- linux-2.4.37.7/include/linux/binfmts.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/binfmts.h	2009-11-10 19:30:27.000000000 -0500
@@ -6,10 +6,10 @@
 
 /*
  * MAX_ARG_PAGES defines the number of pages allocated for arguments
- * and envelope for the new program. 32 should suffice, this gives
- * a maximum env+arg of 128kB w/4KB pages!
+ * and envelope for the new program. 33 should suffice, this gives
+ * a maximum env+arg of 132kB w/4KB pages!
  */
-#define MAX_ARG_PAGES 32
+#define MAX_ARG_PAGES 33
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
@@ -30,6 +30,7 @@ struct linux_binprm{
 	int argc, envc;
 	char * filename;	/* Name of binary */
 	unsigned long loader, exec;
+	int misc;
 };
 
 /*
@@ -59,6 +60,8 @@ extern void compute_creds(struct linux_b
 extern int do_coredump(long signr, struct pt_regs * regs);
 extern void set_binfmt(struct linux_binfmt *new);
 
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+void pax_report_insns(void *pc, void *sp);
 
 #if 0
 /* this went away now */
diff -urNp linux-2.4.37.7/include/linux/coda_linux.h linux-2.4.37.7/include/linux/coda_linux.h
--- linux-2.4.37.7/include/linux/coda_linux.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/coda_linux.h	2009-11-10 19:30:27.000000000 -0500
@@ -24,16 +24,16 @@
 #include <linux/coda_fs_i.h>
 
 /* operations */
-extern struct inode_operations coda_dir_inode_operations;
-extern struct inode_operations coda_file_inode_operations;
-extern struct inode_operations coda_ioctl_inode_operations;
-
-extern struct address_space_operations coda_file_aops;
-extern struct address_space_operations coda_symlink_aops;
-
-extern struct file_operations coda_dir_operations;
-extern struct file_operations coda_file_operations;
-extern struct file_operations coda_ioctl_operations;
+extern const struct inode_operations coda_dir_inode_operations;
+extern const struct inode_operations coda_file_inode_operations;
+extern const struct inode_operations coda_ioctl_inode_operations;
+
+extern const struct address_space_operations coda_file_aops;
+extern const struct address_space_operations coda_symlink_aops;
+
+extern const struct file_operations coda_dir_operations;
+extern const struct file_operations coda_file_operations;
+extern const struct file_operations coda_ioctl_operations;
 
 /* operations shared over more than one file */
 int coda_open(struct inode *i, struct file *f);
diff -urNp linux-2.4.37.7/include/linux/compiler.h linux-2.4.37.7/include/linux/compiler.h
--- linux-2.4.37.7/include/linux/compiler.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/compiler.h	2009-11-10 19:30:27.000000000 -0500
@@ -41,7 +41,7 @@
 #endif
 #endif
 
-#ifdef __KERNEL__
+#ifdef __KERNEL___
 #if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 2
 #error "GCC >= 4.2 miscompiles kernel 2.4, do not use it!"
 #error "While the resulting kernel may boot, you will encounter random bugs"
diff -urNp linux-2.4.37.7/include/linux/dcache.h linux-2.4.37.7/include/linux/dcache.h
--- linux-2.4.37.7/include/linux/dcache.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/dcache.h	2009-11-10 19:30:27.000000000 -0500
@@ -77,7 +77,7 @@ struct dentry {
 	int d_mounted;
 	struct qstr d_name;
 	unsigned long d_time;		/* used by d_revalidate */
-	struct dentry_operations  *d_op;
+	const struct dentry_operations  *d_op;
 	struct super_block * d_sb;	/* The root of the dentry tree */
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
diff -urNp linux-2.4.37.7/include/linux/devfs_fs_kernel.h linux-2.4.37.7/include/linux/devfs_fs_kernel.h
--- linux-2.4.37.7/include/linux/devfs_fs_kernel.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/devfs_fs_kernel.h	2009-11-10 19:30:27.000000000 -0500
@@ -64,7 +64,7 @@ extern void devfs_put (devfs_handle_t de
 extern devfs_handle_t devfs_register (devfs_handle_t dir, const char *name,
 				      unsigned int flags,
 				      unsigned int major, unsigned int minor,
-				      umode_t mode, void *ops, void *info);
+				      umode_t mode, const void *ops, void *info);
 extern void devfs_unregister (devfs_handle_t de);
 extern int devfs_mk_symlink (devfs_handle_t dir, const char *name,
 			     unsigned int flags, const char *link,
@@ -95,7 +95,7 @@ extern void devfs_auto_unregister (devfs
 extern devfs_handle_t devfs_get_unregister_slave (devfs_handle_t master);
 extern const char *devfs_get_name (devfs_handle_t de, unsigned int *namelen);
 extern int devfs_register_chrdev (unsigned int major, const char *name,
-				  struct file_operations *fops);
+				  const struct file_operations *fops);
 extern int devfs_register_blkdev (unsigned int major, const char *name,
 				  struct block_device_operations *bdops);
 extern int devfs_unregister_chrdev (unsigned int major, const char *name);
@@ -106,7 +106,7 @@ extern void devfs_register_series (devfs
 				   unsigned int num_entries,
 				   unsigned int flags, unsigned int major,
 				   unsigned int minor_start,
-				   umode_t mode, void *ops, void *info);
+				   umode_t mode, const void *ops, void *info);
 extern int devfs_alloc_major (char type);
 extern void devfs_dealloc_major (char type, int major);
 extern kdev_t devfs_alloc_devnum (char type);
@@ -136,7 +136,7 @@ static inline devfs_handle_t devfs_regis
 					     unsigned int major,
 					     unsigned int minor,
 					     umode_t mode,
-					     void *ops, void *info)
+					     const void *ops, void *info)
 {
     return NULL;
 }
@@ -242,7 +242,7 @@ static inline const char *devfs_get_name
     return NULL;
 }
 static inline int devfs_register_chrdev (unsigned int major, const char *name,
-					 struct file_operations *fops)
+					 const struct file_operations *fops)
 {
     return register_chrdev (major, name, fops);
 }
@@ -271,7 +271,7 @@ static inline void devfs_register_series
 					  unsigned int flags,
 					  unsigned int major,
 					  unsigned int minor_start,
-					  umode_t mode, void *ops, void *info)
+					  umode_t mode, const void *ops, void *info)
 {
     return;
 }
diff -urNp linux-2.4.37.7/include/linux/efs_fs.h linux-2.4.37.7/include/linux/efs_fs.h
--- linux-2.4.37.7/include/linux/efs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/efs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -45,9 +45,9 @@ static const char cprt[] = "EFS: "EFS_VE
 #define SUPER_INFO(s)				&((s)->u.efs_sb)
 #endif
 
-extern struct inode_operations efs_dir_inode_operations;
-extern struct file_operations efs_dir_operations;
-extern struct address_space_operations efs_symlink_aops;
+extern const struct inode_operations efs_dir_inode_operations;
+extern const struct file_operations efs_dir_operations;
+extern const struct address_space_operations efs_symlink_aops;
 
 extern struct super_block *efs_read_super(struct super_block *, void *, int);
 extern int efs_statfs(struct super_block *, struct statfs *);
diff -urNp linux-2.4.37.7/include/linux/elf.h linux-2.4.37.7/include/linux/elf.h
--- linux-2.4.37.7/include/linux/elf.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/elf.h	2009-11-10 19:30:27.000000000 -0500
@@ -34,6 +34,10 @@ typedef __s64	Elf64_Sxword;
 #define PT_MIPS_REGINFO		0x70000000
 #define PT_MIPS_OPTIONS		0x70000001
 
+#define PT_LOOS			0x60000000
+#define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+#define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+
 /* Flags in the e_flags field of the header */
 #define EF_MIPS_NOREORDER 0x00000001
 #define EF_MIPS_PIC       0x00000002
@@ -44,6 +48,14 @@ typedef __s64	Elf64_Sxword;
 #define EF_MIPS_ABI       0x0000f000
 #define EF_MIPS_ARCH      0xf0000000
 
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC			1	/* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP			2	/* Emulate trampolines */
+#define EF_PAX_MPROTECT			4	/* Restrict mprotect() */
+#define EF_PAX_RANDMMAP			8	/* Randomize mmap() base */
+/*#define EF_PAX_RANDEXEC			16*/	/* Randomize ET_EXEC base */
+#define EF_PAX_SEGMEXEC			32	/* Segmentation based non-executable pages */
+
 /* These constants define the different elf file types */
 #define ET_NONE   0
 #define ET_REL    1
@@ -122,6 +134,8 @@ typedef __s64	Elf64_Sxword;
 #define DT_DEBUG	21
 #define DT_TEXTREL	22
 #define DT_JMPREL	23
+#define DT_FLAGS	30
+  #define DF_TEXTREL	0x00000004
 #define DT_LOPROC	0x70000000
 #define DT_HIPROC	0x7fffffff
 #define DT_MIPS_RLD_VERSION	0x70000001
@@ -458,6 +472,19 @@ typedef struct elf64_hdr {
 #define PF_W		0x2
 #define PF_X		0x1
 
+#define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+/*#define PF_RANDEXEC	(1U << 10)*/	/* Enable  RANDEXEC */
+/*#define PF_NORANDEXEC	(1U << 11)*/	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+
 typedef struct elf32_phdr{
   Elf32_Word	p_type;
   Elf32_Off	p_offset;
@@ -555,6 +582,8 @@ typedef struct elf64_shdr {
 #define	EI_VERSION	6
 #define	EI_PAD		7
 
+#define	EI_PAX		14
+
 #define	ELFMAG0		0x7f		/* EI_MAG */
 #define	ELFMAG1		'E'
 #define	ELFMAG2		'L'
@@ -602,6 +631,7 @@ extern Elf32_Dyn _DYNAMIC [];
 #define elfhdr		elf32_hdr
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
+#define elf_dyn		Elf32_Dyn
 
 #else
 
@@ -609,6 +639,7 @@ extern Elf64_Dyn _DYNAMIC [];
 #define elfhdr		elf64_hdr
 #define elf_phdr	elf64_phdr
 #define elf_note	elf64_note
+#define elf_dyn		Elf64_Dyn
 
 #endif
 
diff -urNp linux-2.4.37.7/include/linux/ext2_fs.h linux-2.4.37.7/include/linux/ext2_fs.h
--- linux-2.4.37.7/include/linux/ext2_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/ext2_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -639,20 +639,20 @@ extern int ext2_statfs (struct super_blo
  */
 
 /* dir.c */
-extern struct file_operations ext2_dir_operations;
+extern const struct file_operations ext2_dir_operations;
 
 /* file.c */
-extern struct inode_operations ext2_file_inode_operations;
-extern struct file_operations ext2_file_operations;
+extern const struct inode_operations ext2_file_inode_operations;
+extern const struct file_operations ext2_file_operations;
 
 /* inode.c */
-extern struct address_space_operations ext2_aops;
+extern const struct address_space_operations ext2_aops;
 
 /* namei.c */
-extern struct inode_operations ext2_dir_inode_operations;
+extern const struct inode_operations ext2_dir_inode_operations;
 
 /* symlink.c */
-extern struct inode_operations ext2_fast_symlink_inode_operations;
+extern const struct inode_operations ext2_fast_symlink_inode_operations;
 
 #endif	/* __KERNEL__ */
 
diff -urNp linux-2.4.37.7/include/linux/ext3_fs.h linux-2.4.37.7/include/linux/ext3_fs.h
--- linux-2.4.37.7/include/linux/ext3_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/ext3_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -702,20 +702,20 @@ extern const char *ext3_decode_error(str
  */
 
 /* dir.c */
-extern struct file_operations ext3_dir_operations;
+extern const struct file_operations ext3_dir_operations;
 
 /* file.c */
-extern struct inode_operations ext3_file_inode_operations;
-extern struct file_operations ext3_file_operations;
+extern const struct inode_operations ext3_file_inode_operations;
+extern const struct file_operations ext3_file_operations;
 
 /* inode.c */
-extern struct address_space_operations ext3_aops;
+extern const struct address_space_operations ext3_aops;
 
 /* namei.c */
-extern struct inode_operations ext3_dir_inode_operations;
+extern const struct inode_operations ext3_dir_inode_operations;
 
 /* symlink.c */
-extern struct inode_operations ext3_fast_symlink_inode_operations;
+extern const struct inode_operations ext3_fast_symlink_inode_operations;
 
 
 #endif	/* __KERNEL__ */
diff -urNp linux-2.4.37.7/include/linux/fsfilter.h linux-2.4.37.7/include/linux/fsfilter.h
--- linux-2.4.37.7/include/linux/fsfilter.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/fsfilter.h	2009-11-10 19:30:27.000000000 -0500
@@ -33,17 +33,17 @@ struct filter_ops { 
 
 struct cache_ops {
         /* operations on the file store */
-        struct super_operations *cache_sops;
+        const struct super_operations *cache_sops;
 
-        struct inode_operations *cache_dir_iops;
-        struct inode_operations *cache_file_iops;
-        struct inode_operations *cache_sym_iops;
+        const struct inode_operations *cache_dir_iops;
+        const struct inode_operations *cache_file_iops;
+        const struct inode_operations *cache_sym_iops;
 
-        struct file_operations *cache_dir_fops;
-        struct file_operations *cache_file_fops;
-        struct file_operations *cache_sym_fops;
+        const struct file_operations *cache_dir_fops;
+        const struct file_operations *cache_file_fops;
+        const struct file_operations *cache_sym_fops;
 
-        struct dentry_operations *cache_dentry_ops;
+        const struct dentry_operations *cache_dentry_ops;
 };
 
 
diff -urNp linux-2.4.37.7/include/linux/fs.h linux-2.4.37.7/include/linux/fs.h
--- linux-2.4.37.7/include/linux/fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -410,7 +410,7 @@ struct address_space {
 	struct list_head	dirty_pages;	/* list of dirty pages */
 	struct list_head	locked_pages;	/* list of locked pages */
 	unsigned long		nrpages;	/* number of total pages */
-	struct address_space_operations *a_ops;	/* methods */
+	const struct address_space_operations *a_ops;	/* methods */
 	struct inode		*host;		/* owner: inode, block_device */
 	struct vm_area_struct	*i_mmap;	/* list of private mappings */
 	struct vm_area_struct	*i_mmap_shared; /* list of shared mappings */
@@ -465,8 +465,8 @@ struct inode {
 	struct semaphore	i_sem;
 	struct rw_semaphore	i_alloc_sem;
 	struct semaphore	i_zombie;
-	struct inode_operations	*i_op;
-	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+	const struct inode_operations	*i_op;
+	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct super_block	*i_sb;
 	wait_queue_head_t	i_wait;
 	struct file_lock	*i_flock;
@@ -566,7 +566,7 @@ struct file {
 	struct list_head	f_list;
 	struct dentry		*f_dentry;
 	struct vfsmount         *f_vfsmnt;
-	struct file_operations	*f_op;
+	const struct file_operations	*f_op;
 	atomic_t		f_count;
 	unsigned int 		f_flags;
 	mode_t			f_mode;
@@ -750,7 +750,7 @@ struct super_block {
 	unsigned char		s_dirt;
 	unsigned long long	s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
-	struct super_operations	*s_op;
+	const struct super_operations	*s_op;
 	struct dquot_operations	*dq_op;
 	struct quotactl_ops	*s_qcop;
 	unsigned long		s_flags;
@@ -1086,7 +1086,7 @@ static inline int get_lease(struct inode
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, struct vfsmount *);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
@@ -1110,16 +1110,16 @@ extern struct char_device *cdget(dev_t);
 extern void cdput(struct char_device *);
 extern int blkdev_open(struct inode *, struct file *);
 extern int blkdev_close(struct inode *, struct file *);
-extern struct file_operations def_blk_fops;
-extern struct address_space_operations def_blk_aops;
-extern struct file_operations def_fifo_fops;
+extern const struct file_operations def_blk_fops;
+extern const struct address_space_operations def_blk_aops;
+extern const struct file_operations def_fifo_fops;
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, mode_t, unsigned, int);
 extern int blkdev_put(struct block_device *, int);
 
 /* fs/devices.c */
 extern const struct block_device_operations *get_blkfops(unsigned int);
-extern int register_chrdev(unsigned int, const char *, struct file_operations *);
+extern int register_chrdev(unsigned int, const char *, const struct file_operations *);
 extern int unregister_chrdev(unsigned int, const char *);
 extern int chrdev_open(struct inode *, struct file *);
 extern const char * bdevname(kdev_t);
@@ -1131,12 +1131,12 @@ extern void init_special_inode(struct in
 extern void make_bad_inode(struct inode *);
 extern int is_bad_inode(struct inode *);
 
-extern struct file_operations read_fifo_fops;
-extern struct file_operations write_fifo_fops;
-extern struct file_operations rdwr_fifo_fops;
-extern struct file_operations read_pipe_fops;
-extern struct file_operations write_pipe_fops;
-extern struct file_operations rdwr_pipe_fops;
+extern const struct file_operations read_fifo_fops;
+extern const struct file_operations write_fifo_fops;
+extern const struct file_operations rdwr_fifo_fops;
+extern const struct file_operations read_pipe_fops;
+extern const struct file_operations write_pipe_fops;
+extern const struct file_operations rdwr_pipe_fops;
 
 extern int fs_may_remount_ro(struct super_block *);
 
@@ -1530,13 +1530,13 @@ extern loff_t generic_file_llseek(struct
 extern ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 
-extern struct file_operations generic_ro_fops;
+extern const struct file_operations generic_ro_fops;
 
 extern int vfs_readlink(struct dentry *, char *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
 extern int page_readlink(struct dentry *, char *, int);
 extern int page_follow_link(struct dentry *, struct nameidata *);
-extern struct inode_operations page_symlink_inode_operations;
+extern const struct inode_operations page_symlink_inode_operations;
 
 extern int vfs_readdir(struct file *, filldir_t, void *);
 extern int dcache_dir_open(struct inode *, struct file *);
@@ -1544,7 +1544,7 @@ extern int dcache_dir_close(struct inode
 extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
 extern int dcache_dir_fsync(struct file *, struct dentry *, int);
 extern int dcache_readdir(struct file *, void *, filldir_t);
-extern struct file_operations dcache_dir_ops;
+extern const struct file_operations dcache_dir_ops;
 
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(kdev_t);
diff -urNp linux-2.4.37.7/include/linux/gracl.h linux-2.4.37.7/include/linux/gracl.h
--- linux-2.4.37.7/include/linux/gracl.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/gracl.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,317 @@
+#ifndef GR_ACL_H
+#define GR_ACL_H
+
+#include <linux/grdefs.h>
+#include <linux/resource.h>
+
+#include <asm/resource.h>
+
+/* Major status information */
+
+#define GR_VERSION  "grsecurity 2.1.14"
+#define GRSECURITY_VERSION 0x2114
+
+enum {
+	GR_SHUTDOWN = 0,
+	GR_ENABLE = 1,
+	GR_SPROLE = 2,
+	GR_RELOAD = 3,
+	GR_SEGVMOD = 4,
+	GR_STATUS = 5,
+	GR_UNSPROLE = 6,
+	GR_PASSSET = 7,
+	GR_SPROLEPAM = 8,
+};
+
+/* Password setup definitions
+ * kernel/grhash.c */
+enum {
+	GR_PW_LEN = 128,
+	GR_SALT_LEN = 16,
+	GR_SHA_LEN = 32,
+};
+
+enum {
+	GR_SPROLE_LEN = 64,
+};
+
+#define GR_NLIMITS 32
+
+/* Begin Data Structures */
+
+struct sprole_pw {
+	unsigned char *rolename;
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];	/* 256-bit SHA hash of the password */
+};
+
+struct name_entry {
+	__u32 key;
+	ino_t inode;
+	__u32 device;
+	char *name;
+	__u16 len;
+	__u8 deleted;
+	struct name_entry *prev;
+	struct name_entry *next;
+};
+
+struct inodev_entry {
+	struct name_entry *nentry;
+	struct inodev_entry *prev;
+	struct inodev_entry *next;
+};
+
+struct acl_role_db {
+	struct acl_role_label **r_hash;
+	__u32 r_size;
+};
+
+struct name_db {
+	struct name_entry **n_hash;
+	__u32 n_size;
+};
+
+struct inodev_db {
+	struct inodev_entry **i_hash;
+	__u32 i_size;
+};
+
+struct crash_uid {
+	uid_t uid;
+	unsigned long expires;
+};
+
+struct gr_hash_struct {
+	void **table;
+	void **nametable;
+	void *first;
+	__u32 table_size;
+	__u32 used_size;
+	int type;
+};
+
+/* Userspace Grsecurity ACL data structures */
+struct acl_subject_label {
+	char *filename;
+	ino_t inode;
+	__u32 device;
+	__u32 mode;
+	__u32 cap_mask;
+	__u32 cap_mask_unused;
+	__u32 cap_lower;
+	__u32 cap_lower_unused;
+
+	struct rlimit res[GR_NLIMITS];
+	__u32 resmask;
+
+	__u8 user_trans_type;
+	__u8 group_trans_type;
+	uid_t *user_transitions;
+	gid_t *group_transitions;
+	__u16 user_trans_num;
+	__u16 group_trans_num;
+
+	__u32 ip_proto[8];
+	__u32 ip_type;
+	struct acl_ip_label **ips;
+	__u32 ip_num;
+	__u32 inaddr_any_override;
+
+	__u32 crashes;
+	unsigned long expires;
+
+	struct acl_subject_label *parent_subject;
+	struct gr_hash_struct *hash;
+	struct acl_subject_label *prev;
+	struct acl_subject_label *next;
+
+	struct acl_object_label **obj_hash;
+	__u32 obj_hash_size;
+	__u16 pax_flags;
+};
+
+struct role_allowed_ip {
+	__u32 addr;
+	__u32 netmask;
+
+	struct role_allowed_ip *prev;
+	struct role_allowed_ip *next;
+};
+
+struct role_transition {
+	char *rolename;
+
+	struct role_transition *prev;
+	struct role_transition *next;
+};
+
+struct acl_role_label {
+	char *rolename;
+	uid_t uidgid;
+	__u16 roletype;
+
+	__u16 auth_attempts;
+	unsigned long expires;
+
+	struct acl_subject_label *root_label;
+	struct gr_hash_struct *hash;
+
+	struct acl_role_label *prev;
+	struct acl_role_label *next;
+
+	struct role_transition *transitions;
+	struct role_allowed_ip *allowed_ips;
+	uid_t *domain_children;
+	__u16 domain_child_num;
+
+	struct acl_subject_label **subj_hash;
+	__u32 subj_hash_size;
+};
+
+struct user_acl_role_db {
+	struct acl_role_label **r_table;
+	__u32 num_pointers;		/* Number of allocations to track */
+	__u32 num_roles;		/* Number of roles */
+	__u32 num_domain_children;	/* Number of domain children */
+	__u32 num_subjects;		/* Number of subjects */
+	__u32 num_objects;		/* Number of objects */
+};
+
+struct acl_object_label {
+	char *filename;
+	ino_t inode;
+	__u32 device;
+	__u32 mode;
+
+	struct acl_subject_label *nested;
+	struct acl_object_label *globbed;
+
+	/* next two structures not used */
+
+	struct acl_object_label *prev;
+	struct acl_object_label *next;
+};
+
+struct acl_ip_label {
+	char *iface;
+	__u32 addr;
+	__u32 netmask;
+	__u16 low, high;
+	__u8 mode;
+	__u32 type;
+	__u32 proto[8];
+
+	/* next two structures not used */
+
+	struct acl_ip_label *prev;
+	struct acl_ip_label *next;
+};
+
+struct gr_arg {
+	struct user_acl_role_db role_db;
+	unsigned char pw[GR_PW_LEN];
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];
+	unsigned char sp_role[GR_SPROLE_LEN];
+	struct sprole_pw *sprole_pws;
+	__u32 segv_device;
+	ino_t segv_inode;
+	uid_t segv_uid;
+	__u16 num_sprole_pws;
+	__u16 mode;
+};
+
+struct gr_arg_wrapper {
+	struct gr_arg *arg;
+	__u32 version;
+	__u32 size;
+};
+
+struct subject_map {
+	struct acl_subject_label *user;
+	struct acl_subject_label *kernel;
+	struct subject_map *prev;
+	struct subject_map *next;
+};
+
+struct acl_subj_map_db {
+	struct subject_map **s_hash;
+	__u32 s_size;
+};
+
+/* End Data Structures Section */
+
+/* Hash functions generated by empirical testing by Brad Spengler
+   Makes good use of the low bits of the inode.  Generally 0-1 times
+   in loop for successful match.  0-3 for unsuccessful match.
+   Shift/add algorithm with modulus of table size and an XOR*/
+
+static __inline__ unsigned int
+rhash(const uid_t uid, const __u16 type, const unsigned int sz)
+{
+	return (((uid << type) + (uid ^ type)) % sz);
+}
+
+static __inline__ unsigned int
+shash(const struct acl_subject_label *userp, const unsigned int sz)
+{
+	return ((const unsigned long)userp % sz);
+}
+
+static __inline__ unsigned int
+fhash(const ino_t ino, const __u32 dev, const unsigned int sz)
+{
+	return (((ino + dev) ^ ((ino << 13) + (ino << 23) + (dev << 9))) % sz);
+}
+
+static __inline__ unsigned int
+nhash(const char *name, const __u16 len, const unsigned int sz)
+{
+	return full_name_hash(name, len) % sz;
+}
+
+#define FOR_EACH_ROLE_START(role,iter) \
+	role = NULL; \
+	iter = 0; \
+	while (iter < acl_role_set.r_size) { \
+		if (role == NULL) \
+			role = acl_role_set.r_hash[iter]; \
+		if (role == NULL) { \
+			iter++; \
+			continue; \
+		}
+
+#define FOR_EACH_ROLE_END(role,iter) \
+		role = role->next; \
+		if (role == NULL) \
+			iter++; \
+	}
+
+#define FOR_EACH_SUBJECT_START(role,subj,iter) \
+	subj = NULL; \
+	iter = 0; \
+	while (iter < role->subj_hash_size) { \
+		if (subj == NULL) \
+			subj = role->subj_hash[iter]; \
+		if (subj == NULL) { \
+			iter++; \
+			continue; \
+		}
+
+#define FOR_EACH_SUBJECT_END(subj,iter) \
+		subj = subj->next; \
+		if (subj == NULL) \
+			iter++; \
+	}
+
+
+#define FOR_EACH_NESTED_SUBJECT_START(role,subj) \
+	subj = role->hash->first; \
+	while (subj != NULL) {
+
+#define FOR_EACH_NESTED_SUBJECT_END(subj) \
+		subj = subj->next; \
+	}
+
+#endif
diff -urNp linux-2.4.37.7/include/linux/gralloc.h linux-2.4.37.7/include/linux/gralloc.h
--- linux-2.4.37.7/include/linux/gralloc.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/gralloc.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,9 @@
+#ifndef __GRALLOC_H
+#define __GRALLOC_H
+
+void acl_free_all(void);
+int acl_alloc_stack_init(unsigned long size);
+void *acl_alloc(unsigned long len);
+void *acl_alloc_num(unsigned long num, unsigned long len);
+
+#endif
diff -urNp linux-2.4.37.7/include/linux/grdefs.h linux-2.4.37.7/include/linux/grdefs.h
--- linux-2.4.37.7/include/linux/grdefs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/grdefs.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,132 @@
+#ifndef GRDEFS_H
+#define GRDEFS_H
+
+/* Begin grsecurity status declarations */
+
+enum {
+	GR_READY = 0x01,
+	GR_STATUS_INIT = 0x00	// disabled state
+};
+
+/* Begin  ACL declarations */
+
+/* Role flags */
+
+enum {
+	GR_ROLE_USER = 0x0001,
+	GR_ROLE_GROUP = 0x0002,
+	GR_ROLE_DEFAULT = 0x0004,
+	GR_ROLE_SPECIAL = 0x0008,
+	GR_ROLE_AUTH = 0x0010,
+	GR_ROLE_NOPW = 0x0020,
+	GR_ROLE_GOD = 0x0040,
+	GR_ROLE_LEARN = 0x0080,
+	GR_ROLE_TPE = 0x0100,
+	GR_ROLE_DOMAIN = 0x0200,
+	GR_ROLE_PAM = 0x0400
+};
+
+/* ACL Subject and Object mode flags */
+enum {
+	GR_DELETED = 0x80000000
+};
+
+/* ACL Object-only mode flags */
+enum {
+	GR_READ 	= 0x00000001,
+	GR_APPEND 	= 0x00000002,
+	GR_WRITE 	= 0x00000004,
+	GR_EXEC 	= 0x00000008,
+	GR_FIND 	= 0x00000010,
+	GR_INHERIT 	= 0x00000020,
+	GR_SETID 	= 0x00000040,
+	GR_CREATE 	= 0x00000080,
+	GR_DELETE 	= 0x00000100,
+	GR_LINK		= 0x00000200,
+	GR_AUDIT_READ 	= 0x00000400,
+	GR_AUDIT_APPEND = 0x00000800,
+	GR_AUDIT_WRITE 	= 0x00001000,
+	GR_AUDIT_EXEC 	= 0x00002000,
+	GR_AUDIT_FIND 	= 0x00004000,
+	GR_AUDIT_INHERIT= 0x00008000,
+	GR_AUDIT_SETID 	= 0x00010000,
+	GR_AUDIT_CREATE = 0x00020000,
+	GR_AUDIT_DELETE = 0x00040000,
+	GR_AUDIT_LINK	= 0x00080000,
+	GR_PTRACERD 	= 0x00100000,
+	GR_NOPTRACE	= 0x00200000,
+	GR_SUPPRESS 	= 0x00400000,
+	GR_NOLEARN 	= 0x00800000
+};
+
+#define GR_AUDITS (GR_AUDIT_READ | GR_AUDIT_WRITE | GR_AUDIT_APPEND | GR_AUDIT_EXEC | \
+		   GR_AUDIT_FIND | GR_AUDIT_INHERIT | GR_AUDIT_SETID | \
+		   GR_AUDIT_CREATE | GR_AUDIT_DELETE | GR_AUDIT_LINK)
+
+/* ACL subject-only mode flags */
+enum {
+	GR_KILL 	= 0x00000001,
+	GR_VIEW 	= 0x00000002,
+	GR_PROTECTED 	= 0x00000004,
+	GR_LEARN 	= 0x00000008,
+	GR_OVERRIDE 	= 0x00000010,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_DUMMY 	= 0x00000020,
+	GR_PROTSHM 	= 0x00000040,
+	GR_KILLPROC 	= 0x00000080,
+	GR_KILLIPPROC	= 0x00000100,
+	/* just a placeholder, this mode is only used in userspace */
+	GR_NOTROJAN 	= 0x00000200,
+	GR_PROTPROCFD 	= 0x00000400,
+	GR_PROCACCT 	= 0x00000800,
+	GR_RELAXPTRACE	= 0x00001000,
+	GR_NESTED	= 0x00002000,
+	GR_INHERITLEARN = 0x00004000,
+	GR_PROCFIND	= 0x00008000,
+	GR_POVERRIDE	= 0x00010000,
+	GR_KERNELAUTH	= 0x00020000,
+};
+
+/* PaX flags */
+enum {
+	GR_PAX_ENABLE_SEGMEXEC  =  0x0001,
+	GR_PAX_ENABLE_PAGEEXEC  =  0x0002,
+	GR_PAX_ENABLE_MPROTECT  =  0x0004,
+	GR_PAX_ENABLE_RANDMMAP  =  0x0008,
+	GR_PAX_ENABLE_EMUTRAMP  =  0x0010,
+	GR_PAX_DISABLE_SEGMEXEC =  0x0100,
+	GR_PAX_DISABLE_PAGEEXEC  = 0x0200,
+	GR_PAX_DISABLE_MPROTECT  = 0x0400,
+	GR_PAX_DISABLE_RANDMMAP  = 0x0800,
+	GR_PAX_DISABLE_EMUTRAMP  = 0x1000
+};
+
+enum {
+	GR_ID_USER      = 0x01,
+	GR_ID_GROUP     = 0x02,
+};
+
+enum {
+	GR_ID_ALLOW     = 0x01,
+	GR_ID_DENY      = 0x02,
+};
+
+#define GR_CRASH_RES	31
+#define GR_UIDTABLE_MAX 500
+
+/* begin resource learning section */
+enum {
+	GR_RLIM_CPU_BUMP = 60,
+	GR_RLIM_FSIZE_BUMP = 50000,
+	GR_RLIM_DATA_BUMP = 10000,
+	GR_RLIM_STACK_BUMP = 1000,
+	GR_RLIM_CORE_BUMP = 10000,
+	GR_RLIM_RSS_BUMP = 500000,
+	GR_RLIM_NPROC_BUMP = 1,
+	GR_RLIM_NOFILE_BUMP = 5,
+	GR_RLIM_MEMLOCK_BUMP = 50000,
+	GR_RLIM_AS_BUMP = 500000,
+	GR_RLIM_LOCKS_BUMP = 2
+};
+
+#endif
diff -urNp linux-2.4.37.7/include/linux/grinternal.h linux-2.4.37.7/include/linux/grinternal.h
--- linux-2.4.37.7/include/linux/grinternal.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/grinternal.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,211 @@
+#ifndef __GRINTERNAL_H
+#define __GRINTERNAL_H
+
+#ifdef CONFIG_GRKERNSEC
+
+#include <linux/grdefs.h>
+#include <linux/gracl.h>
+#include <linux/grmsg.h>
+
+void gr_add_learn_entry(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+__u32 gr_search_file(const struct dentry *dentry, const __u32 mode,
+			    const struct vfsmount *mnt);
+__u32 gr_check_create(const struct dentry *new_dentry,
+			     const struct dentry *parent,
+			     const struct vfsmount *mnt, const __u32 mode);
+int gr_check_protected_task(const struct task_struct *task);
+__u32 to_gr_audit(const __u32 reqmode);
+int gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
+			    struct dentry *old_dentry,
+			    struct dentry *new_dentry,
+			    struct vfsmount *mnt, const __u8 replace);
+int gr_set_acls(const int type);
+int gr_acl_is_enabled(void);
+char gr_roletype_to_char(void);
+
+void gr_handle_alertkill(struct task_struct *task);
+char *gr_to_filename(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename1(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename2(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+char *gr_to_filename3(const struct dentry *dentry,
+			    const struct vfsmount *mnt);
+
+extern int grsec_enable_link;
+extern int grsec_enable_fifo;
+extern int grsec_enable_execve;
+extern int grsec_enable_execlog;
+extern int grsec_enable_signal;
+extern int grsec_enable_forkfail;
+extern int grsec_enable_time;
+extern int grsec_enable_chroot_shmat;
+extern int grsec_enable_chroot_findtask;
+extern int grsec_enable_chroot_mount;
+extern int grsec_enable_chroot_double;
+extern int grsec_enable_chroot_pivot;
+extern int grsec_enable_chroot_chdir;
+extern int grsec_enable_chroot_chmod;
+extern int grsec_enable_chroot_mknod;
+extern int grsec_enable_chroot_fchdir;
+extern int grsec_enable_chroot_nice;
+extern int grsec_enable_chroot_execlog;
+extern int grsec_enable_chroot_caps;
+extern int grsec_enable_chroot_sysctl;
+extern int grsec_enable_chroot_unix;
+extern int grsec_enable_tpe;
+extern int grsec_tpe_gid;
+extern int grsec_enable_tpe_all;
+extern int grsec_enable_socket_all;
+extern int grsec_socket_all_gid;
+extern int grsec_enable_socket_client;
+extern int grsec_socket_client_gid;
+extern int grsec_enable_socket_server;
+extern int grsec_socket_server_gid;
+extern int grsec_audit_gid;
+extern int grsec_enable_group;
+extern int grsec_enable_audit_ipc;
+extern int grsec_enable_audit_textrel;
+extern int grsec_enable_mount;
+extern int grsec_enable_chdir;
+extern int grsec_lock;
+extern int grsec_resource_logging;
+
+extern struct task_struct *child_reaper;
+
+extern spinlock_t grsec_alert_lock;
+extern unsigned long grsec_alert_wtime;
+extern unsigned long grsec_alert_fyet;
+
+extern spinlock_t grsec_audit_lock;
+
+extern rwlock_t grsec_exec_file_lock;
+
+#define gr_task_fullpath(tsk) (tsk->exec_file ? \
+			gr_to_filename2(tsk->exec_file->f_dentry, \
+			tsk->exec_file->f_vfsmnt) : "/")
+
+#define gr_parent_task_fullpath(tsk) (tsk->p_pptr->exec_file ? \
+			gr_to_filename3(tsk->p_pptr->exec_file->f_dentry, \
+			tsk->p_pptr->exec_file->f_vfsmnt) : "/")
+
+#define gr_task_fullpath0(tsk) (tsk->exec_file ? \
+			gr_to_filename(tsk->exec_file->f_dentry, \
+			tsk->exec_file->f_vfsmnt) : "/")
+
+#define gr_parent_task_fullpath0(tsk) (tsk->p_pptr->exec_file ? \
+			gr_to_filename1(tsk->p_pptr->exec_file->f_dentry, \
+			tsk->p_pptr->exec_file->f_vfsmnt) : "/")
+
+#define proc_is_chrooted(tsk_a)  ((tsk_a->pid > 1) && (tsk_a->fs != NULL) && \
+			  ((tsk_a->fs->root->d_inode->i_dev != \
+			  child_reaper->fs->root->d_inode->i_dev) || \
+			  (tsk_a->fs->root->d_inode->i_ino != \
+			  child_reaper->fs->root->d_inode->i_ino)))
+
+#define have_same_root(tsk_a,tsk_b) ((tsk_a->fs != NULL && tsk_b->fs != NULL) && \
+			  (tsk_a->fs->root->d_inode->i_dev == \
+			  tsk_b->fs->root->d_inode->i_dev) && \
+			  (tsk_a->fs->root->d_inode->i_ino == \
+			  tsk_b->fs->root->d_inode->i_ino))
+
+#define DEFAULTSECARGS(task) gr_task_fullpath(task), task->comm, \
+		       task->pid, task->uid, \
+		       task->euid, task->gid, task->egid, \
+		       gr_parent_task_fullpath(task), \
+		       task->p_pptr->comm, task->p_pptr->pid, \
+		       task->p_pptr->uid, task->p_pptr->euid, \
+		       task->p_pptr->gid, task->p_pptr->egid
+
+#define GR_CHROOT_CAPS ( \
+	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG) | \
+	CAP_TO_MASK(CAP_IPC_OWNER))
+
+#define security_learn(normal_msg,args...) \
+({ \
+	read_lock(&grsec_exec_file_lock); \
+	gr_add_learn_entry(normal_msg "\n", ## args); \
+	read_unlock(&grsec_exec_file_lock); \
+})
+
+enum {
+	GR_DO_AUDIT,
+	GR_DONT_AUDIT,
+	GR_DONT_AUDIT_GOOD
+};
+
+enum {
+	GR_TTYSNIFF,
+	GR_RBAC,
+	GR_RBAC_STR,
+	GR_STR_RBAC,
+	GR_RBAC_MODE2,
+	GR_RBAC_MODE3,
+	GR_FILENAME,
+	GR_NOARGS,
+	GR_ONE_INT,
+	GR_ONE_INT_TWO_STR,
+	GR_ONE_STR,
+	GR_STR_INT,
+	GR_TWO_INT,
+	GR_THREE_INT,
+	GR_FIVE_INT_TWO_STR,
+	GR_TWO_STR,
+	GR_THREE_STR,
+	GR_FOUR_STR,
+	GR_STR_FILENAME,
+	GR_FILENAME_STR,
+	GR_FILENAME_TWO_INT,
+	GR_FILENAME_TWO_INT_STR,
+	GR_TEXTREL,
+	GR_PTRACE,
+	GR_RESOURCE,
+	GR_CAP,
+	GR_SIG,
+	GR_CRASH1,
+	GR_CRASH2,
+	GR_PSACCT
+};
+
+#define gr_log_ttysniff(audit, msg, task) gr_log_varargs(audit, msg, GR_TTYSNIFF, task)
+#define gr_log_fs_rbac_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_RBAC, dentry, mnt)
+#define gr_log_fs_rbac_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_RBAC_STR, dentry, mnt, str)
+#define gr_log_fs_str_rbac(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_RBAC, str, dentry, mnt)
+#define gr_log_fs_rbac_mode2(audit, msg, dentry, mnt, str1, str2) gr_log_varargs(audit, msg, GR_RBAC_MODE2, dentry, mnt, str1, str2)
+#define gr_log_fs_rbac_mode3(audit, msg, dentry, mnt, str1, str2, str3) gr_log_varargs(audit, msg, GR_RBAC_MODE3, dentry, mnt, str1, str2, str3)
+#define gr_log_fs_generic(audit, msg, dentry, mnt) gr_log_varargs(audit, msg, GR_FILENAME, dentry, mnt)
+#define gr_log_noargs(audit, msg) gr_log_varargs(audit, msg, GR_NOARGS)
+#define gr_log_int(audit, msg, num) gr_log_varargs(audit, msg, GR_ONE_INT, num)
+#define gr_log_int_str2(audit, msg, num, str1, str2) gr_log_varargs(audit, msg, GR_ONE_INT_TWO_STR, num, str1, str2)
+#define gr_log_str(audit, msg, str) gr_log_varargs(audit, msg, GR_ONE_STR, str)
+#define gr_log_str_int(audit, msg, str, num) gr_log_varargs(audit, msg, GR_STR_INT, str, num)
+#define gr_log_int_int(audit, msg, num1, num2) gr_log_varargs(audit, msg, GR_TWO_INT, num1, num2)
+#define gr_log_int3(audit, msg, num1, num2, num3) gr_log_varargs(audit, msg, GR_THREE_INT, num1, num2, num3)
+#define gr_log_int5_str2(audit, msg, num1, num2, str1, str2) gr_log_varargs(audit, msg, GR_FIVE_INT_TWO_STR, num1, num2, str1, str2)
+#define gr_log_str_str(audit, msg, str1, str2) gr_log_varargs(audit, msg, GR_TWO_STR, str1, str2)
+#define gr_log_str3(audit, msg, str1, str2, str3) gr_log_varargs(audit, msg, GR_THREE_STR, str1, str2, str3)
+#define gr_log_str4(audit, msg, str1, str2, str3, str4) gr_log_varargs(audit, msg, GR_FOUR_STR, str1, str2, str3, str4)
+#define gr_log_str_fs(audit, msg, str, dentry, mnt) gr_log_varargs(audit, msg, GR_STR_FILENAME, str, dentry, mnt)
+#define gr_log_fs_str(audit, msg, dentry, mnt, str) gr_log_varargs(audit, msg, GR_FILENAME_STR, dentry, mnt, str)
+#define gr_log_fs_int2(audit, msg, dentry, mnt, num1, num2) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT, dentry, mnt, num1, num2)
+#define gr_log_fs_int2_str(audit, msg, dentry, mnt, num1, num2, str) gr_log_varargs(audit, msg, GR_FILENAME_TWO_INT_STR, dentry, mnt, num1, num2, str)
+#define gr_log_textrel_ulong_ulong(audit, msg, file, ulong1, ulong2) gr_log_varargs(audit, msg, GR_TEXTREL, file, ulong1, ulong2)
+#define gr_log_ptrace(audit, msg, task) gr_log_varargs(audit, msg, GR_PTRACE, task)
+#define gr_log_res_ulong2_str(audit, msg, task, ulong1, str, ulong2) gr_log_varargs(audit, msg, GR_RESOURCE, task, ulong1, str, ulong2)
+#define gr_log_cap(audit, msg, task, str) gr_log_varargs(audit, msg, GR_CAP, task, str)
+#define gr_log_sig(audit, msg, task, num) gr_log_varargs(audit, msg, GR_SIG, task, num)
+#define gr_log_crash1(audit, msg, task, ulong) gr_log_varargs(audit, msg, GR_CRASH1, task, ulong)
+#define gr_log_crash2(audit, msg, task, str, ulong1, ulong2) gr_log_varargs(audit, msg, GR_CRASH2, task, str, ulong1, ulong2)
+#define gr_log_procacct(audit, msg, task, num1, num2, num3, num4, num5, num6, num7, num8, num9) gr_log_varargs(audit, msg, GR_PSACCT, task, num1, num2, num3, num4, num5, num6, num7, num8, num9)
+
+void gr_log_varargs(int audit, const char *msg, int argtypes, ...);
+
+#endif
+
+#endif
diff -urNp linux-2.4.37.7/include/linux/grmsg.h linux-2.4.37.7/include/linux/grmsg.h
--- linux-2.4.37.7/include/linux/grmsg.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/grmsg.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,108 @@
+#define DEFAULTSECMSG "%.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u, parent %.256s[%.16s:%d] uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_ACL_PROCACCT_MSG "%.256s[%.16s:%d] IP:%u.%u.%u.%u TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u run time:[%ud %uh %um %us] cpu time:[%ud %uh %um %us] %s with exit code %ld, parent %.256s[%.16s:%d] IP:%u.%u.%u.%u TTY:%.64s uid/euid:%u/%u gid/egid:%u/%u"
+#define GR_STOPMOD_MSG "denied modification of module state by "
+#define GR_PTRACE_ACL_MSG "denied ptrace of %.950s(%.16s:%d) by "
+#define GR_IOPERM_MSG "denied use of ioperm() by "
+#define GR_IOPL_MSG "denied use of iopl() by "
+#define GR_SHMAT_ACL_MSG "denied attach of shared memory of UID %u, PID %d, ID %u by "
+#define GR_UNIX_CHROOT_MSG "denied connect() to abstract AF_UNIX socket outside of chroot by "
+#define GR_SHMAT_CHROOT_MSG "denied attach of shared memory outside of chroot by "
+#define GR_KMEM_MSG "denied write of /dev/kmem by "
+#define GR_PORT_OPEN_MSG "denied open of /dev/port by "
+#define GR_MEM_WRITE_MSG "denied write of /dev/mem by "
+#define GR_MEM_MMAP_MSG "denied mmap write of /dev/[k]mem by "
+#define GR_SYMLINK_MSG "not following symlink %.950s owned by %d.%d by "
+#define GR_LEARN_AUDIT_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%lu\t%lu\t%.4095s\t%lu\t%u.%u.%u.%u"
+#define GR_ID_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%c\t%d\t%d\t%d\t%u.%u.%u.%u"
+#define GR_HIDDEN_ACL_MSG "%s access to hidden file %.950s by "
+#define GR_OPEN_ACL_MSG "%s open of %.950s for%s%s by "
+#define GR_CREATE_ACL_MSG "%s create of %.950s for%s%s by "
+#define GR_FIFO_MSG "denied writing FIFO %.950s of %d.%d by "
+#define GR_MKNOD_CHROOT_MSG "denied mknod of %.950s from chroot by "
+#define GR_MKNOD_ACL_MSG "%s mknod of %.950s by "
+#define GR_UNIXCONNECT_ACL_MSG "%s connect() to the unix domain socket %.950s by "
+#define GR_TTYSNIFF_ACL_MSG "terminal being sniffed by IP:%u.%u.%u.%u %.480s[%.16s:%d], parent %.480s[%.16s:%d] against "
+#define GR_MKDIR_ACL_MSG "%s mkdir of %.950s by "
+#define GR_RMDIR_ACL_MSG "%s rmdir of %.950s by "
+#define GR_UNLINK_ACL_MSG "%s unlink of %.950s by "
+#define GR_SYMLINK_ACL_MSG "%s symlink from %.480s to %.480s by "
+#define GR_HARDLINK_MSG "denied hardlink of %.930s (owned by %d.%d) to %.30s for "
+#define GR_LINK_ACL_MSG "%s link of %.480s to %.480s by "
+#define GR_INHERIT_ACL_MSG "successful inherit of %.480s's ACL for %.480s by "
+#define GR_RENAME_ACL_MSG "%s rename of %.480s to %.480s by "
+#define GR_PTRACE_EXEC_ACL_MSG "denied ptrace of %.950s by "
+#define GR_NPROC_MSG "denied overstep of process limit by "
+#define GR_EXEC_ACL_MSG "%s execution of %.950s by "
+#define GR_EXEC_TPE_MSG "denied untrusted exec of %.950s by "
+#define GR_SEGVSTART_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning uid %u from login for %lu seconds"
+#define GR_SEGVNOSUID_ACL_MSG "possible exploit bruteforcing on " DEFAULTSECMSG " banning execution of [%.16s:%lu] for %lu seconds"
+#define GR_MOUNT_CHROOT_MSG "denied mount of %.30s as %.930s from chroot by "
+#define GR_PIVOT_CHROOT_MSG "denied pivot_root from chroot by "
+#define GR_TRUNCATE_ACL_MSG "%s truncate of %.950s by "
+#define GR_ATIME_ACL_MSG "%s access time change of %.950s by "
+#define GR_ACCESS_ACL_MSG "%s access of %.950s for%s%s%s by "
+#define GR_CHROOT_CHROOT_MSG "denied double chroot to %.950s by "
+#define GR_FCHMOD_ACL_MSG "%s fchmod of %.950s by "
+#define GR_CHMOD_CHROOT_MSG "denied chmod +s of %.950s by "
+#define GR_CHMOD_ACL_MSG "%s chmod of %.950s by "
+#define GR_CHROOT_FCHDIR_MSG "denied fchdir outside of chroot to %.950s by "
+#define GR_CHOWN_ACL_MSG "%s chown of %.950s by "
+#define GR_WRITLIB_ACL_MSG "denied load of writable library %.950s by "
+#define GR_INITF_ACL_MSG "init_variables() failed %s by "
+#define GR_DISABLED_ACL_MSG "Error loading %s, trying to run kernel with acls disabled. To disable acls at startup use <kernel image name> gracl=off from your boot loader"
+#define GR_DEV_ACL_MSG "/dev/grsec: %d bytes sent %d required, being fed garbaged by "
+#define GR_SHUTS_ACL_MSG "shutdown auth success for "
+#define GR_SHUTF_ACL_MSG "shutdown auth failure for "
+#define GR_SHUTI_ACL_MSG "ignoring shutdown for disabled RBAC system for "
+#define GR_SEGVMODS_ACL_MSG "segvmod auth success for "
+#define GR_SEGVMODF_ACL_MSG "segvmod auth failure for "
+#define GR_SEGVMODI_ACL_MSG "ignoring segvmod for disabled RBAC system for "
+#define GR_ENABLE_ACL_MSG "%s RBAC system loaded by "
+#define GR_ENABLEF_ACL_MSG "unable to load %s for "
+#define GR_RELOADI_ACL_MSG "ignoring reload request for disabled RBAC system"
+#define GR_RELOAD_ACL_MSG "%s RBAC system reloaded by "
+#define GR_RELOADF_ACL_MSG "failed reload of %s for "
+#define GR_SPROLEI_ACL_MSG "ignoring change to special role for disabled RBAC system for "
+#define GR_SPROLES_ACL_MSG "successful change to special role %s (id %d) by "
+#define GR_SPROLEL_ACL_MSG "special role %s (id %d) exited by "
+#define GR_SPROLEF_ACL_MSG "special role %s failure for "
+#define GR_UNSPROLEI_ACL_MSG "ignoring unauth of special role for disabled RBAC system for "
+#define GR_UNSPROLES_ACL_MSG "successful unauth of special role %s (id %d) by "
+#define GR_UNSPROLEF_ACL_MSG "special role unauth of %s failure for "
+#define GR_INVMODE_ACL_MSG "invalid mode %d by "
+#define GR_PRIORITY_CHROOT_MSG "denied priority change of process (%.16s:%d) by "
+#define GR_FAILFORK_MSG "failed fork with errno %d by "
+#define GR_NICE_CHROOT_MSG "denied priority change by "
+#define GR_UNISIGLOG_MSG "signal %d sent to "
+#define GR_DUALSIGLOG_MSG "signal %d sent to " DEFAULTSECMSG " by "
+#define GR_SIG_ACL_MSG "denied send of signal %d to protected task " DEFAULTSECMSG " by "
+#define GR_SYSCTL_MSG "denied modification of grsecurity sysctl value : %.32s by "
+#define GR_SYSCTL_ACL_MSG "%s sysctl of %.950s for%s%s by "
+#define GR_TIME_MSG "time set by "
+#define GR_DEFACL_MSG "fatal: unable to find subject for (%.16s:%d), loaded by "
+#define GR_MMAP_ACL_MSG "%s executable mmap of %.950s by "
+#define GR_MPROTECT_ACL_MSG "%s executable mprotect of %.950s by "
+#define GR_SOCK_MSG "denied socket(%.16s,%.16s,%.16s) by "
+#define GR_SOCK2_MSG "denied socket(%d,%.16s,%.16s) by "
+#define GR_BIND_MSG "denied bind() by "
+#define GR_CONNECT_MSG "denied connect() by "
+#define GR_BIND_ACL_MSG "denied bind() to %u.%u.%u.%u port %u sock type %.16s protocol %.16s by "
+#define GR_CONNECT_ACL_MSG "denied connect() to %u.%u.%u.%u port %u sock type %.16s protocol %.16s by "
+#define GR_IP_LEARN_MSG "%s\t%u\t%u\t%u\t%.4095s\t%.4095s\t%u.%u.%u.%u\t%u\t%u\t%u\t%u\t%u.%u.%u.%u"
+#define GR_EXEC_CHROOT_MSG "exec of %.980s within chroot by process "
+#define GR_CAP_ACL_MSG "use of %s denied for "
+#define GR_USRCHANGE_ACL_MSG "change to uid %u denied for "
+#define GR_GRPCHANGE_ACL_MSG "change to gid %u denied for "
+#define GR_REMOUNT_AUDIT_MSG "remount of %.30s by "
+#define GR_UNMOUNT_AUDIT_MSG "unmount of %.30s by "
+#define GR_MOUNT_AUDIT_MSG "mount of %.30s to %.64s by "
+#define GR_CHDIR_AUDIT_MSG "chdir to %.980s by "
+#define GR_EXEC_AUDIT_MSG "exec of %.930s (%.128s) by "
+#define GR_MSGQ_AUDIT_MSG "message queue created by "
+#define GR_MSGQR_AUDIT_MSG "message queue of uid:%u euid:%u removed by "
+#define GR_SEM_AUDIT_MSG "semaphore created by "
+#define GR_SEMR_AUDIT_MSG "semaphore of uid:%u euid:%u removed by "
+#define GR_SHM_AUDIT_MSG "shared memory of size %d created by "
+#define GR_SHMR_AUDIT_MSG "shared memory of uid:%u euid:%u removed by "
+#define GR_RESOURCE_MSG "denied resource overstep by requesting %lu for %.16s against limit %lu for "
+#define GR_TEXTREL_AUDIT_MSG "text relocation in %s, VMA:0x%08lx 0x%08lx by "
diff -urNp linux-2.4.37.7/include/linux/grsecurity.h linux-2.4.37.7/include/linux/grsecurity.h
--- linux-2.4.37.7/include/linux/grsecurity.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.37.7/include/linux/grsecurity.h	2009-11-10 19:30:27.000000000 -0500
@@ -0,0 +1,199 @@
+#ifndef GR_SECURITY_H
+#define GR_SECURITY_H
+
+/* notify of brain-dead configs */
+#if defined(CONFIG_PAX_NOEXEC) && !defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_PAX_SEGMEXEC) && !defined(CONFIG_PAX_KERNEXEC)
+#error "CONFIG_PAX_NOEXEC enabled, but PAGEEXEC, SEGMEXEC, and KERNEXEC are disabled."
+#endif
+#if defined(CONFIG_PAX_NOEXEC) && !defined(CONFIG_PAX_EI_PAX) && !defined(CONFIG_PAX_PT_PAX_FLAGS)
+#error "CONFIG_PAX_NOEXEC enabled, but neither CONFIG_PAX_EI_PAX nor CONFIG_PAX_PT_PAX_FLAGS are enabled."
+#endif
+#if defined(CONFIG_PAX_ASLR) && !defined(CONFIG_PAX_EI_PAX) && !defined(CONFIG_PAX_PT_PAX_FLAGS)
+#error "CONFIG_PAX_ASLR enabled, but neither CONFIG_PAX_EI_PAX nor CONFIG_PAX_PT_PAX_FLAGS are enabled."
+#endif
+#if defined(CONFIG_PAX_ALSR) && !defined(CONFIG_PAX_RANDKSTACK) && !defined(CONFIG_PAX_RANDUSTACK) && !defined(CONFIG_PAX_RANDMMAP)
+#error "CONFIG_PAX_ASLR enabled, but RANDKSTACK, RANDUSTACK, and RANDMMAP are disabled."
+#endif
+#if defined(CONFIG_PAX) && !defined(CONFIG_NOEXEC) && !defined(CONFIG_ALSR)
+#error "CONFIG_PAX enabled, but no PaX options are enabled."
+#endif
+
+void gr_handle_brute_attach(struct task_struct *p);
+void gr_handle_brute_check(void);
+
+int gr_check_user_change(int real, int effective, int fs);
+int gr_check_group_change(int real, int effective, int fs);
+
+void gr_del_task_from_ip_table(struct task_struct *p);
+
+int gr_pid_is_chrooted(struct task_struct *p);
+int gr_handle_chroot_nice(void);
+int gr_handle_chroot_sysctl(const int op);
+int gr_handle_chroot_setpriority(const struct task_struct *p,
+					const int niceval);
+int gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt);
+int gr_handle_chroot_chroot(const struct dentry *dentry,
+				   const struct vfsmount *mnt);
+void gr_handle_chroot_caps(struct task_struct *task);
+void gr_handle_chroot_chdir(struct dentry *dentry, struct vfsmount *mnt);
+int gr_handle_chroot_chmod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+int gr_handle_chroot_mknod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int mode);
+int gr_handle_chroot_mount(const struct dentry *dentry,
+				  const struct vfsmount *mnt,
+				  const char *dev_name);
+int gr_handle_chroot_pivot(void);
+int gr_handle_chroot_unix(const pid_t pid);
+
+int gr_handle_rawio(const struct inode *inode);
+int gr_handle_nproc(void);
+
+void gr_handle_ioperm(void);
+void gr_handle_iopl(void);
+
+int gr_tpe_allow(const struct file *file);
+
+int gr_random_pid(spinlock_t * pid_lock, int *next_safe);
+
+void gr_log_forkfail(const int retval);
+void gr_log_timechange(void);
+void gr_log_signal(const int sig, const struct task_struct *t);
+void gr_log_chdir(const struct dentry *dentry,
+			 const struct vfsmount *mnt);
+void gr_log_chroot_exec(const struct dentry *dentry,
+			       const struct vfsmount *mnt);
+void gr_handle_exec_args(struct linux_binprm *bprm, char **argv);
+void gr_log_remount(const char *devname, const int retval);
+void gr_log_unmount(const char *devname, const int retval);
+void gr_log_mount(const char *from, const char *to, const int retval);
+void gr_log_msgget(const int ret, const int msgflg);
+void gr_log_msgrm(const uid_t uid, const uid_t cuid);
+void gr_log_semget(const int err, const int semflg);
+void gr_log_semrm(const uid_t uid, const uid_t cuid);
+void gr_log_shmget(const int err, const int shmflg, const size_t size);
+void gr_log_shmrm(const uid_t uid, const uid_t cuid);
+void gr_log_textrel(struct vm_area_struct *vma);
+
+int gr_handle_follow_link(const struct inode *parent,
+				 const struct inode *inode,
+				 const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+int gr_handle_fifo(const struct dentry *dentry,
+			  const struct vfsmount *mnt,
+			  const struct dentry *dir, const int flag,
+			  const int acc_mode);
+int gr_handle_hardlink(const struct dentry *dentry,
+			      const struct vfsmount *mnt,
+			      struct inode *inode,
+			      const int mode, const char *to);
+
+int gr_task_is_capable(struct task_struct *task, const int cap);
+void gr_learn_resource(const struct task_struct *task, const int limit,
+			      const unsigned long wanted, const int gt);
+void gr_copy_label(struct task_struct *tsk);
+void gr_handle_crash(struct task_struct *task, const int sig);
+int gr_handle_signal(const struct task_struct *p, const int sig);
+int gr_check_crash_uid(const uid_t uid);
+int gr_check_protected_task(const struct task_struct *task);
+int gr_acl_handle_mmap(const struct file *file,
+			      const unsigned long prot);
+int gr_acl_handle_mprotect(const struct file *file,
+				  const unsigned long prot);
+int gr_check_hidden_task(const struct task_struct *tsk);
+__u32 gr_acl_handle_truncate(const struct dentry *dentry,
+				    const struct vfsmount *mnt);
+__u32 gr_acl_handle_utime(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+__u32 gr_acl_handle_access(const struct dentry *dentry,
+				  const struct vfsmount *mnt, const int fmode);
+__u32 gr_acl_handle_fchmod(const struct dentry *dentry,
+				  const struct vfsmount *mnt, mode_t mode);
+__u32 gr_acl_handle_chmod(const struct dentry *dentry,
+				 const struct vfsmount *mnt, mode_t mode);
+__u32 gr_acl_handle_chown(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+int gr_handle_ptrace(struct task_struct *task, const long request);
+int gr_handle_proc_ptrace(struct task_struct *task);
+__u32 gr_acl_handle_execve(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+int gr_check_crash_exec(const struct file *filp);
+int gr_acl_is_enabled(void);
+void gr_set_kernel_label(struct task_struct *task);
+void gr_set_role_label(struct task_struct *task, const uid_t uid,
+			      const gid_t gid);
+int gr_set_proc_label(const struct dentry *dentry,
+			      const struct vfsmount *mnt);
+__u32 gr_acl_handle_hidden_file(const struct dentry *dentry,
+				       const struct vfsmount *mnt);
+__u32 gr_acl_handle_open(const struct dentry *dentry,
+				const struct vfsmount *mnt, const int fmode);
+__u32 gr_acl_handle_creat(const struct dentry *dentry,
+				 const struct dentry *p_dentry,
+				 const struct vfsmount *p_mnt, const int fmode,
+				 const int imode);
+void gr_handle_create(const struct dentry *dentry,
+			     const struct vfsmount *mnt);
+__u32 gr_acl_handle_mknod(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt,
+				 const int mode);
+__u32 gr_acl_handle_mkdir(const struct dentry *new_dentry,
+				 const struct dentry *parent_dentry,
+				 const struct vfsmount *parent_mnt);
+__u32 gr_acl_handle_rmdir(const struct dentry *dentry,
+				 const struct vfsmount *mnt);
+void gr_handle_delete(const ino_t ino, const __u32 dev);
+__u32 gr_acl_handle_unlink(const struct dentry *dentry,
+				  const struct vfsmount *mnt);
+__u32 gr_acl_handle_symlink(const struct dentry *new_dentry,
+				   const struct dentry *parent_dentry,
+				   const struct vfsmount *parent_mnt,
+				   const char *from);
+__u32 gr_acl_handle_link(const struct dentry *new_dentry,
+				const struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				const struct dentry *old_dentry,
+				const struct vfsmount *old_mnt, const char *to);
+int gr_acl_handle_rename(struct dentry *new_dentry,
+				struct dentry *parent_dentry,
+				const struct vfsmount *parent_mnt,
+				struct dentry *old_dentry,
+				struct inode *old_parent_inode,
+				struct vfsmount *old_mnt, const char *newname);
+__u32 gr_check_link(const struct dentry *new_dentry,
+			   const struct dentry *parent_dentry,
+			   const struct vfsmount *parent_mnt,
+			   const struct dentry *old_dentry,
+			   const struct vfsmount *old_mnt);
+int gr_acl_handle_filldir(const struct file *file, const char *name,
+				 const unsigned int namelen, const ino_t ino);
+
+__u32 gr_acl_handle_unix(const struct dentry *dentry,
+				const struct vfsmount *mnt);
+void gr_acl_handle_exit(void);
+void gr_acl_handle_psacct(struct task_struct *task, const long code);
+int gr_acl_handle_procpidmem(const struct task_struct *task);
+__u32 gr_cap_rtnetlink(void);
+
+#ifdef CONFIG_SYSVIPC
+void gr_shm_exit(void);
+#else
+static inline void gr_shm_exit(void)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_GRKERNSEC
+void gr_handle_mem_write(void);
+void gr_handle_kmem_write(void);
+void gr_handle_open_port(void);
+int gr_handle_mem_mmap(const unsigned long offset,
+			      struct vm_area_struct *vma);
+
+extern int grsec_enable_dmesg;
+extern int grsec_enable_shm;
+#endif
+
+#endif
diff -urNp linux-2.4.37.7/include/linux/hfs_fs.h linux-2.4.37.7/include/linux/hfs_fs.h
--- linux-2.4.37.7/include/linux/hfs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/hfs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -244,25 +244,25 @@ extern int hfs_rename(struct inode *, st
 /* dir_cap.c */
 extern const struct hfs_name hfs_cap_reserved1[];
 extern const struct hfs_name hfs_cap_reserved2[];
-extern struct inode_operations hfs_cap_ndir_inode_operations;
-extern struct inode_operations hfs_cap_fdir_inode_operations;
-extern struct inode_operations hfs_cap_rdir_inode_operations;
-extern struct file_operations hfs_cap_dir_operations;
+extern const struct inode_operations hfs_cap_ndir_inode_operations;
+extern const struct inode_operations hfs_cap_fdir_inode_operations;
+extern const struct inode_operations hfs_cap_rdir_inode_operations;
+extern const struct file_operations hfs_cap_dir_operations;
 extern void hfs_cap_drop_dentry(struct dentry *, const ino_t);
 
 /* dir_dbl.c */
 extern const struct hfs_name hfs_dbl_reserved1[];
 extern const struct hfs_name hfs_dbl_reserved2[];
-extern struct inode_operations hfs_dbl_dir_inode_operations;
-extern struct file_operations hfs_dbl_dir_operations;
+extern const struct inode_operations hfs_dbl_dir_inode_operations;
+extern const struct file_operations hfs_dbl_dir_operations;
 extern void hfs_dbl_drop_dentry(struct dentry *, const ino_t);
 
 /* dir_nat.c */
 extern const struct hfs_name hfs_nat_reserved1[];
 extern const struct hfs_name hfs_nat_reserved2[];
-extern struct inode_operations hfs_nat_ndir_inode_operations;
-extern struct inode_operations hfs_nat_hdir_inode_operations;
-extern struct file_operations hfs_nat_dir_operations;
+extern const struct inode_operations hfs_nat_ndir_inode_operations;
+extern const struct inode_operations hfs_nat_hdir_inode_operations;
+extern const struct file_operations hfs_nat_dir_operations;
 extern void hfs_nat_drop_dentry(struct dentry *, const ino_t);
 
 /* file.c */
@@ -271,16 +271,16 @@ extern hfs_s32 hfs_do_read(struct inode 
 extern hfs_s32 hfs_do_write(struct inode *, struct hfs_fork *, hfs_u32,
 			    const char *, hfs_u32);
 extern void hfs_file_fix_mode(struct hfs_cat_entry *entry);
-extern struct inode_operations hfs_file_inode_operations;
-extern struct file_operations hfs_file_operations;
+extern const struct inode_operations hfs_file_inode_operations;
+extern const struct file_operations hfs_file_operations;
 
 /* file_cap.c */
-extern struct inode_operations hfs_cap_info_inode_operations;
-extern struct file_operations hfs_cap_info_operations;
+extern const struct inode_operations hfs_cap_info_inode_operations;
+extern const struct file_operations hfs_cap_info_operations;
 
 /* file_hdr.c */
-extern struct inode_operations hfs_hdr_inode_operations;
-extern struct file_operations hfs_hdr_operations;
+extern const struct inode_operations hfs_hdr_inode_operations;
+extern const struct file_operations hfs_hdr_operations;
 extern const struct hfs_hdr_layout hfs_dbl_fil_hdr_layout;
 extern const struct hfs_hdr_layout hfs_dbl_dir_hdr_layout;
 extern const struct hfs_hdr_layout hfs_nat_hdr_layout;
diff -urNp linux-2.4.37.7/include/linux/highmem.h linux-2.4.37.7/include/linux/highmem.h
--- linux-2.4.37.7/include/linux/highmem.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/highmem.h	2009-11-10 19:30:27.000000000 -0500
@@ -94,6 +94,13 @@ static inline void clear_highpage(struct
 	kunmap(page);
 }
 
+static inline void sanitize_highpage(struct page *page)
+{
+	void *addr = kmap_atomic(page, KM_CLEARPAGE);
+	clear_page(addr);
+	kunmap_atomic(addr, KM_CLEARPAGE);
+}
+
 /*
  * Same but also flushes aliased cache contents to RAM.
  */
diff -urNp linux-2.4.37.7/include/linux/input.h linux-2.4.37.7/include/linux/input.h
--- linux-2.4.37.7/include/linux/input.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/input.h	2009-11-10 19:30:27.000000000 -0500
@@ -685,7 +685,7 @@ struct input_handler {
 	struct input_handle* (*connect)(struct input_handler *handler, struct input_dev *dev);
 	void (*disconnect)(struct input_handle *handle);
 
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	int minor;
 
 	struct input_handle *handle;
diff -urNp linux-2.4.37.7/include/linux/intermezzo_fs.h linux-2.4.37.7/include/linux/intermezzo_fs.h
--- linux-2.4.37.7/include/linux/intermezzo_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/intermezzo_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -337,7 +337,7 @@ int presto_lento_up(int minor);
 int izo_psdev_setchannel(struct file *file, int fd);
 
 /* inode.c */
-extern struct super_operations presto_super_ops;
+extern const struct super_operations presto_super_ops;
 void presto_set_ops(struct inode *inode, struct  filter_fs *filter);
 
 /* dcache.c */
@@ -348,15 +348,15 @@ struct presto_dentry_data *izo_alloc_dda
 int presto_set_dd(struct dentry *);
 int presto_init_ddata_cache(void);
 void presto_cleanup_ddata_cache(void);
-extern struct dentry_operations presto_dentry_ops;
+extern const struct dentry_operations presto_dentry_ops;
 
 /* dir.c */
-extern struct inode_operations presto_dir_iops;
-extern struct inode_operations presto_file_iops;
-extern struct inode_operations presto_sym_iops;
-extern struct file_operations presto_dir_fops;
-extern struct file_operations presto_file_fops;
-extern struct file_operations presto_sym_fops;
+extern const struct inode_operations presto_dir_iops;
+extern const struct inode_operations presto_file_iops;
+extern const struct inode_operations presto_sym_iops;
+extern const struct file_operations presto_dir_fops;
+extern const struct file_operations presto_file_fops;
+extern const struct file_operations presto_sym_fops;
 int presto_setattr(struct dentry *de, struct iattr *iattr);
 int presto_settime(struct presto_file_set *fset, struct dentry *newobj,
                    struct dentry *parent, struct dentry *target,
diff -urNp linux-2.4.37.7/include/linux/iso_fs.h linux-2.4.37.7/include/linux/iso_fs.h
--- linux-2.4.37.7/include/linux/iso_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/iso_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -222,9 +222,9 @@ extern struct dentry *isofs_lookup(struc
 extern struct buffer_head *isofs_bread(struct inode *inode, unsigned int block);
 extern int isofs_get_blocks(struct inode *, long, struct buffer_head **, unsigned long);
 
-extern struct inode_operations isofs_dir_inode_operations;
-extern struct file_operations isofs_dir_operations;
-extern struct address_space_operations isofs_symlink_aops;
+extern const struct inode_operations isofs_dir_inode_operations;
+extern const struct file_operations isofs_dir_operations;
+extern const struct address_space_operations isofs_symlink_aops;
 
 /* The following macros are used to check for memory leaks. */
 #ifdef LEAK_CHECK
diff -urNp linux-2.4.37.7/include/linux/kernel.h linux-2.4.37.7/include/linux/kernel.h
--- linux-2.4.37.7/include/linux/kernel.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/kernel.h	2009-11-10 19:30:27.000000000 -0500
@@ -96,6 +96,9 @@ extern int session_of_pgrp(int pgrp);
 asmlinkage int printk(const char * fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
+asmlinkage void early_printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
 static inline void console_silent(void)
 {
 	console_loglevel = 0;
diff -urNp linux-2.4.37.7/include/linux/minix_fs.h linux-2.4.37.7/include/linux/minix_fs.h
--- linux-2.4.37.7/include/linux/minix_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/minix_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -123,11 +123,11 @@ extern ino_t minix_inode_by_name(struct 
 
 extern int minix_sync_file(struct file *, struct dentry *, int);
 
-extern struct inode_operations minix_file_inode_operations;
-extern struct inode_operations minix_dir_inode_operations;
-extern struct file_operations minix_file_operations;
-extern struct file_operations minix_dir_operations;
-extern struct dentry_operations minix_dentry_operations;
+extern const struct inode_operations minix_file_inode_operations;
+extern const struct inode_operations minix_dir_inode_operations;
+extern const struct file_operations minix_file_operations;
+extern const struct file_operations minix_dir_operations;
+extern const struct dentry_operations minix_dentry_operations;
 
 #endif /* __KERNEL__ */
 
diff -urNp linux-2.4.37.7/include/linux/miscdevice.h linux-2.4.37.7/include/linux/miscdevice.h
--- linux-2.4.37.7/include/linux/miscdevice.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/miscdevice.h	2009-11-10 19:30:27.000000000 -0500
@@ -43,7 +43,7 @@ struct miscdevice 
 {
 	int minor;
 	const char *name;
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	struct miscdevice * next, * prev;
 	devfs_handle_t devfs_handle;
 };
diff -urNp linux-2.4.37.7/include/linux/mm.h linux-2.4.37.7/include/linux/mm.h
--- linux-2.4.37.7/include/linux/mm.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/mm.h	2009-11-10 19:30:27.000000000 -0500
@@ -22,9 +22,13 @@ extern int page_cluster;
 extern struct list_head active_list;
 extern struct list_head inactive_list;
 
+extern void gr_learn_resource(const struct task_struct * task, const int limit,
+			      const unsigned long wanted, const int gt);
+
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/atomic.h>
+#include <asm/mman.h>
 
 /*
  * Linux kernel virtual memory manager primitives.
@@ -64,7 +68,7 @@ struct vm_area_struct {
 	struct vm_area_struct **vm_pprev_share;
 
 	/* Function pointers to deal with this struct. */
-	struct vm_operations_struct * vm_ops;
+	const struct vm_operations_struct * vm_ops;
 
 	/* Information about our backing store: */
 	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE
@@ -72,6 +76,8 @@ struct vm_area_struct {
 	struct file * vm_file;		/* File we map to (can be NULL). */
 	unsigned long vm_raend;		/* XXX: put full readahead info here. */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
+
+	unsigned long vm_mirror;	/* PaX: mirror distance */
 };
 
 /*
@@ -104,9 +110,29 @@ struct vm_area_struct {
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_MIRROR	0x00100000	/* vma is mirroring another */
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+#define VM_MAYNOTWRITE	0x00200000	/* vma cannot be granted VM_WRITE any more */
+#endif
+
+#if defined(__VM_STACK_FLAGS) && !defined(VM_STACK_FLAGS)
+#ifdef ARCH_STACK_GROWSUP
+#define VM_STACK_FLAGS (0x00000233 | __VM_STACK_FLAGS)
+#else
+#define VM_STACK_FLAGS (0x00000133 | __VM_STACK_FLAGS)
+#endif
+#endif
+
 #ifndef VM_STACK_FLAGS
+#ifdef ARCH_STACK_GROWSUP
+#define VM_STACK_FLAGS 0x00000277
+#else
 #define VM_STACK_FLAGS	0x00000177
 #endif
+#endif
 
 #define VM_READHINTMASK			(VM_SEQ_READ | VM_RAND_READ)
 #define VM_ClearReadHint(v)		(v)->vm_flags &= ~VM_READHINTMASK
@@ -496,6 +522,7 @@ extern int zeromap_page_range(unsigned l
 extern int vmtruncate(struct inode * inode, loff_t offset);
 extern pmd_t *FASTCALL(__pmd_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address));
 extern pte_t *FASTCALL(pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address));
+extern pte_t *FASTCALL(pte_alloc_kernel(struct mm_struct *mm, pmd_t *pmd, unsigned long address));
 extern int handle_mm_fault(struct mm_struct *mm,struct vm_area_struct *vma, unsigned long address, int write_access);
 extern int make_pages_present(unsigned long addr, unsigned long end);
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
@@ -587,6 +614,12 @@ static inline void __vma_unlink(struct m
 
 static inline int can_vma_merge(struct vm_area_struct * vma, unsigned long vm_flags)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_flags | vm_flags) & VM_MIRROR)
+		return 0;
+#endif
+
 	if (!vma->vm_file && vma->vm_flags == vm_flags)
 		return 1;
 	else
@@ -640,13 +673,23 @@ static inline unsigned int pf_gfp_mask(u
 
 	return gfp_mask;
 }
-	
+
+/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
+extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
+extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
+					     struct vm_area_struct **pprev);
+
 /* vma is the first one with  address < vma->vm_end,
  * and even  address < vma->vm_start. Have to extend vma. */
 static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)
 {
 	unsigned long grow;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+	unsigned long address_m = 0UL;
+#endif
+
 	/*
 	 * vma->vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
@@ -667,33 +710,62 @@ static inline int expand_stack(struct vm
 	}
 
 	grow = (vma->vm_start - address) >> PAGE_SHIFT;
-	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
-	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur) {
-		spin_unlock(&vma->vm_mm->page_table_lock);
-		return -ENOMEM;
-	}
 
-	if ((vma->vm_flags & VM_LOCKED) &&
-      	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur) {
+	gr_learn_resource(current, RLIMIT_STACK, vma->vm_end - address, 1);
+	gr_learn_resource(current, RLIMIT_AS, (vma->vm_mm->total_vm + grow) << PAGE_SHIFT, 1);
+	gr_learn_resource(current, RLIMIT_MEMLOCK, (vma->vm_mm->locked_vm + grow) << PAGE_SHIFT, 1);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(vma->vm_mm, address_m);
+		if (!vma_m || vma_m->vm_start != address_m || !(vma_m->vm_flags & VM_MIRROR) ||
+		    vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start) {
+			printk(KERN_ERR "PAX: VMMIRROR: expand bug, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			spin_unlock(&vma->vm_mm->page_table_lock);
+			return -ENOMEM;
+		}
+
+		address_m = address + vma->vm_mirror;
+		if (2*grow < grow || vma_m->vm_end - address_m > current->rlim[RLIMIT_STACK].rlim_cur ||
+		    ((vma_m->vm_mm->total_vm + 2*grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur ||
+		    ((vma_m->vm_flags & VM_LOCKED) &&
+		     ((vma_m->vm_mm->locked_vm + 2*grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur)) {
+			spin_unlock(&vma->vm_mm->page_table_lock);
+			return -ENOMEM;
+		}
+	} else
+#endif
+
+	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
+	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur ||
+	    ((vma->vm_flags & VM_LOCKED) &&
+	     ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur)) {
 		spin_unlock(&vma->vm_mm->page_table_lock);
 		return -ENOMEM;
 	}
 
-
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
 		vma->vm_mm->locked_vm += grow;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		vma_m->vm_start = address_m;
+		vma_m->vm_pgoff -= grow;
+		vma_m->vm_mm->total_vm += grow;
+		if (vma_m->vm_flags & VM_LOCKED)
+			vma_m->vm_mm->locked_vm += grow;
+	}
+#endif
+
 	spin_unlock(&vma->vm_mm->page_table_lock);
 	return 0;
 }
 
-/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
-extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
-extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
-					     struct vm_area_struct **pprev);
-
 /* Look up the first VMA which intersects the interval start_addr..end_addr-1,
    NULL if none.  Assume start_addr < end_addr. */
 static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
@@ -705,8 +777,6 @@ static inline struct vm_area_struct * fi
 	return vma;
 }
 
-extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr);
-
 extern struct page * vmalloc_to_page(void *addr);
 
 #endif /* __KERNEL__ */
diff -urNp linux-2.4.37.7/include/linux/msdos_fs.h linux-2.4.37.7/include/linux/msdos_fs.h
--- linux-2.4.37.7/include/linux/msdos_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/msdos_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -256,7 +256,7 @@ extern int fat_get_cluster(struct inode 
 extern int fat_free(struct inode *inode, int skip);
 
 /* fat/dir.c */
-extern struct file_operations fat_dir_operations;
+extern const struct file_operations fat_dir_operations;
 extern int fat_search_long(struct inode *inode, const char *name, int name_len,
 			   int anycase, loff_t *spos, loff_t *lpos);
 extern int fat_readdir(struct file *filp, void *dirent, filldir_t filldir);
@@ -268,8 +268,8 @@ extern int fat_add_entries(struct inode 
 extern int fat_new_dir(struct inode *dir, struct inode *parent, int is_vfat);
 
 /* fat/file.c */
-extern struct file_operations fat_file_operations;
-extern struct inode_operations fat_file_inode_operations;
+extern const struct file_operations fat_file_operations;
+extern const struct inode_operations fat_file_inode_operations;
 extern ssize_t fat_file_read(struct file *filp, char *buf, size_t count,
 			     loff_t *ppos);
 extern int fat_get_block(struct inode *inode, long iblock,
@@ -290,7 +290,7 @@ extern void fat_clear_inode(struct inode
 extern void fat_put_super(struct super_block *sb);
 extern struct super_block *
 fat_read_super(struct super_block *sb, void *data, int silent,
-	       struct inode_operations *fs_dir_inode_ops);
+	       const struct inode_operations *fs_dir_inode_ops);
 extern int fat_statfs(struct super_block *sb, struct statfs *buf);
 extern void fat_write_inode(struct inode *inode, int wait);
 extern int fat_notify_change(struct dentry * dentry, struct iattr * attr);
diff -urNp linux-2.4.37.7/include/linux/msdos_fs_sb.h linux-2.4.37.7/include/linux/msdos_fs_sb.h
--- linux-2.4.37.7/include/linux/msdos_fs_sb.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/msdos_fs_sb.h	2009-11-10 19:30:27.000000000 -0500
@@ -48,7 +48,7 @@ struct msdos_sb_info {
 	struct nls_table *nls_disk;  /* Codepage used on disk */
 	struct nls_table *nls_io;    /* Charset used for input and display */
 	struct cvf_format* cvf_format;
-	void *dir_ops;		     /* Opaque; default directory operations */
+	const void *dir_ops;		     /* Opaque; default directory operations */
 	void *private_data;
 	int dir_per_block;	     /* dir entries per block */
 	int dir_per_block_bits;	     /* log2(dir_per_block) */
diff -urNp linux-2.4.37.7/include/linux/ncp_fs.h linux-2.4.37.7/include/linux/ncp_fs.h
--- linux-2.4.37.7/include/linux/ncp_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/ncp_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -230,8 +230,8 @@ void ncp_update_inode(struct inode *, st
 void ncp_update_inode2(struct inode *, struct ncp_entry_info *);
 
 /* linux/fs/ncpfs/dir.c */
-extern struct inode_operations ncp_dir_inode_operations;
-extern struct file_operations ncp_dir_operations;
+extern const struct inode_operations ncp_dir_inode_operations;
+extern const struct file_operations ncp_dir_operations;
 int ncp_conn_logged_in(struct super_block *);
 int ncp_date_dos2unix(__u16 time, __u16 date);
 void ncp_date_unix2dos(int unix_date, __u16 * time, __u16 * date);
@@ -251,8 +251,8 @@ void ncp_lock_server(struct ncp_server *
 void ncp_unlock_server(struct ncp_server *server);
 
 /* linux/fs/ncpfs/file.c */
-extern struct inode_operations ncp_file_inode_operations;
-extern struct file_operations ncp_file_operations;
+extern const struct inode_operations ncp_file_inode_operations;
+extern const struct file_operations ncp_file_operations;
 int ncp_make_open(struct inode *, int);
 
 /* linux/fs/ncpfs/mmap.c */
diff -urNp linux-2.4.37.7/include/linux/nfs_fs.h linux-2.4.37.7/include/linux/nfs_fs.h
--- linux-2.4.37.7/include/linux/nfs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/nfs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -159,9 +159,9 @@ extern int nfs_notify_change(struct dent
 /*
  * linux/fs/nfs/file.c
  */
-extern struct inode_operations nfs_file_inode_operations;
-extern struct file_operations nfs_file_operations;
-extern struct address_space_operations nfs_file_aops;
+extern const struct inode_operations nfs_file_inode_operations;
+extern const struct file_operations nfs_file_operations;
+extern const struct address_space_operations nfs_file_aops;
 
 static __inline__ struct rpc_cred *
 nfs_file_cred(struct file *file)
@@ -179,14 +179,14 @@ nfs_file_cred(struct file *file)
 /*
  * linux/fs/nfs/dir.c
  */
-extern struct inode_operations nfs_dir_inode_operations;
-extern struct file_operations nfs_dir_operations;
-extern struct dentry_operations nfs_dentry_operations;
+extern const struct inode_operations nfs_dir_inode_operations;
+extern const struct file_operations nfs_dir_operations;
+extern const struct dentry_operations nfs_dentry_operations;
 
 /*
  * linux/fs/nfs/symlink.c
  */
-extern struct inode_operations nfs_symlink_inode_operations;
+extern const struct inode_operations nfs_symlink_inode_operations;
 
 /*
  * linux/fs/nfs/locks.c
diff -urNp linux-2.4.37.7/include/linux/phonedev.h linux-2.4.37.7/include/linux/phonedev.h
--- linux-2.4.37.7/include/linux/phonedev.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/phonedev.h	2009-11-10 19:30:27.000000000 -0500
@@ -10,7 +10,7 @@
 
 struct phone_device {
 	struct phone_device *next;
-	struct file_operations *f_op;
+	const struct file_operations *f_op;
 	int (*open) (struct phone_device *, struct file *);
 	int board;		/* Device private index */
 	int minor;
diff -urNp linux-2.4.37.7/include/linux/proc_fs.h linux-2.4.37.7/include/linux/proc_fs.h
--- linux-2.4.37.7/include/linux/proc_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/proc_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -59,8 +59,8 @@ struct proc_dir_entry {
 	uid_t uid;
 	gid_t gid;
 	unsigned long size;
-	struct inode_operations * proc_iops;
-	struct file_operations * proc_fops;
+	const struct inode_operations * proc_iops;
+	const struct file_operations * proc_fops;
 	get_info_t *get_info;
 	struct module *owner;
 	struct proc_dir_entry *next, *parent, *subdir;
@@ -112,9 +112,9 @@ extern int proc_match(int, const char *,
 extern int proc_readdir(struct file *, void *, filldir_t);
 extern struct dentry *proc_lookup(struct inode *, struct dentry *);
 
-extern struct file_operations proc_kcore_operations;
-extern struct file_operations proc_kmsg_operations;
-extern struct file_operations ppc_htab_operations;
+extern const struct file_operations proc_kcore_operations;
+extern const struct file_operations proc_kmsg_operations;
+extern const struct file_operations ppc_htab_operations;
 
 /*
  * proc_tty.c
@@ -175,7 +175,7 @@ static inline struct proc_dir_entry *pro
 }
 
 static inline struct proc_dir_entry *proc_net_fops_create(const char *name,
-	mode_t mode, struct file_operations *fops)
+	mode_t mode, const struct file_operations *fops)
 {
 	struct proc_dir_entry *res = create_proc_entry(name, mode, proc_net);
 
diff -urNp linux-2.4.37.7/include/linux/qnx4_fs.h linux-2.4.37.7/include/linux/qnx4_fs.h
--- linux-2.4.37.7/include/linux/qnx4_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/qnx4_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -105,10 +105,10 @@ extern struct buffer_head *qnx4_getblk(s
 extern struct buffer_head *qnx4_bread(struct inode *, int, int);
 
 extern int qnx4_create(struct inode *dir, struct dentry *dentry, int mode);
-extern struct inode_operations qnx4_file_inode_operations;
-extern struct inode_operations qnx4_dir_inode_operations;
-extern struct file_operations qnx4_file_operations;
-extern struct file_operations qnx4_dir_operations;
+extern const struct inode_operations qnx4_file_inode_operations;
+extern const struct inode_operations qnx4_dir_inode_operations;
+extern const struct file_operations qnx4_file_operations;
+extern const struct file_operations qnx4_dir_operations;
 extern int qnx4_is_free(struct super_block *sb, long block);
 extern int qnx4_set_bitmap(struct super_block *sb, long block, int busy);
 extern int qnx4_create(struct inode *inode, struct dentry *dentry, int mode);
diff -urNp linux-2.4.37.7/include/linux/random.h linux-2.4.37.7/include/linux/random.h
--- linux-2.4.37.7/include/linux/random.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/random.h	2009-11-10 19:30:27.000000000 -0500
@@ -73,7 +73,7 @@ extern __u32 secure_tcpv6_sequence_numbe
 extern __u32 secure_ipv6_id(__u32 *daddr);
 
 #ifndef MODULE
-extern struct file_operations random_fops, urandom_fops;
+extern const struct file_operations random_fops, urandom_fops;
 #endif
 
 #endif /* __KERNEL___ */
diff -urNp linux-2.4.37.7/include/linux/reiserfs_fs.h linux-2.4.37.7/include/linux/reiserfs_fs.h
--- linux-2.4.37.7/include/linux/reiserfs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/reiserfs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -1968,8 +1968,8 @@ int reiserfs_journal_in_proc( char *buff
 #endif
 
 /* dir.c */
-extern struct inode_operations reiserfs_dir_inode_operations;
-extern struct file_operations reiserfs_dir_operations;
+extern const struct inode_operations reiserfs_dir_inode_operations;
+extern const struct file_operations reiserfs_dir_operations;
 
 /* tail_conversion.c */
 int direct2indirect (struct reiserfs_transaction_handle *, struct inode *, struct path *, struct buffer_head *, loff_t);
@@ -1978,9 +1978,9 @@ void reiserfs_unmap_buffer(struct buffer
 
 
 /* file.c */
-extern struct inode_operations reiserfs_file_inode_operations;
-extern struct file_operations reiserfs_file_operations;
-extern struct address_space_operations reiserfs_address_space_operations ;
+extern const struct inode_operations reiserfs_file_inode_operations;
+extern const struct file_operations reiserfs_file_operations;
+extern const struct address_space_operations reiserfs_address_space_operations ;
 int get_new_buffer (struct reiserfs_transaction_handle *th, struct buffer_head *,
 		    struct buffer_head **, struct path *);
 
diff -urNp linux-2.4.37.7/include/linux/sched.h linux-2.4.37.7/include/linux/sched.h
--- linux-2.4.37.7/include/linux/sched.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/sched.h	2009-11-10 19:30:27.000000000 -0500
@@ -27,6 +27,9 @@ extern unsigned long event;
 #include <linux/securebits.h>
 #include <linux/fs_struct.h>
 
+extern int gr_task_is_capable(struct task_struct *task, const int cap);
+extern int gr_pid_is_chrooted(struct task_struct *p);
+
 struct exec_domain;
 
 /*
@@ -231,8 +234,33 @@ struct mm_struct {
 
 	/* Architecture-specific MM context */
 	mm_context_t context;
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS) || defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	unsigned long pax_flags;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	unsigned long call_dl_resolve;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	unsigned long call_syscall;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	unsigned long delta_mmap;		/* randomized offset */
+	unsigned long delta_exec;		/* randomized offset */
+	unsigned long delta_stack;		/* randomized offset */
+#endif
 };
 
+#define MF_PAX_PAGEEXEC	0x01000000	/* Paging based non-executable pages */
+#define MF_PAX_EMUTRAMP	0x02000000	/* Emulate trampolines */
+#define MF_PAX_MPROTECT	0x04000000	/* Restrict mprotect() */
+#define MF_PAX_RANDMMAP	0x08000000	/* Randomize mmap() base */
+/*#define MF_PAX_RANDEXEC	0x10000000*/	/* Randomize ET_EXEC base */
+#define MF_PAX_SEGMEXEC	0x20000000	/* Segmentation based non-executable pages */
+
 extern int mmlist_nr;
 
 #define INIT_MM(name) \
@@ -406,7 +434,7 @@ struct task_struct {
 	int (*notifier)(void *priv);
 	void *notifier_data;
 	sigset_t *notifier_mask;
-	
+
 /* Thread group tracking */
    	u32 parent_exec_id;
    	u32 self_exec_id;
@@ -417,6 +445,24 @@ struct task_struct {
 	void *journal_info;
 
 	struct list_head *scm_work_list;
+
+#ifdef CONFIG_GRKERNSEC
+/* added by grsecurity's ACL system */
+	struct acl_subject_label *acl;
+	struct acl_role_label *role;
+	struct file *exec_file;
+	u32 curr_ip;
+	u32 gr_saddr;
+	u32 gr_daddr;
+	u16 gr_sport;
+	u16 gr_dport;
+	u16 acl_role_id;
+	u8 acl_sp_role:1;
+	u8 used_accept:1;
+	u8 is_writable:1;
+	u8 brute:1;
+#endif
+
 };
 
 /*
@@ -438,6 +484,43 @@ struct task_struct {
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
+#ifdef CONFIG_PAX_SOFTMODE
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+extern unsigned int pax_aslr;
+#endif
+
+extern unsigned int pax_softmode;
+#endif
+
+extern int pax_check_flags(unsigned long *);
+
+/* if tsk != current then task_lock must be held on it */
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline unsigned long pax_get_flags(struct task_struct *tsk)
+{
+	if (likely(tsk->mm != NULL))
+		return tsk->mm->pax_flags;
+	else
+		return 0UL;
+}
+
+/* if tsk != current then task_lock must be held on it */
+static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+{
+	if (likely(tsk->mm != NULL)) {
+		tsk->mm->pax_flags = flags;
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+extern void pax_set_initial_flags(struct linux_binprm * bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+extern void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+#endif
+
 /*
  * Ptrace flags
  */
@@ -552,6 +635,8 @@ static inline void unhash_pid(struct tas
 	*p->pidhash_pprev = p->pidhash_next;
 }
 
+#include <asm/current.h>
+
 static inline struct task_struct *find_task_by_pid(int pid)
 {
 	struct task_struct *p, **htable = &pidhash[pid_hashfn(pid)];
@@ -559,6 +644,8 @@ static inline struct task_struct *find_t
 	for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
 		;
 
+	if(gr_pid_is_chrooted(p)) p = NULL;
+
 	return p;
 }
 
@@ -580,8 +667,6 @@ extern struct user_struct * alloc_uid(ui
 extern void free_uid(struct user_struct *);
 extern void switch_uid(struct user_struct *);
 
-#include <asm/current.h>
-
 extern unsigned long volatile jiffies;
 extern unsigned long itimer_ticks;
 extern unsigned long itimer_next;
@@ -745,7 +830,7 @@ static inline int fsuser(void)
 static inline int capable(int cap)
 {
 #if 1 /* ok now */
-	if (cap_raised(current->cap_effective, cap))
+	if (cap_raised(current->cap_effective, cap) && gr_task_is_capable(current, cap))
 #else
 	if (cap_is_fs_cap(cap) ? current->fsuid == 0 : current->euid == 0)
 #endif
diff -urNp linux-2.4.37.7/include/linux/seq_file.h linux-2.4.37.7/include/linux/seq_file.h
--- linux-2.4.37.7/include/linux/seq_file.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/seq_file.h	2009-11-10 19:30:27.000000000 -0500
@@ -19,7 +19,7 @@ struct seq_file {
 	size_t count;
 	loff_t index;
 	struct semaphore sem;
-	struct seq_operations *op;
+	const struct seq_operations *op;
 	void *private;
 };
 
@@ -30,7 +30,7 @@ struct seq_operations {
 	int (*show) (struct seq_file *m, void *v);
 };
 
-int seq_open(struct file *, struct seq_operations *);
+int seq_open(struct file *, const struct seq_operations *);
 ssize_t seq_read(struct file *, char *, size_t, loff_t *);
 loff_t seq_lseek(struct file *, loff_t, int);
 int seq_release(struct inode *, struct file *);
diff -urNp linux-2.4.37.7/include/linux/sound.h linux-2.4.37.7/include/linux/sound.h
--- linux-2.4.37.7/include/linux/sound.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/sound.h	2009-11-10 19:30:27.000000000 -0500
@@ -27,11 +27,11 @@
  *	Sound core interface functions
  */
  
-extern int register_sound_special(struct file_operations *fops, int unit);
-extern int register_sound_mixer(struct file_operations *fops, int dev);
-extern int register_sound_midi(struct file_operations *fops, int dev);
-extern int register_sound_dsp(struct file_operations *fops, int dev);
-extern int register_sound_synth(struct file_operations *fops, int dev);
+extern int register_sound_special(const struct file_operations *fops, int unit);
+extern int register_sound_mixer(const struct file_operations *fops, int dev);
+extern int register_sound_midi(const struct file_operations *fops, int dev);
+extern int register_sound_dsp(const struct file_operations *fops, int dev);
+extern int register_sound_synth(const struct file_operations *fops, int dev);
 
 extern void unregister_sound_special(int unit);
 extern void unregister_sound_mixer(int unit);
diff -urNp linux-2.4.37.7/include/linux/sysctl.h linux-2.4.37.7/include/linux/sysctl.h
--- linux-2.4.37.7/include/linux/sysctl.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/sysctl.h	2009-11-10 19:30:27.000000000 -0500
@@ -130,8 +130,20 @@ enum
 	KERN_EXCEPTION_TRACE=58, /* boolean: exception trace */
  	KERN_CORE_SETUID=59,	/* int: set to allow core dumps of setuid apps */
 	KERN_SPARC_SCONS_PWROFF=64, /* int: serial console power-off halt */
+	KERN_GRSECURITY=68,	/* grsecurity */
+
+#ifdef CONFIG_PAX_SOFTMODE
+	KERN_PAX=69,		/* PaX control */
+#endif
+
 };
 
+#ifdef CONFIG_PAX_SOFTMODE
+enum {
+	PAX_ASLR=1,		/* PaX: disable/enable all randomization features */
+	PAX_SOFTMODE=2,		/* PaX: disable/enable soft mode */
+};
+#endif
 
 /* CTL_VM names: */
 enum
diff -urNp linux-2.4.37.7/include/linux/sysv_fs.h linux-2.4.37.7/include/linux/sysv_fs.h
--- linux-2.4.37.7/include/linux/sysv_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/sysv_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -324,14 +324,14 @@ extern void sysv_set_link(struct sysv_di
 extern struct sysv_dir_entry *sysv_dotdot(struct inode*, struct page**);
 extern ino_t sysv_inode_by_name(struct dentry*);
 
-extern struct inode_operations sysv_file_inode_operations;
-extern struct inode_operations sysv_dir_inode_operations;
-extern struct inode_operations sysv_fast_symlink_inode_operations;
-extern struct file_operations sysv_file_operations;
-extern struct file_operations sysv_dir_operations;
-extern struct address_space_operations sysv_aops;
-extern struct super_operations sysv_sops;
-extern struct dentry_operations sysv_dentry_operations;
+extern const struct inode_operations sysv_file_inode_operations;
+extern const struct inode_operations sysv_dir_inode_operations;
+extern const struct inode_operations sysv_fast_symlink_inode_operations;
+extern const struct file_operations sysv_file_operations;
+extern const struct file_operations sysv_dir_operations;
+extern const struct address_space_operations sysv_aops;
+extern const struct super_operations sysv_sops;
+extern const struct dentry_operations sysv_dentry_operations;
 
 extern struct sysv_inode *sysv_raw_inode(struct super_block *, unsigned, struct buffer_head **);
 
diff -urNp linux-2.4.37.7/include/linux/ufs_fs.h linux-2.4.37.7/include/linux/ufs_fs.h
--- linux-2.4.37.7/include/linux/ufs_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/ufs_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -520,7 +520,7 @@ extern struct ufs_cg_private_info * ufs_
 extern void ufs_put_cylinder (struct super_block *, unsigned);
 
 /* dir.c */
-extern struct inode_operations ufs_dir_inode_operations;
+extern const struct inode_operations ufs_dir_inode_operations;
 extern int ufs_check_dir_entry (const char *, struct inode *, struct ufs_dir_entry *, struct buffer_head *, unsigned long);
 extern int ufs_add_link (struct dentry *, struct inode *);
 extern ino_t ufs_inode_by_name(struct inode *, struct dentry *);
@@ -532,10 +532,10 @@ extern struct ufs_dir_entry * ufs_dotdot
 extern void ufs_set_link(struct inode *, struct ufs_dir_entry *, struct buffer_head *, struct inode *);
 
 /* file.c */
-extern struct inode_operations ufs_file_inode_operations;
-extern struct file_operations ufs_file_operations;
+extern const struct inode_operations ufs_file_inode_operations;
+extern const struct file_operations ufs_file_operations;
 
-extern struct address_space_operations ufs_aops;
+extern const struct address_space_operations ufs_aops;
 
 /* ialloc.c */
 extern void ufs_free_inode (struct inode *inode);
@@ -552,7 +552,7 @@ extern struct buffer_head * ufs_getfrag 
 extern struct buffer_head * ufs_bread (struct inode *, unsigned, int, int *);
 
 /* namei.c */
-extern struct file_operations ufs_dir_operations;
+extern const struct file_operations ufs_dir_operations;
         
 /* super.c */
 extern void ufs_warning (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
@@ -561,7 +561,7 @@ extern void ufs_panic (struct super_bloc
 extern void ufs_write_super (struct super_block *);
 
 /* symlink.c */
-extern struct inode_operations ufs_fast_symlink_inode_operations;
+extern const struct inode_operations ufs_fast_symlink_inode_operations;
 
 /* truncate.c */
 extern void ufs_truncate (struct inode *);
diff -urNp linux-2.4.37.7/include/linux/umsdos_fs.h linux-2.4.37.7/include/linux/umsdos_fs.h
--- linux-2.4.37.7/include/linux/umsdos_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/umsdos_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -173,10 +173,10 @@ struct umsdos_ioctl {
 #include <linux/fs.h>
 #endif
 
-extern struct inode_operations umsdos_dir_inode_operations;
-extern struct inode_operations umsdos_rdir_inode_operations;
-extern struct file_operations umsdos_dir_operations;
-extern struct file_operations umsdos_rdir_operations;
+extern const struct inode_operations umsdos_dir_inode_operations;
+extern const struct inode_operations umsdos_rdir_inode_operations;
+extern const struct file_operations umsdos_dir_operations;
+extern const struct file_operations umsdos_rdir_operations;
 
 #include <linux/umsdos_fs.p>
 
diff -urNp linux-2.4.37.7/include/linux/usbdevice_fs.h linux-2.4.37.7/include/linux/usbdevice_fs.h
--- linux-2.4.37.7/include/linux/usbdevice_fs.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/usbdevice_fs.h	2009-11-10 19:30:27.000000000 -0500
@@ -181,10 +181,10 @@ struct dev_state {
 
 /* internal methods & data */
 extern struct usb_driver usbdevfs_driver;
-extern struct file_operations usbdevfs_drivers_fops;
-extern struct file_operations usbdevfs_devices_fops;
-extern struct file_operations usbdevfs_device_file_operations;
-extern struct inode_operations usbdevfs_device_inode_operations;
+extern const struct file_operations usbdevfs_drivers_fops;
+extern const struct file_operations usbdevfs_devices_fops;
+extern const struct file_operations usbdevfs_device_file_operations;
+extern const struct inode_operations usbdevfs_device_inode_operations;
 extern void usbdevfs_conn_disc_event(void);
 
 #endif /* __KERNEL__ */
diff -urNp linux-2.4.37.7/include/linux/usb.h linux-2.4.37.7/include/linux/usb.h
--- linux-2.4.37.7/include/linux/usb.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/usb.h	2009-11-10 19:30:27.000000000 -0500
@@ -456,7 +456,7 @@ struct usb_driver {
 
 	struct list_head driver_list;
 
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	int minor;
 
 	struct semaphore serialize;
diff -urNp linux-2.4.37.7/include/linux/videodev.h linux-2.4.37.7/include/linux/videodev.h
--- linux-2.4.37.7/include/linux/videodev.h	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/include/linux/videodev.h	2009-11-10 19:30:27.000000000 -0500
@@ -20,7 +20,7 @@ struct video_device
 	int minor;
 
 	/* device ops + callbacks */
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	void (*release)(struct video_device *vfd);
 
 	/* old, obsolete interface -- dropped in 2.5.x, don't use it */
diff -urNp linux-2.4.37.7/init/main.c linux-2.4.37.7/init/main.c
--- linux-2.4.37.7/init/main.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/init/main.c	2009-11-10 19:30:27.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/bootmem.h>
 #include <linux/file.h>
 #include <linux/tty.h>
+#include <linux/grsecurity.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -117,6 +118,8 @@ extern void ecard_init(void);
 extern void ipc_init(void);
 #endif
 
+extern void grsecurity_init(void);
+
 /*
  * Boot command-line arguments
  */
@@ -142,6 +145,15 @@ static int __init profile_setup(char *st
 
 __setup("profile=", profile_setup);
 
+#ifdef CONFIG_PAX_SOFTMODE
+static int __init setup_pax_softmode(char *str)
+{
+	get_option(&str, &pax_softmode);
+	return 1;
+}
+__setup("pax_softmode=", setup_pax_softmode);
+#endif
+
 static int __init checksetup(char *line)
 {
 	struct kernel_param *p;
@@ -566,6 +578,7 @@ static int init(void * unused)
 	do_basic_setup();
 
 	prepare_namespace();
+	grsecurity_init();
 
 	/*
 	 * Ok, we have completed the initial bootup, and
diff -urNp linux-2.4.37.7/ipc/msg.c linux-2.4.37.7/ipc/msg.c
--- linux-2.4.37.7/ipc/msg.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/ipc/msg.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -326,6 +327,9 @@ asmlinkage long sys_msgget (key_t key, i
 		msg_unlock(id);
 	}
 	up(&msg_ids.sem);
+
+	gr_log_msgget(ret, msgflg);
+
 	return ret;
 }
 
@@ -560,6 +564,8 @@ asmlinkage long sys_msgctl (int msqid, i
 		break;
 	}
 	case IPC_RMID:
+		gr_log_msgrm(ipcp->uid, ipcp->cuid);
+
 		freeque (msqid); 
 		break;
 	}
diff -urNp linux-2.4.37.7/ipc/sem.c linux-2.4.37.7/ipc/sem.c
--- linux-2.4.37.7/ipc/sem.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/ipc/sem.c	2009-11-10 19:30:27.000000000 -0500
@@ -63,6 +63,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/time.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -182,6 +183,9 @@ asmlinkage long sys_semget (key_t key, i
 	}
 
 	up(&sem_ids.sem);
+
+	gr_log_semget(err, semflg);
+
 	return err;
 }
 
@@ -724,6 +728,8 @@ static int semctl_down(int semid, int se
 
 	switch(cmd){
 	case IPC_RMID:
+		gr_log_semrm(ipcp->uid, ipcp->cuid);
+
 		freeary(semid);
 		err = 0;
 		break;
diff -urNp linux-2.4.37.7/ipc/shm.c linux-2.4.37.7/ipc/shm.c
--- linux-2.4.37.7/ipc/shm.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/ipc/shm.c	2009-11-10 19:30:27.000000000 -0500
@@ -23,6 +23,7 @@
 #include <linux/mman.h>
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 #include "util.h"
 
@@ -38,12 +39,25 @@ struct shmid_kernel /* private to the ke
 	time_t			shm_ctim;
 	pid_t			shm_cprid;
 	pid_t			shm_lprid;
+
+#ifdef CONFIG_GRKERNSEC
+	time_t			shm_createtime;
+	pid_t			shm_lapid;
+#endif
 };
 
+#ifdef CONFIG_GRKERNSEC
+extern int gr_handle_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+        	            const time_t shm_createtime, const uid_t cuid,
+                	    const int shmid);
+extern int gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+                    const time_t shm_createtime);
+#endif
+
 #define shm_flags	shm_perm.mode
 
-static struct file_operations shm_file_operations;
-static struct vm_operations_struct shm_vm_ops;
+static const struct file_operations shm_file_operations;
+static const struct vm_operations_struct shm_vm_ops;
 
 static struct ipc_ids shm_ids;
 
@@ -68,8 +82,19 @@ int 	shm_ctlmni = SHMMNI;
 
 static int shm_tot; /* total number of shared memory pages */
 
+#ifdef CONFIG_GRKERNSEC_KHEAP
+static kmem_cache_t *shm_cachep;
+#endif
+
 void __init shm_init (void)
 {
+#ifdef CONFIG_GRKERNSEC_KHEAP
+	shm_cachep = kmem_cache_create("shm_cache", sizeof(struct shmid_kernel),
+					0, 0, NULL, NULL);
+	if (!shm_cachep)
+		panic("cannot create shm slab cache");
+#endif
+	
 	ipc_init_ids(&shm_ids, 1);
 #ifdef CONFIG_PROC_FS
 	create_proc_read_entry("sysvipc/shm", 0, 0, sysvipc_shm_read_proc, NULL);
@@ -80,6 +105,7 @@ static inline int shm_checkid(struct shm
 {
 	if (ipc_checkid(&shm_ids,&s->shm_perm,id))
 		return -EIDRM;
+
 	return 0;
 }
 
@@ -127,7 +153,13 @@ static void shm_destroy (struct shmid_ke
 	shm_unlock(shp->id);
 	shmem_lock(shp->shm_file, 0);
 	fput (shp->shm_file);
+
+#ifdef CONFIG_GRKERNSEC_KHEAP
+	kmem_cache_free(shm_cachep, shp);
+#else
 	kfree (shp);
+#endif
+
 }
 
 /*
@@ -149,6 +181,17 @@ static void shm_close (struct vm_area_st
 	shp->shm_lprid = current->pid;
 	shp->shm_dtim = CURRENT_TIME;
 	shp->shm_nattch--;
+#ifdef CONFIG_GRKERNSEC_SHM
+	if (grsec_enable_shm) {
+		if (shp->shm_nattch == 0) {
+			shp->shm_flags |= SHM_DEST;
+			shm_destroy(shp);
+		} else
+			shm_unlock(id);
+		up(&shm_ids.sem);
+		return;
+	}
+#endif
 	if(shp->shm_nattch == 0 &&
 	   shp->shm_flags & SHM_DEST)
 		shm_destroy (shp);
@@ -167,11 +210,11 @@ static int shm_mmap(struct file * file, 
 	return 0;
 }
 
-static struct file_operations shm_file_operations = {
+static const struct file_operations shm_file_operations = {
 	mmap:	shm_mmap
 };
 
-static struct vm_operations_struct shm_vm_ops = {
+static const struct vm_operations_struct shm_vm_ops = {
 	open:	shm_open,	/* callback for a new vm-area open */
 	close:	shm_close,	/* callback for when the vm-area is released */
 	nopage:	shmem_nopage,
@@ -192,7 +235,12 @@ static int newseg (key_t key, int shmflg
 	if (shm_tot + numpages >= shm_ctlall)
 		return -ENOSPC;
 
+#ifdef CONFIG_GRKERNSEC_KHEAP
+	shp = (struct shmid_kernel *) kmem_cache_alloc(shm_cachep, SLAB_USER);
+#else
 	shp = (struct shmid_kernel *) kmalloc (sizeof (*shp), GFP_USER);
+#endif
+
 	if (!shp)
 		return -ENOMEM;
 	sprintf (name, "SYSV%08x", key);
@@ -211,6 +259,9 @@ static int newseg (key_t key, int shmflg
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
 	shp->shm_ctim = CURRENT_TIME;
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_createtime = CURRENT_TIME;
+#endif
 	shp->shm_segsz = size;
 	shp->shm_nattch = 0;
 	shp->id = shm_buildid(id,shp->shm_perm.seq);
@@ -224,7 +275,11 @@ static int newseg (key_t key, int shmflg
 no_id:
 	fput(file);
 no_file:
+#ifdef CONFIG_GRKERNSEC_KHEAP
+	kmem_cache_free(shm_cachep, shp);
+#else
 	kfree(shp);
+#endif
 	return error;
 }
 
@@ -256,6 +311,9 @@ asmlinkage long sys_shmget (key_t key, s
 		shm_unlock(id);
 	}
 	up(&shm_ids.sem);
+
+	gr_log_shmget(err, shmflg, size);
+
 	return err;
 }
 
@@ -511,6 +569,9 @@ asmlinkage long sys_shmctl (int shmid, i
 			err=-EPERM;
 			goto out_unlock_up;
 		}
+
+		gr_log_shmrm(shp->shm_perm.uid, shp->shm_perm.cuid);
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
@@ -624,9 +685,28 @@ asmlinkage long sys_shmat (int shmid, ch
 		shm_unlock(shmid);
 		return -EACCES;
 	}
+
+#ifdef CONFIG_GRKERNSEC
+	if (!gr_handle_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime,
+			     shp->shm_perm.cuid, shmid)) {
+		shm_unlock(shmid);
+		return -EACCES;
+	}
+
+	if (!gr_chroot_shmat(shp->shm_cprid, shp->shm_lapid, shp->shm_createtime)) {
+		shm_unlock(shmid);
+		return -EACCES;
+	}
+#endif
+
 	file = shp->shm_file;
 	size = file->f_dentry->d_inode->i_size;
 	shp->shm_nattch++;
+
+#ifdef CONFIG_GRKERNSEC
+	shp->shm_lapid = current->pid;
+#endif
+
 	shm_unlock(shmid);
 
 	down_write(&current->mm->mmap_sem);
@@ -751,3 +831,26 @@ done:
 	return len;
 }
 #endif
+
+void gr_shm_exit(void)
+{
+#ifdef CONFIG_GRKERNSEC_SHM
+	int i;
+	struct task_struct *task = current;
+	struct shmid_kernel *shp;
+
+	if (!grsec_enable_shm)
+		return;
+
+	for (i = 0; i <= shm_ids.max_id; i++) {
+		shp = shm_get(i);
+		if (shp && (shp->shm_cprid == task->pid) &&
+		    (shp->shm_nattch <= 0)) {
+			shp->shm_flags |= SHM_DEST;
+			shm_destroy(shp);
+		}
+	}
+#endif
+	return;
+}
+
diff -urNp linux-2.4.37.7/kernel/capability.c linux-2.4.37.7/kernel/capability.c
--- linux-2.4.37.7/kernel/capability.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/capability.c	2009-11-10 19:30:27.000000000 -0500
@@ -7,6 +7,7 @@
 
 #include <linux/mm.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
 
@@ -168,7 +169,6 @@ asmlinkage long sys_capset(cap_user_head
              target = current;
      }
 
-
      /* verify restrictions on target's new Inheritable set */
      if (!cap_issubset(inheritable,
                        cap_combine(target->cap_inheritable,
diff -urNp linux-2.4.37.7/kernel/exit.c linux-2.4.37.7/kernel/exit.c
--- linux-2.4.37.7/kernel/exit.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/exit.c	2009-11-10 19:30:27.000000000 -0500
@@ -16,6 +16,7 @@
 #ifdef CONFIG_BSD_PROCESS_ACCT
 #include <linux/acct.h>
 #endif
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -438,10 +439,16 @@ fake_volatile:
 #ifdef CONFIG_BSD_PROCESS_ACCT
 	acct_process(code);
 #endif
+
+	gr_acl_handle_psacct(tsk, code);
+	gr_acl_handle_exit();
+	gr_del_task_from_ip_table(tsk);
+
 	__exit_mm(tsk);
 
 	lock_kernel();
 	sem_exit();
+	gr_shm_exit();
 	__exit_files(tsk);
 	__exit_fs(tsk);
 	exit_namespace(tsk);
diff -urNp linux-2.4.37.7/kernel/fork.c linux-2.4.37.7/kernel/fork.c
--- linux-2.4.37.7/kernel/fork.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/fork.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/namespace.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -665,6 +666,8 @@ int do_fork(unsigned long clone_flags, u
 			goto fork_out;
 	}
 
+	gr_handle_brute_check();
+
 	retval = -ENOMEM;
 	p = alloc_task_struct();
 	if (!p)
@@ -679,6 +682,9 @@ int do_fork(unsigned long clone_flags, u
 	 * friends to set the per-user process limit to something lower
 	 * than the amount of processes root is running. -- Rik
 	 */
+
+	gr_learn_resource(p, RLIMIT_NPROC, atomic_read(&p->user->processes), 0);
+
 	if (atomic_read(&p->user->processes) >= p->rlim[RLIMIT_NPROC].rlim_cur
 		      && p->user != &root_user
 	              && !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE))
@@ -765,6 +771,7 @@ int do_fork(unsigned long clone_flags, u
 	retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);
 	if (retval)
 		goto bad_fork_cleanup_namespace;
+	gr_copy_label(p);
 	p->semundo = NULL;
 	
 	/* ok, now we should be set up.. */
@@ -848,6 +855,9 @@ bad_fork_cleanup_count:
 	free_uid(p->user);
 bad_fork_free:
 	free_task_struct(p);
+
+	gr_log_forkfail(retval);
+
 	goto fork_out;
 }
 
diff -urNp linux-2.4.37.7/kernel/ksyms.c linux-2.4.37.7/kernel/ksyms.c
--- linux-2.4.37.7/kernel/ksyms.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/ksyms.c	2009-11-10 19:30:27.000000000 -0500
@@ -50,6 +50,7 @@
 #include <linux/dnotify.h>
 #include <linux/crc32.h>
 #include <linux/firmware.h>
+#include <linux/grsecurity.h>
 #include <asm/checksum.h>
 
 #if defined(CONFIG_PROC_FS)
@@ -622,3 +623,9 @@ EXPORT_SYMBOL(dump_stack);
 /* To match ksyms with System.map */
 extern const char _end[];
 EXPORT_SYMBOL(_end);
+
+/* grsecurity */
+EXPORT_SYMBOL(gr_task_is_capable);
+EXPORT_SYMBOL(gr_pid_is_chrooted);
+EXPORT_SYMBOL(gr_learn_resource);
+EXPORT_SYMBOL(gr_set_kernel_label);
diff -urNp linux-2.4.37.7/kernel/module.c linux-2.4.37.7/kernel/module.c
--- linux-2.4.37.7/kernel/module.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/module.c	2009-11-10 19:30:27.000000000 -0500
@@ -55,6 +55,8 @@ struct module kernel_module =
 
 struct module *module_list = &kernel_module;
 
+extern int gr_check_modstop(void);
+
 #endif	/* defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS) */
 
 /* inter_module functions are always available, even when the kernel is
@@ -296,6 +298,9 @@ sys_create_module(const char *name_user,
 	struct module *mod;
 	unsigned long flags;
 
+	if (gr_check_modstop())
+		return -EPERM;
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 	lock_kernel();
@@ -351,6 +356,9 @@ sys_init_module(const char *name_user, s
 	unsigned long mod_user_size, flags;
 	struct module_ref *dep;
 
+	if (gr_check_modstop())
+		return -EPERM;
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 	lock_kernel();
@@ -612,6 +620,9 @@ sys_delete_module(const char *name_user)
 	long error;
 	int something_changed;
 
+	if (gr_check_modstop())
+		return -EPERM;
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 
@@ -900,6 +911,11 @@ sys_query_module(const char *name_user, 
 	struct module *mod;
 	int err;
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	if (!capable(CAP_SYS_MODULE))
+		return -EPERM;
+#endif
+
 	lock_kernel();
 	if (name_user == NULL)
 		mod = &kernel_module;
@@ -969,6 +985,11 @@ sys_get_kernel_syms(struct kernel_sym *t
 	int i;
 	struct kernel_sym ksym;
 
+#ifdef CONFIG_GRKERNSEC_HIDESYM
+	if (!capable(CAP_SYS_MODULE))
+		return 0;
+#endif
+
 	lock_kernel();
 	for (mod = module_list, i = 0; mod; mod = mod->next) {
 		/* include the count for the module name! */
@@ -1241,7 +1262,7 @@ static int s_show(struct seq_file *m, vo
 	return 0;
 }
 
-struct seq_operations ksyms_op = {
+const struct seq_operations ksyms_op = {
 	start:	s_start,
 	next:	s_next,
 	stop:	s_stop,
diff -urNp linux-2.4.37.7/kernel/printk.c linux-2.4.37.7/kernel/printk.c
--- linux-2.4.37.7/kernel/printk.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/printk.c	2009-11-10 19:30:27.000000000 -0500
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -299,6 +300,11 @@ out:
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
+#ifdef CONFIG_GRKERNSEC_DMESG
+	if (grsec_enable_dmesg && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	else
+#endif
 	if ((type != 3) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	return do_syslog(type, buf, len);
diff -urNp linux-2.4.37.7/kernel/resource.c linux-2.4.37.7/kernel/resource.c
--- linux-2.4.37.7/kernel/resource.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/resource.c	2009-11-10 19:30:27.000000000 -0500
@@ -67,7 +67,7 @@ static int r_show(struct seq_file *m, vo
 	return 0;
 }
 
-static struct seq_operations resource_op = {
+static const struct seq_operations resource_op = {
 	.start	= r_start,
 	.next	= r_next,
 	.stop	= r_stop,
@@ -94,14 +94,14 @@ static int iomem_open(struct inode *inod
 	return res;
 }
 
-struct file_operations proc_ioports_operations = {
+const struct file_operations proc_ioports_operations = {
 	.open		= ioports_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= seq_release,
 };
 
-struct file_operations proc_iomem_operations = {
+const struct file_operations proc_iomem_operations = {
 	.open		= iomem_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
diff -urNp linux-2.4.37.7/kernel/sched.c linux-2.4.37.7/kernel/sched.c
--- linux-2.4.37.7/kernel/sched.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/sched.c	2009-11-10 19:30:27.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/file.h>
 #include <linux/smp_lock.h>
 #include <linux/nmi.h>
 #include <linux/interrupt.h>
@@ -29,6 +30,11 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/grsecurity.h>
+
+#ifdef CONFIG_GRKERNSEC
+extern rwlock_t grsec_exec_file_lock;
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -910,6 +916,9 @@ asmlinkage long sys_nice(int increment)
 			return -EPERM;
 		if (increment < -40)
 			increment = -40;
+
+		if (gr_handle_chroot_nice())
+			return -EPERM;
 	}
 	if (increment > 40)
 		increment = 40;
@@ -1288,12 +1297,23 @@ void reparent_to_init(void)
 
 	write_lock_irq(&tasklist_lock);
 
+#ifdef CONFIG_GRKERNSEC
+	write_lock(&grsec_exec_file_lock);
+	if (this_task->exec_file) {
+		fput(this_task->exec_file);
+		this_task->exec_file = NULL;
+	}
+	write_unlock(&grsec_exec_file_lock);
+#endif
+
 	/* Reparent to init */
 	REMOVE_LINKS(this_task);
 	this_task->p_pptr = child_reaper;
 	this_task->p_opptr = child_reaper;
 	SET_LINKS(this_task);
 
+	gr_set_kernel_label(this_task);
+
 	/* Set the exit signal to SIGCHLD so we signal init on exit */
 	this_task->exit_signal = SIGCHLD;
 
@@ -1327,6 +1347,15 @@ void daemonize(void)
 {
 	struct fs_struct *fs;
 
+#ifdef CONFIG_GRKERNSEC
+	write_lock(&grsec_exec_file_lock);
+	if (current->exec_file) {
+		fput(current->exec_file);
+		current->exec_file = NULL;
+	}
+	write_unlock(&grsec_exec_file_lock);
+#endif
+	gr_set_kernel_label(current);
 
 	/*
 	 * If we were started as result of loading a module, close all of the
diff -urNp linux-2.4.37.7/kernel/signal.c linux-2.4.37.7/kernel/signal.c
--- linux-2.4.37.7/kernel/signal.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/signal.c	2009-11-10 19:30:27.000000000 -0500
@@ -13,6 +13,8 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -336,11 +338,11 @@ static int rm_sig_from_queue(int sig, st
  */
 int bad_signal(int sig, struct siginfo *info, struct task_struct *t)
 {
-	return (!info || ((unsigned long)info != 1 && SI_FROMUSER(info)))
-	    && ((sig != SIGCONT) || (current->session != t->session))
+	return ((!info || ((unsigned long)info != 1 && SI_FROMUSER(info)))
+	    && ((((sig != SIGCONT) || (current->session != t->session))
 	    && (current->euid ^ t->suid) && (current->euid ^ t->uid)
 	    && (current->uid ^ t->suid) && (current->uid ^ t->uid)
-	    && !capable(CAP_KILL);
+	    && !capable(CAP_KILL)) || gr_handle_signal(t, sig)));
 }
 
 /*
@@ -566,6 +568,9 @@ printk("SIG queue (%s:%d): %d ", t->comm
 		goto out_nolock;
 
 	spin_lock_irqsave(&t->sigmask_lock, flags);
+
+	gr_log_signal(sig, t);
+
 	handle_stop_signal(sig, t);
 
 	/* Optimize away the signal, if it's a signal that can be
@@ -614,6 +619,8 @@ force_sig_info(int sig, struct siginfo *
 	recalc_sigpending(t);
 	spin_unlock_irqrestore(&t->sigmask_lock, flags);
 
+	gr_handle_crash(t, sig);
+
 	return send_sig_info(sig, info, t);
 }
 
@@ -1059,7 +1066,7 @@ sys_tkill(int pid, int sig)
        p = find_task_by_pid(pid);
        error = -ESRCH;
        if (p) {
-               error = send_sig_info(sig, &info, p);
+              error = send_sig_info(sig, &info, p);
        }
        read_unlock(&tasklist_lock);
        return error;
diff -urNp linux-2.4.37.7/kernel/sys.c linux-2.4.37.7/kernel/sys.c
--- linux-2.4.37.7/kernel/sys.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/sys.c	2009-11-10 19:30:27.000000000 -0500
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/utsname.h>
@@ -14,6 +15,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -239,6 +241,12 @@ asmlinkage long sys_setpriority(int whic
 		}
 		if (error == -ESRCH)
 			error = 0;
+
+		if (gr_handle_chroot_setpriority(p, niceval)) {
+			read_unlock(&tasklist_lock);
+			return -EACCES;
+		}
+
 		if (niceval < p->nice && !capable(CAP_SYS_NICE))
 			error = -EACCES;
 		else
@@ -417,6 +425,10 @@ asmlinkage long sys_setregid(gid_t rgid,
 			return -EPERM;
 		}
 	}
+
+	if (gr_check_group_change(new_rgid, new_egid, -1))
+		return -EPERM;
+
 	if (new_egid != old_egid)
 	{
 		current->mm->dumpable = 0;
@@ -425,6 +437,9 @@ asmlinkage long sys_setregid(gid_t rgid,
 	if (rgid != (gid_t) -1 ||
 	    (egid != (gid_t) -1 && egid != old_rgid))
 		current->sgid = new_egid;
+
+	gr_set_role_label(current, current->uid, new_rgid);
+
 	current->fsgid = new_egid;
 	current->egid = new_egid;
 	current->gid = new_rgid;
@@ -440,6 +455,9 @@ asmlinkage long sys_setgid(gid_t gid)
 {
 	int old_egid = current->egid;
 
+	if (gr_check_group_change(gid, gid, gid))
+		return -EPERM;
+
 	if (capable(CAP_SETGID))
 	{
 		if(old_egid != gid)
@@ -447,6 +465,9 @@ asmlinkage long sys_setgid(gid_t gid)
 			current->mm->dumpable=0;
 			wmb();
 		}
+
+		gr_set_role_label(current, current->uid, gid);
+
 		current->gid = current->egid = current->sgid = current->fsgid = gid;
 	}
 	else if ((gid == current->gid) || (gid == current->sgid))
@@ -523,6 +544,9 @@ static int set_user(uid_t new_ruid, int 
 		current->mm->dumpable = 0;
 		wmb();
 	}
+
+	gr_set_role_label(current, new_ruid, current->gid);
+
 	current->uid = new_ruid;
 	return 0;
 }
@@ -567,6 +591,9 @@ asmlinkage long sys_setreuid(uid_t ruid,
 			return -EPERM;
 	}
 
+	if (gr_check_user_change(new_ruid, new_euid, -1))
+		return -EPERM;
+
 	if (new_ruid != old_ruid && set_user(new_ruid, new_euid != old_euid) < 0)
 		return -EAGAIN;
 
@@ -610,6 +637,12 @@ asmlinkage long sys_setuid(uid_t uid)
 	old_suid = current->suid;
 	new_suid = old_suid;
 	
+	if (gr_check_crash_uid(uid))
+		return -EPERM;
+
+	if (gr_check_user_change(uid, uid, uid))
+		return -EPERM;
+
 	if (capable(CAP_SETUID)) {
 		if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
 			return -EAGAIN;
@@ -654,6 +687,10 @@ asmlinkage long sys_setresuid(uid_t ruid
 		    (suid != current->euid) && (suid != current->suid))
 			return -EPERM;
 	}
+
+	if (gr_check_user_change(ruid, euid, -1))
+		return -EPERM;
+
 	if (ruid != (uid_t) -1) {
 		if (ruid != current->uid && set_user(ruid, euid != current->euid) < 0)
 			return -EAGAIN;
@@ -704,6 +741,10 @@ asmlinkage long sys_setresgid(gid_t rgid
 		    (sgid != current->egid) && (sgid != current->sgid))
 			return -EPERM;
 	}
+
+	if (gr_check_group_change(rgid, egid, -1))
+		return -EPERM;
+
 	if (egid != (gid_t) -1) {
 		if (egid != current->egid)
 		{
@@ -713,8 +754,10 @@ asmlinkage long sys_setresgid(gid_t rgid
 		current->egid = egid;
 	}
 	current->fsgid = current->egid;
-	if (rgid != (gid_t) -1)
+	if (rgid != (gid_t) -1) {
+		gr_set_role_label(current, current->uid, rgid);
 		current->gid = rgid;
+	}
 	if (sgid != (gid_t) -1)
 		current->sgid = sgid;
 	return 0;
@@ -747,6 +790,9 @@ asmlinkage long sys_setfsuid(uid_t uid)
 	    uid == current->suid || uid == current->fsuid || 
 	    capable(CAP_SETUID))
 	{
+		if (gr_check_user_change(-1, -1, uid))
+			return old_fsuid;
+
 		if (uid != old_fsuid)
 		{
 			current->mm->dumpable = 0;
@@ -789,6 +835,9 @@ asmlinkage long sys_setfsgid(gid_t gid)
 	    gid == current->sgid || gid == current->fsgid || 
 	    capable(CAP_SETGID))
 	{
+		if (gr_check_group_change(-1, -1, gid))
+			return old_fsgid;
+
 		if (gid != old_fsgid)
 		{
 			current->mm->dumpable = 0;
@@ -1137,6 +1186,10 @@ asmlinkage long sys_setrlimit(unsigned i
        if (new_rlim.rlim_cur > new_rlim.rlim_max)
                return -EINVAL;
 	old_rlim = current->rlim + resource;
+
+	if (old_rlim->rlim_max < old_rlim->rlim_cur)
+		return -EINVAL;
+
 	if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
 	     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
 	    !capable(CAP_SYS_RESOURCE))
diff -urNp linux-2.4.37.7/kernel/sysctl.c linux-2.4.37.7/kernel/sysctl.c
--- linux-2.4.37.7/kernel/sysctl.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/sysctl.c	2009-11-10 19:30:27.000000000 -0500
@@ -39,6 +39,13 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
+#include <linux/grsecurity.h>
+#include <linux/grinternal.h>
+
+extern __u32 gr_handle_sysctl(const ctl_table * table, const void *oldval,
+			      const void *newval);
+extern int gr_handle_sysctl_mod(const char *dirname, const char *name, const int op);
+extern int gr_handle_chroot_sysctl(const int op);
 
 /* External variables not in a header file. */
 extern int panic_timeout;
@@ -128,6 +135,27 @@ static ctl_table debug_table[];
 static ctl_table dev_table[];
 extern ctl_table random_table[];
 
+static ctl_table grsecurity_table[];
+
+#ifdef CONFIG_PAX_SOFTMODE
+unsigned int pax_softmode;
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+unsigned int pax_aslr=1;
+#endif
+
+static ctl_table pax_table[] = {
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+	{PAX_ASLR, "aslr", &pax_aslr, sizeof(unsigned int), 0600, NULL, &proc_dointvec},
+#endif
+
+	{PAX_SOFTMODE, "softmode", &pax_softmode, sizeof(unsigned int), 0600, NULL, &proc_dointvec},
+
+	{0}
+};
+#endif
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_FS
@@ -136,12 +164,12 @@ static ssize_t proc_readsys(struct file 
 static ssize_t proc_writesys(struct file *, const char *, size_t, loff_t *);
 static int proc_sys_permission(struct inode *, int);
 
-struct file_operations proc_sys_file_operations = {
+const struct file_operations proc_sys_file_operations = {
 	read:		proc_readsys,
 	write:		proc_writesys,
 };
 
-static struct inode_operations proc_sys_inode_operations = {
+static const struct inode_operations proc_sys_inode_operations = {
 	permission:	proc_sys_permission,
 };
 
@@ -278,8 +306,197 @@ static ctl_table kern_table[] = {
 	{KERN_EXCEPTION_TRACE,"exception-trace",
 	 &exception_trace,sizeof(int),0644,NULL,&proc_dointvec},
 #endif	
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_MODSTOP)
+	{KERN_GRSECURITY, "grsecurity", NULL, 0, 0500, grsecurity_table},
+#endif
+
+#ifdef CONFIG_PAX_SOFTMODE
+	{KERN_PAX,"pax",NULL,0,0500,pax_table},
+#endif
+
+	{0}
+};
+
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_MODSTOP)
+enum {GS_LINK=1, GS_FIFO, GS_EXECVE, GS_EXECLOG, GS_SIGNAL, 
+GS_FORKFAIL, GS_TIME, GS_RESLOG, GS_CHROOT_SHMAT, GS_CHROOT_UNIX, GS_CHROOT_MNT,
+GS_CHROOT_FCHDIR, GS_CHROOT_DBL, GS_CHROOT_PVT, GS_CHROOT_CD, GS_CHROOT_CM,
+GS_CHROOT_MK, GS_CHROOT_NI, GS_CHROOT_EXECLOG, GS_CHROOT_CAPS, 
+GS_CHROOT_SYSCTL, GS_TPE, GS_TPE_GID, GS_TPE_ALL,
+GS_SOCKET_ALL, GS_SOCKET_ALL_GID, GS_SOCKET_CLIENT,
+GS_SOCKET_CLIENT_GID, GS_SOCKET_SERVER, GS_SOCKET_SERVER_GID,
+GS_GROUP, GS_GID, GS_ACHDIR, GS_AMOUNT, GS_AIPC, GS_DMSG,
+GS_TEXTREL, GS_FINDTASK, GS_SHM, GS_LOCK, GS_MODSTOP};
+
+#ifdef CONFIG_GRKERNSEC_MODSTOP
+extern int grsec_modstop;
+#endif
+
+static ctl_table grsecurity_table[] = {
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+#ifdef CONFIG_GRKERNSEC_LINK
+	{GS_LINK, "linking_restrictions", &grsec_enable_link, sizeof (int),
+	 0600, NULL, &proc_dointvec}, 
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	{GS_FIFO, "fifo_restrictions", &grsec_enable_fifo, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	{GS_EXECVE, "execve_limiting", &grsec_enable_execve, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	{GS_EXECLOG, "exec_logging", &grsec_enable_execlog, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	{GS_SIGNAL, "signal_logging", &grsec_enable_signal, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	{GS_FORKFAIL, "forkfail_logging", &grsec_enable_forkfail, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	{GS_TIME, "timechange_logging", &grsec_enable_time, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RESLOG
+	{GS_RESLOG, "resource_logging", &grsec_resource_logging, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SHMAT
+	{GS_CHROOT_SHMAT, "chroot_deny_shmat", &grsec_enable_chroot_shmat, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+	{GS_CHROOT_UNIX, "chroot_deny_unix", &grsec_enable_chroot_unix, sizeof(int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	{GS_CHROOT_MNT, "chroot_deny_mount", &grsec_enable_chroot_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	{GS_CHROOT_FCHDIR, "chroot_deny_fchdir", &grsec_enable_chroot_fchdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	{GS_CHROOT_DBL, "chroot_deny_chroot", &grsec_enable_chroot_double, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	{GS_CHROOT_PVT, "chroot_deny_pivot", &grsec_enable_chroot_pivot, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	{GS_CHROOT_CD, "chroot_enforce_chdir", &grsec_enable_chroot_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	{GS_CHROOT_CM, "chroot_deny_chmod", &grsec_enable_chroot_chmod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	{GS_CHROOT_MK, "chroot_deny_mknod", &grsec_enable_chroot_mknod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	{GS_CHROOT_NI, "chroot_restrict_nice", &grsec_enable_chroot_nice, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	{GS_CHROOT_EXECLOG, "chroot_execlog",
+	 &grsec_enable_chroot_execlog, sizeof (int),
+         0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	{GS_CHROOT_CAPS, "chroot_caps", &grsec_enable_chroot_caps, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
+	{GS_CHROOT_SYSCTL, "chroot_deny_sysctl", &grsec_enable_chroot_sysctl, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	{GS_TPE, "tpe", &grsec_enable_tpe, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_TPE_GID, "tpe_gid", &grsec_tpe_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	{GS_TPE_ALL, "tpe_restrict_all", &grsec_enable_tpe_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	{GS_SOCKET_ALL, "socket_all", &grsec_enable_socket_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_ALL_GID, "socket_all_gid",
+	 &grsec_socket_all_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	{GS_SOCKET_CLIENT, "socket_client", 
+	 &grsec_enable_socket_client, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_CLIENT_GID, "socket_client_gid", 
+	 &grsec_socket_client_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	{GS_SOCKET_SERVER, "socket_server", 
+	 &grsec_enable_socket_server, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_SERVER_GID, "socket_server_gid",
+	 &grsec_socket_server_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	{GS_GROUP, "audit_group", &grsec_enable_group, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_GID, "audit_gid",
+	 &grsec_audit_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	{GS_ACHDIR, "audit_chdir", &grsec_enable_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	{GS_AMOUNT, "audit_mount", &grsec_enable_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_TEXTREL
+	{GS_TEXTREL, "audit_textrel", &grsec_enable_audit_textrel, sizeof(int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	{GS_AIPC, "audit_ipc", &grsec_enable_audit_ipc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	{GS_DMSG, "dmesg", &grsec_enable_dmesg, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	{GS_FINDTASK, "chroot_findtask", &grsec_enable_chroot_findtask, 
+	 sizeof (int), 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SHM
+	{GS_SHM, "destroy_unused_shm", &grsec_enable_shm, sizeof (int),
+	0600, NULL, &proc_dointvec},
+#endif
+	{GS_LOCK, "grsec_lock", &grsec_lock, sizeof (int), 0600, NULL,
+	 &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_MODSTOP
+	{GS_MODSTOP, "disable_modules", &grsec_modstop, sizeof (int), 0600,
+	NULL, &proc_dointvec},
+#endif
 	{0}
 };
+#endif
 
 static ctl_table vm_table[] = {
 	{VM_GFP_DEBUG, "vm_gfp_debug", 
@@ -487,6 +704,11 @@ static int test_perm(int mode, int op)
 
 static inline int ctl_perm(ctl_table *table, int op)
 {
+	if (table->de && gr_handle_sysctl_mod(table->de->parent->name, table->de->name, op))
+		return -EACCES;
+	if (gr_handle_chroot_sysctl(op))
+		return -EACCES;
+
 	return test_perm(table->mode, op);
 }
 
@@ -520,6 +742,10 @@ repeat:
 				table = table->child;
 				goto repeat;
 			}
+
+			if (!gr_handle_sysctl(table, oldval, newval))
+				return -EPERM;
+
 			error = do_sysctl_strategy(table, name, nlen,
 						   oldval, oldlenp,
 						   newval, newlen, context);
diff -urNp linux-2.4.37.7/kernel/time.c linux-2.4.37.7/kernel/time.c
--- linux-2.4.37.7/kernel/time.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/time.c	2009-11-10 19:30:27.000000000 -0500
@@ -27,6 +27,7 @@
 #include <linux/mm.h>
 #include <linux/timex.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -89,6 +90,9 @@ asmlinkage long sys_stime(int * tptr)
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
 	write_unlock_irq(&xtime_lock);
+
+	gr_log_timechange();
+
 	return 0;
 }
 
@@ -167,6 +171,8 @@ int do_sys_settimeofday(struct timeval *
 		 * globally block out interrupts when it runs.
 		 */
 		do_settimeofday(tv);
+
+		gr_log_timechange();
 	}
 	return 0;
 }
diff -urNp linux-2.4.37.7/kernel/timer.c linux-2.4.37.7/kernel/timer.c
--- linux-2.4.37.7/kernel/timer.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/kernel/timer.c	2009-11-10 19:30:27.000000000 -0500
@@ -541,6 +541,9 @@ static inline void do_process_times(stru
 
 	psecs = (p->times.tms_utime += user);
 	psecs += (p->times.tms_stime += system);
+
+	gr_learn_resource(p, RLIMIT_CPU, psecs / HZ, 1);
+
 	if (psecs / HZ > p->rlim[RLIMIT_CPU].rlim_cur) {
 		/* Send SIGXCPU every second.. */
 		if (!(psecs % HZ))
diff -urNp linux-2.4.37.7/Makefile linux-2.4.37.7/Makefile
--- linux-2.4.37.7/Makefile	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/Makefile	2009-11-10 19:30:27.000000000 -0500
@@ -6,6 +6,9 @@ EXTRAVERSION = .7
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
 ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+#do this so we don't have to release a new patch for each .x.y unless necessary
+EXTRAVERSION :=$(EXTRAVERSION)-grsec
+KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -136,9 +139,10 @@ export SVGA_MODE = -DSVGA_MODE=NORMAL_VG
 
 CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
 NETWORKS	=net/network.o
+GRSECURITY	=grsecurity/grsec.o
 
 LIBS		=$(TOPDIR)/lib/lib.a
-SUBDIRS		=kernel drivers mm fs net ipc lib crypto
+SUBDIRS		=kernel drivers mm fs net ipc lib crypto grsecurity
 
 DRIVERS-n :=
 DRIVERS-y :=
@@ -282,7 +286,7 @@ export kbuild_2_4_nostdinc
 
 export	CPPFLAGS CFLAGS CFLAGS_KERNEL AFLAGS AFLAGS_KERNEL
 
-export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS
+export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS GRSECURITY
 
 .S.s:
 	$(CPP) $(AFLAGS) $(AFLAGS_KERNEL) -traditional -o $*.s $<
@@ -301,6 +305,7 @@ vmlinux: include/linux/version.h $(CONFI
 		$(CORE_FILES) \
 		$(DRIVERS) \
 		$(NETWORKS) \
+		$(GRSECURITY) \
 		$(LIBS) \
 		--end-group \
 		-o vmlinux
@@ -385,6 +390,11 @@ init/do_mounts.o: init/do_mounts.c inclu
 fs lib mm ipc kernel drivers net: dummy
 	$(MAKE) CFLAGS="$(CFLAGS) $(CFLAGS_KERNEL)" $(subst $@, _dir_$@, $@)
 
+cscope:
+	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print > cscope.files
+	find kernel drivers mm fs net ipc lib crypto init arch/${ARCH} include/asm-$(ARCH) include/asm-generic -name '*.[chS]' >> cscope.files
+	cscope -k -b -q < cscope.files
+
 TAGS: dummy
 	{ find include/asm-${ARCH} -name '*.h' -print ; \
 	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print ; \
diff -urNp linux-2.4.37.7/mm/filemap.c linux-2.4.37.7/mm/filemap.c
--- linux-2.4.37.7/mm/filemap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/filemap.c	2009-11-10 19:30:27.000000000 -0500
@@ -2308,7 +2308,7 @@ int filemap_sync(struct vm_area_struct *
 	return error;
 }
 
-static struct vm_operations_struct generic_file_vm_ops = {
+static const struct vm_operations_struct generic_file_vm_ops = {
 	nopage:		filemap_nopage,
 };
 
@@ -2324,7 +2324,13 @@ int generic_file_mmap(struct file * file
 			return -EINVAL;
 	}
 	if (!mapping->a_ops->readpage)
-		return -ENOEXEC;
+		return -ENODEV;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	UPDATE_ATIME(inode);
 	vma->vm_ops = &generic_file_vm_ops;
 	return 0;
@@ -2554,8 +2560,42 @@ static long madvise_fixup_middle(struct 
  * We can potentially split a vm area into separate
  * areas, each area with its own behavior.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static long __madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior);
+
+static long madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + (unsigned long)vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + (unsigned long)vma->vm_mirror;
+			end_m = end + (unsigned long)vma->vm_mirror;
+			error = __madvise_behavior(vma_m, start_m, end_m, behavior);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: madvise bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __madvise_behavior(vma, start, end, behavior);
+}
+
+static long __madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior)
+#else
 static long madvise_behavior(struct vm_area_struct * vma,
 	unsigned long start, unsigned long end, int behavior)
+#endif
 {
 	int error = 0;
 
@@ -3068,6 +3108,7 @@ int precheck_file_write(struct file *fil
 	err = -EFBIG;
 	
 	if (!S_ISBLK(inode->i_mode) && limit != RLIM_INFINITY) {
+		gr_learn_resource(current, RLIMIT_FSIZE, pos, 0);
 		if (pos >= limit) {
 			send_sig(SIGXFSZ, current, 0);
 			goto out;
@@ -3103,6 +3144,7 @@ int precheck_file_write(struct file *fil
 	 */
 	 
 	if (!S_ISBLK(inode->i_mode)) {
+		gr_learn_resource(current, RLIMIT_FSIZE, *count + (u32)pos, 0);
 		if (pos >= inode->i_sb->s_maxbytes)
 		{
 			if (*count || pos > inode->i_sb->s_maxbytes) {
diff -urNp linux-2.4.37.7/mm/memory.c linux-2.4.37.7/mm/memory.c
--- linux-2.4.37.7/mm/memory.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/memory.c	2009-11-10 19:30:27.000000000 -0500
@@ -468,9 +468,9 @@ int get_user_pages(struct task_struct *t
 	do {
 		struct vm_area_struct *	vma;
 
-		vma = find_extend_vma(mm, start);
+		vma = find_vma(mm, start);
 
-		if ( !vma || (pages && vma->vm_flags & VM_IO) || !(flags & vma->vm_flags) )
+		if ( !vma || start < vma->vm_start || (pages && vma->vm_flags & VM_IO) || !(flags & vma->vm_flags) )
 			return i ? : -EFAULT;
 
 		spin_lock(&mm->page_table_lock);
@@ -929,6 +929,63 @@ static inline void break_cow(struct vm_a
 	establish_pte(vma, address, page_table, pte_mkwrite(pte_mkdirty(mk_pte(new_page, vma->vm_page_prot))));
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+/* PaX: if vma is mirrored, synchronize the mirror's PTE
+ *
+ * mm->page_table_lock is held on entry and is not released on exit or inside
+ * to ensure atomic changes to the PTE states (swapout, mremap, munmap, etc)
+ */
+static void pax_mirror_fault(struct vm_area_struct *vma, unsigned long address, pte_t *pte)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m;
+	struct vm_area_struct * vma_m = NULL;
+	pte_t * pte_m, entry_m;
+	struct page * page_m;
+
+	address_m = vma->vm_start + vma->vm_mirror;
+	vma_m = find_vma(mm, address_m);
+	BUG_ON(!vma_m || vma_m->vm_start != address_m);
+
+	address_m = address + vma->vm_mirror;
+	pte_m = pte_offset(pmd_offset(pgd_offset(mm, address_m), address_m), address_m);
+
+	if (pte_same(*pte, *pte_m))
+		return;
+
+	if (pte_present(*pte_m)) {
+		flush_cache_page(vma_m, address_m);
+		flush_icache_page(vma_m, pte_page(*pte_m));
+	}
+	entry_m = ptep_get_and_clear(pte_m);
+	if (pte_present(entry_m))
+		flush_tlb_page(vma_m, address_m);
+
+	if (pte_none(entry_m)) {
+		++mm->rss;
+	} else if (pte_present(entry_m)) {
+		page_m = pte_page(entry_m);
+		if (VALID_PAGE(page_m) && !PageReserved(page_m))
+			page_cache_release(page_m);
+		else
+			++mm->rss;
+	} else {
+		free_swap_and_cache(pte_to_swp_entry(entry_m));
+		++mm->rss;
+	}
+
+	page_m = pte_page(*pte);
+	if (VALID_PAGE(page_m) && !PageReserved(page_m))
+		page_cache_get(page_m);
+	else
+		--mm->rss;
+	entry_m = mk_pte(page_m, vma_m->vm_page_prot);
+	if (pte_write(*pte) && (vma_m->vm_flags & VM_WRITE))
+		entry_m = pte_mkdirty(pte_mkwrite(entry_m));
+	establish_pte(vma_m, address_m, pte_m, entry_m);
+}
+#endif
+
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
@@ -993,6 +1050,12 @@ static int do_wp_page(struct mm_struct *
 
 		/* Free the old page.. */
 		new_page = old_page;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			pax_mirror_fault(vma, address, page_table);
+#endif
+
 	}
 	spin_unlock(&mm->page_table_lock);
 	page_cache_release(new_page);
@@ -1070,6 +1133,7 @@ out_unlock:
 
 do_expand:
 	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	gr_learn_resource(current, RLIMIT_FSIZE, offset, 1);
 	if (limit != RLIM_INFINITY && offset > limit)
 		goto out_sig;
 	if (offset > inode->i_sb->s_maxbytes)
@@ -1183,6 +1247,12 @@ static int do_swap_page(struct mm_struct
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, pte);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return ret;
 }
@@ -1229,6 +1299,12 @@ static int do_anonymous_page(struct mm_s
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, addr, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, addr, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 1;	/* Minor fault */
 
@@ -1311,6 +1387,12 @@ static int do_no_page(struct mm_struct *
 
 	/* no need to invalidate: a not-present page shouldn't be cached */
 	update_mmu_cache(vma, address, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 2;	/* Major fault */
 }
@@ -1362,6 +1444,12 @@ static inline int handle_pte_fault(struc
 	}
 	entry = pte_mkyoung(entry);
 	establish_pte(vma, address, pte, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, pte);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 1;
 }
@@ -1383,6 +1471,43 @@ int handle_mm_fault(struct mm_struct *mm
 	 * and the SMP-safe atomic PTE updates.
 	 */
 	spin_lock(&mm->page_table_lock);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		unsigned long address_m;
+		struct vm_area_struct * vma_m;
+		pgd_t *pgd_m;
+		pmd_t *pmd_m;
+
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(mm, address_m);
+
+		/* PaX: sanity checks */
+		if (!vma_m) {
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug, %08lx, %p, %08lx, %p\n",
+			       address, vma, address_m, vma_m);
+			return 0;
+		} else if (!(vma_m->vm_flags & VM_MIRROR) ||
+			   vma_m->vm_start != address_m ||
+			   vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug2, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return 0;
+		}
+
+		address_m = address + vma->vm_mirror;
+		pgd_m = pgd_offset(mm, address_m);
+		pmd_m = pmd_alloc(mm, pgd_m, address_m);
+		if (!pmd_m || !pte_alloc(mm, pmd_m, address_m)) {
+			spin_unlock(&mm->page_table_lock);
+			return -1;
+		}
+	}	
+#endif
+
 	pmd = pmd_alloc(mm, pgd, address);
 
 	if (pmd) {
@@ -1467,6 +1592,40 @@ out:
 	return pte_offset(pmd, address);
 }
 
+#ifndef pmd_populate_kernel
+#define pmd_populate_kernel(mm,pmd,new) pmd_populate(mm,pmd,new)
+#endif
+
+pte_t fastcall *pte_alloc_kernel(struct mm_struct *mm, pmd_t *pmd, unsigned long address)
+{
+	if (pmd_none(*pmd)) {
+		pte_t *new;
+
+		/* "fast" allocation can happen without dropping the lock.. */
+		new = pte_alloc_one_fast(mm, address);
+		if (!new) {
+			spin_unlock(&mm->page_table_lock);
+			new = pte_alloc_one(mm, address);
+			spin_lock(&mm->page_table_lock);
+			if (!new)
+				return NULL;
+
+			/*
+			 * Because we dropped the lock, we should re-check the
+			 * entry, as somebody else could have populated it..
+			 */
+			if (!pmd_none(*pmd)) {
+				pte_free(new);
+				check_pgt_cache();
+				goto out;
+			}
+		}
+		pmd_populate_kernel(mm, pmd, new);
+	}
+out:
+	return pte_offset(pmd, address);
+}
+
 int make_pages_present(unsigned long addr, unsigned long end)
 {
 	int ret, len, write;
diff -urNp linux-2.4.37.7/mm/mlock.c linux-2.4.37.7/mm/mlock.c
--- linux-2.4.37.7/mm/mlock.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/mlock.c	2009-11-10 19:30:27.000000000 -0500
@@ -114,25 +114,44 @@ static inline int mlock_fixup_middle(str
 	return 0;
 }
 
+static int __mlock_fixup(struct vm_area_struct * vma, 
+	unsigned long start, unsigned long end, unsigned int newflags);
+
 static int mlock_fixup(struct vm_area_struct * vma, 
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
 	int pages, retval;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+	unsigned long start_m = 0UL, end_m = 0UL, newflags_m = 0UL;
+#endif
+
 	if (newflags == vma->vm_flags)
 		return 0;
 
-	if (start == vma->vm_start) {
-		if (end == vma->vm_end)
-			retval = mlock_fixup_all(vma, newflags);
-		else
-			retval = mlock_fixup_start(vma, end, newflags);
-	} else {
-		if (end == vma->vm_end)
-			retval = mlock_fixup_end(vma, start, newflags);
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(vma->vm_mm, start_m);
+		if (!vma_m || vma_m->vm_start != start_m || !(vma_m->vm_flags & VM_MIRROR)) {
+			printk("PAX: VMMIRROR: mlock bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+
+		start_m = start + vma->vm_mirror;
+		end_m = end + vma->vm_mirror;
+		if (newflags & VM_LOCKED)
+			newflags_m = vma_m->vm_flags | VM_LOCKED;
 		else
-			retval = mlock_fixup_middle(vma, start, end, newflags);
+			newflags_m = vma_m->vm_flags & ~VM_LOCKED;
+		retval = __mlock_fixup(vma_m, start_m, end_m, newflags_m);
+		if (retval)
+			return retval;
 	}
+#endif
+
+	retval = __mlock_fixup(vma, start, end, newflags);
 	if (!retval) {
 		/* keep track of amount of locked VM */
 		pages = (end - start) >> PAGE_SHIFT;
@@ -141,6 +160,32 @@ static int mlock_fixup(struct vm_area_st
 			make_pages_present(start, end);
 		}
 		vma->vm_mm->locked_vm -= pages;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			vma->vm_mm->locked_vm -= pages;
+#endif
+
+	}
+
+	return retval;
+}
+
+static int __mlock_fixup(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	int retval;
+
+	if (start == vma->vm_start) {
+		if (end == vma->vm_end)
+			retval = mlock_fixup_all(vma, newflags);
+		else
+			retval = mlock_fixup_start(vma, end, newflags);
+	} else {
+		if (end == vma->vm_end)
+			retval = mlock_fixup_end(vma, start, newflags);
+		else
+			retval = mlock_fixup_middle(vma, start, end, newflags);
 	}
 	return retval;
 }
@@ -159,6 +204,17 @@ static int do_mlock(unsigned long start,
 		return -EINVAL;
 	if (end == start)
 		return 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	vma = find_vma(current->mm, start);
 	if (!vma || vma->vm_start > start)
 		return -ENOMEM;
@@ -209,6 +265,7 @@ asmlinkage long sys_mlock(unsigned long 
 	lock_limit >>= PAGE_SHIFT;
 
 	/* check against resource limits */
+	gr_learn_resource(current, RLIMIT_MEMLOCK, (current->mm->locked_vm << PAGE_SHIFT) + len, 1);
 	if (locked > lock_limit)
 		goto out;
 
@@ -253,6 +310,16 @@ static int do_mlockall(int flags)
 	for (vma = current->mm->mmap; vma ; vma = vma->vm_next) {
 		unsigned int newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+			if (vma->vm_end > SEGMEXEC_TASK_SIZE)
+				break;
+		} else
+#endif
+
+		if (vma->vm_end > TASK_SIZE)
+			break;
+
 		newflags = vma->vm_flags | VM_LOCKED;
 		if (!(flags & MCL_CURRENT))
 			newflags &= ~VM_LOCKED;
@@ -276,6 +343,7 @@ asmlinkage long sys_mlockall(int flags)
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
+	gr_learn_resource(current, RLIMIT_MEMLOCK, current->mm->total_vm, 1);
 	if (current->mm->total_vm > lock_limit)
 		goto out;
 
diff -urNp linux-2.4.37.7/mm/mmap.c linux-2.4.37.7/mm/mmap.c
--- linux-2.4.37.7/mm/mmap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/mmap.c	2009-11-10 19:30:27.000000000 -0500
@@ -15,6 +15,8 @@
 #include <linux/fs.h>
 #include <linux/personality.h>
 #include <linux/mount.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -171,6 +173,7 @@ asmlinkage unsigned long sys_brk(unsigne
 
 	/* Check against rlimit.. */
 	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	gr_learn_resource(current, RLIMIT_DATA, brk - mm->start_data, 1);
 	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
 		goto out;
 
@@ -208,6 +211,11 @@ static inline unsigned long calc_vm_flag
 		_trans(prot, PROT_WRITE, VM_WRITE) |
 		_trans(prot, PROT_EXEC, VM_EXEC);
 	flag_bits =
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_trans(flags, MAP_MIRROR, VM_MIRROR) |
+#endif
+
 		_trans(flags, MAP_GROWSDOWN, VM_GROWSDOWN) |
 		_trans(flags, MAP_DENYWRITE, VM_DENYWRITE) |
 		_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE);
@@ -393,7 +401,47 @@ static int vma_merge(struct mm_struct * 
 	return 0;
 }
 
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flags, unsigned long pgoff);
+
 unsigned long do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flag, unsigned long pgoff)
+{
+	unsigned long ret = -EINVAL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || (addr > SEGMEXEC_TASK_SIZE-len)))
+		goto out;
+#endif
+
+	ret = __do_mmap_pgoff(file, addr, len, prot, flag, pgoff);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && ret < TASK_SIZE && ((flag & MAP_TYPE) == MAP_PRIVATE)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && (!(current->mm->pax_flags & MF_PAX_MPROTECT) || ((prot & PROT_EXEC) && file && !(prot & PROT_WRITE)))
+#endif
+
+	   )
+	{
+		unsigned long ret_m;
+		prot = prot & PROT_EXEC ? prot & ~PROT_WRITE : PROT_NONE;
+		ret_m = __do_mmap_pgoff(NULL, ret + SEGMEXEC_TASK_SIZE, 0UL, prot, flag | MAP_MIRROR | MAP_FIXED, ret);
+		if (ret_m >= TASK_SIZE) {
+			do_munmap(current->mm, ret, len);
+			ret = ret_m;
+		}
+	}
+
+out:
+#endif
+
+	return ret;
+}
+
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long pgoff)
 {
 	struct mm_struct * mm = current->mm;
@@ -403,6 +451,28 @@ unsigned long do_mmap_pgoff(struct file 
 	int error;
 	rb_node_t ** rb_link, * rb_parent;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+
+	if (flags & MAP_MIRROR) {
+		/* PaX: sanity checks, to be removed when proved to be stable */
+		if (file || len || ((flags & MAP_TYPE) != MAP_PRIVATE))
+			return -EINVAL;
+
+		vma_m = find_vma(mm, pgoff);
+
+		if (!vma_m ||
+		    vma_m->vm_start != pgoff ||
+		    (vma_m->vm_flags & VM_MIRROR) ||
+		    (prot & PROT_WRITE))
+			return -EINVAL;
+
+		file = vma_m->vm_file;
+		pgoff = vma_m->vm_pgoff;
+		len = vma_m->vm_end - vma_m->vm_start;
+	}
+#endif
+
 	if (file) {
 		if (!file->f_op || !file->f_op->mmap)
 			return -ENODEV;
@@ -440,10 +510,29 @@ unsigned long do_mmap_pgoff(struct file 
 	 */
 	vm_flags = calc_vm_flags(prot,flags) | mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+	if (file && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+		vm_flags &= ~VM_MAYEXEC;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT) {
+			if ((prot & (PROT_WRITE | PROT_EXEC)) != PROT_EXEC)
+				vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+			else
+				vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
+		}
+#endif
+
+	}
+#endif
+
 	/* mlock MCL_FUTURE? */
 	if (vm_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
 		locked += len;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked, 1);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			return -EAGAIN;
 	}
@@ -488,6 +577,9 @@ unsigned long do_mmap_pgoff(struct file 
 		}
 	}
 
+	if (!gr_acl_handle_mmap(file, prot))
+		return -EACCES;
+
 	/* Clear old maps */
 munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
@@ -498,6 +590,7 @@ munmap_back:
 	}
 
 	/* Check against address space limit. */
+	gr_learn_resource(current, RLIMIT_AS, (mm->total_vm << PAGE_SHIFT) + len, 1);
 	if ((mm->total_vm << PAGE_SHIFT) + len
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
@@ -525,11 +618,19 @@ munmap_back:
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = vm_flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((file || !(mm->pax_flags & MF_PAX_PAGEEXEC)) && (vm_flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[vm_flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = pgoff;
 	vma->vm_file = NULL;
 	vma->vm_private_data = NULL;
+	vma->vm_mirror = 0;
 	vma->vm_raend = 0;
 
 	if (file) {
@@ -553,6 +654,14 @@ munmap_back:
 			goto free_vma;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR) {
+		vma_m->vm_flags |= VM_MIRROR;
+		vma_m->vm_mirror = vma->vm_start - vma_m->vm_start;
+		vma->vm_mirror = vma_m->vm_start - vma->vm_start;
+	}
+#endif
+
 	/* Can addr have changed??
 	 *
 	 * Answer: Yes, several device drivers can do it in their
@@ -623,22 +732,38 @@ free_vma:
 static inline unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct vm_area_struct *vma;
+	unsigned long task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
-	if (len > TASK_SIZE)
+	if (len > task_size)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current->mm, addr);
-		if (TASK_SIZE - len >= addr &&
+		if (task_size - len >= addr &&
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
 	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE);
 
+#ifdef CONFIG_PAX_RANDMMAP
+	/* PaX: randomize base address if requested */
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		addr += current->mm->delta_mmap;
+#endif
+
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr)
+		if (task_size - len < addr)
 			return -ENOMEM;
 		if (!vma || addr + len <= vma->vm_start)
 			return addr;
@@ -759,28 +884,6 @@ struct vm_area_struct * find_vma_prev(st
 	return NULL;
 }
 
-struct vm_area_struct * find_extend_vma(struct mm_struct * mm, unsigned long addr)
-{
-	struct vm_area_struct * vma;
-	unsigned long start;
-
-	addr &= PAGE_MASK;
-	vma = find_vma(mm,addr);
-	if (!vma)
-		return NULL;
-	if (vma->vm_start <= addr)
-		return vma;
-	if (!(vma->vm_flags & VM_GROWSDOWN))
-		return NULL;
-	start = vma->vm_start;
-	if (expand_stack(vma, addr))
-		return NULL;
-	if (vma->vm_flags & VM_LOCKED) {
-		make_pages_present(addr, start);
-	}
-	return vma;
-}
-
 /* Normal function to fix up a mapping
  * This function is the default for when an area has no specific
  * function.  This may be used as part of a more specific routine.
@@ -856,6 +959,7 @@ static struct vm_area_struct * unmap_fix
 		mpnt->vm_pgoff = area->vm_pgoff + ((end - area->vm_start) >> PAGE_SHIFT);
 		mpnt->vm_file = area->vm_file;
 		mpnt->vm_private_data = area->vm_private_data;
+		mpnt->vm_mirror = area->vm_mirror;
 		if (mpnt->vm_file)
 			get_file(mpnt->vm_file);
 		if (mpnt->vm_ops && mpnt->vm_ops->open)
@@ -941,7 +1045,24 @@ no_mmaps:
  * work.  This now handles partial unmappings.
  * Jeremy Fitzhardine <jeremy@sw.oz.au>
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __do_munmap(struct mm_struct *mm, unsigned long addr, size_t len);
+
+int do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+{
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		int ret = __do_munmap(mm, addr + SEGMEXEC_TASK_SIZE, len);
+		if (ret)
+			return ret;
+	}
+
+	return __do_munmap(mm, addr, len);
+}
+
+static int __do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+#else
 int do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+#endif
 {
 	struct vm_area_struct *mpnt, *prev, **npp, *free, *extra;
 
@@ -1039,6 +1160,12 @@ asmlinkage long sys_munmap(unsigned long
 	int ret;
 	struct mm_struct *mm = current->mm;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-len))
+		return -EINVAL;
+#endif
+
 	down_write(&mm->mmap_sem);
 	ret = do_munmap(mm, addr, len);
 	up_write(&mm->mmap_sem);
@@ -1059,18 +1186,47 @@ static inline void verify_mmap_write_loc
  *  anonymous maps.  eventually we may be able to do some
  *  brk-specific accounting here.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static unsigned long __do_brk(unsigned long addr, unsigned long len);
+
+unsigned long do_brk(unsigned long addr, unsigned long len)
+{
+	unsigned long ret;
+
+	ret = __do_brk(addr, len);
+	if (ret == addr && (current->mm->pax_flags & (MF_PAX_SEGMEXEC | MF_PAX_MPROTECT)) == MF_PAX_SEGMEXEC) {
+		unsigned long ret_m;
+
+		ret_m = __do_mmap_pgoff(NULL, addr + SEGMEXEC_TASK_SIZE, 0UL, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_MIRROR, addr);
+		if (ret_m > TASK_SIZE) {
+			do_munmap(current->mm, addr, len);
+			ret = ret_m;
+		}
+	}
+
+	return ret;
+}
+
+static unsigned long __do_brk(unsigned long addr, unsigned long len)
+#else
 unsigned long do_brk(unsigned long addr, unsigned long len)
+#endif
 {
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
-	unsigned long flags;
+	unsigned long flags, task_size = TASK_SIZE;
 	rb_node_t ** rb_link, * rb_parent;
 
 	len = PAGE_ALIGN(len);
 	if (!len)
 		return addr;
 
-	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if ((addr + len) > task_size || (addr + len) < addr)
 		return -EINVAL;
 
 	if (addr < mmap_min_addr && !capable(CAP_SYS_RAWIO))
@@ -1082,6 +1238,7 @@ unsigned long do_brk(unsigned long addr,
 	if (mm->def_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
 		locked += len;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked, 1);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			return -EAGAIN;
 	}
@@ -1104,6 +1261,7 @@ unsigned long do_brk(unsigned long addr,
 	}
 
 	/* Check against address space limits *after* clearing old maps... */
+	gr_learn_resource(current, RLIMIT_AS, (mm->total_vm << PAGE_SHIFT) + len, 1);
 	if ((mm->total_vm << PAGE_SHIFT) + len
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
@@ -1116,6 +1274,18 @@ unsigned long do_brk(unsigned long addr,
 
 	flags = VM_DATA_DEFAULT_FLAGS | mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	/* Can we just expand an old anonymous mapping? */
 	if (rb_parent && vma_merge(mm, prev, rb_parent, addr, addr + len, flags))
 		goto out;
@@ -1131,11 +1301,19 @@ unsigned long do_brk(unsigned long addr,
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+		vma->vm_page_prot = protection_map[(flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = 0;
 	vma->vm_file = NULL;
 	vma->vm_private_data = NULL;
+	vma->vm_mirror = 0;
 
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 
diff -urNp linux-2.4.37.7/mm/mprotect.c linux-2.4.37.7/mm/mprotect.c
--- linux-2.4.37.7/mm/mprotect.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/mprotect.c	2009-11-10 19:30:27.000000000 -0500
@@ -7,6 +7,12 @@
 #include <linux/smp_lock.h>
 #include <linux/shm.h>
 #include <linux/mman.h>
+#include <linux/grsecurity.h>
+
+#ifdef CONFIG_PAX_MPROTECT
+#include <linux/elf.h>
+#include <linux/fs.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -236,6 +242,45 @@ static inline int mprotect_fixup_middle(
 	return 0;
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags);
+
+static int mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+
+			if (vma_m->vm_start >= SEGMEXEC_TASK_SIZE && !(newflags & VM_EXEC))
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, vma_m->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
+			else
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, newflags);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: mprotect bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __mprotect_fixup(vma, pprev, start, end, newflags);
+}
+
+static int __mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	pgprot_t newprot;
+	int error;
+#else
 static int mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
@@ -246,6 +291,14 @@ static int mprotect_fixup(struct vm_area
 		*pprev = vma;
 		return 0;
 	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if (!(vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+		newprot = protection_map[(newflags | VM_EXEC) & 0xf];
+	else
+#endif
+
 	newprot = protection_map[newflags & 0xf];
 	if (start == vma->vm_start) {
 		if (end == vma->vm_end)
@@ -264,6 +317,69 @@ static int mprotect_fixup(struct vm_area
 	return 0;
 }
 
+#ifdef CONFIG_PAX_MPROTECT
+/* PaX: non-PIC ELF libraries need relocations on their executable segments
+ * therefore we'll grant them VM_MAYWRITE once during their life.
+ *
+ * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+ * basis because we want to allow the common case and not the special ones.
+ */
+static inline void pax_handle_maywrite(struct vm_area_struct * vma, unsigned long start)
+{
+	struct elfhdr elf_h;
+	struct elf_phdr elf_p, p_dyn;
+	elf_dyn dyn;
+	unsigned long i, j = 65536UL / sizeof(struct elf_phdr);
+
+#ifndef CONFIG_PAX_NOELFRELOCS
+	if ((vma->vm_start != start) ||
+	    !vma->vm_file ||
+	    !(vma->vm_flags & VM_MAYEXEC) ||
+	    (vma->vm_flags & VM_MAYNOTWRITE))
+#endif
+
+		return;
+
+	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char*)&elf_h, sizeof(elf_h)) ||
+	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+
+#ifdef CONFIG_PAX_ETEXECRELOCS
+	    (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC) ||
+#else
+	    elf_h.e_type != ET_DYN ||
+#endif
+
+	    !elf_check_arch(&elf_h) ||
+	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+	    elf_h.e_phnum > j)
+		return;
+
+	for (i = 0UL; i < elf_h.e_phnum; i++) {
+		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char*)&elf_p, sizeof(elf_p)))
+			return;
+		if (elf_p.p_type == PT_DYNAMIC) {
+			p_dyn = elf_p;
+			j = i;
+		}
+	}
+	if (elf_h.e_phnum <= j)
+		return;
+
+	i = 0UL;
+	do {
+		if (sizeof(dyn) != kernel_read(vma->vm_file, p_dyn.p_offset + i*sizeof(dyn), (char*)&dyn, sizeof(dyn)))
+			return;
+		if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+			vma->vm_flags |= VM_MAYWRITE | VM_MAYNOTWRITE;
+			gr_log_textrel(vma);
+			return;
+		}
+		i++;
+	} while (dyn.d_tag != DT_NULL);
+	return;
+}
+#endif
+
 asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
 	unsigned long nstart, end, tmp;
@@ -276,6 +392,17 @@ asmlinkage long sys_mprotect(unsigned lo
 	end = start + len;
 	if (end < start)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
 		return -EINVAL;
 	if (end == start)
@@ -288,6 +415,16 @@ asmlinkage long sys_mprotect(unsigned lo
 	if (!vma || vma->vm_start > start)
 		goto out;
 
+	if (!gr_acl_handle_mprotect(vma->vm_file, prot)) {
+		error = -EACCES;
+		goto out;
+	}
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && (prot & PROT_WRITE))
+		pax_handle_maywrite(vma, start);
+#endif
+
 	for (nstart = start ; ; ) {
 		unsigned int newflags;
 		int last = 0;
@@ -300,6 +437,12 @@ asmlinkage long sys_mprotect(unsigned lo
 			goto out;
 		}
 
+#ifdef CONFIG_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && !(prot & PROT_WRITE) && (vma->vm_flags & VM_MAYNOTWRITE))
+			newflags &= ~VM_MAYWRITE;
+#endif
+
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
diff -urNp linux-2.4.37.7/mm/mremap.c linux-2.4.37.7/mm/mremap.c
--- linux-2.4.37.7/mm/mremap.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/mremap.c	2009-11-10 19:30:27.000000000 -0500
@@ -226,7 +226,7 @@ unsigned long do_mremap(unsigned long ad
 	unsigned long flags, unsigned long new_addr)
 {
 	struct vm_area_struct *vma;
-	unsigned long ret = -EINVAL;
+	unsigned long ret = -EINVAL, task_size = TASK_SIZE;
 
 	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 		goto out;
@@ -237,10 +237,15 @@ unsigned long do_mremap(unsigned long ad
 	old_len = PAGE_ALIGN(old_len);
 	new_len = PAGE_ALIGN(new_len);
 
-	if (old_len > TASK_SIZE || addr > TASK_SIZE - old_len)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (old_len > task_size || addr > task_size - old_len)
 		goto out;
 
-	if (addr >= TASK_SIZE)
+	if (addr >= task_size)
 		goto out;
 
 	/* new_addr is only valid if MREMAP_FIXED is specified */
@@ -250,10 +255,10 @@ unsigned long do_mremap(unsigned long ad
 		if (!(flags & MREMAP_MAYMOVE))
 			goto out;
 
-		if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
+		if (new_len > task_size || new_addr > task_size - new_len)
 			goto out;
 
-		if (new_addr >= TASK_SIZE)
+		if (new_addr >= task_size)
 			goto out;
 
 		/*
@@ -304,6 +309,14 @@ unsigned long do_mremap(unsigned long ad
 	vma = find_vma(current->mm, addr);
 	if (!vma || vma->vm_start > addr)
 		goto out;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_flags & VM_MIRROR)) {
+		ret = -EINVAL;
+		goto out;
+	}
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
@@ -315,10 +328,13 @@ unsigned long do_mremap(unsigned long ad
 		unsigned long locked = current->mm->locked_vm << PAGE_SHIFT;
 		locked += new_len - old_len;
 		ret = -EAGAIN;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked, 1);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			goto out;
 	}
 	ret = -ENOMEM;
+
+	gr_learn_resource(current, RLIMIT_AS, (current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len), 1);
 	if ((current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len)
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		goto out;
@@ -334,7 +350,7 @@ unsigned long do_mremap(unsigned long ad
 	if (old_len == vma->vm_end - addr &&
 	    !((flags & MREMAP_FIXED) && (addr != new_addr)) &&
 	    (old_len != new_len || !(flags & MREMAP_MAYMOVE))) {
-		unsigned long max_addr = TASK_SIZE;
+		unsigned long max_addr = task_size;
 		if (vma->vm_next)
 			max_addr = vma->vm_next->vm_start;
 		/* can we just expand the current mapping? */
diff -urNp linux-2.4.37.7/mm/page_alloc.c linux-2.4.37.7/mm/page_alloc.c
--- linux-2.4.37.7/mm/page_alloc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/page_alloc.c	2009-11-10 19:30:27.000000000 -0500
@@ -162,12 +162,16 @@ static void fastcall __free_pages_ok (st
 	page_idx = page - base;
 	if (page_idx & ~mask)
 		BUG();
-	index = page_idx >> (1 + order);
-
-	area = zone->free_area + order;
 
 	spin_lock_irqsave(&zone->lock, flags);
 
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	for (index = 1U << order; index; --index)
+		sanitize_highpage(page + index - 1);
+#endif
+
+	index = page_idx >> (1 + order);
+	area = zone->free_area + order;
 	zone->free_pages -= mask;
 
 	while (mask + (1 << (MAX_ORDER-1))) {
diff -urNp linux-2.4.37.7/mm/shmem.c linux-2.4.37.7/mm/shmem.c
--- linux-2.4.37.7/mm/shmem.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/shmem.c	2009-11-10 19:30:27.000000000 -0500
@@ -65,12 +65,12 @@ enum sgp_type {
 static int shmem_getpage(struct inode *inode, unsigned long idx,
 			 struct page **pagep, enum sgp_type sgp);
 
-static struct super_operations shmem_ops;
-static struct address_space_operations shmem_aops;
-static struct file_operations shmem_file_operations;
-static struct inode_operations shmem_inode_operations;
-static struct inode_operations shmem_dir_inode_operations;
-static struct vm_operations_struct shmem_vm_ops;
+static const struct super_operations shmem_ops;
+static const struct address_space_operations shmem_aops;
+static const struct file_operations shmem_file_operations;
+static const struct inode_operations shmem_inode_operations;
+static const struct inode_operations shmem_dir_inode_operations;
+static const struct vm_operations_struct shmem_vm_ops;
 
 LIST_HEAD(shmem_inodes);
 static spinlock_t shmem_ilock = SPIN_LOCK_UNLOCKED;
@@ -841,7 +841,7 @@ void shmem_lock(struct file *file, int l
 
 static int shmem_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct vm_operations_struct *ops;
+	const struct vm_operations_struct *ops;
 	struct inode *inode = file->f_dentry->d_inode;
 
 	ops = &shmem_vm_ops;
@@ -930,8 +930,8 @@ out:
 
 #ifdef CONFIG_TMPFS
 
-static struct inode_operations shmem_symlink_inode_operations;
-static struct inode_operations shmem_symlink_inline_operations;
+static const struct inode_operations shmem_symlink_inode_operations;
+static const struct inode_operations shmem_symlink_inline_operations;
 
 /*
  * tmpfs itself makes no use of generic_file_read, generic_file_mmap
@@ -1188,7 +1188,7 @@ static int shmem_delete_dentry(struct de
  */
 static struct dentry *shmem_lookup(struct inode *dir, struct dentry *dentry)
 {
-	static struct dentry_operations shmem_dentry_operations = {
+	static const struct dentry_operations shmem_dentry_operations = {
 		.d_delete = shmem_delete_dentry,
 	};
 
@@ -1424,12 +1424,12 @@ static int shmem_follow_link(struct dent
 	return res;
 }
 
-static struct inode_operations shmem_symlink_inline_operations = {
+static const struct inode_operations shmem_symlink_inline_operations = {
 	readlink:	shmem_readlink_inline,
 	follow_link:	shmem_follow_link_inline,
 };
 
-static struct inode_operations shmem_symlink_inode_operations = {
+static const struct inode_operations shmem_symlink_inode_operations = {
 	truncate:	shmem_truncate,
 	readlink:	shmem_readlink,
 	follow_link:	shmem_follow_link,
@@ -1570,7 +1570,7 @@ static struct super_block *shmem_read_su
 	return sb;
 }
 
-static struct address_space_operations shmem_aops = {
+static const struct address_space_operations shmem_aops = {
 	removepage:	shmem_removepage,
 	writepage:	shmem_writepage,
 #ifdef CONFIG_TMPFS
@@ -1580,7 +1580,7 @@ static struct address_space_operations s
 #endif
 };
 
-static struct file_operations shmem_file_operations = {
+static const struct file_operations shmem_file_operations = {
 	mmap:		shmem_mmap,
 #ifdef CONFIG_TMPFS
 	read:		shmem_file_read,
@@ -1589,12 +1589,12 @@ static struct file_operations shmem_file
 #endif
 };
 
-static struct inode_operations shmem_inode_operations = {
+static const struct inode_operations shmem_inode_operations = {
 	truncate:	shmem_truncate,
 	setattr:	shmem_notify_change,
 };
 
-static struct inode_operations shmem_dir_inode_operations = {
+static const struct inode_operations shmem_dir_inode_operations = {
 #ifdef CONFIG_TMPFS
 	create:		shmem_create,
 	lookup:		shmem_lookup,
@@ -1608,7 +1608,7 @@ static struct inode_operations shmem_dir
 #endif
 };
 
-static struct super_operations shmem_ops = {
+static const struct super_operations shmem_ops = {
 #ifdef CONFIG_TMPFS
 	statfs:		shmem_statfs,
 	remount_fs:	shmem_remount_fs,
@@ -1617,7 +1617,7 @@ static struct super_operations shmem_ops
 	put_inode:	force_delete,
 };
 
-static struct vm_operations_struct shmem_vm_ops = {
+static const struct vm_operations_struct shmem_vm_ops = {
 	nopage:		shmem_nopage,
 };
 
@@ -1628,7 +1628,7 @@ static DECLARE_FSTYPE(tmpfs_fs_type, "tm
 #else
 static DECLARE_FSTYPE(tmpfs_fs_type, "tmpfs", shmem_read_super, FS_LITTER|FS_NOMOUNT);
 #endif
-static struct vfsmount *shm_mnt;
+struct vfsmount *shm_mnt;
 
 static int __init init_tmpfs(void)
 {
diff -urNp linux-2.4.37.7/mm/slab.c linux-2.4.37.7/mm/slab.c
--- linux-2.4.37.7/mm/slab.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/slab.c	2009-11-10 19:30:27.000000000 -0500
@@ -2017,7 +2017,7 @@ static int s_show(struct seq_file *m, vo
  * + further values on SMP and with statistics enabled
  */
 
-struct seq_operations slabinfo_op = {
+const struct seq_operations slabinfo_op = {
 	start:	s_start,
 	next:	s_next,
 	stop:	s_stop,
diff -urNp linux-2.4.37.7/mm/swap_state.c linux-2.4.37.7/mm/swap_state.c
--- linux-2.4.37.7/mm/swap_state.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/swap_state.c	2009-11-10 19:30:27.000000000 -0500
@@ -31,7 +31,7 @@ static int swap_writepage(struct page *p
 	return 0;
 }
 
-static struct address_space_operations swap_aops = {
+static const struct address_space_operations swap_aops = {
 	writepage: swap_writepage,
 	sync_page: block_sync_page,
 };
diff -urNp linux-2.4.37.7/mm/vmalloc.c linux-2.4.37.7/mm/vmalloc.c
--- linux-2.4.37.7/mm/vmalloc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/mm/vmalloc.c	2009-11-10 19:30:27.000000000 -0500
@@ -140,7 +140,7 @@ static inline int alloc_area_pmd(pmd_t *
 	if (end > PGDIR_SIZE)
 		end = PGDIR_SIZE;
 	do {
-		pte_t * pte = pte_alloc(&init_mm, pmd, address);
+		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
 		if (!pte)
 			return -ENOMEM;
 		if (alloc_area_pte(pte, address, end - address,
diff -urNp linux-2.4.37.7/net/8021q/vlanproc.c linux-2.4.37.7/net/8021q/vlanproc.c
--- linux-2.4.37.7/net/8021q/vlanproc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/8021q/vlanproc.c	2009-11-10 19:30:27.000000000 -0500
@@ -75,7 +75,7 @@ static char term_msg[]   = "***KERNEL:  
  *	Generic /proc/net/vlan/<file> file and inode operations 
  */
 
-static struct file_operations vlan_fops = {
+static const struct file_operations vlan_fops = {
 	read:	vlan_proc_read,
 	ioctl: NULL, /* vlan_proc_ioctl */
 };
@@ -84,7 +84,7 @@ static struct file_operations vlan_fops 
  *	/proc/net/vlan/<device> file and inode operations
  */
 
-static struct file_operations vlandev_fops = {
+static const struct file_operations vlandev_fops = {
 	read:	vlan_proc_read,
 	ioctl:	NULL, /* vlan_proc_ioctl */
 };
diff -urNp linux-2.4.37.7/net/atm/br2684.c linux-2.4.37.7/net/atm/br2684.c
--- linux-2.4.37.7/net/atm/br2684.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/atm/br2684.c	2009-11-10 19:30:27.000000000 -0500
@@ -773,7 +773,7 @@ static ssize_t br2684_proc_read(struct f
 	return len;
 }
 
-static struct file_operations br2684_proc_operations = {
+static const struct file_operations br2684_proc_operations = {
 	read: br2684_proc_read,
 };
 
diff -urNp linux-2.4.37.7/net/atm/mpoa_proc.c linux-2.4.37.7/net/atm/mpoa_proc.c
--- linux-2.4.37.7/net/atm/mpoa_proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/atm/mpoa_proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -41,7 +41,7 @@ static int parse_qos(const char *buff, i
 /*
  *   Define allowed FILE OPERATIONS
  */
-static struct file_operations mpc_file_operations = {
+static const struct file_operations mpc_file_operations = {
 	read:		proc_mpc_read,
 	write:		proc_mpc_write,
 };
diff -urNp linux-2.4.37.7/net/atm/proc.c linux-2.4.37.7/net/atm/proc.c
--- linux-2.4.37.7/net/atm/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/atm/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -54,11 +54,11 @@ static ssize_t proc_dev_atm_read(struct 
 static ssize_t proc_spec_atm_read(struct file *file,char *buf,size_t count,
     loff_t *pos);
 
-static struct file_operations proc_dev_atm_operations = {
+static const struct file_operations proc_dev_atm_operations = {
 	read:		proc_dev_atm_read,
 };
 
-static struct file_operations proc_spec_atm_operations = {
+static const struct file_operations proc_spec_atm_operations = {
 	read:		proc_spec_atm_read,
 };
 
@@ -244,7 +244,7 @@ static int clip_seq_show(struct seq_file
 	return 0;
 }
 
-static struct seq_operations arp_seq_ops = {
+static const struct seq_operations arp_seq_ops = {
 	.start	= clip_seq_start,
 	.next	= neigh_seq_next,
 	.stop	= neigh_seq_stop,
@@ -282,7 +282,7 @@ out_kfree:
 	goto out;
 }
 
-static struct file_operations arp_seq_fops = {
+static const struct file_operations arp_seq_fops = {
 	.open		= arp_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
diff -urNp linux-2.4.37.7/net/core/neighbour.c linux-2.4.37.7/net/core/neighbour.c
--- linux-2.4.37.7/net/core/neighbour.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/core/neighbour.c	2009-11-10 19:30:27.000000000 -0500
@@ -63,7 +63,7 @@ void neigh_changeaddr(struct neigh_table
 
 static int neigh_glbl_allocs;
 static struct neigh_table *neigh_tables;
-static struct file_operations neigh_stat_seq_fops;
+static const struct file_operations neigh_stat_seq_fops;
 
 /*
    Neighbour hash table buckets are protected with rwlock tbl->lock.
@@ -1896,7 +1896,7 @@ static int neigh_stat_seq_show(struct se
 	return 0;
 }
 
-static struct seq_operations neigh_stat_seq_ops = {
+static const struct seq_operations neigh_stat_seq_ops = {
 	.start	= neigh_stat_seq_start,
 	.next	= neigh_stat_seq_next,
 	.stop	= neigh_stat_seq_stop,
@@ -1914,7 +1914,7 @@ static int neigh_stat_seq_open(struct in
 	return ret;
 };
 
-static struct file_operations neigh_stat_seq_fops = {
+static const struct file_operations neigh_stat_seq_fops = {
 	.owner	 = THIS_MODULE,
 	.open 	 = neigh_stat_seq_open,
 	.read	 = seq_read,
diff -urNp linux-2.4.37.7/net/decnet/dn_neigh.c linux-2.4.37.7/net/decnet/dn_neigh.c
--- linux-2.4.37.7/net/decnet/dn_neigh.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/decnet/dn_neigh.c	2009-11-10 19:30:27.000000000 -0500
@@ -550,7 +550,7 @@ static void *dn_neigh_seq_start(struct s
 			       NEIGH_SEQ_NEIGH_ONLY);
 }
 
-static struct seq_operations dn_neigh_seq_ops = {
+static const struct seq_operations dn_neigh_seq_ops = {
 	.start = dn_neigh_seq_start,
 	.next = neigh_seq_next,
 	.stop = neigh_seq_stop,
@@ -581,7 +581,7 @@ out_kfree:
 	goto out;
 }
 
-static struct file_operations dn_neigh_seq_fops = {
+static const struct file_operations dn_neigh_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open		= dn_neigh_seq_open,
 	.read		= seq_read,
diff -urNp linux-2.4.37.7/net/ipv4/arp.c linux-2.4.37.7/net/ipv4/arp.c
--- linux-2.4.37.7/net/ipv4/arp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv4/arp.c	2009-11-10 19:30:27.000000000 -0500
@@ -1311,7 +1311,7 @@ static void *arp_seq_start(struct seq_fi
 
 /* ------------------------------------------------------------------------ */
 
-static struct seq_operations arp_seq_ops = {
+static const struct seq_operations arp_seq_ops = {
 	.start	= arp_seq_start,
 	.next	= neigh_seq_next,
 	.stop	= neigh_seq_stop,
@@ -1341,7 +1341,7 @@ out_kfree:
 	goto out;
 }
 
-static struct file_operations arp_seq_fops = {
+static const struct file_operations arp_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open		= arp_seq_open,
 	.read		= seq_read,
diff -urNp linux-2.4.37.7/net/ipv4/tcp_ipv4.c linux-2.4.37.7/net/ipv4/tcp_ipv4.c
--- linux-2.4.37.7/net/ipv4/tcp_ipv4.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv4/tcp_ipv4.c	2009-11-10 19:30:27.000000000 -0500
@@ -67,6 +67,7 @@
 #include <linux/inet.h>
 #include <linux/stddef.h>
 #include <linux/ipsec.h>
+#include <linux/grsecurity.h>
 
 extern int sysctl_ip_dynaddr;
 extern int sysctl_ip_default_ttl;
@@ -80,6 +81,8 @@ int sysctl_tcp_low_latency = 0;
 static struct inode tcp_inode;
 static struct socket *tcp_socket=&tcp_inode.u.socket_i;
 
+extern void gr_update_task_in_ip_table(struct task_struct *task, const struct sock *sk);
+
 void tcp_v4_send_check(struct sock *sk, struct tcphdr *th, int len, 
 		       struct sk_buff *skb);
 
@@ -734,6 +737,8 @@ static int tcp_v4_hash_connect(struct so
 		}
 		spin_unlock(&head->lock);
 
+		gr_update_task_in_ip_table(current, sk);
+
 		if (tw) {
 			tcp_tw_deschedule(tw);
 			tcp_timewait_kill(tw);
@@ -1691,6 +1696,9 @@ int tcp_v4_do_rcv(struct sock *sk, struc
 	return 0;
 
 reset:
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!skb->dev || (skb->dev->flags & IFF_LOOPBACK))
+#endif
 	tcp_v4_send_reset(skb);
 discard:
 	kfree_skb(skb);
@@ -1785,6 +1793,9 @@ no_tcp_socket:
 bad_packet:
 		TCP_INC_STATS_BH(TcpInErrs);
 	} else {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (skb->dev->flags & IFF_LOOPBACK)
+#endif
 		tcp_v4_send_reset(skb);
 	}
 
diff -urNp linux-2.4.37.7/net/ipv4/tcp_minisocks.c linux-2.4.37.7/net/ipv4/tcp_minisocks.c
--- linux-2.4.37.7/net/ipv4/tcp_minisocks.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv4/tcp_minisocks.c	2009-11-10 19:30:27.000000000 -0500
@@ -977,8 +977,11 @@ listen_overflow:
 
 embryonic_reset:
 	NET_INC_STATS_BH(EmbryonicRsts);
+
+#ifndef CONFIG_GRKERNSEC_BLACKHOLE
 	if (!(flg & TCP_FLAG_RST))
 		req->class->send_reset(skb);
+#endif
 
 	tcp_synq_drop(sk, req, prev);
 	return NULL;
diff -urNp linux-2.4.37.7/net/ipv4/udp.c linux-2.4.37.7/net/ipv4/udp.c
--- linux-2.4.37.7/net/ipv4/udp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv4/udp.c	2009-11-10 19:30:27.000000000 -0500
@@ -91,6 +91,7 @@
 #include <net/ipv6.h>
 #include <net/protocol.h>
 #include <linux/skbuff.h>
+#include <linux/grsecurity.h>
 #include <net/sock.h>
 #include <net/udp.h>
 #include <net/icmp.h>
@@ -98,6 +99,9 @@
 #include <net/inet_common.h>
 #include <net/checksum.h>
 
+extern int gr_search_udp_recvmsg(struct sock *sk, const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr);
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -481,9 +485,18 @@ int udp_sendmsg(struct sock *sk, struct 
 		ufh.uh.dest = usin->sin_port;
 		if (ufh.uh.dest == 0)
 			return -EINVAL;
+
+		err = gr_search_udp_sendmsg(sk, usin);
+		if (err)
+			return err;
 	} else {
 		if (sk->state != TCP_ESTABLISHED)
 			return -EDESTADDRREQ;
+
+		err = gr_search_udp_sendmsg(sk, NULL);
+		if (err)
+			return err;
+
 		ufh.daddr = sk->daddr;
 		ufh.uh.dest = sk->dport;
 		/* Open fast path for connected socket.
@@ -712,6 +725,10 @@ try_again:
 	if (!skb)
 		goto out;
   
+	err = gr_search_udp_recvmsg(sk, skb);
+	if (err)
+		goto out_free;
+
   	copied = skb->len - sizeof(struct udphdr);
 	if (copied > len) {
 		copied = len;
@@ -1001,6 +1018,9 @@ int udp_rcv(struct sk_buff *skb)
 		goto csum_error;
 
 	UDP_INC_STATS_BH(UdpNoPorts);
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (skb->dev->flags & IFF_LOOPBACK)
+#endif
 	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
 
 	/*
diff -urNp linux-2.4.37.7/net/ipv6/tcp_ipv6.c linux-2.4.37.7/net/ipv6/tcp_ipv6.c
--- linux-2.4.37.7/net/ipv6/tcp_ipv6.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv6/tcp_ipv6.c	2009-11-10 19:30:27.000000000 -0500
@@ -1519,6 +1519,9 @@ static int tcp_v6_do_rcv(struct sock *sk
 	return 0;
 
 reset:
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+	if (!skb->dev || (skb->dev->flags & IFF_LOOPBACK))
+#endif
 	tcp_v6_send_reset(skb);
 discard:
 	if (opt_skb)
@@ -1629,6 +1632,9 @@ no_tcp_socket:
 bad_packet:
 		TCP_INC_STATS_BH(TcpInErrs);
 	} else {
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		if (skb->dev->flags & IFF_LOOPBACK)
+#endif
 		tcp_v6_send_reset(skb);
 	}
 
diff -urNp linux-2.4.37.7/net/ipv6/udp.c linux-2.4.37.7/net/ipv6/udp.c
--- linux-2.4.37.7/net/ipv6/udp.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/ipv6/udp.c	2009-11-10 19:30:27.000000000 -0500
@@ -685,6 +685,9 @@ int udpv6_rcv(struct sk_buff *skb)
 			goto discard;
 		UDP6_INC_STATS_BH(UdpNoPorts);
 
+#ifdef CONFIG_GRKERNSEC_BLACKHOLE
+		if (skb->dev->flags & IFF_LOOPBACK)
+#endif
 		icmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0, dev);
 
 		kfree_skb(skb);
diff -urNp linux-2.4.37.7/net/netlink/af_netlink.c linux-2.4.37.7/net/netlink/af_netlink.c
--- linux-2.4.37.7/net/netlink/af_netlink.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/netlink/af_netlink.c	2009-11-10 19:30:27.000000000 -0500
@@ -45,6 +45,7 @@
 #include <linux/bitops.h>
 #include <linux/mm.h>
 #include <linux/types.h>
+#include <linux/grsecurity.h>
 #include <net/sock.h>
 #include <net/scm.h>
 
@@ -833,7 +834,8 @@ static int netlink_sendmsg(struct socket
 	   check them, when this message will be delivered
 	   to corresponding kernel module.   --ANK (980802)
 	 */
-	NETLINK_CB(skb).eff_cap = current->cap_effective;
+
+	NETLINK_CB(skb).eff_cap = gr_cap_rtnetlink();
 
 	err = -EFAULT;
 	if (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len)) {
diff -urNp linux-2.4.37.7/net/netlink/netlink_dev.c linux-2.4.37.7/net/netlink/netlink_dev.c
--- linux-2.4.37.7/net/netlink/netlink_dev.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/netlink/netlink_dev.c	2009-11-10 19:30:27.000000000 -0500
@@ -159,7 +159,7 @@ static int netlink_ioctl(struct inode *i
 }
 
 
-static struct file_operations netlink_fops = {
+static const struct file_operations netlink_fops = {
 	owner:		THIS_MODULE,
 	llseek:		no_llseek,
 	read:		netlink_read,
diff -urNp linux-2.4.37.7/net/netsyms.c linux-2.4.37.7/net/netsyms.c
--- linux-2.4.37.7/net/netsyms.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/netsyms.c	2009-11-10 19:30:27.000000000 -0500
@@ -24,6 +24,7 @@
 #include <net/checksum.h>
 #include <linux/etherdevice.h>
 #include <net/route.h>
+#include <linux/grsecurity.h>
 #ifdef CONFIG_HIPPI
 #include <linux/hippidevice.h>
 #endif
@@ -617,6 +618,21 @@ EXPORT_SYMBOL(register_gifconf);
 
 EXPORT_SYMBOL(softnet_data);
 
+EXPORT_SYMBOL(gr_cap_rtnetlink);
+
+extern int gr_search_udp_recvmsg(const struct sock *sk, const struct sk_buff *skb);
+extern int gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr);
+
+EXPORT_SYMBOL(gr_search_udp_recvmsg);
+EXPORT_SYMBOL(gr_search_udp_sendmsg);
+
+#ifdef CONFIG_UNIX_MODULE
+EXPORT_SYMBOL(gr_acl_handle_unix);
+EXPORT_SYMBOL(gr_acl_handle_mknod);
+EXPORT_SYMBOL(gr_handle_chroot_unix);
+EXPORT_SYMBOL(gr_handle_create);
+#endif
+
 #if defined(CONFIG_NET_RADIO) || defined(CONFIG_NET_PCMCIA_RADIO)
 #include <net/iw_handler.h>
 EXPORT_SYMBOL(wireless_send_event);
diff -urNp linux-2.4.37.7/net/packet/af_packet.c linux-2.4.37.7/net/packet/af_packet.c
--- linux-2.4.37.7/net/packet/af_packet.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/packet/af_packet.c	2009-11-10 19:30:27.000000000 -0500
@@ -1614,7 +1614,7 @@ static void packet_mm_close(struct vm_ar
 		atomic_dec(&sk->protinfo.af_packet->mapped);
 }
 
-static struct vm_operations_struct packet_mmap_ops = {
+static const struct vm_operations_struct packet_mmap_ops = {
 	open:	packet_mm_open,
 	close:	packet_mm_close,
 };
diff -urNp linux-2.4.37.7/net/sctp/proc.c linux-2.4.37.7/net/sctp/proc.c
--- linux-2.4.37.7/net/sctp/proc.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/sctp/proc.c	2009-11-10 19:30:27.000000000 -0500
@@ -100,7 +100,7 @@ static int sctp_snmp_seq_open(struct ino
 	return single_open(file, sctp_snmp_seq_show, NULL);
 }
 
-static struct file_operations sctp_snmp_seq_fops = {
+static const struct file_operations sctp_snmp_seq_fops = {
 	.owner	 = THIS_MODULE,
 	.open	 = sctp_snmp_seq_open,
 	.read	 = seq_read,
@@ -194,7 +194,7 @@ static int sctp_eps_seq_open(struct inod
 	return single_open(file, sctp_eps_seq_show, NULL);
 }
 
-static struct file_operations sctp_eps_seq_fops = {
+static const struct file_operations sctp_eps_seq_fops = {
 	.open	 = sctp_eps_seq_open,
 	.read	 = seq_read,
 	.llseek	 = seq_lseek,
@@ -260,7 +260,7 @@ static int sctp_assocs_seq_open(struct i
 	return single_open(file, sctp_assocs_seq_show, NULL);
 }
 
-static struct file_operations sctp_assocs_seq_fops = {
+static const struct file_operations sctp_assocs_seq_fops = {
 	.open	 = sctp_assocs_seq_open,
 	.read	 = seq_read,
 	.llseek	 = seq_lseek,
diff -urNp linux-2.4.37.7/net/socket.c linux-2.4.37.7/net/socket.c
--- linux-2.4.37.7/net/socket.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/socket.c	2009-11-10 19:30:27.000000000 -0500
@@ -85,6 +85,21 @@
 #include <net/scm.h>
 #include <linux/netfilter.h>
 
+extern void gr_attach_curr_ip(const struct sock *sk);
+extern int gr_handle_sock_all(const int family, const int type,
+			      const int protocol);
+extern int gr_handle_sock_server(const struct sockaddr *sck);  
+extern int gr_handle_sock_server_other(const struct socket *sck);  
+extern int gr_handle_sock_client(const struct sockaddr *sck);
+extern int gr_search_connect(struct socket * sock,
+			     struct sockaddr_in * addr);  
+extern int gr_search_bind(struct socket * sock,
+			  struct sockaddr_in * addr);
+extern int gr_search_listen(const struct socket * sock);
+extern int gr_search_accept(const struct socket * sock);
+extern int gr_search_socket(const int domain, const int type,
+			    const int protocol);
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_read(struct file *file, char *buf,
 			 size_t size, loff_t *ppos);
@@ -111,7 +126,7 @@ static ssize_t sock_sendpage(struct file
  *	in the operation structures but are done directly via the socketcall() multiplexor.
  */
 
-static struct file_operations socket_file_ops = {
+static const struct file_operations socket_file_ops = {
 	llseek:		no_llseek,
 	read:		sock_read,
 	write:		sock_write,
@@ -271,7 +286,7 @@ static int sockfs_statfs(struct super_bl
 	return 0;
 }
 
-static struct super_operations sockfs_ops = {
+static const struct super_operations sockfs_ops = {
 	statfs:		sockfs_statfs,
 };
 
@@ -298,13 +313,13 @@ static struct super_block * sockfs_read_
 	return sb;
 }
 
-static struct vfsmount *sock_mnt;
+struct vfsmount *sock_mnt;
 static DECLARE_FSTYPE(sock_fs_type, "sockfs", sockfs_read_super, FS_NOMOUNT);
 static int sockfs_delete_dentry(struct dentry *dentry)
 {
 	return 1;
 }
-static struct dentry_operations sockfs_dentry_operations = {
+static const struct dentry_operations sockfs_dentry_operations = {
 	d_delete:	sockfs_delete_dentry,
 };
 
@@ -906,6 +921,16 @@ asmlinkage long sys_socket(int family, i
 	int retval;
 	struct socket *sock;
 
+	if(!gr_search_socket(family, type, protocol)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (gr_handle_sock_all(family, type, protocol)) {
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
@@ -1001,12 +1026,27 @@ asmlinkage long sys_bind(int fd, struct 
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr * sck;
 	int err;
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
-		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
+		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+			sck = (struct sockaddr *) address;
+
+			if (gr_handle_sock_server(sck)) {
+				sockfd_put(sock);
+				return -EACCES;
+			}
+
+			err = gr_search_bind(sock, (struct sockaddr_in *) sck);
+			if (err) {
+				sockfd_put(sock);
+				return err;
+			}
+
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
+		}
 		sockfd_put(sock);
 	}			
 	return err;
@@ -1029,6 +1069,18 @@ asmlinkage long sys_listen(int fd, int b
 	if ((sock = sockfd_lookup(fd, &err)) != NULL) {
 		if ((unsigned) backlog > sysctl_somaxconn)
 			backlog = sysctl_somaxconn;
+
+		if (gr_handle_sock_server_other(sock)) {
+			sockfd_put(sock);
+			return -EPERM;
+		}
+
+		err = gr_search_listen(sock);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+
 		err=sock->ops->listen(sock, backlog);
 		sockfd_put(sock);
 	}
@@ -1065,6 +1117,15 @@ asmlinkage long sys_accept(int fd, struc
 	newsock->type = sock->type;
 	newsock->ops = sock->ops;
 
+	if (gr_handle_sock_server_other(sock)) {
+		err = -EPERM;
+		goto out_release;
+	}
+
+	err = gr_search_accept(sock);
+	if (err)
+		goto out_release;
+
 	err = sock->ops->accept(sock, newsock, sock->file->f_flags);
 	if (err < 0)
 		goto out_release;
@@ -1084,6 +1145,8 @@ asmlinkage long sys_accept(int fd, struc
 	if ((err = sock_map_fd(newsock)) < 0)
 		goto out_release;
 
+	gr_attach_curr_ip(newsock->sk);
+
 out_put:
 	sockfd_put(sock);
 out:
@@ -1111,6 +1174,7 @@ asmlinkage long sys_connect(int fd, stru
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr * sck;
 	int err;
 
 	sock = sockfd_lookup(fd, &err);
@@ -1119,6 +1183,18 @@ asmlinkage long sys_connect(int fd, stru
 	err = move_addr_to_kernel(uservaddr, addrlen, address);
 	if (err < 0)
 		goto out_put;
+
+	sck = (struct sockaddr *) address;
+
+	err = gr_search_connect(sock, (struct sockaddr_in *) sck);
+	if (err)
+		goto out_put;
+
+	if (gr_handle_sock_client(sck)) {
+		err = -EACCES;
+		goto out_put;
+	}
+
 	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
 				 sock->file->f_flags);
 out_put:
diff -urNp linux-2.4.37.7/net/unix/af_unix.c linux-2.4.37.7/net/unix/af_unix.c
--- linux-2.4.37.7/net/unix/af_unix.c	2009-11-07 11:52:20.000000000 -0500
+++ linux-2.4.37.7/net/unix/af_unix.c	2009-11-10 19:30:27.000000000 -0500
@@ -109,6 +109,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/rtnetlink.h>
+#include <linux/grsecurity.h>
 
 #include <asm/checksum.h>
 
@@ -589,6 +590,11 @@ static unix_socket *unix_find_other(stru
 		if (err)
 			goto put_fail;
 
+		if (!gr_acl_handle_unix(nd.dentry, nd.mnt)) {
+			err = -EACCES;
+			goto put_fail;
+		}
+		
 		err = -ECONNREFUSED;
 		if (!S_ISSOCK(nd.dentry->d_inode->i_mode))
 			goto put_fail;
@@ -612,6 +618,13 @@ static unix_socket *unix_find_other(stru
 		if (u) {
 			struct dentry *dentry;
 			dentry = u->protinfo.af_unix.dentry;
+
+			if (!gr_handle_chroot_unix(u->peercred.pid)) {
+				err = -EPERM;
+				sock_put(u);
+				goto fail;
+			}
+
 			if (dentry)
 				UPDATE_ATIME(dentry->d_inode);
 		} else
@@ -710,9 +723,19 @@ static int unix_bind(struct socket *sock
 		 * All right, let's create it.
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
+	
+		if (!gr_acl_handle_mknod(dentry, nd.dentry, nd.mnt, mode)) {
+			err = -EACCES;
+			goto out_mknod_dput;
+		}	
+
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
+
 		if (err)
 			goto out_mknod_dput;
+
+		gr_handle_create(dentry, nd.mnt);
+
 		up(&nd.dentry->d_inode->i_sem);
 		dput(nd.dentry);
 		nd.dentry = dentry;
@@ -730,6 +753,10 @@ static int unix_bind(struct socket *sock
 			goto out_unlock;
 		}
 
+#ifdef CONFIG_GRKERNSEC_CHROOT_UNIX
+		sk->peercred.pid = current->pid;
+#endif
+
 		list = &unix_socket_table[addr->hash];
 	} else {
 		list = &unix_socket_table[dentry->d_inode->i_ino & (UNIX_HASH_SIZE-1)];
@@ -856,6 +883,9 @@ static int unix_stream_connect(struct so
 	int st;
 	int err;
 	long timeo;
+#ifdef CONFIG_GRKERNSEC
+	struct task_struct *p, **htable;
+#endif
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -982,6 +1012,17 @@ restart:
 	/* Set credentials */
 	sk->peercred = other->peercred;
 
+#ifdef CONFIG_GRKERNSEC
+	read_lock(&tasklist_lock);
+	htable = &pidhash[pid_hashfn(other->peercred.pid)];
+	for (p = *htable; p && p->pid != other->peercred.pid; p = p->pidhash_next);
+	if (p) {
+		p->curr_ip = current->curr_ip;
+		p->used_accept = 1;
+	}
+	read_unlock(&tasklist_lock);
+#endif
+
 	sock_hold(newsk);
 	unix_peer(sk)=newsk;
 	sock->state=SS_CONNECTED;
