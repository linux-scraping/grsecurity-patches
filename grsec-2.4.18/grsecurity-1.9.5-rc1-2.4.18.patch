diff -urN linux/Documentation/Configure.help linux/Documentation/Configure.help
--- linux/Documentation/Configure.help	Mon Feb 25 14:37:51 2002
+++ linux/Documentation/Configure.help	Mon Jun  3 21:18:06 2002
@@ -2404,6 +2404,20 @@
   If you want to compile it as a module, say M here and read
   <file:Documentation/modules.txt>.  If unsure, say `N'.
 
+stealth networking support
+CONFIG_IP_NF_MATCH_STEALTH
+  Enabling this option will drop all syn packets coming to unserved tcp
+  ports as well as all packets coming to unserved udp ports.  If you
+  are using your system to route any type of packets (ie. via NAT)
+  you should put this module at the end of your ruleset, since it will 
+  drop packets that aren't going to ports that are listening on your 
+  machine itself, it doesn't take into account that the packet might be 
+  destined for someone on your internal network if you're using NAT for 
+  instance.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
 MAC address match support
 CONFIG_IP_NF_MATCH_MAC
   MAC matching allows you to match packets based on the source
@@ -19946,6 +19960,742 @@
   - "Area6" if it is connected to Area 6 (0x18000000)
 
   "Area6" will work for most boards. For ADX, select "Area5".
+
+Grsecurity
+CONFIG_GRKERNSEC
+  If you say Y here, you will be able to configure many features that
+  will enhance the security of your system.  It is highly recommended
+  that you say Y here and read through the help for each option so
+  you fully understand the features and can evaluate their usefulness
+  for your machine.
+
+Additional security levels
+CONFIG_GRKERNSEC_LOW
+
+  Low additional security
+  -----------------------------------------------------------------------
+  If you choose this option, several of the grsecurity options will
+  be enabled that will give you greater protection against a number
+  of attacks, while assuring that none of your software will have any 
+  conflicts with the additional security measures.  If you run a lot of 
+  unusual software, or you are having problems with the higher security 
+  levels, you should say Y here.  With this option, the following features
+  are enabled:
+  
+  linking restrictions
+  fifo restrictions
+  secure fds
+  random pids
+  enforcing nproc on execve()
+  restricted dmesg
+  random ip ids
+  enforced chdir("/") on chroot
+  secure keymap loading
+
+  Medium additional security
+  -----------------------------------------------------------------------
+  If you say Y here, several features in addition to those included in the 
+  low additional security level will be enabled.  These features provide
+  even more security to your system, though in rare cases they may
+  be incompatible with very old or poorly written software.  If you 
+  enable this option, make sure that your auth service (identd) is 
+  running as gid 10 (usually group wheel). With this option the following 
+  features (in addition to those provided in the low additional security 
+  level) will be enabled:
+
+  random tcp source ports
+  altered ping ids
+  failed fork logging
+  time change logging
+  signal logging
+  deny mounts in chroot
+  deny double chrooting
+  deny mknod in chroot
+  /proc restrictions with special gid set to 10 (usually wheel)
+  pax's random mmap
+
+  High additional security
+  ----------------------------------------------------------------------
+  If you say Y here, many of the features of grsecurity will be enabled,
+  that will protect you against virtually all kinds of attacks against
+  your system.  The much hightened security comes at a cost of an 
+  increased chance of incompatabilities with rare software on your 
+  machine.  It is highly recommended that you view 
+  <http://grsecurity.net/features.htm> and read about each option.  Since 
+  this security level enabled PaX, you should also view 
+  <http://pageexec.virtualave.net> and read about the PaX project.  While 
+  you are there, download chpax.c and run chpax -p on binaries that cause 
+  problems with PaX.  Also remember that since the /proc restrictions are 
+  enabled, you must run your identd as group wheel (gid 10).  The 
+  grsecurity ACL system is also enabled in this level.  To learn how to 
+  correctly configure it, view the ACL documentation on 
+  <http://grsecurity.net>.  This security level enables the following 
+  features in addition to those listed in the low and medium security 
+  levels:
+
+  grsecurity ACL system
+  additional /proc restrictions
+  signal restrictions in chroot
+  chmod restrictions in chroot
+  no ptrace in chroot
+  priority restrictions in chroot
+  PaX - random mmap, noexec on all memory pages, restricted mprotect
+  fixed mmap restrictions
+  mount/unmount/remount logging
+  restricted ptrace (only root and users in group wheel (gid 10) are 
+  allowed to ptrace)
+
+Customized additional security
+CONFIG_GRKERNSEC_CUSTOM
+  If you say Y here, you will be able to configure every grsecurity 
+  option, which allows you to enable many more features that aren't 
+  covered in the basic security levels.  These additional features include 
+  TPE, socket restrictions, and the sysctl system for grsecurity.  It is 
+  advised that you read through the help for each option to determine its 
+  usefulness in your situation.
+
+Openwall Non-executable Stack
+CONFIG_GRKERNSEC_STACK
+  If you say Y here, your system will not allow execution of
+  code on the stack, making buffer overflow exploitation more difficult.
+  The code for this protection is taken from the Openwall patch for
+  linux 2.2 by Solar Designer. You can view his projects at 
+  <http://www.openwall.com/linux>.
+  Exploits against your machine with this protection will have to dabble 
+  in more obscure methods of exploitation(bss,got,heap..)
+
+Gcc trampoline support
+CONFIG_GRKERNSEC_STACK_GCC
+  If you say Y here, the system will support trampoline code along
+  with the stack protection.  If you do not have any programs on
+  your system that require this (glibc 2.0 users must say YES to
+  this option) you may say no here.
+
+PaX protection
+CONFIG_GRKERNSEC_PAX 
+  By design the IA-32 architecture does not allow for protecting
+  memory pages against execution, i.e. if a page is readable (such
+  as the stack or heap) it is also executable.  There is a well
+  known exploit technique that makes use of this fact and a common
+  programming mistake where an attacker can introduce executable
+  code of his choice somewhere in the attacked program's memory
+  (typically the stack or the heap) and then execute it.  If the
+  attacked program was running with different (typically higher)
+  privileges than that of the attacker, then he can elevate his
+  own privilege level (e.g. get a root shell, write to files for
+  which he does not have write access to, etc).
+
+  Since the implementation is software based, it comes with a
+  performance impact, you should evaluate your system carefully
+  before deciding to use this feature on production systems.
+
+  Enabling this feature will enforce the non-executable flag on
+  memory pages thereby making it harder to execute 'foreign' code
+  in a program.  This will also break programs that rely on the
+  old behaviour and expect that dynamically allocated memory via
+  the malloc() family of functions is executable (which it is not).
+  Notable examples are the XFree86 4.x server, the java runtime
+  and wine.
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis.  chpax is available at
+  <http://pageexec.virtualave.net>
+
+Emulate trampolines
+CONFIG_GRKERNSEC_PAX_EMUTRAMP
+  There are some programs and libraries that for one reason or
+  another attempt to execute special small code snippets from
+  non-executable memory pages.  Most notable examples are the
+  signal handler return code generated by the kernel itself and
+  the GCC trampolines.
+
+  If you enabled CONFIG_GRKERNSEC_PAX then such programs will no
+  longer work under your kernel.  As a remedy you can say Y here
+  and use the 'chpax' utility to enable trampoline emulation for
+  the affected programs yet still have the protection provided by
+  CONFIG_GRKERNSEC_PAX.  Alternatively you can say N here and use
+  the 'chpax' utility to disable CONFIG_GRKERNSEC_PAX for the
+  affected files.  chpax is available at 
+  <http://pageexec.virtualave.net>
+
+  NOTE: enabling this feature *may* open up a loophole in the
+  protection provided by CONFIG_GRKERNSEC_PAX that an attacker
+  could abuse.  Therefore the best solution is to not have any
+  files on your system that would require this option.  This can
+  be achieved by not using libc5 (which relies on the kernel
+  signal handler return code) and not using or rewriting programs
+  that make use of the nested function implementation of GCC.
+  Skilled users can just fix GCC itself so that it implements
+  nested function calls in a way that does not interfere with PaX.
+
+Restrict mprotect()
+CONFIG_GRKERNSEC_PAX_MPROTECT
+  Enabling this option will prevent programs from
+   - changing the executable status of memory pages that were
+     not originally created as executable,
+   - making read-only executable pages writable again,
+   - creating executable pages from anonymous memory.
+
+  You should say Y here to complete the protection provided by
+  the enforcement of the PAGE_EXEC flag (CONFIG_GRKERNSEC_PAX).
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis. chpax is available at
+  <http://pageexec.virtualave.net>
+
+Randomize mmap() base
+CONFIG_GRKERNSEC_PAX_RANDMMAP
+  By saying Y here the kernel will somewhat randomize the address
+  space layout of programs at each execution (the top of the stack, the
+  base address for mmap() requests that do not specify one themselves
+  and the base address of dynamic ELF executables).
+
+  As a result all dynamically loaded libraries will appear at random
+  addresses and therefore be harder to exploit by a technique where
+  an attacker attempts to execute library code for his purposes
+  (e.g. spawn a shell from an exploited program that is running at
+  an elevated privilege level).
+
+  Furthermore, if a program is relinked as a dynamic ELF file, its
+  base address layout will be randomized as well, completing the full
+  randomization of the address space.  Attacking such programs becomes
+  a guess game.
+
+  It is strongly recommended to say Y here even if CONFIG_GRKERNSEC_PAX
+  is not enabled as address space layout randomization has negligible 
+  impact on performance yet it provides a very effective protection.
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis.  chpax is available at
+  <http://pageexec.virtualave.net>
+
+Deny ioctl writes to /dev/kmem
+CONFIG_GRKERNSEC_KMEM
+  If you say Y here, root will not be able to modify the contents of
+  kernel memory via ioctl.  There are still many other methods of 
+  inserting code into the kernel that removing module support and writing 
+  to /dev/kmem will not stop.  If you want to further restrict the actions 
+  of root, it is recommended that you use grsecurity's ACL system.  This 
+  option is not known to cause any software incompatibilities, therefore 
+  it is recommended that you say Y here.
+
+Proc Restrictions
+CONFIG_GRKERNSEC_PROC
+  If you say Y here, the permissions of the /proc filesystem
+  will be altered to enhance system security and privacy.  Depending
+  upon the options you choose, you can either restrict users to see
+  only the processes they themselves run, or choose a group that can
+  view all processes and files normally restricted to root if you choose
+  the "restrict to user only" option.  NOTE: If you're running identd as 
+  a non-root user, you will have to run it as the group you specify here.
+
+Restrict /proc to user only
+CONFIG_GRKERNSEC_PROC_USER
+  If you say Y here, non-root users will only be able to view their own 
+  processes, and restricts them from viewing network-related information,  
+  and viewing kernel symbol and module information.
+
+Restrict /proc to user and group
+CONFIG_GRKERNSEC_PROC_USERGROUP
+  If you say Y here, you will be able to select a group that will be
+  able to view all processes, network-related information, and
+  kernel and symbol information.  This option is useful if you want
+  to run identd as a non-root user.
+
+Additional proc restrictions
+CONFIG_GRKERNSEC_PROC_ADD
+  If you say Y here, additional restrictions will be placed on
+  /proc that keep normal users from viewing cpu and device information.
+
+Dmesg(8) Restriction
+CONFIG_GRKERNSEC_DMESG
+  If you say Y here, non-root users will not be able to use dmesg(8)
+  to view up to the last 4kb of messages in the kernel's log buffer.
+  If the sysctl option is enabled, a sysctl option with name "dmesg" is 
+  created.
+
+Linking restrictions
+CONFIG_GRKERNSEC_LINK
+  If you say Y here, /tmp race exploits will be prevented, since users
+  will no longer be able to follow symlinks owned by other users in 
+  world-writeable +t directories (i.e. /tmp), unless the owner of the 
+  symlink is the owner of the directory. users will also not be
+  able to hardlink to files they do not own.  If the sysctl option is
+  enabled, a sysctl option with name "linking_restrictions" is created.
+
+FIFO restrictions
+CONFIG_GRKERNSEC_FIFO
+  If you say Y here, users will not be able to write to FIFOs they don't
+  own in world-writeable +t directories (i.e. /tmp), unless the owner of
+  the FIFO is the same owner of the directory it's held in.  If the sysctl
+  option is enabled, a sysctl option with name "fifo_restrictions" is 
+  created.
+
+Secure file descriptors
+CONFIG_GRKERNSEC_FD
+  If you say Y here, binaries will be protected from data spoofing
+  attacks (eg. making a program read /etc/shadow).  The patches do this
+  by opening up /dev/null to any of the stdin, stdout, stderr file descriptors
+  for binaries that are open.  If the sysctl option is enabled, a sysctl 
+  option with name "secure_fds" is created.
+
+  NOTE: as of glibc 2.1, this option is no longer needed in the kernel.
+  Most users can therefore say N here.  Anyone still using glibc < 2.1 or 
+  libc5 should say Y here.
+
+Exec process limiting
+CONFIG_GRKERNSEC_EXECVE
+  If you say Y here, users with a resource limit on processes will
+  have the value checked during execve() calls.  The current system
+  only checks the system limit during fork() calls.  If the sysctl option
+  is enabled, a sysctl option with name "execve_limiting" is created.
+
+Single group for auditing
+CONFIG_GRKERNSEC_AUDIT_GROUP
+  If you say Y here, the exec, chdir, (un)mount, and ipc logging features
+  will only operate on a group you specify.  This option is recommended
+  if you only want to watch certain users instead of having a large
+  amount of logs from the entire system.  If the sysctl option is enabled,
+  a sysctl option with name "audit_group" is created.
+
+GID for auditing
+CONFIG_GRKERNSEC_AUDIT_GID
+  Here you can choose the GID that will be the target of kernel auditing.
+  Remember to add the users you want to log to the GID specified here.
+  If the sysctl option is enabled, whatever you choose here won't matter. 
+  You'll have to specify the GID in your bootup script by echoing the GID 
+  to the proper /proc entry.  View the help on the sysctl option for more 
+  information.  If the sysctl option is enabled, a sysctl option with name 
+  "audit_gid" is created.
+
+Chdir logging
+CONFIG_GRKERNSEC_AUDIT_CHDIR
+  If you say Y here, all chdir() calls will be logged.  If the sysctl 
+  option is enabled, a sysctl option with name "audit_chdir" is created.
+
+(Un)Mount logging
+CONFIG_GRKERNSEC_AUDIT_MOUNT
+  If you say Y here, all mounts and unmounts will be logged.  If the 
+  sysctl option is enabled, a sysctl option with name "audit_mount" is 
+  created.
+
+IPC logging
+CONFIG_GRKERNSEC_AUDIT_IPC
+  If you say Y here, creation and removal of message queues, semaphores,
+  and shared memory will be logged.  If the sysctl option is enabled, a
+  sysctl option with name "audit_ipc" is created.
+
+Exec logging
+CONFIG_GRKERNSEC_EXECLOG
+  If you say Y here, all execve() calls will be logged (since the
+  other exec*() calls are frontends to execve(), all execution
+  will be logged).  Useful for shell-servers that like to keep track
+  of their users.  If the sysctl option is enabled, a sysctl option with
+  name "exec_logging" is created.
+  WARNING: This option when enabled will produce a LOT of logs, especially
+  on an active system.
+
+Set*id logging
+CONFIG_GRKERNSEC_SUID
+  If you say Y here, all set*id() calls will be logged.  Such information
+  could be useful when detecting a possible intrusion attempt.  This 
+  option can produce a lot of logs on an active system.  If the sysctl
+  option is enabled, a sysctl option with name "suid_logging" is created.
+
+Log set*ids to root
+CONFIG_GRKERNSEC_SUID_ROOT
+  If you say Y here, only set*id() calls where a user is changing to the
+  gid or uid of the root user will be logged.  Such information
+  could be useful when detecting a possible intrusion attempt.  This
+  option will produce less logs than logging all calls.  If the sysctl
+  option is enabled, a sysctl option with name "suid_root_logging" is
+  created.
+
+Signal logging
+CONFIG_GRKERNSEC_SIGNAL
+  If you say Y here, certain important signals will be logged, such as
+  SIGSEGV, which will as a result inform you of when a error in a program
+  occurred, which in some cases could mean a possible exploit attempt.
+  If the sysctl option is enabled, a sysctl option with name 
+  "signal_logging" is created.
+
+Fork failure logging
+CONFIG_GRKERNSEC_FORKFAIL
+  If you say Y here, all failed fork() attempts will be logged.
+  This could suggest a fork bomb, or someone attempting to overstep
+  their process limit.  If the sysctl option is enabled, a sysctl option
+  with name "forkfail_logging" is created.
+
+Time change logging
+CONFIG_GRKERNSEC_TIME
+  If you say Y here, any changes of the system clock will be logged.
+  If the sysctl option is enabled, a sysctl option with name 
+  "timechange_logging" is created.
+
+Secure keymap loading
+CONFIG_GRKERNSEC_KBMAP
+  If you say Y here, KDSKBENT and KDSKBSENT ioctl calls being
+  called by unprivileged users will be denied. If you answer N,
+  everyone with access to the console will be able to modify keyboard 
+  bindings.  If the sysctl option is enabled, a sysctl option with name
+  "secure_kbmap" is created.
+
+Chroot jail restrictions
+CONFIG_GRKERNSEC_CHROOT
+  If you say Y here, you will be able to choose several options that will
+  make breaking out of a chrooted jail much more difficult.  If you
+  encounter no software incompatibilities with the following options, it
+  is recommended that you enable each one.
+
+Restricted signals in chroot
+CONFIG_GRKERNSEC_CHROOT_SIG
+  If you say Y here, processes inside a chroot will not be able to send
+  signals outside of the chroot.  The only signals allowed are null 
+  signals which perform no action, and the parent process sending 
+  a certain signal to its child.  If the sysctl option is enabled, a
+  sysctl option with name "chroot_restrict_sigs" is created.
+
+Deny mounts in chroot
+CONFIG_GRKERNSEC_CHROOT_MOUNT
+  If you say Y here, processes inside a chroot will not be able to
+  mount or remount filesystems.  If the sysctl option is enabled, a 
+  sysctl option with name "chroot_deny_mount" is created.
+
+Deny pivot_root in chroot
+CONFIG_GRKERNSEC_CHROOT_PIVOT
+  If you say Y here, processes inside a chroot will not be able to use
+  a function called pivot_root() that was introduced in Linux 2.3.41.  It 
+  works similar to chroot in that it changes the root filesystem.  This 
+  function could be misused in a chrooted process to attempt to break out 
+  of the chroot, and therefore should not be allowed.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_pivot" is 
+  created.
+
+Deny double-chroots
+CONFIG_GRKERNSEC_CHROOT_DOUBLE
+  If you say Y here, processes inside a chroot will not be able to chroot
+  again.  This is a widely used method of breaking out of a chroot jail
+  and should not be allowed.  If the sysctl option is enabled, a sysctl
+  option with name "chroot_deny_chroot" is created.
+
+Deny fchdir outside of chroot
+CONFIG_GRKERNSEC_CHROOT_FCHDIR
+  If you say Y here, a well-known method of breaking chroots by fchdir'ing 
+  to a file descriptor of the chrooting process that points to the 
+  outside filesystem will be stopped.  If the sysctl option is enabled,
+  a sysctl option with name "chroot_deny_fchdir" is created.
+
+Enforce chdir("/") on all chroots
+CONFIG_GRKERNSEC_CHROOT_CHDIR
+  If you say Y here, the current working directory of all newly-chrooted
+  applications will be set to the the root directory of the chroot.
+  The man page on chroot(2) states:
+  Note that this call does not change  the  current  working
+  directory,  so  that `.' can be outside the tree rooted at
+  `/'.  In particular, the  super-user  can  escape  from  a
+  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.  
+
+  It is recommended that you say Y here, since it's not known to break
+  any software.  If the sysctl option is enabled, a sysctl option with
+  name "chroot_enforce_chdir" is created.
+
+Deny (f)chmod +s in chroot
+CONFIG_GRKERNSEC_CHROOT_CHMOD
+  If you say Y here, processes inside a chroot will not be able to chmod
+  or fchmod files to make them have suid or sgid bits.  This protects 
+  against another published method of breaking a chroot.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+  created.
+
+Deny mknod in chroot
+CONFIG_GRKERNSEC_CHROOT_MKNOD
+  If you say Y here, processes inside a chroot will not be allowed to
+  mknod.  The problem with using mknod inside a chroot is that it
+  would allow an attacker to create a device entry that is the same
+  as one on the physical root of your system, which could range from
+  anyhing from the console device to a device for your harddrive (which
+  they could then use to wipe the drive or steal data).  It is recommended
+  that you say Y here, unless you run into software incompatibilities.
+  If the sysctl option is enabled, a sysctl option with name
+  "chroot_deny_mknod" is created.
+
+Deny ptraces in chroot
+CONFIG_GRKERNSEC_CHROOT_PTRACE
+  If you say Y here, processes inside a chroot will not be able to ptrace
+  other processes.  Ptracing a process allows one to attach and alter the
+  flow of execution for the process.  It is strongly recommended that you
+  say Y here.  If the sysctl option is enabled, a sysctl option with name
+  "chroot_deny_ptrace" is created.
+
+Restrict priority changes in chroot
+CONFIG_GRKERNSEC_CHROOT_NICE
+  If you say Y here, processes inside a chroot will not be able to raise
+  the priority of processes in the chroot, or alter the priority of 
+  processes outside the chroot.  This provides more security than simply
+  removing CAP_SYS_NICE from the process' capability set.  If the
+  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+  is created.
+
+Log all execs within chroot
+CONFIG_GRKERNSEC_CHROOT_EXECLOG
+  If you say Y here, all executions inside a chroot jail will be logged 
+  to syslog.  If the sysctl option is enabled, a sysctl option with name
+  "chroot_execlog" is created.
+
+Chroot jail capability restrictions
+CONFIG_GRKERNSEC_CHROOT_CAPS
+  If you say Y here, the capabilities on all root processes within a
+  chroot jail will be lowered to stop module insertion, raw i/o,
+  system and net admin tasks, rebooting the system, modifying immutable 
+  files, and changing the system time.  This is left an option because it 
+  can break some apps.  Disable this if your chrooted apps are having
+  problems performing those kinds of tasks.  If the sysctl option is 
+  enabled, a sysctl option with name "chroot_caps" is created.
+
+Trusted path execution
+CONFIG_GRKERNSEC_TPE
+  If you say Y here, you will be able to choose a gid to add to the
+  supplementary groups of users you want to mark as "untrusted."
+  These users will not be able to execute any files that are not in
+  root-owned directories writeable only by root.  If the sysctl option
+  is enabled, a sysctl option with name "tpe" is created.
+
+Group for trusted path execution
+CONFIG_GRKERNSEC_TPE_GID
+  Here you can choose the GID to enable trusted path protection for.
+  Remember to add the users you want protection enabled for to the GID 
+  specified here.  If the sysctl option is enabled, whatever you choose
+  here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "tpe_gid" is created.
+
+Partially restrict non-root users
+CONFIG_GRKERNSEC_TPE_ALL
+  If you say Y here, All non-root users other than the ones in the 
+  group specified in the main TPE option will only be allowed to
+  execute files in directories they own that are not group or
+  world-writeable, or in directories owned by root and writeable only by
+  root.  If the sysctl option is enabled, a sysctl option with name 
+  "tpe_restrict_all" is created.
+
+Trusted path execution glibc protection
+CONFIG_GRKERNSEC_TPE_GLIBC
+  If you say Y here, all non-root users executing any files while 
+  glibc specific environment variables such as LD_PRELOAD are set, 
+  will have their environment cleared of these variables, since they 
+  could be used to evade the trusted path execution protection.  It also 
+  protects against evasion through executing the dynamic linker to run a 
+  rogue binary.  It is recommended you say Y here also. If the sysctl 
+  option is enabled, a sysctl option with name "tpe_glibc" is created.
+
+Ptrace logging
+CONFIG_GRKERNSEC_AUDIT_PTRACE
+  If you say Y here, all successful ptraces will be logged.  Ptraces are 
+  special operations performed when programs like strace or gdb are run.  
+  They have also been the focus of some kernel vulnerabilities.  If the 
+  sysctl option is enabled, a sysctl option with name "audit_ptrace" is 
+  created.
+
+Restricted ptrace
+CONFIG_GRKERNSEC_PTRACE
+  If you say Y here, no one but root will be able to ptrace processes.
+  Tracing syscalls inside the kernel will also be disabled.  If the 
+  sysctl option is enabled, a sysctl option with name "restrict_ptrace" 
+  is created.
+
+Allow ptrace for group
+CONFIG_GRKERNSEC_PTRACE_GROUP
+  If you say Y here, you will be able to choose a GID of whose users
+  will be able to ptrace.  If the sysctl option is enabled, a sysctl 
+  option with name "allow_ptrace_group" is created.
+
+GID for ptrace
+CONFIG_GRKERNSEC_PTRACE_GID
+  Here you can choose the GID of whose users will be able to ptrace.
+  Remember to add the users you want ptrace enabled for to the GID
+  specified here.  If the sysctl option is enabled, whatever you choose
+  here won't matter. You'll have to specify the GID in your bootup
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "ptrace_gid" is created.
+
+Randomized PIDs
+CONFIG_GRKERNSEC_RANDPID
+  If you say Y here, all PIDs created on the system will be
+  pseudo-randomly generated.  This is extremely effective along
+  with the /proc restrictions to disallow an attacker from guessing
+  pids of daemons, etc.  PIDs are also used in some cases as part
+  of a naming system for temporary files, so this option would keep
+  those filenames from being predicted as well.  We also use code
+  to make sure that PID numbers aren't reused too soon.  If the sysctl
+  option is enabled, a sysctl option with name "rand_pids" is created.
+
+Randomized IP IDs
+CONFIG_GRKERNSEC_RANDID
+  If you say Y here, all the id field on all outgoing packets
+  will be randomized.  This hinders os fingerprinters and
+  keeps your machine from being used as a bounce for an untraceable
+  portscan.  Ids are used for fragmented packets, fragments belonging
+  to the same packet have the same id.  By default linux only
+  increments the id value on each packet sent to an individual host.
+  We use a port of the OpenBSD random ip id code to achieve the
+  randomness, while keeping the possibility of id duplicates to
+  near none.  If the sysctl option is enabled, a sysctl option with name
+  "rand_ip_ids" is created.
+
+Randomized TCP source ports
+CONFIG_GRKERNSEC_RANDSRC
+  If you say Y here, situations where a source port is generated on the
+  fly for the TCP protocol (ie. with connect() ) will be altered so that
+  the source port is generated at random, instead of a simple incrementing
+  algorithm.  If the sysctl option is enabled, a sysctl option with name
+  "rand_tcp_src_ports" is created.
+
+Randomized RPC XIDs
+CONFIG_GRKERNSEC_RANDRPC
+  If you say Y here, the method of determining XIDs for RPC requests will
+  be randomized, instead of using linux's default behavior of simply
+  incrementing the XID.  If you want your RPC connections to be more
+  secure, say Y here.  If the sysctl option is enabled, a sysctl option 
+  with name "rand_rpc" is created.
+
+Altered Ping IDs
+CONFIG_GRKERNSEC_RANDPING
+  If you say Y here, the way Linux handles echo replies will be changed
+  so that the reply uses an ID equal to the ID of the echo request.
+  This will help in confusing OS detection.  If the sysctl option is
+  enabled, a sysctl option with name "altered_pings" is created.
+
+Socket restrictions
+CONFIG_GRKERNSEC_SOCKET
+  If you say Y here, you will be able to choose from several options.
+  If you assign a GID on your system and add it to the supplementary
+  groups of users you want to restrict socket access to, this patch
+  will perform up to three things, based on the option(s) you choose.
+
+Deny all socket access
+CONFIG_GRKERNSEC_SOCKET_ALL
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine or run server
+  applications from your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_all" is created.
+
+Group for disabled socket access
+CONFIG_GRKERNSEC_SOCKET_ALL_GID
+  Here you can choose the GID to disable socket access for. Remember to 
+  add the users you want socket access disabled for to the GID 
+  specified here.  If the sysctl option is enabled, whatever you choose
+  here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_all_gid" is created.
+
+Deny all client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine, but will be
+  able to run servers.  If this option is enabled, all users in the group
+  you specify will have to use passive mode when initiating ftp transfers
+  from the shell on your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_client" is created.
+
+Group for disabled client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT_GID
+  Here you can choose the GID to disable client socket access for. 
+  Remember to add the users you want client socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, whatever you 
+  choose here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_client_gid" is created.
+
+Deny all server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to run server applications from your machine.  If the sysctl 
+  option is enabled, a sysctl option with name "socket_server" is created.
+
+Group for disabled server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER_GID
+  Here you can choose the GID to disable server socket access for. 
+  Remember to add the users you want server socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, whatever you 
+  choose here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_server_gid" is created.
+
+Sysctl support
+CONFIG_GRKERNSEC_SYSCTL
+  If you say Y here, you will be able to change the options that
+  grsecurity runs with at bootup, without having to recompile your
+  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+  to enable (1) or disable (0) various features.  All the sysctl entries
+  are mutable until the "grsec_lock" entry is set to a non-zero value.
+  All features are disabled by default. Please note that this option could 
+  reduce the effectiveness of the added security of this patch if an ACL 
+  system is not put in place.  Your init scripts should be read-only, and 
+  root should not have access to adding modules or performing raw i/o 
+  operations.  All options should be set at startup, and the grsec_lock 
+  entry should be set to a non-zero value after all the options are set.  
+  *THIS IS EXTREMELY IMPORTANT*
+
+Grsecurity ACL System
+CONFIG_GRKERNSEC_ACL
+  If you say Y here, you enable the Access Control List system for 
+  grsecurity. Unlike many other popular ACL systems, it allows both 
+  process and file ACLs. To use the ACL system, you must also download the 
+  userspace code and documentation off the grsecurity website: 
+  <http://grsecurity.net>  You will then need to run gradm setup to set 
+  your password and create your config files.
+  
+Denied capability logging
+CONFIG_GRKERNSEC_ACL_CAPLOG
+  If you say Y here, logs will be produced when a root-owned process does 
+  not have a needed capability raised in his set.  This information is 
+  useful when creating ACLs for your system.
+
+Number of burst messages
+CONFIG_GRKERNSEC_FLOODBURST
+  This option allows you to choose the maximum number of messages allowed
+  within the flood time interval you chose in a separate option.  The 
+  default should be suitable for most people, however if you find that 
+  many of your logs are being interpreted as flooding, you may want to 
+  raise this value.
+
+Seconds in between log messages
+CONFIG_GRKERNSEC_FLOODTIME
+  This option allows you to enforce the number of seconds between
+  grsecurity log messages.  The default should be suitable for most 
+  people, however, if you choose to change it, choose a value small enough
+  to allow informative logs to be produced, but large enough to
+  prevent flooding.
+
+ACL Debugging Messages
+CONFIG_GR_DEBUG
+  This option allows the grsecurity ACL system to print debugging messages 
+  as an aid to finding problems in your ACL sets.
+
+Extra ACL Debugging Messages
+CONFIG_GR_SUPERDEBUG
+  This option allows you to enable additional debugging messages that can 
+  also help you in finding problems in your ACL sets or to gain a better 
+  understanding of the internal workings of the ACL system.
+
+Maximum tries before password lockout
+CONFIG_GR_MAXTRIES
+  This option enforces the maximum number of times a user can attempt
+  to authorize themselves with the grsecurity ACL system before being
+  denied the ability to attempt authorization again for a specified time.  
+  The lower the number, the harder it will be to brute-force a password.
+
+Time to wait after max password tries, in seconds
+CONFIG_GR_TIMEOUT
+  This option specifies the time the user must wait after attempting to 
+  authorize to the ACL system with the maximum number of invalid 
+  passwords.  The higher the number, the harder it will be to brute-force 
+  a password.
 
 #
 # m68k-specific kernel options
diff -urN linux/Makefile linux/Makefile
--- linux/Makefile	Mon Feb 25 14:37:52 2002
+++ linux/Makefile	Mon Jun  3 21:18:06 2002
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 18
-EXTRAVERSION =
+EXTRAVERSION = -grsec
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -120,9 +120,10 @@
 
 CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
 NETWORKS	=net/network.o
+GRSECURITY	=grsecurity/grsec.o
 
 LIBS		=$(TOPDIR)/lib/lib.a
-SUBDIRS		=kernel drivers mm fs net ipc lib
+SUBDIRS		=kernel drivers mm fs net ipc lib grsecurity
 
 DRIVERS-n :=
 DRIVERS-y :=
@@ -245,7 +246,7 @@
 
 export	CPPFLAGS CFLAGS CFLAGS_KERNEL AFLAGS AFLAGS_KERNEL
 
-export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS
+export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS GRSECURITY
 
 .S.s:
 	$(CPP) $(AFLAGS) $(AFLAGS_KERNEL) -traditional -o $*.s $<
@@ -264,6 +265,7 @@
 		$(CORE_FILES) \
 		$(DRIVERS) \
 		$(NETWORKS) \
+		$(GRSECURITY) \
 		$(LIBS) \
 		--end-group \
 		-o vmlinux
diff -urN linux/arch/alpha/config.in linux/arch/alpha/config.in
--- linux/arch/alpha/config.in	Tue Nov 20 18:49:31 2001
+++ linux/arch/alpha/config.in	Mon Jun  3 21:18:06 2002
@@ -393,3 +393,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/arm/config.in linux/arch/arm/config.in
--- linux/arch/arm/config.in	Fri Nov  9 16:58:02 2001
+++ linux/arch/arm/config.in	Mon Jun  3 21:18:06 2002
@@ -606,3 +606,12 @@
 dep_bool '  Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
 dep_bool '  kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/cris/config.in linux/arch/cris/config.in
--- linux/arch/cris/config.in	Mon Feb 25 14:37:52 2002
+++ linux/arch/cris/config.in	Mon Jun  3 21:18:06 2002
@@ -254,3 +254,12 @@
   int ' Profile shift count' CONFIG_PROFILE_SHIFT 2
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/i386/config.in linux/arch/i386/config.in
--- linux/arch/i386/config.in	Mon Feb 25 14:37:52 2002
+++ linux/arch/i386/config.in	Mon Jun  3 21:18:06 2002
@@ -425,3 +425,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux/arch/i386/kernel/entry.S	Mon Feb 25 14:37:53 2002
+++ linux/arch/i386/kernel/entry.S	Mon Jun  3 21:18:06 2002
@@ -45,6 +45,7 @@
 #include <linux/linkage.h>
 #include <asm/segment.h>
 #include <asm/smp.h>
+#include <asm/page.h>
 
 EBX		= 0x00
 ECX		= 0x04
@@ -381,8 +382,52 @@
 	jmp error_code
 
 ENTRY(page_fault)
+#ifdef CONFIG_GRKERNSEC_PAX
+	ALIGN
+	pushl $ SYMBOL_NAME(pax_do_page_fault)
+	pushl %ds
+	pushl %eax
+	xorl %eax,%eax
+	pushl %ebp
+	pushl %edi
+	pushl %esi
+	pushl %edx
+	decl %eax			# eax = -1
+	pushl %ecx
+	pushl %ebx
+	cld
+	movl %es,%ecx
+	movl ORIG_EAX(%esp), %esi	# get the error code
+	movl ES(%esp), %edi		# get the function address
+	movl %eax, ORIG_EAX(%esp)
+	movl %ecx, ES(%esp)
+	movl %esp,%edx
+	pushl %esi			# push the error code
+	pushl %edx			# push the pt_regs pointer
+	movl $(__KERNEL_DS),%edx
+	movl %edx,%ds
+	movl %edx,%es
+	GET_CURRENT(%ebx)
+	call *%edi
+	addl $8,%esp
+	decl %eax
+	jnz ret_from_exception
+
+	popl %ebx
+	popl %ecx
+	popl %edx
+	popl %esi
+	popl %edi
+	popl %ebp
+	popl %eax
+	popl %ds
+	popl %es
+	addl $4,%esp
+	jmp system_call
+#else
 	pushl $ SYMBOL_NAME(do_page_fault)
 	jmp error_code
+#endif
 
 ENTRY(machine_check)
 	pushl $0
diff -urN linux/arch/i386/kernel/head.S linux/arch/i386/kernel/head.S
--- linux/arch/i386/kernel/head.S	Mon Feb 25 14:37:53 2002
+++ linux/arch/i386/kernel/head.S	Mon Jun  3 21:18:06 2002
@@ -433,7 +433,11 @@
 	.quad 0x0000000000000000	/* not used */
 	.quad 0x00cf9a000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
 	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+#ifdef CONFIG_GRKERNSEC_STACK
+        .quad 0x00cbfa000000f7ff        /* 0x23 user   3GB-8MB code at 0 */
+#else
 	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
+#endif
 	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
 	.quad 0x0000000000000000	/* not used */
 	.quad 0x0000000000000000	/* not used */
diff -urN linux/arch/i386/kernel/ptrace.c linux/arch/i386/kernel/ptrace.c
--- linux/arch/i386/kernel/ptrace.c	Wed Nov 21 13:42:41 2001
+++ linux/arch/i386/kernel/ptrace.c	Mon Jun  3 21:18:06 2002
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -177,6 +178,28 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if(grsec_enable_ptrace && current->uid && ((grsec_enable_ptrace_group && 
+	   !in_group_p(grsec_ptrace_gid)) || !grsec_enable_ptrace_group)) {
+		security_alert("denied ptrace of (%.16s:%d) by " DEFAULTSECMSG,
+				"denied ptraces", child->comm, child->pid, DEFAULTSECARGS);
+		goto out_tsk;
+	}
+
+	if((grsec_enable_audit_ptrace && grsec_enable_group && 
+	   in_group_p(grsec_audit_gid)) || (grsec_enable_audit_ptrace && !grsec_enable_group)) {
+		printk(KERN_INFO "grsec: ptrace of (%.16s:%d) by " DEFAULTSECMSG "\n",
+			child->comm, child->pid, DEFAULTSECARGS);
+	}
+
+	if(grsec_enable_chroot_ptrace && proc_is_chrooted(current) &&
+	   have_same_root(current,child)) {
+		security_alert("denied ptrace of process(%.16s:%d) within chroot jail "
+                               "(%.32s:%lu) by " DEFAULTSECMSG, "ptrace from chroot",
+                               child->comm,child->pid,kdevname(current->fs->root->d_inode->i_dev),
+                               current->fs->root->d_inode->i_ino, DEFAULTSECARGS);
+		goto out_tsk;
+	}
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
@@ -439,11 +462,23 @@
 	return ret;
 }
 
+#ifdef CONFIG_GRKERNSEC_PTRACE
+asmlinkage void syscall_trace(int unused)
+#else
 asmlinkage void syscall_trace(void)
+#endif
 {
+#ifdef CONFIG_GRKERNSEC_PTRACE
+	struct pt_regs *regs = (struct pt_regs *) &unused;
+#endif
+
 	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) !=
 			(PT_PTRACED|PT_TRACESYS))
 		return;
+#ifdef CONFIG_GRKERNSEC_PTRACE
+	if(!user_mode(regs))
+		return;
+#endif
 	/* the 0x80 provides a way for the tracing parent to distinguish
 	   between a syscall stop and SIGTRAP delivery */
 	current->exit_code = SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
diff -urN linux/arch/i386/kernel/signal.c linux/arch/i386/kernel/signal.c
--- linux/arch/i386/kernel/signal.c	Mon Feb 25 14:37:53 2002
+++ linux/arch/i386/kernel/signal.c	Mon Jun  3 21:18:06 2002
@@ -7,6 +7,7 @@
  *  2000-06-20  Pentium III FXSR, SSE support by Gareth Hughes
  */
 
+#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -421,11 +422,15 @@
 	if (ka->sa.sa_flags & SA_RESTORER) {
 		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);
 	} else {
+#ifdef CONFIG_GRKERNSEC_STACK
+		err |= __put_user(MAGIC_SIGRETURN, &frame->pretcode);
+#else
 		err |= __put_user(frame->retcode, &frame->pretcode);
 		/* This is popl %eax ; movl $,%eax ; int $0x80 */
 		err |= __put_user(0xb858, (short *)(frame->retcode+0));
 		err |= __put_user(__NR_sigreturn, (int *)(frame->retcode+2));
 		err |= __put_user(0x80cd, (short *)(frame->retcode+6));
+#endif
 	}
 
 	if (err)
@@ -496,11 +501,15 @@
 	if (ka->sa.sa_flags & SA_RESTORER) {
 		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);
 	} else {
+#ifdef CONFIG_GRKERNSEC_STACK
+		err |= __put_user(MAGIC_RT_SIGRETURN, &frame->pretcode);
+#else
 		err |= __put_user(frame->retcode, &frame->pretcode);
 		/* This is movl $,%eax ; int $0x80 */
 		err |= __put_user(0xb8, (char *)(frame->retcode+0));
 		err |= __put_user(__NR_rt_sigreturn, (int *)(frame->retcode+1));
 		err |= __put_user(0x80cd, (short *)(frame->retcode+5));
+#endif
 	}
 
 	if (err)
diff -urN linux/arch/i386/kernel/traps.c linux/arch/i386/kernel/traps.c
--- linux/arch/i386/kernel/traps.c	Sun Sep 30 15:26:08 2001
+++ linux/arch/i386/kernel/traps.c	Mon Jun  3 21:18:06 2002
@@ -49,6 +49,7 @@
 
 #include <linux/irq.h>
 #include <linux/module.h>
+#include <linux/grsecurity.h>
 
 asmlinkage int system_call(void);
 asmlinkage void lcall7(void);
@@ -348,14 +349,183 @@
 DO_ERROR(12, SIGBUS,  "stack segment", stack_segment)
 DO_ERROR_INFO(17, SIGBUS, "alignment check", alignment_check, BUS_ADRALN, get_cr2())
 
+#if defined(CONFIG_GRKERNSEC_STACK) && defined(CONFIG_GRKERNSEC_STACK_GCC)
+static unsigned long *get_reg(struct pt_regs *regs, unsigned char regnum)
+{
+	switch (regnum) {
+		case 0: return &regs->eax;
+		case 1: return &regs->ecx;
+		case 2: return &regs->edx;
+		case 3: return &regs->ebx;
+		case 4: return &regs->esp;
+		case 5: return &regs->ebp;
+		case 6: return &regs->esi;
+		case 7: return &regs->edi;
+	}
+
+	return NULL;
+}
+static unsigned long get_modrm(struct pt_regs *regs, int *err)
+{
+	unsigned char modrm, sib;
+	signed char rel8;
+	unsigned long rel32;
+	int size, regnum, scale;
+	unsigned long index, base, addr, value;
+
+	*err |= __get_user(modrm, (unsigned char *)(regs->eip + 1));
+	size = 2;
+	regnum = modrm & 7;
+	addr = *get_reg(regs, regnum);
+	if (regnum == 4 && (modrm & 0xC0) != 0xC0) {
+		*err |= __get_user(sib, (unsigned char *)(regs->eip + 2));
+		size = 3;
+		scale = sib >> 6;
+		index = *get_reg(regs, (sib >> 3) & 7);
+		base = *get_reg(regs, sib & 7);
+		addr = base + (index << scale);
+	}
+
+	switch (modrm & 0xC0) {
+	case 0x00:
+		if (regnum == 5) {
+			*err |= __get_user(addr,
+				(unsigned long *)(regs->eip + 2));
+			size = 6;
+		}
+		*err |= __get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x40:
+		*err |= __get_user(rel8, (signed char *)(regs->eip + size));
+		size++;
+		addr += rel8;
+		*err |= __get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x80:
+		*err |= __get_user(rel32, (unsigned long *)(regs->eip + size));
+		size += 4;
+		addr += rel32;
+		*err |= __get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0xC0:
+	default:
+		value = addr;
+	}
+
+	if (*err) return 0;
+	regs->eip += size;
+	return value;
+}
+#endif
 asmlinkage void do_general_protection(struct pt_regs * regs, long error_code)
 {
+#ifdef CONFIG_GRKERNSEC_STACK
+	unsigned long addr;
+#ifdef CONFIG_GRKERNSEC_STACK_GCC
+	unsigned char insn;
+	int err, count;
+#endif
+#endif
 	if (regs->eflags & VM_MASK)
 		goto gp_in_vm86;
 
 	if (!(regs->xcs & 3))
 		goto gp_in_kernel;
 
+#ifdef CONFIG_GRKERNSEC_STACK
+/* Check if it was return from a signal handler */
+	if ((regs->xcs & 0xFFFF) == __USER_CS)
+	if (*(unsigned char *)regs->eip == 0xC3)
+	if (!__get_user(addr, (unsigned long *)regs->esp)) {
+		if ((addr & 0xFFFFFFFE) == MAGIC_SIGRETURN) {
+/* Call sys_sigreturn() or sys_rt_sigreturn() to restore the context */
+			regs->esp += 8;
+			__asm__("movl %3,%%esi\n\t"
+				"subl %1,%%esp\n\t"
+				"movl %2,%%ecx\n\t"
+				"movl %%esp,%%edi\n\t"
+				"rep; movsl\n\t"
+				"testl $1,%4\n\t"
+				"jnz 1f\n\t"
+				"call sys_sigreturn\n\t"
+				"leal %3,%%edi\n\t"
+				"jmp 2f\n\t"
+				"1:\n\t"
+				"call sys_rt_sigreturn\n\t"
+				"leal %3,%%edi\n\t"
+				"2:\n\t"
+				"addl %1,%%edi\n\t"
+				"movl %%esp,%%esi\n\t"
+				"movl %2,%%ecx\n\t"
+				"movl (%%edi),%%edi\n\t"
+				"rep; movsl\n\t"
+				"movl %%esi,%%esp"
+			:
+/* %eax is returned separately */
+			"=a" (regs->eax)
+			:
+			"i" (sizeof(*regs)),
+			"i" (sizeof(*regs) >> 2),
+			"m" (regs),
+			"r" (addr)
+			:
+			"cx", "dx", "si", "di", "cc", "memory");
+			return;
+		}
+/*
+ * Check if we're returning to the stack area, which is only likely to happen
+ * when attempting to exploit a buffer overflow.
+ */
+		if (addr >= PAGE_OFFSET - _STK_LIM && addr < PAGE_OFFSET)
+			security_alert("return onto stack by " DEFAULTSECMSG,
+				       "returns onto stack", DEFAULTSECARGS);
+	}
+
+#ifdef CONFIG_GRKERNSEC_STACK_GCC
+/* Check if it could have been a trampoline call */
+	if ((regs->xcs & 0xFFFF) == __USER_CS)
+	if (*(unsigned char *)regs->eip == 0xFF)
+	if (!__get_user(insn, (unsigned char *)(regs->eip + 1)))
+	if ((insn & 0x38) == 0x10 && insn != 0xD4) {    /* call mod r/m */
+/* First, emulate the call */
+		err = 0;
+		addr = get_modrm(regs, &err);
+		if (!err) {
+			regs->esp -= 4;
+			err = __put_user(regs->eip, (unsigned long *)regs->esp);
+			regs->eip = addr;
+		}  
+/* Then, start emulating the trampoline itself */
+		count = 0;
+		while (!err && !__get_user(insn, (unsigned char *)regs->eip++))
+		if ((insn & 0xF8) == 0xB8) {            /* movl imm32,%reg */
+/* We only have 8 GP registers, no reason to initialize one twice */
+			if (count++ >= 8) break;
+			err |= __get_user(addr, (unsigned long *)regs->eip);
+			regs->eip += 4;
+			*get_reg(regs, insn & 7) = addr;
+		} else
+		if (insn == 0xFF) {
+			err |= __get_user(insn, (unsigned char *)regs->eip);
+			if ((insn & 0xF8) == 0xE0) {    /* jmp *%reg */
+				regs->eip = *get_reg(regs, insn & 7);
+				if (err) break; else return;
+			}
+			break;
+		} else
+		if (insn == 0xE9) {                     /* jmp rel32 */
+			err |= __get_user(addr, (unsigned long *)regs->eip);
+			if (err) break;
+			regs->eip += 4 + addr;
+			return;
+		} else
+			break;
+	}
+#endif
+#endif
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
 	force_sig(SIGSEGV, current);
diff -urN linux/arch/i386/mm/fault.c linux/arch/i386/mm/fault.c
--- linux/arch/i386/mm/fault.c	Mon Feb 25 14:37:53 2002
+++ linux/arch/i386/mm/fault.c	Mon Jun  3 21:18:06 2002
@@ -4,6 +4,7 @@
  *  Copyright (C) 1995  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -19,6 +20,9 @@
 #include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_RANDMMAP)
+#include <linux/unistd.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -144,23 +148,31 @@
  *	bit 1 == 0 means read, 1 means write
  *	bit 2 == 0 means kernel, 1 means user-mode
  */
+#ifdef CONFIG_GRKERNSEC_PAX
+asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+#else
 asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)
+#endif
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
+#ifndef CONFIG_GRKERNSEC_PAX
 	unsigned long address;
+#endif
 	unsigned long page;
 	unsigned long fixup;
 	int write;
 	siginfo_t info;
 
+#ifndef CONFIG_GRKERNSEC_PAX
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
 
 	/* It's safe to allow irq's after cr2 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
 		local_irq_enable();
+#endif
 
 	tsk = current;
 
@@ -218,21 +230,37 @@
 good_area:
 	info.si_code = SEGV_ACCERR;
 	write = 0;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	switch (error_code & 7) {
+#else
 	switch (error_code & 3) {
+#endif
 		default:	/* 3: write, present */
 #ifdef TEST_VERIFY_AREA
 			if (regs->cs == KERNEL_CS)
 				printk("WP fault at %08lx\n", regs->eip);
 #endif
 			/* fall through */
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		case 7:		/* PaX: write, present, some protection violation */
+#endif
 		case 2:		/* write, not present */
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		case 6:
+#endif
 			if (!(vma->vm_flags & VM_WRITE))
 				goto bad_area;
 			write++;
 			break;
 		case 1:		/* read, present */
 			goto bad_area;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		case 5:		/* PaX: read, present, protection violation */
+#endif
 		case 0:		/* read, not present */
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		case 4:
+#endif
 			if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
 				goto bad_area;
 	}
@@ -407,3 +435,322 @@
 		return;
 	}
 }
+#ifdef CONFIG_GRKERNSEC_PAX
+/* PaX: called with the page_table_lock spinlock held */
+static inline pte_t * pax_get_pte(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd || !pgd_present(*pgd))
+		return 0;
+	pmd = pmd_offset(pgd, address);
+	if (!pmd || !pmd_present(*pmd))
+		return 0;
+	return pte_offset(pmd, address);
+}
+
+/*
+ * PaX: decide what to do with offenders
+ *
+ * returns 0 when access should be allowed
+ *         1 when task should be killed
+ *         2 when sigreturn trampoline was detected
+ *         3 when rt_sigreturn trampoline was detected
+ *         4 when gcc trampoline was detected
+ */
+static int pax_handle_read_fault(struct pt_regs *regs, unsigned long address)
+{
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	static unsigned char trans[8] = {6, 1, 2, 0, 13, 5, 3, 4};
+	int err;
+
+	if (!(current->flags & PF_PAX_EMUTRAMP))
+		return 1;
+
+	{ /* PaX: sigreturn emulation */
+		unsigned char pop, mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = __get_user(pop, (unsigned char *)(regs->eip));
+		err |= __get_user(mov, (unsigned char *)(regs->eip + 1));
+		err |= __get_user(nr, (unsigned long *)(regs->eip + 2));
+		err |= __get_user(sys, (unsigned short *)(regs->eip + 6));
+
+		if (!err) {
+			if (pop == 0x58 &&
+			    mov == 0xb8 &&
+			    nr == __NR_sigreturn &&
+			    sys == 0x80cd)
+			{
+				regs->esp += 4;
+				regs->eax = nr;
+				regs->eip += 8;
+				return 2;
+			}
+		}
+	}
+
+	{ /* PaX: rt_sigreturn emulation */
+		unsigned char mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = __get_user(mov, (unsigned char *)(regs->eip));
+		err |= __get_user(nr, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(sys, (unsigned short *)(regs->eip + 5));
+
+		if (!err) {
+			if (mov == 0xb8 &&
+			    nr == __NR_rt_sigreturn &&
+			    sys == 0x80cd)
+			{
+				regs->eax = nr;
+				regs->eip += 7;
+				return 3;
+			}
+		}
+	}
+
+	{ /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2, ret;
+
+		err = __get_user(mov1, (unsigned char *)(regs->eip));
+		err |= __get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(mov2, (unsigned char *)(regs->eip + 5));
+		err |= __get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= __get_user(jmp, (unsigned short *)(regs->eip + 10));
+		err |= __get_user(ret, (unsigned long *)(regs->esp));
+
+		if (!err) {
+			unsigned short call;
+
+			err = __get_user(call, (unsigned short *)(ret-2));
+			if (!err) {
+				if ((mov1 & 0xF8) == 0xB8 &&
+				    (mov2 & 0xF8) == 0xB8 &&
+				    (mov1 & 0x07) != (mov2 & 0x07) &&
+				    (jmp & 0xF8FF) == 0xE0FF &&
+				    (mov2 & 0x07) == ((jmp>>8) & 0x07) &&
+				    (call & 0xF8FF) == 0xD0FF &&
+				    (regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]]))
+				{
+					((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+					((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+					regs->eip = addr2;
+					return 4;
+				}
+			}
+		}
+	}
+
+	{ /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2, ret;
+
+		err = __get_user(mov, (unsigned char *)(regs->eip));
+		err |= __get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= __get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= __get_user(ret, (unsigned long *)(regs->esp));
+
+		if (!err) {
+			unsigned short call;
+
+			err = __get_user(call, (unsigned short *)(ret-2));
+			if (!err) {
+				if ((mov & 0xF8) == 0xB8 &&
+				    jmp == 0xE9 &&
+				    (call & 0xF8FF) == 0xD0FF &&
+				    (regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]]))
+				{
+					((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+					regs->eip += addr2 + 10;
+					return 4;
+				}
+			}
+		}
+	}
+#endif
+
+	return 1; /* PaX in action */
+}
+
+/*
+ * PaX: handle the extra page faults or pass it down to the original handler
+ *
+ * returns 0 when nothing special was detected
+ *         1 when sigreturn trampoline (syscall) has to be emulated
+ */
+asmlinkage int pax_do_page_fault(struct pt_regs *regs, unsigned long error_code)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	unsigned long address;
+	pte_t *pte;
+	unsigned char pte_mask = _PAGE_ACCESSED | _PAGE_USER;
+	int ret;
+	unsigned long i;
+
+	__asm__("movl %%cr2,%0":"=r" (address));
+
+	/* It's safe to allow irq's after cr2 has been saved */
+	if (regs->eflags & X86_EFLAGS_IF)
+		local_irq_enable();
+
+	if ((error_code & 5) != 5 || address >= TASK_SIZE || regs->xcs != __USER_CS || (VM_MASK & regs->eflags))
+		goto chain;
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	if (error_code == 7) {
+		pte_mask |= _PAGE_DIRTY;
+	/* PaX: take a look at read faults before acquiring any locks */
+	} else if (regs->eip == address) { /* read/instruction fetch attempt from a protected page in user mode */
+		ret = pax_handle_read_fault(regs, address);
+		switch (ret) {
+		case 4:
+			tsk->thread.pax_faults.eip = 0;
+			tsk->thread.pax_faults.count = 0;
+			return 0;
+
+		case 3:
+		case 2:
+			tsk->thread.pax_faults.eip = 0;
+			tsk->thread.pax_faults.count = 0;
+			return 1;
+
+		default:
+		case 1: {
+			char* buffer = (char*)__get_free_page(GFP_ATOMIC);
+			char* path=NULL;
+
+			if (buffer) {
+				struct vm_area_struct* vma;
+
+				down_read(&mm->mmap_sem);
+				vma = mm->mmap;
+				while (vma) {
+					if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
+						break;
+					}
+					vma = vma->vm_next;
+				}
+				if (vma)
+					path = d_path(vma->vm_file->f_dentry, vma->vm_file->f_vfsmnt, buffer, PAGE_SIZE);
+				up_read(&mm->mmap_sem);
+			}
+			printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, EIP: %08lX, ESP: %08lX\n", path, tsk->comm, tsk->pid, tsk->uid, tsk->euid, regs->eip, regs->esp);
+			if (buffer) free_page((unsigned long)buffer);
+			printk(KERN_ERR "PAX: bytes at EIP: ");
+			for (i = 0; i < 20; i++) {
+				unsigned char c;
+				if (__get_user(c, (unsigned char*)(regs->eip+i))) {
+					printk("<invalid address>.");
+					break;
+				}
+				printk("%02x ", c);
+			}
+			printk("\n");
+
+			tsk->thread.pax_faults.eip = 0;
+			tsk->thread.pax_faults.count = 0;
+			tsk->thread.cr2 = address;
+			tsk->thread.error_code = error_code;
+			tsk->thread.trap_no = 14;
+			force_sig(SIGKILL,tsk);
+			return 0;
+		}
+
+		case 0:
+		}
+	}
+
+	spin_lock(&mm->page_table_lock);
+	pte = pax_get_pte(mm, address);
+	if (!pte || !(pte_val(*pte) & _PAGE_PRESENT) || pte_exec(*pte)) {
+		spin_unlock(&mm->page_table_lock);
+		goto chain;
+	}
+
+	if ((error_code == 7) && !pte_write(*pte)) { /* write attempt to a protected page in user mode */
+		spin_unlock(&mm->page_table_lock);
+		goto chain;
+	}
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+#if 0
+	if (regs->eip != tsk->thread.pax_faults.eip) { /* detect DTLB trashing */
+		tsk->thread.pax_faults.eip = regs->eip;
+		tsk->thread.pax_faults.count = 0;
+#endif
+pax_emu:
+		__asm__ __volatile__ (
+			"orb %2,%1\n"
+#if 0
+/*   
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's   
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+ * the best thing in omitting it is that we gain around 15-20% speed in 
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+
+			"invlpg %0\n"
+#endif
+			"testb $0,%0\n"
+			"xorb %3,%1\n"
+			:
+			: "m" (*(char*)address), "m" (*(char*)pte) , "r" (pte_mask) , "i" (_PAGE_USER)
+			: "memory", "cc");
+		spin_unlock(&mm->page_table_lock);
+		return 0;
+#if 0
+	}
+#endif
+
+	if (tsk->thread.pax_faults.count < 4) {
+		++tsk->thread.pax_faults.count;
+		goto pax_emu;
+	}
+	spin_unlock(&mm->page_table_lock);
+
+	printk(KERN_ERR "PAX: preventing DoS: %s:%d, EIP: %08lX, ESP: %08lX\n", tsk->comm, tsk->pid, regs->eip, regs->esp);
+	printk(KERN_ERR "PAX: bytes at EIP: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (__get_user(c, (unsigned char*)(regs->eip+i))) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%02x ", c);
+
+	}
+	printk("\n");
+
+	tsk->thread.pax_faults.eip = 0;
+	tsk->thread.pax_faults.count = 0;
+	tsk->thread.cr2 = address;
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = 14;
+	force_sig(SIGKILL,tsk);
+
+	return 0;
+
+chain:
+	do_page_fault(regs, error_code, address);
+	return 0;
+}
+#endif
+
diff -urN linux/arch/i386/mm/init.c linux/arch/i386/mm/init.c
--- linux/arch/i386/mm/init.c	Fri Dec 21 12:41:53 2001
+++ linux/arch/i386/mm/init.c	Mon Jun  3 21:18:06 2002
@@ -400,7 +400,11 @@
 	pmd = pmd_offset(pgd, vaddr);
 	pte = pte_offset(pmd, vaddr);
 	old_pte = *pte;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	*pte = mk_pte_phys(0, PAGE_READONLY_EXEC);
+#else
 	*pte = mk_pte_phys(0, PAGE_READONLY);
+#endif
 	local_flush_tlb();
 
 	boot_cpu_data.wp_works_ok = do_test_wp_bit(vaddr);
diff -urN linux/arch/ia64/config.in linux/arch/ia64/config.in
--- linux/arch/ia64/config.in	Fri Nov  9 17:26:17 2001
+++ linux/arch/ia64/config.in	Mon Jun  3 21:18:06 2002
@@ -276,3 +276,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/m68k/config.in linux/arch/m68k/config.in
--- linux/arch/m68k/config.in	Mon Jun 11 22:15:27 2001
+++ linux/arch/m68k/config.in	Mon Jun  3 21:18:06 2002
@@ -546,3 +546,12 @@
 #bool 'Debug kmalloc/kfree' CONFIG_DEBUG_MALLOC
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/mips/config.in linux/arch/mips/config.in
--- linux/arch/mips/config.in	Mon Oct 15 16:41:34 2001
+++ linux/arch/mips/config.in	Mon Jun  3 21:18:06 2002
@@ -520,3 +520,12 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/mips64/config.in linux/arch/mips64/config.in
--- linux/arch/mips64/config.in	Sun Sep  9 13:43:02 2001
+++ linux/arch/mips64/config.in	Mon Jun  3 21:18:06 2002
@@ -276,3 +276,12 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/parisc/config.in linux/arch/parisc/config.in
--- linux/arch/parisc/config.in	Tue Apr 17 20:19:25 2001
+++ linux/arch/parisc/config.in	Mon Jun  3 21:18:06 2002
@@ -208,3 +208,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/ppc/config.in linux/arch/ppc/config.in
--- linux/arch/ppc/config.in	Mon Feb 25 14:37:55 2002
+++ linux/arch/ppc/config.in	Mon Jun  3 21:18:06 2002
@@ -400,3 +400,12 @@
 bool 'Include kgdb kernel debugger' CONFIG_KGDB
 bool 'Include xmon kernel debugger' CONFIG_XMON
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/s390/config.in linux/arch/s390/config.in
--- linux/arch/s390/config.in	Mon Feb 25 14:37:56 2002
+++ linux/arch/s390/config.in	Mon Jun  3 21:18:06 2002
@@ -73,3 +73,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/s390x/config.in linux/arch/s390x/config.in
--- linux/arch/s390x/config.in	Mon Feb 25 14:37:56 2002
+++ linux/arch/s390x/config.in	Mon Jun  3 21:18:06 2002
@@ -77,3 +77,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sh/config.in linux/arch/sh/config.in
--- linux/arch/sh/config.in	Mon Feb 25 14:37:56 2002
+++ linux/arch/sh/config.in	Mon Jun  3 21:18:06 2002
@@ -386,3 +386,12 @@
    bool 'Early printk support' CONFIG_SH_EARLY_PRINTK
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sparc/config.in linux/arch/sparc/config.in
--- linux/arch/sparc/config.in	Mon Jun 11 22:15:27 2001
+++ linux/arch/sparc/config.in	Mon Jun  3 21:18:06 2002
@@ -266,3 +266,12 @@
 
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sparc64/config.in linux/arch/sparc64/config.in
--- linux/arch/sparc64/config.in	Fri Dec 21 12:41:53 2001
+++ linux/arch/sparc64/config.in	Mon Jun  3 21:18:06 2002
@@ -306,3 +306,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/drivers/char/mem.c linux/drivers/char/mem.c
--- linux/drivers/char/mem.c	Fri Dec 21 12:41:54 2001
+++ linux/drivers/char/mem.c	Mon Jun  3 21:18:06 2002
@@ -21,6 +21,7 @@
 #include <linux/raw.h>
 #include <linux/tty.h>
 #include <linux/capability.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -46,6 +47,12 @@
 			    const char * buf, size_t count, loff_t *ppos)
 {
 	ssize_t written;
+#ifdef CONFIG_GRKERNSEC_KMEM
+		security_alert("attempted write to read-only kernel memory by "
+				 DEFAULTSECMSG, "attempted kernel writes", 
+				 DEFAULTSECARGS);
+		return -EPERM;
+#endif
 
 	written = 0;
 #if defined(__sparc__) || defined(__mc68000__)
@@ -200,9 +207,21 @@
 	/*
 	 * Don't dump addresses that are not real memory to a core file.
 	 */
+#ifdef CONFIG_GRKERNSEC_PAX
+	if (offset >= __pa(high_memory) || (file->f_flags & O_SYNC)) {
+#else 
 	if (offset >= __pa(high_memory) || (file->f_flags & O_SYNC))
+#endif
 		vma->vm_flags |= VM_IO;
 
+#ifdef CONFIG_GRKERNSEC_PAX
+		/* it turned out to be device memory (eg. video RAM), don't apply PaX */
+		if ((current->flags & PF_PAX_PAGEEXEC) &&!(vma->vm_flags & VM_EXEC)) {
+			vma->vm_flags |= VM_EXEC | VM_MAYEXEC;
+			vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+		}                                                                                                          
+	}
+#endif
 	if (remap_page_range(vma->vm_start, offset, vma->vm_end-vma->vm_start,
 			     vma->vm_page_prot))
 		return -EAGAIN;
@@ -291,7 +310,9 @@
 			wrote = (unsigned long) high_memory - p;
 
 		wrote = do_write_mem(file, (void*)p, p, buf, wrote, ppos);
-
+#ifdef CONFIG_GRKERNSEC_KMEM
+	if(wrote == -EPERM) return -EPERM;
+#endif
 		p += wrote;
 		buf += wrote;
 		count -= wrote;
@@ -401,8 +422,12 @@
 			count = size;
 
 		zap_page_range(mm, addr, count);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	        zeromap_page_range(addr, count, vma->vm_page_prot); 
+#else
         	zeromap_page_range(addr, count, PAGE_COPY);
 
+#endif
 		size -= count;
 		buf += count;
 		addr += count;
diff -urN linux/drivers/char/vt.c linux/drivers/char/vt.c
--- linux/drivers/char/vt.c	Fri Nov 16 13:08:28 2001
+++ linux/drivers/char/vt.c	Mon Jun  3 21:18:06 2002
@@ -32,6 +32,7 @@
 #include <linux/vt_kern.h>
 #include <linux/kbd_diacr.h>
 #include <linux/selection.h>
+#include <linux/grsecurity.h>
 
 #ifdef CONFIG_FB_COMPAT_XPMAC
 #include <asm/vc_ioctl.h>
@@ -177,7 +178,7 @@
 		    val = (i ? K_HOLE : K_NOSUCHMAP);
 		return put_user(val, &user_kbe->kb_value);
 	case KDSKBENT:
-		if (!perm)
+		if (!perm || (grsec_enable_kbmap && !suser()))
 			return -EPERM;
 		if (!i && v == K_NOSUCHMAP) {
 			/* disallocate map */
@@ -298,7 +299,7 @@
 			return -EFAULT;
 		return ((p && *p) ? -EOVERFLOW : 0);
 	case KDSKBSENT:
-		if (!perm)
+		if (!perm || (grsec_enable_kbmap && !suser()))
 			return -EPERM;
 
 		q = func_table[i];
diff -urN linux/drivers/ieee1394/video1394.c linux/drivers/ieee1394/video1394.c
--- linux/drivers/ieee1394/video1394.c	Mon Feb 25 14:37:58 2002
+++ linux/drivers/ieee1394/video1394.c	Mon Jun  3 21:18:06 2002
@@ -843,7 +843,11 @@
         pos=(unsigned long) d->buf;
         while (size > 0) {
                 page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
                 if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+#endif
                         return -EAGAIN;
                 start+=PAGE_SIZE;
                 pos+=PAGE_SIZE;
diff -urN linux/drivers/media/video/bttv-driver.c linux/drivers/media/video/bttv-driver.c
--- linux/drivers/media/video/bttv-driver.c	Mon Feb 25 14:37:58 2002
+++ linux/drivers/media/video/bttv-driver.c	Mon Jun  3 21:18:06 2002
@@ -2052,7 +2052,11 @@
         pos=(unsigned long) btv->fbuffer;
         while (size > 0) {
                 page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+                if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
                 if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+#endif
                         return -EAGAIN;
                 start+=PAGE_SIZE;
                 pos+=PAGE_SIZE;
diff -urN linux/drivers/media/video/cpia.c linux/drivers/media/video/cpia.c
--- linux/drivers/media/video/cpia.c	Thu Oct 25 16:53:47 2001
+++ linux/drivers/media/video/cpia.c	Mon Jun  3 21:18:06 2002
@@ -3005,7 +3005,11 @@
 	pos = (unsigned long)(cam->frame_buf);
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up(&cam->busy_lock);
 			return -EAGAIN;
 		}
diff -urN linux/drivers/media/video/meye.c linux/drivers/media/video/meye.c
--- linux/drivers/media/video/meye.c	Fri Dec 21 12:41:54 2001
+++ linux/drivers/media/video/meye.c	Mon Jun  3 21:18:06 2002
@@ -1263,7 +1263,11 @@
 
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up(&meye.lock);
 			return -EAGAIN;
 		}
diff -urN linux/drivers/media/video/planb.c linux/drivers/media/video/planb.c
--- linux/drivers/media/video/planb.c	Mon Feb 25 14:37:58 2002
+++ linux/drivers/media/video/planb.c	Mon Jun  3 21:18:06 2002
@@ -2008,7 +2008,11 @@
 	}
 	for (i = 0; i < pb->rawbuf_size; i++) {
 		if (remap_page_range(start, virt_to_phys((void *)pb->rawbuf[i]),
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+						PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
 						PAGE_SIZE, PAGE_SHARED))
+#endif
 			return -EAGAIN;
 		start += PAGE_SIZE;
 		if (size <= PAGE_SIZE)
diff -urN linux/drivers/media/video/zr36067.c linux/drivers/media/video/zr36067.c
--- linux/drivers/media/video/zr36067.c	Mon Feb 25 14:37:58 2002
+++ linux/drivers/media/video/zr36067.c	Mon Jun  3 21:18:06 2002
@@ -4322,7 +4322,11 @@
 				    frag_tab[2 * j];
 				page = virt_to_phys(bus_to_virt(pos));	/* should just be pos on i386 */
 				if (remap_page_range
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+				    (start, page, todo, PAGE_SHARED_EXEC)) {
+#else
 				    (start, page, todo, PAGE_SHARED)) {
+#endif
 					printk(KERN_ERR
 					       "%s: zoran_mmap(V4L): remap_page_range failed\n",
 					       zr->name);
@@ -4363,7 +4367,11 @@
 			       ("V4L remap page range %d 0x%lx %ld to 0x%lx\n",
 				i, page, todo, start));
 			if (remap_page_range
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+			    (start, page, todo, PAGE_SHARED_EXEC)) {
+#else
 			    (start, page, todo, PAGE_SHARED)) {
+#endif
 				printk(KERN_ERR
 				       "%s: zoran_mmap(V4L): remap_page_range failed\n",
 				       zr->name);
diff -urN linux/drivers/media/video/zr36120.c linux/drivers/media/video/zr36120.c
--- linux/drivers/media/video/zr36120.c	Mon Feb 25 14:37:58 2002
+++ linux/drivers/media/video/zr36120.c	Mon Jun  3 21:18:06 2002
@@ -1484,7 +1484,11 @@
 	pos = (unsigned long)ztv->fbuffer;
 	while (size>0) {
 		unsigned long page = virt_to_phys((void*)pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+#endif
 			return -EAGAIN;
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
diff -urN linux/drivers/pci/proc.c linux/drivers/pci/proc.c
--- linux/drivers/pci/proc.c	Fri Nov 16 21:38:39 2001
+++ linux/drivers/pci/proc.c	Mon Jun  3 21:18:06 2002
@@ -562,7 +562,15 @@
 		pci_for_each_dev(dev) {
 			pci_proc_attach_device(dev);
 		}
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+		entry = create_proc_entry("pci", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+		entry = create_proc_entry("pci", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 		entry = create_proc_entry("pci", 0, NULL);
+#endif
 		if (entry)
 			entry->proc_fops = &proc_pci_operations;
 	}
diff -urN linux/drivers/usb/ov511.c linux/drivers/usb/ov511.c
--- linux/drivers/usb/ov511.c	Mon Feb 25 14:38:07 2002
+++ linux/drivers/usb/ov511.c	Mon Jun  3 21:18:06 2002
@@ -5578,7 +5578,11 @@
 	pos = (unsigned long)ov511->fbuf;
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up(&ov511->lock);
 			return -EAGAIN;
 		}
diff -urN linux/drivers/usb/pwc-if.c linux/drivers/usb/pwc-if.c
--- linux/drivers/usb/pwc-if.c	Mon Feb 25 14:38:07 2002
+++ linux/drivers/usb/pwc-if.c	Mon Jun  3 21:18:06 2002
@@ -1593,7 +1593,11 @@
 	pos = (unsigned long)pdev->image_data;
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+#endif
 			return -EAGAIN;
 
 		start += PAGE_SIZE;
diff -urN linux/drivers/usb/se401.c linux/drivers/usb/se401.c
--- linux/drivers/usb/se401.c	Fri Sep 14 17:27:10 2001
+++ linux/drivers/usb/se401.c	Mon Jun  3 21:18:06 2002
@@ -1374,7 +1374,11 @@
 	pos = (unsigned long)se401->fbuf;
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up(&se401->lock);
 			return -EAGAIN;
 		}
diff -urN linux/drivers/usb/stv680.c linux/drivers/usb/stv680.c
--- linux/drivers/usb/stv680.c	Mon Feb 25 14:38:07 2002
+++ linux/drivers/usb/stv680.c	Mon Jun  3 21:18:06 2002
@@ -1450,7 +1450,11 @@
 	pos = (unsigned long) stv680->fbuf;
 	while (size > 0) {
 		page = kvirt_to_pa (pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range (start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range (start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up (&stv680->lock);
 			return -EAGAIN;
 		}
diff -urN linux/drivers/usb/usbvideo.c linux/drivers/usb/usbvideo.c
--- linux/drivers/usb/usbvideo.c	Thu Oct 11 02:42:46 2001
+++ linux/drivers/usb/usbvideo.c	Mon Jun  3 21:18:06 2002
@@ -1199,7 +1199,11 @@
 	pos = (unsigned long) uvd->fbuf;
 	while (size > 0) {
 		page = usbvideo_kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC))
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+#endif
 			return -EAGAIN;
 
 		start += PAGE_SIZE;
diff -urN linux/drivers/usb/vicam.c linux/drivers/usb/vicam.c
--- linux/drivers/usb/vicam.c	Mon Feb 25 14:38:07 2002
+++ linux/drivers/usb/vicam.c	Mon Jun  3 21:18:06 2002
@@ -691,7 +691,11 @@
 	pos = (unsigned long)vicam->fbuf;
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED_EXEC)) {
+#else
 		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+#endif
 			up(&vicam->sem);
 			return -EAGAIN;
 		}
diff -urN linux/fs/binfmt_aout.c linux/fs/binfmt_aout.c
--- linux/fs/binfmt_aout.c	Fri Nov  2 20:39:20 2001
+++ linux/fs/binfmt_aout.c	Mon Jun  3 21:18:06 2002
@@ -5,6 +5,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/config.h>
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -307,6 +308,25 @@
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+#ifdef CONFIG_GRKERNSEC_STACK
+       if (N_FLAGS(ex) & F_STACKEXEC) current->flags |= PF_STACKEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX
+      if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC))
+              current->flags |= PF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+      if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+              current->flags |= PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+      if (!(N_FLAGS(ex) & F_PAX_MPROTECT))        
+              current->flags |= PF_PAX_MPROTECT;
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -393,7 +413,11 @@
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+				PROT_READ | PROT_WRITE,
+#else
 				PROT_READ | PROT_WRITE | PROT_EXEC,
+#endif
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -urN linux/fs/binfmt_elf.c linux/fs/binfmt_elf.c
--- linux/fs/binfmt_elf.c	Mon Feb 25 14:38:08 2002
+++ linux/fs/binfmt_elf.c	Mon Jun  3 21:18:06 2002
@@ -11,6 +11,7 @@
 
 #include <linux/module.h>
 
+#include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/stat.h>
 #include <linux/sched.h>
@@ -33,6 +34,9 @@
 #include <linux/smp_lock.h>
 #include <linux/compiler.h>
 #include <linux/highmem.h>
+#if defined(CONFIG_GRKERNSEC_PAX_RANDMMAP) || defined(CONFIG_GRKERNSEC_PAX)
+#include <linux/random.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
@@ -73,7 +77,10 @@
 #define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))
 #define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))
 
-static struct linux_binfmt elf_format = {
+#ifndef CONFIG_GRKERNSEC_STACK
+static
+#endif
+struct linux_binfmt elf_format = {
 	NULL, THIS_MODULE, load_elf_binary, load_elf_library, elf_core_dump, ELF_EXEC_PAGESIZE
 };
 
@@ -154,6 +161,11 @@
 		u_platform = u_platform - ((current->pid % 64) << 7);
 #endif	
 
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	if (current->flags & PF_PAX_RANDMMAP)
+		u_platform -= (current->mm->delta_stack & ~PAGE_MASK);
+#endif
+
 	/*
 	 * Force 16 byte _final_ alignment here for generality.
 	 */
@@ -595,7 +607,49 @@
 	current->mm->end_data = 0;
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	current->mm->delta_mmap = 0;
+	current->mm->delta_exec = 0;
+	current->mm->delta_stack = 0;
+#endif
 	current->flags &= ~PF_FORKNOEXEC;
+
+#ifdef CONFIG_GRKERNSEC_STACK
+       if (elf_ex.e_flags & EF_STACKEXEC)
+	current->flags |= PF_STACKEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX
+	if (!(elf_ex.e_flags & EF_PAX_PAGEEXEC))
+		current->flags |= PF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	if (elf_ex.e_flags & EF_PAX_EMUTRAMP)
+		current->flags |= PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	if (!(elf_ex.e_flags & EF_PAX_MPROTECT))
+		current->flags |= PF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	if (!(elf_ex.e_flags & EF_PAX_RANDMMAP)) {
+		unsigned short delta;
+		current->flags |= PF_PAX_RANDMMAP;
+
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_mmap = (unsigned long)delta << PAGE_SHIFT;
+
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_exec = (unsigned long)delta << PAGE_SHIFT;
+
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_stack = (unsigned long)delta << 4;
+	}
+#endif
+
 	elf_entry = (unsigned long) elf_ex.e_entry;
 
 	/* Do this so that we can load the interpreter, if need be.  We will
@@ -646,6 +700,13 @@
 			   base, as well as whatever program they might try to exec.  This
 		           is because the brk will follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if (current->flags | PF_PAX_RANDMMAP) {
+				load_bias = ELF_PAGESTART(0x08048000 - vaddr + current->mm->delta_exec);
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
diff -urN linux/fs/exec.c linux/fs/exec.c
--- linux/fs/exec.c	Fri Dec 21 12:41:55 2001
+++ linux/fs/exec.c	Mon Jun  3 21:18:06 2002
@@ -41,6 +41,8 @@
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
+#include <linux/major.h>
+#include <linux/grsecurity.h>
 
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
@@ -278,7 +280,12 @@
 	lru_cache_add(page);
 	flush_dcache_page(page);
 	flush_page_to_ram(page);
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page,
+		(tsk->flags & PF_PAX_PAGEEXEC)?PAGE_COPY_NOEXEC:PAGE_COPY_EXEC))));
+#else
 	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, PAGE_COPY))));
+#endif
 	tsk->mm->rss++;
 	spin_unlock(&tsk->mm->page_table_lock);
 
@@ -299,6 +306,12 @@
 
 	stack_base = STACK_TOP - MAX_ARG_PAGES*PAGE_SIZE;
 
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	if (current->flags & PF_PAX_RANDMMAP)
+		stack_base = PAGE_MASK & (stack_base - current->mm->delta_stack);
+
+#endif
+ 
 	bprm->p += stack_base;
 	if (bprm->loader)
 		bprm->loader += stack_base;
@@ -312,9 +325,15 @@
 	{
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+		mpnt->vm_end = stack_base + MAX_ARG_PAGES*PAGE_SIZE;
+		mpnt->vm_page_prot = (current->flags & PF_PAX_PAGEEXEC)?PAGE_COPY_NOEXEC:PAGE_COPY_EXEC;
+		mpnt->vm_flags = (current->flags & PF_PAX_PAGEEXEC)?VM_STACK_FLAGS:(VM_STACK_FLAGS|VM_EXEC|VM_MAYEXEC);
+#else
 		mpnt->vm_end = STACK_TOP;
 		mpnt->vm_page_prot = PAGE_COPY;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+#endif
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
@@ -474,6 +493,66 @@
 		kmem_cache_free(sigact_cachep, oldsig);
 }
 
+static inline int tweak_fd_open_null(struct linux_binprm *bprm)
+{
+	struct inode *i;
+	struct dentry *d;
+	struct file *f;
+
+	if(!(i = get_empty_inode()))
+		return -ENOMEM;
+	if(!(d = d_alloc_root(i))) {
+        	iput(i);
+        	return -ENOMEM;
+    	}
+	if(!(f = get_empty_filp())) {
+        	dput(d);
+        	iput(i);
+        	return -ENFILE;
+    	}
+    	i->i_uid = current->fsuid;
+    	i->i_gid = current->fsgid;
+    	i->i_blksize = PAGE_SIZE;
+    	i->i_blocks = 0;
+    	i->i_atime = i->i_mtime = i->i_ctime = CURRENT_TIME;
+    	i->i_state = I_DIRTY;
+	init_special_inode(i, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR,3));
+
+    	f->f_flags = O_RDWR;
+    	f->f_mode = FMODE_READ | FMODE_WRITE;
+    	f->f_dentry = d;
+	f->f_op = fops_get(i->i_fop);
+    	f->f_pos = 0;
+    	f->f_reada = 0;
+	f->f_vfsmnt = mntget(child_reaper->fs->rootmnt);
+    	f->f_op->open(i,f);
+    	bprm->tweak_fd_null = f;
+
+   	return 0;
+}
+
+static int tweak_fd_0_1_2(struct linux_binprm *bprm)
+{
+    	int fd,new,retval;
+
+    	for(fd=0;fd<=2;fd++) {
+        	if(current->files->fd[fd]) continue;
+        	if((new = get_unused_fd()) != fd) {
+            		if(new >= 0) put_unused_fd(new);
+            		return -EMFILE;
+        	}
+        	if(bprm->tweak_fd_null)
+            		atomic_inc(&bprm->tweak_fd_null->f_count);
+        	else
+            		if((retval = tweak_fd_open_null(bprm)))
+                		return retval;
+
+        	fd_install(fd,bprm->tweak_fd_null);
+        	bprm->tweak_fd_mask |= 1 << fd;
+    	}
+    	return 0;
+}
+
 /*
  * These functions flushes out all traces of the currently running executable
  * so that a new one can be started
@@ -563,6 +642,25 @@
 				current->comm[i++] = ch;
 	}
 	current->comm[i] = '\0';
+#ifdef CONFIG_GRKERNSEC_STACK
+        current->flags &= ~PF_STACKEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX
+	current->flags &= ~PF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	current->flags &= ~PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	current->flags &= ~PF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	current->flags &= ~PF_PAX_RANDMMAP;
+#endif
 
 	flush_thread();
 
@@ -580,6 +678,9 @@
 	flush_signal_handlers(current);
 	flush_old_files(current->files);
 
+        if(grsec_enable_fd)
+        	return tweak_fd_0_1_2(bprm);
+
 	return 0;
 
 mmap_failed:
@@ -661,6 +762,24 @@
 			cap_set_full(bprm->cap_effective);
 	}
 
+	if ((current->ptrace & PT_PTRACED) && current->uid && grsec_enable_ptrace
+	    && ((grsec_enable_ptrace_group && !in_group_p(grsec_ptrace_gid)) ||
+	    !grsec_enable_ptrace_group)) {
+		security_alert("denied ptrace of [%.32s:%lu] (%s) by " DEFAULTSECMSG,
+			"denied ptraces", kdevname(bprm->file->f_dentry->d_inode->i_dev),
+			bprm->file->f_dentry->d_inode->i_ino, bprm->filename, 
+			DEFAULTSECARGS);
+		return -EPERM;
+	}
+
+	if ((current->ptrace & PT_PTRACED) && ((grsec_enable_audit_ptrace 
+	    && !grsec_enable_group) || (grsec_enable_group && in_group_p(grsec_audit_gid)))) {
+		printk(KERN_INFO "grsec: ptrace of [%.32s:%lu] (%s) by " DEFAULTSECMSG "\n",
+			kdevname(bprm->file->f_dentry->d_inode->i_dev),
+                        bprm->file->f_dentry->d_inode->i_ino, bprm->filename, 
+			DEFAULTSECARGS);
+	}
+
 	memset(bprm->buf,0,BINPRM_BUF_SIZE);
 	return kernel_read(bprm->file,0,bprm->buf,BINPRM_BUF_SIZE);
 }
@@ -698,7 +817,9 @@
 		if (must_not_trace_exec(current)
 		    || atomic_read(&current->fs->count) > 1
 		    || atomic_read(&current->files->count) > 1
-		    || atomic_read(&current->sig->count) > 1) {
+		    || atomic_read(&current->sig->count) > 1
+		    || (grsec_enable_fd && tweak_fd_0_1_2(bprm))) {
+
 			if(!capable(CAP_SETUID)) {
 				bprm->e_uid = current->uid;
 				bprm->e_gid = current->gid;
@@ -708,6 +829,7 @@
 							current->cap_permitted);
 			}
 		}
+
 		do_unlock = 1;
 	}
 
@@ -849,6 +971,44 @@
 	return retval;
 }
 
+/* used for cleaning environment variables of insecure glibc vars */
+
+#define MAXBADGLIBCVARS 7
+static struct badglibcvars {
+	const char *name;
+	const short len;
+} badglibcvar[] = {
+        {"LD_PRELOAD", 10},
+        {"LD_LIBRARY_PATH", 15},
+        {"LD_ORIGIN_PATH", 14},
+        {"LD_DEBUG_OUTPUT", 15},
+        {"LD_PROFILE", 10},
+        {"LD_AOUT_LIBRARY_PATH", 20},
+        {"LD_AOUT_PRELOAD", 15}
+};
+
+static inline int gr_unsetenv(char **envpp, struct linux_binprm *bprmo)
+{
+	int i,ret=0;
+	char **envpo = envpp;
+	while(*envpo != NULL) {
+		for(i = 0;i<MAXBADGLIBCVARS;i++) {
+			if(!strncmp(*envpo, badglibcvar[i].name,
+			   badglibcvar[i].len) && (*envpo)[badglibcvar[i].len] == '=') {
+				char **dp = envpo;
+
+				do
+					dp[0] = dp[1];
+				while (*dp++);
+				ret++;
+				bprmo->envc--;
+				break;
+			} else if(i == (MAXBADGLIBCVARS - 1))
+				++envpo;
+		}
+	}
+	return ret;
+}
 
 /*
  * sys_execve() executes a new program.
@@ -858,7 +1018,8 @@
 	struct linux_binprm bprm;
 	struct file *file;
 	int retval;
-	int i;
+	int i, x, badenvs;
+	char grarg[96];
 
 	file = open_exec(filename);
 
@@ -866,6 +1027,27 @@
 	if (IS_ERR(file))
 		return retval;
 
+	if(grsec_enable_execve && current->user) {
+		if(atomic_read(&current->user->processes) > current->rlim[RLIMIT_NPROC].rlim_cur) {
+			security_alert("Attempt to overstep process limit by " DEFAULTSECMSG,
+		       			"proc limit overstep", DEFAULTSECARGS);
+			allow_write_access(file);
+			fput(file);
+			return -EAGAIN;
+    		}
+	}
+
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(file->f_dentry,GR_EXEC,file->f_vfsmnt)) == GR_DENY) ) 
+	{
+		security_alert("denying execution of %.1024s by " DEFAULTSECMSG,
+	                       "file exec attempts", filename, DEFAULTSECARGS);
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+#endif
+
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
 
@@ -886,15 +1068,105 @@
 		return bprm.envc;
 	}
 
+        if (grsec_enable_fd) {
+		bprm.tweak_fd_mask = 0;
+        	bprm.tweak_fd_null = NULL;
+	}
+
 	retval = prepare_binprm(&bprm);
 	if (retval < 0) 
 		goto out; 
 
+	if (grsec_enable_tpe) {
+		if (grsec_enable_tpe_glibc) {
+			if(grsec_enable_tpe_all?current->uid:in_group_p(grsec_tpe_gid)){
+				badenvs = gr_unsetenv(envp,&bprm);
+
+				if(badenvs)
+					security_alert("exec of %.32s by " DEFAULTSECMSG
+						" attempted to use %d malicious environment(s)",
+						"malicious environments", filename, 
+						DEFAULTSECARGS,badenvs);
+			}
+		}
+	/* end of glibc checks */
+		if((current->uid) && in_group_p(grsec_tpe_gid) &&
+		   ((file->f_dentry->d_parent->d_inode->i_uid) ||
+   		   (!(file->f_dentry->d_parent->d_inode->i_uid) &&
+		   ((file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) ||
+		   (file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH))))){
+			security_alert("denied exec of %.32s by " DEFAULTSECMSG
+				" reason: untrusted","denied execs",
+				filename, DEFAULTSECARGS);
+			retval = -EACCES;
+			goto out;
+		} else if(grsec_enable_tpe_all && (current->uid) && 
+			!(((!(file->f_dentry->d_parent->d_inode->i_uid) &&
+			!(file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) &&
+			!(file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH)) ||
+			((file->f_dentry->d_parent->d_inode->i_uid == current->uid) &&
+			!(file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) &&
+			!(file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH))))){
+				security_alert("denied exec of %.32s by " DEFAULTSECMSG
+						" reason: untrusted","denied execs",
+						filename, DEFAULTSECARGS);
+				retval = -EACCES;
+				goto out;
+		}
+	}
+
+	if (grsec_enable_chroot_execlog && proc_is_chrooted(current))
+		printk(KERN_INFO "grsec: exec of %.64s within chroot "
+			"jail (%.32s:%lu) by process " DEFAULTSECMSG "\n",
+			filename,kdevname(current->fs->root->d_inode->i_dev),
+			current->fs->root->d_inode->i_ino, DEFAULTSECARGS);
+	else if ((in_group_p(grsec_audit_gid) && grsec_enable_group && 
+	         grsec_enable_execlog) || (grsec_enable_execlog && !grsec_enable_group)) {
+		memset(&grarg, 0, sizeof(grarg));
+		for(x = 0; x < bprm.argc; x++) {
+			strncat(grarg, argv[x], sizeof(grarg) - strlen(grarg) - 1);
+			if(((strlen(grarg) + 2) < sizeof(grarg)) && (x < bprm.argc - 1))
+				break;
+			strcat(grarg, " ");
+		}
+		printk(KERN_INFO "grsec: exec of [%.32s:%lu] (%.68s) by "
+			DEFAULTSECMSG "\n", kdevname(file->f_dentry->d_inode->i_dev),
+			file->f_dentry->d_inode->i_ino, grarg, DEFAULTSECARGS);
+	}
+
 	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
 	if (retval < 0) 
 		goto out; 
 
 	bprm.exec = bprm.p;
+
+#ifdef CONFIG_GRKERNSEC_ACL
+	if(current->pid < 2) /* Init is the first real process, so its 
+		   		acl lock is NOT initialized on fork.
+			        see its exec in init/main.c 
+			        This also applies to swapper */
+		current->acl_lock = RW_LOCK_UNLOCKED;
+	
+	if(gr_set_proc_label(file->f_dentry,file->f_vfsmnt, filename)) {
+		if(file->f_dentry && file->f_dentry->d_inode)
+			security_alert("could not set acl for [%.32s:%lu]",
+				"acl set failures",
+				kdevname(file->f_dentry->d_inode->i_dev),
+				file->f_dentry->d_inode->i_ino);
+		retval = -EACCES;
+		goto out; 
+	}
+	else if(!grsec_enable_tpe_glibc && current->acl) {
+		badenvs = gr_unsetenv(envp,&bprm);
+		if(badenvs)
+			security_alert("exec of %.32s by " DEFAULTSECMSG 
+					" attempted to use %d malicious environment(s)",
+					"malicious environments", filename, 
+					DEFAULTSECARGS, badenvs);
+	}
+#endif
+
+
 	retval = copy_strings(bprm.envc, envp, &bprm);
 	if (retval < 0) 
 		goto out; 
@@ -904,9 +1176,16 @@
 		goto out; 
 
 	retval = search_binary_handler(&bprm,regs);
-	if (retval >= 0)
+#ifdef CONFIG_GRKERNSEC_ACL
+	/* search_binary_handler ends up calling compute_creds() which sets 
+	   caps initially...bleh...can't have it overwriting our hard work */
+	if(current->acl)
+		gr_set_caps();
+#endif
+	if (retval >= 0) {
 		/* execve success */
 		return retval;
+	}
 
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
@@ -920,6 +1199,12 @@
 			__free_page(page);
 	}
 
+	if(grsec_enable_fd && bprm.tweak_fd_mask) {                                            
+		for(i=0;i<=2;i++)
+            		if(bprm.tweak_fd_mask & (1 << i))
+                		(void)sys_close(i);
+	}
+
 	return retval;
 }
 
@@ -970,7 +1257,11 @@
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
+#ifdef CONFIG_GRKERNSEC_ACL
+	if (do_truncate(file->f_dentry, 0, file->f_vfsmnt) != 0)
+#else
 	if (do_truncate(file->f_dentry, 0) != 0)
+#endif
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
diff -urN linux/fs/namei.c linux/fs/namei.c
--- linux/fs/namei.c	Mon Feb 25 14:38:09 2002
+++ linux/fs/namei.c	Mon Jun  3 21:18:06 2002
@@ -22,10 +22,12 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#include <linux/grsecurity.h>
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
 
+
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
 /* [Feb-1997 T. Schoebel-Theuer]
@@ -343,6 +345,21 @@
 		current->state = TASK_RUNNING;
 		schedule();
 	}
+
+        if(grsec_enable_link && S_ISLNK(dentry->d_inode->i_mode) &&
+	   (dentry->d_parent->d_inode->i_mode & S_ISVTX) &&
+	   dentry->d_parent->d_inode->i_uid != dentry->d_inode->i_uid &&
+	   (dentry->d_parent->d_inode->i_mode & S_IWOTH) &&
+	   current->fsuid != dentry->d_inode->i_uid) {
+		security_alert("not following symlink (%.30s/%.30s) of [%.32s]:%lu owned by %d.%d "
+			"by " DEFAULTSECMSG,"symlinks not followed",
+			dentry->d_parent->d_name.name, dentry->d_name.name,
+			kdevname(dentry->d_inode->i_dev), dentry->d_inode->i_ino,
+			dentry->d_inode->i_uid, dentry->d_inode->i_gid, DEFAULTSECARGS);
+		path_release(nd);
+		return -EACCES;
+        }
+
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
@@ -626,6 +643,21 @@
 		else if (this.len == 2 && this.name[1] == '.')
 			nd->last_type = LAST_DOTDOT;
 return_base:
+#ifdef CONFIG_GRKERNSEC_ACL
+		if( ( (gr_search_file(nd->dentry,GR_FIND,nd->mnt)) == GR_DENY) )
+		{
+			security_alert("attempt to access hidden file "
+			"[%.32s:%lu] by " DEFAULTSECMSG, 
+			"hidden file access attempts",
+			kdevname(nd->dentry->d_inode->i_dev),
+			nd->dentry->d_inode->i_ino,DEFAULTSECARGS);
+			err =  -ENOENT; /*Fake that its not there*/
+			if(dentry != nd->dentry)
+				dput(dentry);
+			path_release(nd);
+			goto return_err;
+		}
+#endif
 		return 0;
 out_dput:
 		dput(dentry);
@@ -956,6 +988,22 @@
 	return error;
 }
 
+
+#ifdef CONFIG_GRKERNSEC_ACL
+
+static __inline__ __u16 to_grflags(const int mode)
+{
+	__u16 retval = 0;
+	if(mode & O_APPEND)
+		retval |= GR_APPEND;
+	else if(mode & FMODE_WRITE)
+		retval |= GR_WRITE;
+	if(mode & FMODE_READ)
+		retval |= GR_READ;
+	return retval;
+}
+#endif
+
 /*
  *	open_namei()
  *
@@ -977,6 +1025,33 @@
 	struct dentry *dentry;
 	struct dentry *dir;
 	int count = 0;
+#ifdef CONFIG_GRKERNSEC_ACL	
+	int gr_flag;
+	
+	if(path_init(pathname,lookup_flags(flag),nd))
+		error = path_walk(pathname,nd);
+	
+	gr_flag = to_grflags(flag);
+	
+	if( !error && nd->dentry->d_inode && 
+			(gr_search_file(nd->dentry,gr_flag,nd->mnt))
+				== GR_DENY)
+	{
+		security_alert("attempt to open %.1024s for %s%s"
+		"by " DEFAULTSECMSG, 	
+		"file open attempts", pathname, gr_flag & GR_READ ? "reading "
+		: "", gr_flag & GR_WRITE ? "writing " : gr_flag & GR_APPEND ?
+		"append " : "",
+		DEFAULTSECARGS);
+		error = -EACCES;
+		goto exit;
+	}
+	if(!error)
+		path_release(nd);
+	else
+		return error;
+#endif
+
 
 	acc_mode = ACC_MODE(flag);
 
@@ -1022,6 +1098,19 @@
 
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
+#ifdef CONFIG_GRKERNSEC_ACL
+		
+		gr_flag |= GR_WRITE; /* Creating a file is
+				      *  write operation 
+				      *  at the least */
+		if((gr_check_create(dentry,nd->dentry,nd->mnt,gr_flag))
+				== GR_DENY)
+		{
+			up(&dir->d_inode->i_sem);
+			error = -EACCES;
+			goto exit_dput;
+		}
+#endif
 		error = vfs_create(dir->d_inode, dentry,
 				   mode & ~current->fs->umask);
 		up(&dir->d_inode->i_sem);
@@ -1032,12 +1121,31 @@
 		/* Don't check for write permission, don't truncate */
 		acc_mode = 0;
 		flag &= ~O_TRUNC;
+#ifdef CONFIG_GRKERNSEC_ACL		
+		gr_handle_create(pathname,nd);
+#endif
 		goto ok;
 	}
 
 	/*
 	 * It already exists.
 	 */
+
+	inode = dentry->d_inode;
+	if (grsec_enable_fifo && S_ISFIFO(inode->i_mode) && !(flag & O_EXCL)
+	    && (dir->d_inode->i_mode & S_ISVTX) &&
+	    (inode->i_uid != dir->d_inode->i_uid) &&
+	    (current->fsuid != inode->i_uid)) {
+		up(&dir->d_inode->i_sem);
+		if(!permission(inode, acc_mode))
+			security_alert("denied writing FIFO (%.32s/%.32s) of %d.%d "
+				"by " DEFAULTSECMSG, "writes into a FIFO denied",
+				dentry->d_parent->d_name.name,dentry->d_name.name,
+				inode->i_uid, inode->i_gid, DEFAULTSECARGS);
+		error = -EACCES;
+		goto exit;
+	}
+
 	up(&dir->d_inode->i_sem);
 
 	error = -EEXIST;
@@ -1127,7 +1236,11 @@
 		if (!error) {
 			DQUOT_INIT(inode);
 			
+#ifdef CONFIG_GRKERNSEC_ACL			
+			error = do_truncate(dentry,0,nd->mnt);
+#else
 			error = do_truncate(dentry, 0);
+#endif
 		}
 		put_write_access(inode);
 		if (error)
@@ -1158,6 +1271,22 @@
 	 * stored in nd->last.name and we will have to putname() it when we
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
+
+	if(grsec_enable_link && S_ISLNK(dentry->d_inode->i_mode) &&
+	  (dentry->d_parent->d_inode->i_mode & S_ISVTX) &&
+	  dentry->d_parent->d_inode->i_uid != dentry->d_inode->i_uid &&
+	  (dentry->d_parent->d_inode->i_mode & S_IWOTH) &&
+	  current->fsuid != dentry->d_inode->i_uid) {
+	  	security_alert("not following symlink (%.30s/%.30s) [%.32s]:%lu of %d.%d "
+			 "by " DEFAULTSECMSG,"symlinks not followed",
+			 dentry->d_parent->d_name.name, dentry->d_name.name, 
+			 kdevname(dentry->d_inode->i_dev), 
+			 dentry->d_inode->i_ino, dentry->d_inode->i_uid,
+			 dentry->d_inode->i_gid, DEFAULTSECARGS);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	UPDATE_ATIME(dentry->d_inode);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
 	dput(dentry);
@@ -1241,6 +1370,7 @@
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	char grdevmode;
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1257,6 +1387,46 @@
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && proc_is_chrooted(current)) {
+		switch (mode & S_IFMT) {
+			case S_IFREG:
+				grdevmode = 'r';
+				break;
+			case S_IFCHR:
+				grdevmode = 'c';
+				break;
+			case S_IFBLK:
+				grdevmode = 'b';
+				break;
+			case S_IFSOCK:
+				grdevmode = 's';
+				break;
+			default:
+				grdevmode = 'u';
+		}
+		security_alert("refused attempt to mknod(%c:%.32s) (%.30s) from chroot() jail (%s:%lu) "
+			       "owned by %d %d by " DEFAULTSECMSG, 
+			       "mknods in chroot denied",grdevmode,kdevname(dev),tmp,
+			       kdevname(current->fs->root->d_inode->i_dev),current->fs->root->d_inode->i_ino,
+			       current->fs->root->d_inode->i_uid,current->fs->root->d_inode->i_gid,
+			       DEFAULTSECARGS);
+		error = -EPERM;
+		dput(dentry);
+		goto out_dput;
+	}
+
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) == GR_DENY) )
+	{
+		security_alert("attempt to mknod %.1024s by "
+				DEFAULTSECMSG, "mknod attempts", filename,
+				DEFAULTSECARGS);
+		error = -EACCES;
+		dput(dentry);
+		goto out_dput;
+	}
+#endif
+	
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
@@ -1270,8 +1440,20 @@
 		default:
 			error = -EINVAL;
 		}
+#ifdef CONFIG_GRKERNSEC_ACL
+		if(!error)
+		{
+			struct nameidata newfile = {
+				dentry : dentry,
+				mnt    : nd.mnt
+			};
+			
+			gr_handle_create(tmp,&newfile);
+		}
+#endif
 		dput(dentry);
 	}
+out_dput:
 	up(&nd.dentry->d_inode->i_sem);
 	path_release(&nd);
 out:
@@ -1324,8 +1506,35 @@
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+#ifdef CONFIG_GRKERNSEC_ACL
+			error = 0;
+
+			if(gr_check_create(dentry,nd.dentry,nd.mnt,GR_WRITE) == 
+					GR_DENY)
+			{
+				security_alert("attempt to mkdir %.1024s by "
+						DEFAULTSECMSG, "mkdir attempts",
+						pathname, DEFAULTSECARGS);
+				error = -EACCES;
+						
+			}
+			if(!error)
+#endif
+
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
+#ifdef CONFIG_GRKERNSEC_ACL
+			if(!error)
+			{
+				struct nameidata temp =
+				{ 
+					dentry : dentry,
+					mnt :    nd.mnt
+				};
+			gr_handle_create(pathname,&temp);
+			}
+#endif
+			
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1407,6 +1616,10 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+#ifdef CONFIG_GRKERNSEC_ACL
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
+#endif
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1432,7 +1645,30 @@
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
-		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = 0;
+		if(dentry->d_inode)
+		{
+			saved_ino = dentry->d_inode->i_ino;
+			saved_dev = dentry->d_inode->i_dev;
+		}
+		if( ( (gr_search_file(dentry,GR_WRITE,nd.mnt)) == GR_DENY))
+		{
+			security_alert("attempt to rmdir %.1024s by "
+					DEFAULTSECMSG, "rmdir attempts",
+					pathname,
+					DEFAULTSECARGS);
+			error = -EACCES;
+		}
+		if(!error)
+		{
+#endif
+			error = vfs_rmdir(nd.dentry->d_inode, dentry);
+#ifdef CONFIG_GRKERNSEC_ACL
+			if(!error && (saved_dev || saved_ino))
+				gr_handle_delete(saved_ino,saved_dev);
+		}
+#endif
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1476,6 +1712,10 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+#ifdef CONFIG_GRKERNSEC_ACL
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
+#endif
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1495,7 +1735,31 @@
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
-		error = vfs_unlink(nd.dentry->d_inode, dentry);
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = 0;
+		if(dentry->d_inode)
+		{
+			saved_ino = dentry->d_inode->i_ino;
+			saved_dev = dentry->d_inode->i_dev;
+		}
+		if( ( (gr_search_file(dentry,GR_WRITE, nd.mnt)) == GR_DENY)) 
+		{
+		security_alert("attempt to unlink %.1024s by " DEFAULTSECMSG,
+				"unlink attempts",
+                		name, DEFAULTSECARGS);
+			error = -EACCES;
+		}
+		if(!error)
+		{
+#endif
+			error = vfs_unlink(nd.dentry->d_inode, dentry);
+#ifdef CONFIG_GRKERNSEC_ACL
+		}
+		if(!error && (saved_ino || saved_dev))
+		{
+			gr_handle_delete(saved_ino,saved_dev);
+		}
+#endif
 	exit2:
 		dput(dentry);
 	}
@@ -1560,7 +1824,21 @@
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
+#ifdef CONFIG_GRKERNSEC_ACL
+			error = 0;
+			if( gr_search_file(nd.dentry,GR_WRITE,nd.mnt)
+					== GR_DENY)
+			{
+				security_alert("attempt to symlink %.1024s"
+					   "to %.1024s by " DEFAULTSECMSG,
+					   "symlink attempts",
+					from, to, DEFAULTSECARGS);
+				error = -EACCES;
+			}
+
+			if(!error)	
+#endif
+				error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1651,6 +1929,31 @@
 		new_dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
+			error = 0;
+			if(grsec_enable_link && current->fsuid != old_nd.dentry->d_inode->i_uid &&
+		  	   (!S_ISREG(old_nd.dentry->d_inode->i_mode) ||
+		  	   (old_nd.dentry->d_inode->i_mode & S_ISUID) ||
+	          	   ((old_nd.dentry->d_inode->i_mode & (S_ISGID | S_IXGRP)) == 
+		  	   (S_ISGID | S_IXGRP)) || (permission(old_nd.dentry->d_inode,
+		  	   MAY_READ | MAY_WRITE))) && !capable(CAP_FOWNER) && current->uid) {
+				security_alert("denied hardlink of %.30s (owned by %d.%d) to %.30s for "
+						DEFAULTSECMSG, "denied hardlinks",oldname,old_nd.dentry->d_inode->i_uid,
+						old_nd.dentry->d_inode->i_gid,newname,DEFAULTSECARGS);
+				error = -EPERM;
+			}
+			if(!error)
+#ifdef CONFIG_GRKERNSEC_ACL
+			if( gr_search_file(old_nd.dentry,GR_WRITE,old_nd.mnt) 
+					== GR_DENY || gr_search_file(nd.dentry,
+						GR_WRITE,nd.mnt) == GR_DENY)
+			{
+				security_alert("attempt to link %.1024s to %.1024s by " 
+                                	DEFAULTSECMSG, "attempted links", oldname, newname,
+					DEFAULTSECARGS);
+				error = -EPERM;
+			}
+			if(!error)
+#endif
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
 			dput(new_dentry);
 		}
@@ -1889,10 +2192,42 @@
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+	error = 0;
+	if(!new_dentry->d_inode)
+	{
+		if(gr_check_create(new_dentry,newnd.dentry,newnd.mnt,GR_WRITE)
+				== GR_DENY || gr_search_file(old_dentry,
+					GR_WRITE,oldnd.mnt) == GR_DENY) 
+		{
+			security_alert("attempt to rename %.1024s to %.1024s "
+					"by " DEFAULTSECMSG, "rename attempts",
+					oldname,newname,DEFAULTSECARGS);
+			error = -EACCES;
+		}
+	}
+				
+	else if( gr_search_file(old_dentry,GR_WRITE,oldnd.mnt) == GR_DENY
+			|| gr_search_file(new_dir,GR_WRITE,newnd.mnt)
+			== GR_DENY) 
+	{
+		security_alert("attempt to rename %.1024s to %.1024s by " 
+                                DEFAULTSECMSG, "rename attempts", 
+				oldname, newname,
+				DEFAULTSECARGS);
+		error = -EACCES;
+	}
+	if(!error) {
+#endif
+
+
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
+#ifdef CONFIG_GRKERNSEC_ACL
+	}
+#endif
 
 	dput(new_dentry);
 exit4:
diff -urN linux/fs/namespace.c linux/fs/namespace.c
--- linux/fs/namespace.c	Mon Feb 25 14:38:09 2002
+++ linux/fs/namespace.c	Mon Jun  3 21:18:06 2002
@@ -16,6 +16,8 @@
 #include <linux/acct.h>
 #include <linux/module.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -327,6 +329,10 @@
 		if (!(sb->s_flags & MS_RDONLY)) {
 			lock_kernel();
 			retval = do_remount_sb(sb, MS_RDONLY, 0);
+
+			if(grsec_enable_mount && (retval >= 0))
+				printk(KERN_INFO "grsec: remount of %.30s by " DEFAULTSECMSG "\n",mnt->mnt_devname, DEFAULTSECARGS);
+
 			unlock_kernel();
 		}
 		up_write(&sb->s_umount);
@@ -353,6 +359,10 @@
 	}
 	spin_unlock(&dcache_lock);
 	up(&mount_sem);
+
+	if(grsec_enable_mount && (retval >= 0))
+		printk(KERN_INFO "grsec: unmount of %.30s by " DEFAULTSECMSG "\n",mnt->mnt_devname, DEFAULTSECARGS);
+
 	return retval;
 }
 
@@ -735,6 +745,17 @@
 	if (retval)
 		return retval;
 
+	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+		security_alert("denied attempt to mount (%.30s) as %.64s from chroot jail (%.32s:%lu) "
+			"of %d.%d by " DEFAULTSECMSG, "denied mounts in chroot",
+			dev_name,dir_name, kdevname(current->fs->root->d_inode->i_dev),
+			current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		retval = -EPERM;
+		path_release(&nd);
+		return retval;
+	}
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -746,6 +767,10 @@
 		retval = do_add_mount(&nd, type_page, flags, mnt_flags,
 				      dev_name, data_page);
 	path_release(&nd);
+
+	if(grsec_enable_mount && (retval >= 0))
+		printk(KERN_INFO "grsec: mount %.30s to %.64s by " DEFAULTSECMSG "\n",dev_name,dir_name, DEFAULTSECARGS);
+
 	return retval;
 }
 
@@ -835,6 +860,15 @@
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+
+	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+		security_alert("denied attempt to pivot_root(%.30s,%.30s) from chroot jail (%.32s:%lu) "
+			"of %d.%d by " DEFAULTSECMSG, "denied pivot_roots in chroot",
+			new_root,put_old, kdevname(current->fs->root->d_inode->i_dev),
+			current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		return -EPERM;
+	}
 
 	lock_kernel();
 
diff -urN linux/fs/open.c linux/fs/open.c
--- linux/fs/open.c	Fri Oct 12 16:48:42 2001
+++ linux/fs/open.c	Mon Jun  3 21:18:06 2002
@@ -15,11 +15,29 @@
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/iobuf.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
+
+
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
+#ifdef CONFIG_GRKERNSEC_ACL
+static int conv_flags(int p) 
+{
+	int retval = LOOKUP_FOLLOW|LOOKUP_POSITIVE;
+	if(p & O_NOFOLLOW)
+		retval &= ~LOOKUP_FOLLOW;
+	if( (p & (O_CREAT|O_EXCL)) == (O_CREAT | O_EXCL))
+		retval &= ~LOOKUP_FOLLOW;
+	if(p & O_DIRECTORY)
+		retval |= LOOKUP_DIRECTORY;
+	return retval;
+}
+#endif
+
+
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
 	int retval = -ENODEV;
@@ -71,7 +89,11 @@
 	return error;
 }
 
+#ifdef CONFIG_GRKERNSEC_ACL
+int do_truncate(struct dentry *dentry, loff_t length, struct vfsmount *mnt)
+#else
 int do_truncate(struct dentry *dentry, loff_t length)
+#endif
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
@@ -81,6 +103,17 @@
 	if (length < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(dentry,GR_WRITE,mnt)) == GR_DENY)) {
+		security_alert("attempted to truncate file [%.32s:%lu] by "
+			DEFAULTSECMSG, "file truncate attempts",
+			kdevname(dentry->d_inode->i_dev),
+			dentry->d_inode->i_ino, DEFAULTSECARGS);
+		return -EACCES;
+	}
+#endif
+
+
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
@@ -139,7 +172,11 @@
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = do_truncate(nd.dentry, length, nd.mnt);
+#else
 		error = do_truncate(nd.dentry, length);
+#endif
 	}
 	put_write_access(inode);
 
@@ -191,7 +228,11 @@
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = do_truncate(dentry, length, file->f_vfsmnt);
+#else
 		error = do_truncate(dentry, length);
+#endif
 out_putf:
 	fput(file);
 out:
@@ -245,6 +286,20 @@
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+       if( ( (gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) == GR_DENY))
+       {
+               security_alert("attempted to change access time for file "  
+               		"[%.32s:%lu] by " DEFAULTSECMSG,
+			"file access time change attempts",
+               		kdevname(nd.dentry->d_inode->i_dev),
+			nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+	       error = -EACCES;
+	       goto dput_and_out;
+       }
+#endif
+
+
 	/* Don't worry, the checks are done in inode_change_ok() */
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (times) {
@@ -290,6 +345,20 @@
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+       if( ( (gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) == GR_DENY))
+       {
+               security_alert("attempted to change access time for file "
+                	"[%.32s:%lu] by " DEFAULTSECMSG,
+			"file access time change attempts",
+			kdevname(nd.dentry->d_inode->i_dev),
+               		nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+                error = -EACCES;
+		goto dput_and_out;
+       }
+#endif
+
+
 	/* Don't worry, the checks are done in inode_change_ok() */
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (utimes) {
@@ -341,11 +410,26 @@
 
 	res = user_path_walk(filename, &nd);
 	if (!res) {
+
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+#ifdef CONFIG_GRKERNSEC_ACL
+		
+	       if( !res && ( (gr_search_file(nd.dentry,GR_READ,nd.mnt))
+				       == GR_DENY)) 
+       		{
+               		security_alert("attempted to access file [%.32s:%lu] "
+               			"by " DEFAULTSECMSG, "file access attempts",
+				kdevname(nd.dentry->d_inode->i_dev),
+				nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+               		path_release(&nd);
+               		res =  -EACCES;
+       		}
+#endif
+
 		path_release(&nd);
 	}
 
@@ -378,6 +462,22 @@
 	if (error)
 		goto dput_and_out;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+       if( ( (gr_search_file(nd.dentry,GR_READ,nd.mnt)) == GR_DENY)) 
+       {
+               security_alert("Attempted to chdir to directory [%.32s:%lu]"
+               		"by " DEFAULTSECMSG, "chdir attempts",
+			kdevname(nd.dentry->d_inode->i_dev),
+			nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+               error = -EACCES;
+               goto dput_and_out;
+       }
+#endif
+
+	if((grsec_enable_group && in_group_p(grsec_audit_gid) && 
+	   grsec_enable_chdir) || (grsec_enable_chdir && !grsec_enable_group))
+		printk(KERN_INFO "grsec: chdir(\"%.64s\") by " DEFAULTSECMSG "\n", filename, DEFAULTSECARGS);
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -408,6 +508,33 @@
 		goto out_putf;
 
 	error = permission(inode, MAY_EXEC);
+
+	if(!error && grsec_enable_chroot_fchdir && proc_is_chrooted(current) && 
+	   ((file->f_vfsmnt->mnt_root->d_inode->i_dev != current->fs->root->d_inode->i_dev) ||
+	   (file->f_vfsmnt->mnt_root->d_inode->i_ino != current->fs->root->d_inode->i_ino))) {
+		security_alert("Attempted fchdir outside of chroot to %.16s by "
+				DEFAULTSECMSG, "attempted fchdirs",
+				file->f_dentry->d_name.name, DEFAULTSECARGS);
+		error = -EACCES;
+	}
+
+#ifdef CONFIG_GRKERNSEC_ACL
+       if(!error && ((gr_search_file(file->f_dentry,GR_READ,file->f_vfsmnt))
+			       == GR_DENY)) 
+       {
+               security_alert("attempted to fchdir to directory [%.32s:%lu]"
+               			"by " DEFAULTSECMSG, 
+				"fchdir attempts",
+			kdevname(file->f_dentry->d_inode->i_dev),
+                        file->f_dentry->d_inode->i_ino, DEFAULTSECARGS);
+               error = -EACCES;
+       }
+#endif
+
+	if(!error && ((grsec_enable_group && in_group_p(grsec_audit_gid) && 
+	   grsec_enable_chdir) || (grsec_enable_chdir && !grsec_enable_group)))
+		printk(KERN_INFO "grsec: fchdir(%d) to %.64s by " DEFAULTSECMSG "\n", fd, dentry->d_name.name, DEFAULTSECARGS);
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -442,8 +569,26 @@
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+	if(grsec_enable_chroot_double && proc_is_chrooted(current)) {
+		security_alert("denied attempt to chroot() from (%.32s:%lu) to (%.30s)"
+			       ", process " DEFAULTSECMSG, "double chroot() denied",
+			       kdevname(current->fs->root->d_inode->i_dev),
+			       current->fs->root->d_inode->i_ino,name, DEFAULTSECARGS);
+			goto dput_and_out;
+	}
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
+
+	if(grsec_enable_chroot_caps && proc_is_chrooted(current) && (current->pid > 1)) {
+		cap_drop(current->cap_permitted,GR_CHROOT_CAPS);
+		cap_drop(current->cap_inheritable,GR_CHROOT_CAPS);
+		cap_drop(current->cap_effective,GR_CHROOT_CAPS);
+	}
+
+	if (grsec_enable_chroot_chdir)
+		set_fs_pwd(current->fs, nd.mnt, nd.dentry);
+
 	error = 0;
 dput_and_out:
 	path_release(&nd);
@@ -472,8 +617,36 @@
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(dentry,GR_WRITE,file->f_vfsmnt)) == GR_DENY))
+	{
+		security_alert("Attempt to fchmod program [%.32s:%lu]"
+			"by " DEFAULTSECMSG, "fchmod attempts",
+			kdevname(dentry->d_inode->i_dev),
+                        dentry->d_inode->i_ino,DEFAULTSECARGS);
+
+		err = -EACCES;
+		goto out_putf;
+	}
+#endif
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if(grsec_enable_chroot_chmod && ((mode & S_ISUID) || (mode & S_ISGID))
+	   && proc_is_chrooted(current)) {
+		security_alert("denied attempt to fchmod +s (%.32s:%lu) owned by %d.%d to mode 0%07o "
+			   "from chroot jail (%.32s:%lu) of %d.%d by "
+			   DEFAULTSECMSG, "denied fchmod +s in chroot",
+			   kdevname(inode->i_dev),inode->i_ino,inode->i_uid,inode->i_gid,mode,
+			   kdevname(current->fs->root->d_inode->i_dev),current->fs->root->d_inode->i_ino,
+			   current->fs->root->d_inode->i_uid,current->fs->root->d_inode->i_gid,
+			   DEFAULTSECARGS);
+		err = -EPERM;
+		goto out_putf;
+	}	    
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	err = notify_change(dentry, &newattrs);
@@ -504,8 +677,34 @@
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) == GR_DENY)) 
+	{
+		security_alert("Attempt to chmod file %1024s by "
+				DEFAULTSECMSG, "chmod attempts",
+                	        filename, DEFAULTSECARGS); 
+		error = -EACCES;
+		goto dput_and_out;
+	}
+#endif
+
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (grsec_enable_chroot_chmod && ((mode & S_ISUID) || (mode & S_ISGID))
+	    && proc_is_chrooted(current)) {
+		security_alert("denied attempt to chmod +s (%.32s:%lu) (%.30s) owned by %d.%d to mode 0%07o "
+			   "from chroot jail (%.32s:%lu) of %d.%d by "
+			   DEFAULTSECMSG,"denied chmod +s in chroot",
+			   kdevname(inode->i_dev),inode->i_ino,filename,inode->i_uid,inode->i_gid,
+			   mode,kdevname(current->fs->root->d_inode->i_dev),
+			   current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			   current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		    error = -EPERM;
+		    goto dput_and_out;
+	}
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	error = notify_change(nd.dentry, &newattrs);
@@ -516,7 +715,11 @@
 	return error;
 }
 
+#ifdef CONFIG_GRKERNSEC_ACL
+static int chown_common(struct dentry * dentry, uid_t user, gid_t group, struct vfsmount *mnt)
+#else
 static int chown_common(struct dentry * dentry, uid_t user, gid_t group)
+#endif
 {
 	struct inode * inode;
 	int error;
@@ -533,6 +736,19 @@
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( ( (gr_search_file(dentry,GR_WRITE,mnt)) == GR_DENY))
+	{
+		security_alert("Attempt to chown file [%.32s:%lu] "
+			"to %d.%d by " DEFAULTSECMSG, "chown attempts",
+			kdevname(dentry->d_inode->i_dev),
+			dentry->d_inode->i_ino,
+			user, group, DEFAULTSECARGS);
+		error = -EACCES;
+		goto out;
+	}
+#endif
+
 	if (user == (uid_t) -1)
 		user = inode->i_uid;
 	if (group == (gid_t) -1)
@@ -583,7 +799,11 @@
 
 	error = user_path_walk(filename, &nd);
 	if (!error) {
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = chown_common(nd.dentry, user, group, nd.mnt);
+#else
 		error = chown_common(nd.dentry, user, group);
+#endif
 		path_release(&nd);
 	}
 	return error;
@@ -596,7 +816,11 @@
 
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = chown_common(nd.dentry, user, group, nd.mnt);
+#else
 		error = chown_common(nd.dentry, user, group);
+#endif
 		path_release(&nd);
 	}
 	return error;
@@ -610,7 +834,12 @@
 
 	file = fget(fd);
 	if (file) {
+#ifdef CONFIG_GRKERNSEC_ACL
+		error = chown_common(file->f_dentry, user,
+				group, file->f_vfsmnt);
+#else
 		error = chown_common(file->f_dentry, user, group);
+#endif
 		fput(file);
 	}
 	return error;
@@ -632,8 +861,11 @@
  */
 struct file *filp_open(const char * filename, int flags, int mode)
 {
-	int namei_flags, error;
+	int namei_flags, error = 0;
 	struct nameidata nd;
+#ifdef CONFIG_GRKERNSEC_ACL
+	struct nameidata test;
+#endif
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -641,6 +873,28 @@
 	if (namei_flags & O_TRUNC)
 		namei_flags |= 2;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+	if( (path_init(filename,conv_flags(namei_flags),&test)) )
+		error = path_walk(filename,&test);
+	if((gr_status & GR_READY) && !error 
+			&& S_ISBLK(test.dentry->d_inode->i_mode) 
+			&& !capable(CAP_SYS_RAWIO)) 
+		{
+			security_alert("Attempt to open block device "
+				"[%.32s:%lu] with "
+				"insuffificent capabilities by process "
+		        	DEFAULTSECMSG,
+				"attempt to access block devices",
+				kdevname(test.dentry->d_inode->i_dev),
+				test.dentry->d_inode->i_ino,
+				DEFAULTSECARGS);
+			error = -EACCES;
+			path_release(&test);
+			return ERR_PTR(error);
+		}
+	if(!error)
+		path_release(&test);
+#endif
 	error = open_namei(filename, namei_flags, mode, &nd);
 	if (!error)
 		return dentry_open(nd.dentry, nd.mnt, flags);
diff -urN linux/fs/proc/base.c linux/fs/proc/base.c
--- linux/fs/proc/base.c	Mon Feb 25 14:38:09 2002
+++ linux/fs/proc/base.c	Mon Jun  3 21:18:06 2002
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/file.h>
 #include <linux/string.h>
+#include <linux/grsecurity.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -669,7 +670,11 @@
 	inode->i_gid = 0;
 	if (ino == PROC_PID_INO || task_dumpable(task)) {
 		inode->i_uid = task->euid;
+#ifndef CONFIG_GRKERNSEC_PROC_USERGROUP
 		inode->i_gid = task->egid;
+#else
+		inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#endif
 	}
 
 out:
@@ -972,13 +977,28 @@
 	if (!task)
 		goto out;
 
+#ifdef CONFIG_GRKERNSEC_ACL
+		if(gr_check_hidden_task(task))
+		{
+			free_task_struct(task);
+			goto out;
+		}
+#endif
+
+
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
 
 	free_task_struct(task);
 
 	if (!inode)
 		goto out;
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP;
+#else
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
+#endif
 	inode->i_op = &proc_base_inode_operations;
 	inode->i_fop = &proc_base_operations;
 	inode->i_nlink = 3;
@@ -1018,8 +1038,13 @@
 		int pid = p->pid;
 		if (!pid)
 			continue;
+#ifdef CONFIG_GRKERNSEC_ACL
+			if(gr_check_hidden_task(p)) 
+				continue;
+#endif
 		if (--index >= 0)
 			continue;
+
 		pids[nr_pids] = pid;
 		nr_pids++;
 		if (nr_pids >= PROC_MAXPIDS)
diff -urN linux/fs/proc/generic.c linux/fs/proc/generic.c
--- linux/fs/proc/generic.c	Fri Sep  7 13:53:59 2001
+++ linux/fs/proc/generic.c	Mon Jun  3 21:18:06 2002
@@ -491,6 +491,22 @@
 	return ent;
 }
 
+#ifdef CONFIG_GRKERNSEC_PROC
+struct proc_dir_entry *proc_priv_mkdir(const char *name, mode_t mode, struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry *ent;
+
+	ent = proc_create(&parent, name, mode, 2);
+	if (ent) {
+		ent->proc_fops = &proc_dir_operations;
+		ent->proc_iops = &proc_dir_inode_operations;
+
+		proc_register(parent, ent);
+	}
+	return ent;
+}
+#endif
+
 struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,
 					 struct proc_dir_entry *parent)
 {
diff -urN linux/fs/proc/inode.c linux/fs/proc/inode.c
--- linux/fs/proc/inode.c	Sat Nov 17 14:24:32 2001
+++ linux/fs/proc/inode.c	Mon Jun  3 21:18:06 2002
@@ -152,7 +152,11 @@
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+			inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 			inode->i_gid = de->gid;
+#endif
 		}
 		if (de->size)
 			inode->i_size = de->size;
diff -urN linux/fs/proc/proc_misc.c linux/fs/proc/proc_misc.c
--- linux/fs/proc/proc_misc.c	Wed Nov 21 00:29:09 2001
+++ linux/fs/proc/proc_misc.c	Mon Jun  3 21:18:06 2002
@@ -507,39 +507,93 @@
 		{"meminfo",	meminfo_read_proc},
 		{"version",	version_read_proc},
 #ifdef CONFIG_MODULES
+#ifndef CONFIG_GRKERNSEC_PROC
 		{"modules",	modules_read_proc},
 #endif
+#endif
 		{"stat",	kstat_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"devices",	devices_read_proc},
+#endif
 		{"partitions",	partitions_read_proc},
 #if !defined(CONFIG_ARCH_S390)
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"interrupts",	interrupts_read_proc},
 #endif
+#endif
 		{"filesystems",	filesystems_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"dma",		dma_read_proc},
 		{"ioports",	ioports_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#endif
 #ifdef CONFIG_SGI_DS1286
 		{"rtc",		ds1286_read_proc},
 #endif
 		{"locks",	locks_read_proc},
 		{"swaps",	swaps_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"iomem",	memory_read_proc},
+#endif
 		{"execdomains",	execdomains_read_proc},
 		{NULL,}
 	};
 	for (p = simple_ones; p->name; p++)
 		create_proc_read_entry(p->name, 0, NULL, p->read_proc, NULL);
 
+#if defined(CONFIG_GRKERNSEC_PROC) && defined(CONFIG_MODULES)
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	create_proc_read_entry("modules", S_IRUSR, NULL, &modules_read_proc, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	create_proc_read_entry("modules", S_IRUSR | S_IRGRP, NULL, &modules_read_proc, NULL);
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	create_proc_read_entry("devices", S_IRUSR, NULL, &devices_read_proc, NULL);
+	create_proc_read_entry("dma", S_IRUSR, NULL, &dma_read_proc, NULL);
+	create_proc_read_entry("ioports", S_IRUSR, NULL, &ioports_read_proc, NULL);
+	create_proc_read_entry("cmdline", S_IRUSR, NULL, &cmdline_read_proc, NULL);
+	create_proc_read_entry("iomem", S_IRUSR, NULL, &memory_read_proc, NULL);
+#if !defined(CONFIG_ARCH_S390)
+	create_proc_read_entry("interrupts", S_IRUSR, NULL, &interrupts_read_proc, NULL);
+#endif
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	create_proc_read_entry("devices", S_IRUSR | S_IRGRP, NULL, &devices_read_proc, NULL);
+	create_proc_read_entry("dma", S_IRUSR | S_IRGRP, NULL, &dma_read_proc, NULL);
+	create_proc_read_entry("ioports", S_IRUSR | S_IRGRP, NULL, &ioports_read_proc, NULL);
+	create_proc_read_entry("cmdline", S_IRUSR | S_IRGRP, NULL, &cmdline_read_proc, NULL);
+	create_proc_read_entry("iomem", S_IRUSR | S_IRGRP, NULL, &memory_read_proc, NULL);
+#if !defined(CONFIG_ARCH_S390)
+	create_proc_read_entry("interrupts", S_IRUSR | S_IRGRP, NULL, &interrupts_read_proc, NULL);
+#endif
+#endif
+#endif
 	/* And now for trickier ones */
 	entry = create_proc_entry("kmsg", S_IRUSR, &proc_root);
 	if (entry)
 		entry->proc_fops = &proc_kmsg_operations;
 	create_seq_entry("mounts", 0, &proc_mounts_operations);
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	create_seq_entry("cpuinfo", S_IRUSR, &proc_cpuinfo_operations);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	create_seq_entry("cpuinfo", S_IRUSR | S_IRGRP, &proc_cpuinfo_operations);
+#endif
+#else
 	create_seq_entry("cpuinfo", 0, &proc_cpuinfo_operations);
+#endif
+
 #ifdef CONFIG_MODULES
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	create_seq_entry("ksyms", S_IRUSR, &proc_ksyms_operations);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	create_seq_entry("ksyms", S_IRUSR | S_IRGRP, &proc_ksyms_operations);
+#else
 	create_seq_entry("ksyms", 0, &proc_ksyms_operations);
 #endif
+#endif
 	proc_root_kcore = create_proc_entry("kcore", S_IRUSR, NULL);
 	if (proc_root_kcore) {
 		proc_root_kcore->proc_fops = &proc_kcore_operations;
@@ -561,7 +615,15 @@
 			entry->proc_fops = &ppc_htab_operations;
 	}
 #endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	entry = create_proc_read_entry("slabinfo", S_IWUSR | S_IRUSR, NULL,
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	entry = create_proc_read_entry("slabinfo", S_IWUSR | S_IRUSR | S_IRGRP, NULL,
+#endif
+#else
 	entry = create_proc_read_entry("slabinfo", S_IWUSR | S_IRUGO, NULL,
+#endif
 				       slabinfo_read_proc, NULL);
 	if (entry)
 		entry->write_proc = slabinfo_write_proc;
diff -urN linux/fs/proc/proc_tty.c linux/fs/proc/proc_tty.c
--- linux/fs/proc/proc_tty.c	Fri Apr 21 18:17:57 2000
+++ linux/fs/proc/proc_tty.c	Mon Jun  3 21:18:06 2002
@@ -174,7 +174,13 @@
 	if (!proc_mkdir("tty", 0))
 		return;
 	proc_tty_ldisc = proc_mkdir("tty/ldisc", 0);
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_tty_driver = proc_priv_mkdir("tty/driver", S_IFDIR|S_IRUSR|S_IXUSR, 0);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_tty_driver = proc_priv_mkdir("tty/driver", S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP, 0);
+#else
 	proc_tty_driver = proc_mkdir("tty/driver", 0);
+#endif
 
 	create_proc_read_entry("tty/ldiscs", 0, 0, tty_ldiscs_read_proc,NULL);
 	create_proc_read_entry("tty/drivers", 0, 0, tty_drivers_read_proc,NULL);
diff -urN linux/fs/proc/root.c linux/fs/proc/root.c
--- linux/fs/proc/root.c	Sat Oct 20 22:14:42 2001
+++ linux/fs/proc/root.c	Mon Jun  3 21:18:06 2002
@@ -37,13 +37,25 @@
 		return;
 	}
 	proc_misc_init();
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_net = proc_priv_mkdir("net", S_IFDIR|S_IRUSR|S_IXUSR, 0);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_net = proc_priv_mkdir("net", S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP, 0);
+#else
 	proc_net = proc_mkdir("net", 0);
+#endif
 #ifdef CONFIG_SYSVIPC
 	proc_mkdir("sysvipc", 0);
 #endif
 #ifdef CONFIG_SYSCTL
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_sys_root = proc_priv_mkdir("sys", S_IFDIR|S_IRUSR|S_IXUSR, 0);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_sys_root = proc_priv_mkdir("sys", S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP, 0);
+#else
 	proc_sys_root = proc_mkdir("sys", 0);
 #endif
+#endif
 #if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)
 	proc_mkdir("sys/fs", 0);
 	proc_mkdir("sys/fs/binfmt_misc", 0);
@@ -61,7 +73,16 @@
 #ifdef CONFIG_PPC_RTAS
 	proc_rtas_init();
 #endif
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	proc_bus = proc_priv_mkdir("bus", S_IFDIR|S_IRUSR|S_IXUSR, 0);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	proc_bus = proc_priv_mkdir("bus", S_IFDIR|S_IRUSR|S_IXUSR|S_IXGRP|S_IRGRP, 0);
+#endif
+#else
 	proc_bus = proc_mkdir("bus", 0);
+#endif
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry)
diff -urN linux/fs/readdir.c linux/fs/readdir.c
--- linux/fs/readdir.c	Sun Aug 12 17:59:08 2001
+++ linux/fs/readdir.c	Mon Jun  3 21:18:06 2002
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/file.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -120,6 +121,9 @@
 struct readdir_callback {
 	struct old_linux_dirent * dirent;
 	int count;
+#ifdef CONFIG_GRKERNSEC_ACL
+	struct nameidata nd;
+#endif
 };
 
 static int fillonedir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -127,9 +131,26 @@
 {
 	struct readdir_callback * buf = (struct readdir_callback *) __buf;
 	struct old_linux_dirent * dirent;
+#ifdef CONFIG_GRKERNSEC_ACL
+	ino_t old_ino;
+#endif
 
 	if (buf->count)
 		return -EINVAL;
+#ifdef CONFIG_GRKERNSEC_ACL
+	if(buf->nd.dentry->d_inode)
+	{
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+	if( gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt) == GR_DENY)
+	{
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+		return 0;
+	}
+	buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+#endif
+	    
 	buf->count++;
 	dirent = buf->dirent;
 	put_user(ino, &dirent->d_ino);
@@ -153,6 +174,10 @@
 
 	buf.count = 0;
 	buf.dirent = dirent;
+#ifdef CONFIG_GRKERNSEC_ACL
+	buf.nd.dentry = file->f_dentry;
+	buf.nd.mnt = file->f_vfsmnt;
+#endif
 
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (error >= 0)
@@ -181,6 +206,9 @@
 	struct linux_dirent * previous;
 	int count;
 	int error;
+#ifdef CONFIG_GRKERNSEC_ACL
+	struct nameidata nd;
+#endif
 };
 
 static int filldir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -189,10 +217,26 @@
 	struct linux_dirent * dirent;
 	struct getdents_callback * buf = (struct getdents_callback *) __buf;
 	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
+#ifdef CONFIG_GRKERNSEC_ACL
+	ino_t old_ino;
+#endif
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+#ifdef CONFIG_GRKERNSEC_ACL
+	if(buf->nd.dentry && buf->nd.dentry->d_inode)
+	{
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+	if( gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt) == GR_DENY) 
+	{
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+		return 0;
+	}
+	buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+#endif
 	dirent = buf->previous;
 	if (dirent)
 		put_user(offset, &dirent->d_off);
@@ -224,6 +268,10 @@
 	buf.previous = NULL;
 	buf.count = count;
 	buf.error = 0;
+#ifdef CONFIG_GRKERNSEC_ACL
+	buf.nd.dentry = file->f_dentry;
+	buf.nd.mnt = file->f_vfsmnt;
+#endif
 
 	error = vfs_readdir(file, filldir, &buf);
 	if (error < 0)
@@ -259,6 +307,9 @@
 	struct linux_dirent64 * previous;
 	int count;
 	int error;
+#ifdef CONFIG_GRKERNSEC_ACL
+	struct nameidata nd;
+#endif
 };
 
 static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,
@@ -268,9 +319,28 @@
 	struct getdents_callback64 * buf = (struct getdents_callback64 *) __buf;
 	int reclen = ROUND_UP64(NAME_OFFSET(dirent) + namlen + 1);
 
+#ifdef CONFIG_GRKERNSEC_ACL
+	ino_t old_ino;
+#endif
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+#ifdef CONFIG_GRKERNSEC_ACL
+	if(buf->nd.dentry->d_inode)
+	{
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+		if((gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt)) 
+				== GR_DENY) {
+			buf->nd.dentry->d_inode->i_ino = old_ino;
+			return 0;
+		}
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+#endif
+
+
+	
 	dirent = buf->previous;
 	if (dirent) {
 		d.d_off = offset;
@@ -307,6 +377,11 @@
 	buf.previous = NULL;
 	buf.count = count;
 	buf.error = 0;
+#ifdef CONFIG_GRKERNSEC_ACL
+	buf.nd.mnt = file->f_vfsmnt;
+	buf.nd.dentry = file->f_dentry;
+#endif
+
 
 	error = vfs_readdir(file, filldir64, &buf);
 	if (error < 0)
diff -urN linux/grsecurity/Config.in linux/grsecurity/Config.in
--- linux/grsecurity/Config.in	Wed Dec 31 19:00:00 1969
+++ linux/grsecurity/Config.in	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,297 @@
+choice 'Security level' \
+        "Low		CONFIG_GRKERNSEC_LOW \
+         Medium		CONFIG_GRKERNSEC_MID \
+         High		CONFIG_GRKERNSEC_HI \
+	  Customized	CONFIG_GRKERNSEC_CUSTOM" Customized
+if [ "$CONFIG_GRKERNSEC_LOW" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_RANDSRC n
+define_bool CONFIG_GRKERNSEC_RANDRPC n
+define_bool CONFIG_GRKERNSEC_RANDPING n
+define_bool CONFIG_GRKERNSEC_FORKFAIL n
+define_bool CONFIG_GRKERNSEC_TIME n
+define_bool CONFIG_GRKERNSEC_SIGNAL n
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE n
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT n
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD n
+define_bool CONFIG_GRKERNSEC_PROC n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP n
+fi
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_ACL n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR n
+define_bool CONFIG_GRKERNSEC_CHROOT_SIG n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP n
+define_bool CONFIG_GRKERNSEC_PAX n
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT n
+define_bool CONFIG_GRKERNSEC_CHROOT_PTRACE n
+define_bool CONFIG_GRKERNSEC_AUDIT_PTRACE n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_PTRACE n
+define_bool CONFIG_GRKERNSEC_PTRACE_GROUP n
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_FD n
+define_bool CONFIG_GRKERNSEC_KBMAP y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+fi
+if [ "$CONFIG_GRKERNSEC_MID" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_ACL n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_SIG n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX n
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT n
+define_bool CONFIG_GRKERNSEC_CHROOT_PTRACE n
+define_bool CONFIG_GRKERNSEC_AUDIT_PTRACE n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_PTRACE n
+define_bool CONFIG_GRKERNSEC_PTRACE_GROUP n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_FD n
+define_bool CONFIG_GRKERNSEC_KBMAP y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_RANDSRC y
+define_bool CONFIG_GRKERNSEC_RANDRPC y
+define_bool CONFIG_GRKERNSEC_RANDPING y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP y
+fi
+fi
+if [ "$CONFIG_GRKERNSEC_HI" = "y" ]; then
+define_int CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_FD n
+define_bool CONFIG_GRKERNSEC_KBMAP y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_RANDSRC y
+define_bool CONFIG_GRKERNSEC_RANDRPC y
+define_bool CONFIG_GRKERNSEC_RANDPING y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+define_bool CONFIG_GRKERNSEC_KMEM y
+define_bool CONFIG_GRKERNSEC_ACL y
+define_int CONFIG_GR_MAXTRIES 3
+define_int CONFIG_GR_TIMEOUT 30
+define_bool CONFIG_GRKERNSEC_PROC_ADD y
+define_bool CONFIG_GRKERNSEC_CHROOT_SIG y
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE y
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP y
+define_bool CONFIG_GRKERNSEC_PAX y
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PTRACE y
+define_bool CONFIG_GRKERNSEC_AUDIT_PTRACE y
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT y
+define_bool CONFIG_GRKERNSEC_PTRACE y
+define_bool CONFIG_GRKERNSEC_PTRACE_GROUP y
+define_int CONFIG_GRKERNSEC_PTRACE_GID 10
+fi
+if [ "$CONFIG_GRKERNSEC_CUSTOM" = "y" ]; then
+mainmenu_option next_comment
+comment 'Buffer Overflow Protection'
+if [ "$CONFIG_X86" = "y" ]; then
+if [ "$CONFIG_GRKERNSEC_PAX" != "y" ]; then
+bool 'Openwall non-executable stack' CONFIG_GRKERNSEC_STACK
+if [ "$CONFIG_GRKERNSEC_STACK" != "n" ]; then
+bool '   Gcc trampoline support' CONFIG_GRKERNSEC_STACK_GCC
+fi
+fi
+if [ "$CONFIG_GRKERNSEC_STACK" != "y" ]; then
+bool 'PaX protection' CONFIG_GRKERNSEC_PAX
+if [ "$CONFIG_GRKERNSEC_PAX" = "y" ]; then
+  bool '   Emulate trampolines' CONFIG_GRKERNSEC_PAX_EMUTRAMP
+  bool '   Restrict mprotect()' CONFIG_GRKERNSEC_PAX_MPROTECT
+fi
+  bool 'Randomize mmap() base' CONFIG_GRKERNSEC_PAX_RANDMMAP
+fi
+fi
+bool 'Deny ioctl writes of /dev/kmem' CONFIG_GRKERNSEC_KMEM
+endmenu
+mainmenu_option next_comment
+comment 'Access Control Lists'
+   bool 'Grsecurity ACL system' CONFIG_GRKERNSEC_ACL
+if [ "$CONFIG_GRKERNSEC_ACL" = "y" ]; then
+   bool 'ACL Debugging Messages' CONFIG_GR_DEBUG
+   if [ "$CONFIG_GR_DEBUG" = "y" ]; then
+   	bool 'Extra ACL Debugging Messages' CONFIG_GR_SUPERDEBUG
+   fi	
+   bool 'Denied capability logging' CONFIG_GRKERNSEC_ACL_CAPLOG
+   int 'Maximum tries before password lockout' CONFIG_GR_MAXTRIES 3
+   int 'Time to wait after max password tries, in seconds' CONFIG_GR_TIMEOUT 30
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Filesystem Protections'
+bool 'Proc restrictions' CONFIG_GRKERNSEC_PROC
+if [ "$CONFIG_GRKERNSEC_PROC" != "n" ]; then
+bool '   Restrict to user only' CONFIG_GRKERNSEC_PROC_USER
+if [ "$CONFIG_GRKERNSEC_PROC_USER" != "n" ]; then
+bool '      Additional restrictions' CONFIG_GRKERNSEC_PROC_ADD
+fi
+if [ "$CONFIG_GRKERNSEC_PROC_USER" != "y" ]; then
+bool '   Allow special group' CONFIG_GRKERNSEC_PROC_USERGROUP
+if [ "$CONFIG_GRKERNSEC_PROC_USERGROUP" != "n" ]; then
+int  '   GID for special group' CONFIG_GRKERNSEC_PROC_GID 1001
+bool '      Additional restrictions' CONFIG_GRKERNSEC_PROC_ADD
+fi
+fi
+fi
+bool 'Linking restrictions' CONFIG_GRKERNSEC_LINK
+bool 'FIFO restrictions' CONFIG_GRKERNSEC_FIFO
+bool 'Secure file descriptors' CONFIG_GRKERNSEC_FD
+bool 'Chroot jail restrictions' CONFIG_GRKERNSEC_CHROOT
+if [ "$CONFIG_GRKERNSEC_CHROOT" != "n" ]; then
+bool '   Restricted signals' CONFIG_GRKERNSEC_CHROOT_SIG
+bool '   Deny mounts' CONFIG_GRKERNSEC_CHROOT_MOUNT
+bool '   Deny double-chroots' CONFIG_GRKERNSEC_CHROOT_DOUBLE
+bool '   Deny pivot_root in chroot' CONFIG_GRKERNSEC_CHROOT_PIVOT
+bool '   Enforce chdir("/") on all chroots' CONFIG_GRKERNSEC_CHROOT_CHDIR
+bool '   Deny fchdir outside of chroot' CONFIG_GRKERNSEC_CHROOT_FCHDIR
+bool '   Deny (f)chmod +s' CONFIG_GRKERNSEC_CHROOT_CHMOD
+bool '   Deny mknod' CONFIG_GRKERNSEC_CHROOT_MKNOD
+if [ "$CONFIG_X86" != "n" ]; then
+bool '   Deny ptraces' CONFIG_GRKERNSEC_CHROOT_PTRACE
+fi
+bool '   Restrict priority changes' CONFIG_GRKERNSEC_CHROOT_NICE
+fi
+bool 'Capability restrictions within chroot' CONFIG_GRKERNSEC_CHROOT_CAPS
+bool 'Secure keymap loading' CONFIG_GRKERNSEC_KBMAP
+endmenu
+mainmenu_option next_comment
+comment 'Kernel Auditing'
+bool 'Single group for auditing' CONFIG_GRKERNSEC_AUDIT_GROUP
+if [ "$CONFIG_GRKERNSEC_AUDIT_GROUP" != "n" ]; then
+int  '   GID for auditing' CONFIG_GRKERNSEC_AUDIT_GID 1007
+fi
+bool 'Exec logging' CONFIG_GRKERNSEC_EXECLOG
+bool 'Log execs within chroot' CONFIG_GRKERNSEC_CHROOT_EXECLOG
+bool 'Chdir logging' CONFIG_GRKERNSEC_AUDIT_CHDIR
+bool '(Un)Mount logging' CONFIG_GRKERNSEC_AUDIT_MOUNT
+bool 'IPC logging' CONFIG_GRKERNSEC_AUDIT_IPC
+if [ "$CONFIG_X86" != "n" ]; then
+bool 'Ptrace logging' CONFIG_GRKERNSEC_AUDIT_PTRACE
+fi
+bool 'Signal logging' CONFIG_GRKERNSEC_SIGNAL
+bool 'Fork failure logging' CONFIG_GRKERNSEC_FORKFAIL
+if [ "$CONFIG_GRKERNSEC_SUID_ROOT" != "y" ]; then
+bool 'Set*id logging' CONFIG_GRKERNSEC_SUID
+fi
+if [ "$CONFIG_GRKERNSEC_SUID" != "y" ]; then
+bool 'Log set*ids to root' CONFIG_GRKERNSEC_SUID_ROOT
+fi
+bool 'Time change logging' CONFIG_GRKERNSEC_TIME
+endmenu
+mainmenu_option next_comment
+comment 'Executable Protections'
+bool 'Exec process limiting' CONFIG_GRKERNSEC_EXECVE
+bool 'Dmesg(8) restriction' CONFIG_GRKERNSEC_DMESG
+bool 'Randomized PIDs' CONFIG_GRKERNSEC_RANDPID
+bool 'Trusted path execution' CONFIG_GRKERNSEC_TPE
+if [ "$CONFIG_GRKERNSEC_TPE" != "n" ]; then
+bool '   Glibc protection' CONFIG_GRKERNSEC_TPE_GLIBC
+bool '   Partially restrict non-root users' CONFIG_GRKERNSEC_TPE_ALL
+int  '   GID for untrusted users:' CONFIG_GRKERNSEC_TPE_GID 1005
+fi
+if [ "$CONFIG_X86" != "n" ]; then
+bool 'Restricted ptrace' CONFIG_GRKERNSEC_PTRACE
+if [ "$CONFIG_GRKERNSEC_PTRACE" != "n" ]; then
+bool '   Allow ptrace for group' CONFIG_GRKERNSEC_PTRACE_GROUP
+if [ "$CONFIG_GRKERNSEC_PTRACE_GROUP" != "n" ]; then
+int  '   GID for ptrace' CONFIG_GRKERNSEC_PTRACE_GID 1008
+fi
+fi
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Network Protections'
+bool 'Randomized IP IDs' CONFIG_GRKERNSEC_RANDID
+bool 'Randomized TCP source ports' CONFIG_GRKERNSEC_RANDSRC
+bool 'Randomized RPC XIDs' CONFIG_GRKERNSEC_RANDRPC
+bool 'Altered Ping IDs' CONFIG_GRKERNSEC_RANDPING
+bool 'Socket restrictions' CONFIG_GRKERNSEC_SOCKET
+if [ "$CONFIG_GRKERNSEC_SOCKET" != "n" ]; then
+bool '  Deny any sockets to group' CONFIG_GRKERNSEC_SOCKET_ALL
+if [ "$CONFIG_GRKERNSEC_SOCKET_ALL" != "n" ]; then
+int  '   GID to deny all sockets for:' CONFIG_GRKERNSEC_SOCKET_ALL_GID 1004
+fi
+bool '  Deny client sockets to group' CONFIG_GRKERNSEC_SOCKET_CLIENT
+if [ "$CONFIG_GRKERNSEC_SOCKET_CLIENT" != "n" ]; then
+int  '   GID to deny client sockets for:' CONFIG_GRKERNSEC_SOCKET_CLIENT_GID 1003
+fi
+bool '  Deny server sockets to group' CONFIG_GRKERNSEC_SOCKET_SERVER
+if [ "$CONFIG_GRKERNSEC_SOCKET_SERVER" != "n" ]; then
+int  '   GID to deny server sockets for:' CONFIG_GRKERNSEC_SOCKET_SERVER_GID 1002
+fi
+fi
+endmenu
+if [ "$CONFIG_SYSCTL" != "n" ]; then
+mainmenu_option next_comment
+comment 'Sysctl support'
+bool 'Sysctl support' CONFIG_GRKERNSEC_SYSCTL
+endmenu
+fi
+mainmenu_option next_comment
+comment 'Miscellaneous Features'
+int 'Seconds in between log messages (minimum)' CONFIG_GRKERNSEC_FLOODTIME 30
+int 'Number of messages in a burst (maximum)' CONFIG_GRKERNSEC_FLOODBURST 4
+endmenu
+fi
diff -urN linux/grsecurity/Makefile linux/grsecurity/Makefile
--- linux/grsecurity/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/grsecurity/Makefile	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,13 @@
+#
+# grsecurity (c) 2002 Brad Spengler, Michael Dalton
+# 
+# all grsecurity-related code is released under the
+# GNU General Public License (GPL) http://www.gnu.org
+#
+
+O_TARGET := grsec.o
+
+obj-y = grsecurity.o
+obj-$(CONFIG_GRKERNSEC_ACL) += grsum.o gracl.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux/grsecurity/gracl.c linux/grsecurity/gracl.c
--- linux/grsecurity/gracl.c	Wed Dec 31 19:00:00 1969
+++ linux/grsecurity/gracl.c	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,1472 @@
+/* 
+ * grsecurity/gracl.c
+ * Copyright Michael Dalton, Brad Spengler 2000, 2001, 2002
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/ctype.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grsum.h>
+#include <linux/sysctl.h>
+
+static struct acl_subject_db acl_subj_set;
+static struct acl_object_db acl_obj_set;
+static struct name_db name_set;
+
+static rwlock_t gr_list_lock = RW_LOCK_UNLOCKED;
+
+unsigned long gr_status = GR_STATUS_INIT;
+
+int gr_disable = 0;
+
+/* The two 'special' modes : authentication and admin(called god_label for
+ * historical reasons) mode */
+
+static struct acl_subject_label god_label;
+
+static struct acl_subject_label auth_label;
+
+static unsigned long table_sizes[] = {
+	1, 2, 3, 7, 13, 31, 61, 127,
+	251, 509, 1021, 2039, 4093, 8191, 16381, 32749,
+	65521, 131071, 262139, 524287, 1048573, 2097143,
+	4194301, 8388593, 16777213, 33554393, 67108859,
+	134217689, 268435399, 536870909, 1073741789,
+	2147483647
+};
+
+struct admin_pw pwent;		/* Password entry */
+
+#ifdef CONFIG_GR_SUPERDEBUG
+static void list_procs(void);
+static void list_names(void);
+#endif
+
+static __inline__ struct acl_subject_label *
+lookup_acl_subj_label(const ino_t ino, const kdev_t dev)
+{
+	struct acl_subject_label *match =
+	    &acl_subj_set.s_hash[fhash(ino, dev, acl_subj_set.s_size)];
+	while ((match->mode & GR_EXISTS) &&
+	       (match->inode != ino || match->device != dev)) {
+		match += 1 % acl_subj_set.s_size;
+	}
+
+	if (!(match->mode & GR_EXISTS))
+		return NULL;
+	return (match->inode == ino) && (match->device == dev) ? match : NULL;
+}
+
+static __inline__ struct acl_object_label *
+lookup_acl_obj_label(const ino_t ino, const kdev_t dev,
+		     const unsigned long parent_pos)
+{
+	struct acl_object_label *match =
+	    &acl_obj_set.o_hash[phash(ino, dev, parent_pos,
+				      acl_obj_set.o_size)];
+	while ((match->mode & GR_EXISTS) && (match->inode != ino ||
+					     match->device != dev ||
+					     match->parent_pos != parent_pos)) {
+
+		match += 1 % acl_obj_set.o_size;
+	}
+	if (!(match->mode & GR_EXISTS))
+		return NULL;
+	return ((match->inode == ino) && (match->device == dev)
+		&& (match->parent_pos == parent_pos)) ? match : NULL;
+}
+
+static __inline__ struct name_entry *
+lookup_name_entry(const char *name)
+{
+	struct name_entry *match =
+	    &name_set.n_hash[nhash(name, name_set.n_size)];
+	while ((match->mode & GR_EXISTS) && (strcmp(match->name, name)) != 0) {
+		match += 1 % name_set.n_size;
+	}
+	if (!match->name)
+		return NULL;
+	return ((strcmp(name, match->name)) == 0) ? match : NULL;
+}
+
+/* The following routines perofmr insertion into the tables after
+ * the add_{type} process the config file */
+
+static int
+insert_name_entry(char *name, ino_t ino, kdev_t dev, __u8 mode)
+{
+	struct name_entry *curr =
+	    &name_set.n_hash[nhash(name, name_set.n_size)];
+	while (curr->mode & GR_EXISTS) {
+		if (!(strcmp(name, curr->name)))
+			break;
+#ifdef CONFIG_GR_DEBUG
+		security_debug("Hey, I had a name entry collision(I am %s and "
+			       "I collided with %s)", name, curr->name);
+#endif
+		curr = ++curr > &name_set.n_hash[name_set.n_size - 1] ?
+		    name_set.n_hash : curr;
+	}
+
+	/* Duplicate entries are actually expected here..the same filename
+	 * might be associated with a process subject acl and a file acl
+	 * for instance */
+
+	curr->inode = ino;
+	curr->device = dev;
+	curr->mode |= mode;
+	if (!curr->name) {
+		curr->name = kmalloc(strlen(name) + 1, GFP_KERNEL);
+		if (!curr->name)
+			return 1;
+		strncpy(curr->name, name, strlen(name) + 1);
+		curr->name[strlen(name)] = '\0';
+	}
+
+	++name_set.n_used;
+	return 0;
+}
+
+static int
+insert_acl_obj_label(struct acl_object_label *obj)
+{
+	struct acl_object_label *curr =
+	    &acl_obj_set.o_hash[phash(obj->inode, obj->device,
+				      obj->parent_pos,
+				      acl_obj_set.o_size)];
+	while (curr->mode & GR_EXISTS) {
+#ifdef CONFIG_GR_DEBUG
+		static int once = 0;
+		if (!once) {
+			security_debug("Hey, I had an acl object label collision"
+			     " (I am %ld " "%d)", obj->inode, obj->device);
+			once = 1;
+		}
+#endif
+		if (curr->inode == obj->inode && curr->device == obj->device
+		    && curr->parent_pos == obj->parent_pos) {
+			security_alert("Duplicate acl object entries%s",
+				       "duplicate entries", "");
+			return 1;
+		}
+		curr = ++curr > &acl_obj_set.o_hash[acl_obj_set.o_size - 1]
+		    ? acl_obj_set.o_hash : curr;
+	}
+	curr->inode = obj->inode;
+	curr->device = obj->device;
+	curr->mode = obj->mode;
+	curr->parent_pos = obj->parent_pos;
+	//curr->time = obj->time;
+	++acl_obj_set.o_used;
+	return 0;
+
+}
+
+static int
+insert_acl_subj_label(struct acl_subject_label *obj)
+{
+	struct acl_subject_label *curr =
+	    &acl_subj_set.s_hash[fhash(obj->inode, obj->device,
+				       acl_subj_set.s_size)];
+
+	while (curr->mode & GR_EXISTS) {
+#ifdef CONFIG_GR_DEBUG
+		security_debug("Hey, I had an acl subject label collision"
+			       " (I am %ld " "%d )", curr->inode,
+			       curr->device);
+#endif
+		if (curr->inode == obj->inode && curr->device == obj->device) {
+			security_alert("Duplicate acl subject entries%s",
+				       "duplicate entries", "");
+
+			return 1;
+		}
+
+		curr = ++curr > &acl_subj_set.s_hash[acl_subj_set.s_size - 1]
+		    ? acl_subj_set.s_hash : curr;
+	}
+	curr->inode = obj->inode;
+	curr->device = obj->device;
+	curr->cap_raise = obj->cap_raise;
+	curr->cap_lower = obj->cap_lower;
+	curr->cap_raise_inherit = obj->cap_raise_inherit;
+	curr->cap_lower_inherit = obj->cap_lower_inherit;
+	curr->mode = obj->mode;
+	curr->pos = obj->pos;
+
+	++acl_subj_set.s_used;
+
+	return 0;
+
+}
+
+/* Create a table(requesting size close to 2^pwr entrie of member size)
+ * and replace the current table size with the new one.
+ * We use prime table sizes until we reach the bounds of 32-bit word machines 
+ * Once we reach there we simply double the table size */
+
+static void *
+create_table(unsigned long *len, unsigned long member)
+{
+	void *newtable;
+	unsigned int pwr = 1 << ((sizeof (unsigned long) * 8) - 1);
+	while (pwr > *len * member)
+		pwr >>= 1;
+	if (pwr > (sizeof (table_sizes) / sizeof (table_sizes[0]) - 1)) {
+		newtable = kmalloc((*len) * 2 * member, GFP_KERNEL);
+		*len = (*len) * 2;
+	} else {
+		newtable = kmalloc(table_sizes[pwr] * member, GFP_KERNEL);
+		*len = table_sizes[pwr];
+	}
+	return newtable;
+}
+
+#ifdef CONFIG_GR_SUPERDEBUG
+
+static void
+list_names(void)
+{
+	int i;
+	struct name_entry *curr;
+
+	for (i = 0; i < name_set.n_size; i++) {
+		curr = &name_set.n_hash[i];
+		if (curr->mode & GR_EXISTS)
+			security_debug("Name Entry pos %d has inode %lu dev %s "
+				       "mode %x name %s", i, curr->inode,
+				       kdevname(curr->device), curr->mode,
+				       curr->name);
+	}
+
+	return;
+}
+
+static void
+list_procs(void)
+{
+	int i;
+	struct acl_subject_label *curr;
+	struct acl_object_label *curr2;
+	for (i = 0; i < acl_subj_set.s_size; i++) {
+		curr = &acl_subj_set.s_hash[i];
+		if (curr->mode & GR_EXISTS)
+			security_alert("MAC Subject pos %d has inode %lu dev %s"
+				       " mode %x pos %ld", "", i, curr->inode,
+				       kdevname(curr->device),
+				       curr->mode, curr->pos);
+	}
+	for (i = 0; i < acl_obj_set.o_size; i++) {
+		curr2 = &acl_obj_set.o_hash[i];
+		if (curr2->mode & GR_EXISTS)
+			security_alert("MAC Object pos %d has inode %lu dev %s "
+				       " mode %x parent %ld", "", i,
+				       curr2->inode, kdevname(curr2->device),
+				       curr2->mode, curr2->parent_pos);
+	}
+
+	return;
+}
+
+#endif
+
+static int
+init_variables(unsigned long acl_obj_size, unsigned long acl_subj_size)
+{
+	acl_subj_set.s_size = acl_subj_size;
+	acl_obj_set.o_size = acl_obj_size;
+	name_set.n_size = (acl_obj_size + acl_subj_size);
+	/* We only want 50% full tables for now */
+
+	acl_subj_set.s_hash =
+	    create_table(&acl_subj_set.s_size,
+			 sizeof (struct acl_subject_label));
+	acl_obj_set.o_hash =
+	    create_table(&acl_obj_set.o_size, sizeof (struct acl_object_label));
+	name_set.n_hash =
+	    create_table(&name_set.n_size, sizeof (struct name_entry));
+
+	if (!acl_subj_set.s_hash || !acl_obj_set.o_hash || !name_set.n_hash)
+		return 1;
+	memset(acl_subj_set.s_hash, 0,
+	       sizeof (struct acl_subject_label) * acl_subj_set.s_size);
+	memset(acl_obj_set.o_hash, 0,
+	       sizeof (struct acl_object_label) * acl_obj_set.o_size);
+	memset(name_set.n_hash, 0,
+	       sizeof (struct name_entry) * name_set.n_size);
+
+	acl_subj_set.s_used = acl_obj_set.o_used = name_set.n_used = 0;
+
+	return 0;
+}
+
+static int
+parse_args(struct gr_arg *args)
+{
+	unsigned int pos;
+	struct user_acl_subject_label ** s_tmp = args->subj_db.s_table;
+	struct user_acl_object_label ** o_tmp = args->obj_db.o_table;
+/* Special case: acl subjects 0 and 1 are god_label/auth_label mode respectively */
+
+	if (args->subj_db.s_entries < 2)
+		return -EINVAL;
+	/* We must at least have admin and auth_label mode specified */
+
+	for (pos = 0; pos < args->subj_db.s_entries; pos++, s_tmp++) {
+		struct user_acl_subject_label *s_curr = *s_tmp;
+		struct acl_subject_label s_temp = {
+			inode:s_curr->inode,
+			device:s_curr->device,
+			mode:s_curr->mode,
+			pos:s_curr->pos
+		};
+
+		/* Bleh: converting __u32 to kernel_cap_t ... and 
+		 * kernel_cap_t is either __u32 or a struct depending on
+		 * your funktitude, so we use those kinky macros in capability.h
+		 */
+		cap_t(s_temp.cap_raise) = to_cap_t(s_curr->cap_raise);
+		cap_t(s_temp.cap_lower) = to_cap_t(s_curr->cap_lower);
+		cap_t(s_temp.cap_raise_inherit) = 
+			to_cap_t(s_curr->cap_raise_inherit);
+		cap_t(s_temp.cap_lower_inherit) = 
+			to_cap_t(s_curr->cap_lower_inherit);
+
+		if (!(strcmp(s_curr->filename, "god")))
+			god_label = s_temp;
+		else if (!(strcmp(s_curr->filename, "auth")))
+			auth_label = s_temp;
+		insert_name_entry(s_curr->filename, s_curr->inode, s_curr->device,
+				  GR_NAME_ACL_SUBJECT);
+		insert_acl_subj_label(&s_temp);
+	}
+
+	for (pos = 0;pos < args->obj_db.o_entries; pos++, o_tmp++) {
+
+		struct user_acl_object_label *o_curr = *o_tmp;
+		struct acl_object_label o_temp = {
+			inode:o_curr->inode,
+			device:o_curr->device,
+			mode:o_curr->mode,
+			parent_pos:o_curr->parent_pos
+		};
+
+		insert_name_entry(o_curr->filename, o_curr->inode, o_curr->device,
+				  GR_NAME_ACL_OBJECT);
+		insert_acl_obj_label(&o_temp);
+	}
+	return 0;
+}
+
+static void
+free_variables(void)
+{
+	int i;
+	kfree(acl_subj_set.s_hash);
+	kfree(acl_obj_set.o_hash);
+	for(i = 0; i < name_set.n_used ; i++)
+		if(name_set.n_hash[i].name)
+			kfree(name_set.n_hash[i].name);
+	kfree(name_set.n_hash);
+
+	return;
+}
+
+static int
+copy_user_acl(struct gr_arg *arg)
+{
+	struct user_acl_object_label ** o_kerntable = NULL;
+	struct user_acl_subject_label ** s_kerntable = NULL;
+	struct user_acl_object_label ** o_tmp = NULL;
+	struct user_acl_subject_label ** s_tmp = NULL;
+	struct user_acl_object_label ** o_utmp = NULL;
+	struct user_acl_subject_label ** s_utmp = NULL;
+
+	int err = 0;
+
+	unsigned long s_num = 1;
+	unsigned long o_num = 1;
+
+	if ((o_tmp = o_kerntable = (struct user_acl_object_label **)
+			kmalloc(arg->obj_db.o_entries * sizeof 
+			(struct user_acl_object_label *), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	if ((s_tmp = s_kerntable = (struct user_acl_subject_label **)
+			kmalloc(arg->subj_db.s_entries * sizeof 
+			(struct user_acl_subject_label *), GFP_KERNEL)) == NULL) {
+		kfree(o_kerntable);
+		return -ENOMEM;
+	}
+
+	s_utmp = arg->subj_db.s_table;
+	o_utmp = arg->obj_db.o_table;
+
+	for(;o_num <= arg->obj_db.o_entries;o_num++,o_kerntable++,o_utmp++) {
+		if ((*o_kerntable = (struct user_acl_object_label *)kmalloc(sizeof 
+				(struct user_acl_object_label), GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(*o_kerntable, *o_utmp, 
+	     			sizeof (struct user_acl_object_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		if (((*o_kerntable)->filename = (char *)kmalloc((*o_kerntable)->filename_len, GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user((*o_kerntable)->filename, (*o_utmp)->filename, 
+	     			(*o_kerntable)->filename_len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+	}
+	for(;s_num <= arg->subj_db.s_entries;s_num++,s_kerntable++,s_utmp++) {
+		if ((*s_kerntable = kmalloc(sizeof 
+				(struct user_acl_subject_label), GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(*s_kerntable, *s_utmp,
+		 		sizeof (struct user_acl_subject_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		if (((*s_kerntable)->filename = (char *)kmalloc((*s_kerntable)->filename_len, GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user((*s_kerntable)->filename, (*s_utmp)->filename, 
+	     			(*s_kerntable)->filename_len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+	}
+
+	arg->subj_db.s_table = s_tmp;
+	arg->obj_db.o_table = o_tmp;
+#ifdef CONFIG_GR_DEBUG
+	security_debug("Iterating through received table");
+	security_debug("Note: there should be %ld acl suject entries and %ld acl "
+			"object entries", arg->subj_db.s_entries,
+			arg->obj_db.o_entries);
+	{
+		int i;
+		for(i = 0; i < arg->subj_db.s_entries; i++,s_tmp++) {
+			if(!((*s_tmp)->mode & GR_EXISTS))
+				continue;
+			security_debug("Subject label position %d has inode "
+					"%ld device %d", i, (*s_tmp)->inode,
+					(*s_tmp)->device);
+		}
+		for(i = 0; i < arg->obj_db.o_entries; i++,o_tmp++) {
+			if(!((*o_tmp)->mode & GR_EXISTS))
+				continue;
+			security_debug("Object label position %d has inode "
+					"%ld device %d", i, (*o_tmp)->inode,
+					(*o_tmp)->device);
+		}
+	}
+#endif
+	goto return_err;
+cleanup:
+	o_kerntable = o_tmp;
+	s_kerntable = s_tmp;
+
+	while(--o_num) {
+		kfree(*o_kerntable);
+		o_kerntable++;
+	}
+
+	kfree(o_kerntable);
+	while(--s_num) {
+		kfree(*s_kerntable);
+		s_kerntable++;
+	}
+	kfree(s_kerntable);	
+return_err:	
+	return err;
+
+}
+
+static void
+free_user_acl(struct gr_arg *args)
+{
+	unsigned long i;
+	for(i=0;i<args->subj_db.s_entries;i++) {
+		kfree(*(args->subj_db.s_table));
+		args->subj_db.s_table++;
+	}
+	kfree(args->subj_db.s_table);
+
+	for(i=0;i<args->obj_db.o_entries;i++) {
+		kfree(*(args->obj_db.o_table));
+		args->obj_db.o_table++;
+	}
+	kfree(args->obj_db.o_table);
+
+	return;
+}
+
+static int
+add_pw_conf(void)
+{
+	struct file *filp;
+	int retval;
+	mm_segment_t old_fs = get_fs();
+	filp = filp_open(PW_CONF, O_RDONLY, O_RDONLY);
+	if ((IS_ERR(filp)) || (filp == NULL) || (!(filp->f_op->read))) {
+		security_alert("Could not open config file %.1024s",
+			       "config file open errors", PW_CONF);
+		return 1;
+	}
+	filp->f_pos = 0;
+	set_fs(KERNEL_DS);
+	retval = filp->f_op->read(filp, (unsigned char *) &pwent.salt, sizeof (pwent.salt),
+				  &filp->f_pos);
+	retval += filp->f_op->read(filp, (unsigned char *) &pwent.sum, sizeof (pwent.sum),
+				  &filp->f_pos);
+	set_fs(old_fs);
+	if (retval != (sizeof (pwent.sum) + sizeof (pwent.salt))) {
+		security_alert("Invalid pw entry detected, got %d wanted %d",
+			       "password file errors",
+			       retval, sizeof (pwent.sum));
+		retval = 1;
+	} else
+		retval = 0;
+	filp_close(filp, NULL);
+	return retval;
+}
+
+static int
+grsecurity_init(struct gr_arg *args)
+{
+	int error = 0;
+	if(copy_user_acl(args))
+		return -ENOMEM;
+	if (init_variables(args->obj_db.o_entries, args->subj_db.s_entries)) {
+		security_alert("init_variables() failed%s", "", GR_VERSION);
+		error = -1;
+	} else if (add_pw_conf()) {
+		security_alert("add_pw_conf() failed%s", "", GR_VERSION);
+		error = -2;
+		free_variables();
+	} 
+	else if (parse_args(args)) {
+		security_alert("parse_args failed%s", "", GR_VERSION);
+		error = -3;
+		free_variables();
+	}
+
+	if (!error) {
+		struct task_struct *task;
+
+#ifdef CONFIG_GR_SUPERDEBUG
+		list_procs();
+		list_names();
+#endif
+
+		spin_lock(&task_capability_lock);
+		read_lock(&tasklist_lock);
+		for_each_task(task) {
+			struct acl_subject_label *curr = NULL;
+
+			if (task->acl == &god_label || task->acl == &auth_label)
+				continue;
+			write_lock(&task->acl_lock);
+			if (task->proc_info.inode >
+			    ACL_SUBJ_LABEL_OFFSET
+			    || task->proc_info.device > ACL_SUBJ_LABEL_OFFSET)
+				curr =
+				    lookup_acl_subj_label(task->
+							  proc_info.
+							  inode,
+							  task->
+							  proc_info.device);
+			if (!curr)
+				curr =
+				    lookup_acl_subj_label(child_reaper->fs->
+							  root->d_inode->i_ino,
+							  child_reaper->fs->
+							  root->d_inode->i_dev);
+
+			if(!curr)
+			{
+				printk("Error! Cannot find default acl\n");
+				write_unlock(&task->acl_lock);
+				read_unlock(&tasklist_lock);
+				spin_unlock(&task_capability_lock);
+				free_user_acl(args);
+				printk("After free user acl\n");
+				return 1;
+			}
+			task->acl = curr;
+			task->cap_permitted =
+			    cap_intersect(task->cap_permitted, cap_bset);
+			task->cap_permitted =
+			    cap_combine(task->cap_permitted, curr->cap_raise);
+			task->cap_permitted =
+			    cap_drop(task->cap_permitted, curr->cap_lower);
+			task->cap_effective = task->cap_permitted;
+			task->cap_inheritable =
+			    cap_combine(task->cap_inheritable,
+					curr->cap_raise_inherit);
+
+			task->cap_inheritable =
+			    cap_drop(task->cap_inheritable,
+				     curr->cap_lower_inherit);
+
+#ifdef CONFIG_GR_DEBUG
+			security_debug("Applied ACL to already "
+				       "running process %s(%d)"
+				       "file [%.32s:%lu]",
+				       task->comm, task->pid,
+				       kdevname(curr->device), curr->inode);
+
+#endif
+			write_unlock(&task->acl_lock);
+		}
+		read_unlock(&tasklist_lock);
+		spin_unlock(&task_capability_lock);
+		gr_status |= GR_READY;
+	} else {
+		security_alert("Error loading %s, trying to run kernel with "
+			       "acls disabled. To disable acls at startup "
+			       "use <kernel image name> gracl=off from your "
+			       "boot loader", "error loading acls", GR_VERSION);
+	}
+	free_user_acl(args);
+	printk("After other free_user_acl\n");
+	return error;
+}
+
+/* * * * * * * * * * * * * * * * * * * * * * *
+ * Begin Misc Section 
+ * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Searching stuff, program exit cleanup, and sysctl parsing */
+
+/* do_find_{type} - checks to see if an entry is defined based on its
+ * arguments, usually an inode/dev passed via  temp_file_label structure,
+ * and in the case of process objects, the parent's "position" in the config
+ * file as well */
+
+#if 0
+static __inline__ int
+chk_time(struct gr_time time)
+{
+	if (time.acl_time_init < 0)
+		return 1;
+
+	if (time.acl_time_init <= (CURRENT_TIME % 86400) &&
+	    time.acl_time_expire >= (CURRENT_TIME % 86400))
+		return 1;
+	return 0;
+}
+#endif
+
+static __inline__ unsigned long
+do_find_proc_obj(struct temp_file_label *curr)
+{
+	struct acl_object_label *match;
+	struct acl_subject_label *proc;
+
+	read_lock(&current->acl_lock);
+	proc = (struct acl_subject_label *) current->acl;
+#ifdef CONFIG_GR_DEBUG
+	security_debug("Find proc acl for subject (%x)",current->acl);
+#endif
+	match = lookup_acl_obj_label(curr->inode, curr->device, proc->pos);
+	read_unlock(&current->acl_lock);
+
+	if (!match || (match->mode & GR_DELETED))
+		return GR_NOTFOUND;
+	if ((match->mode & curr->mode) == curr->mode
+	    /*&& chk_time(match->time) */ ) {
+		return GR_ALLOW;
+	} else {
+		return GR_DENY;
+	}
+}
+
+static __inline__ unsigned long
+do_find_proc_subj(struct temp_file_label *curr)
+{
+
+	struct acl_subject_label *retval = NULL;
+
+	retval = lookup_acl_subj_label(curr->inode, curr->device);
+	if (retval && !(retval->mode & GR_DELETED)) {
+		curr->mode = (unsigned long) retval;
+		return GR_ALLOW;
+	} else {
+		curr->mode = (unsigned long) NULL;
+		return GR_NOTFOUND;
+	}
+}
+
+/* chk_label checks to see if an acl is defined for a file or any of its
+ * parent directories by calling searchfn. */
+
+static __inline__ unsigned long
+chk_label(struct nameidata *nd,
+	  struct temp_file_label *searchval,
+	  unsigned long (*searchfn) (struct temp_file_label *))
+{
+	struct dentry *dentry = nd->dentry;
+	struct vfsmount *mnt = nd->mnt;
+	unsigned long retval;
+
+	while (1) {
+		struct vfsmount *parent;
+		struct dentry *new_dentry;
+
+		/*
+		 * Note: caller holds current->acl r/w spinlock (read required)
+		 */
+
+		if (!dentry->d_inode) {
+			retval = GR_DENY;
+			goto exit;
+		}
+
+		searchval->inode = dentry->d_inode->i_ino;
+		searchval->device = dentry->d_inode->i_dev;
+		read_lock(&gr_list_lock);
+		if ((retval = (*searchfn) (searchval))
+		    != GR_NOTFOUND) {
+			read_unlock(&gr_list_lock);
+			goto exit;
+		}
+		read_unlock(&gr_list_lock);
+		read_lock(&current->fs->lock);
+		if (dentry == current->fs->root && mnt == current->fs->rootmnt) {
+			read_unlock(&current->fs->lock);
+			break;
+		}
+
+		read_unlock(&current->fs->lock);
+
+		spin_lock(&dcache_lock);
+		if (dentry != mnt->mnt_root) {
+			new_dentry = dget(dentry->d_parent);
+			spin_unlock(&dcache_lock);
+			if (dentry != nd->dentry)
+				dput(dentry);
+			dentry = new_dentry;
+			continue;
+		}
+		parent = mnt->mnt_parent;
+		if (parent == mnt) {
+			spin_unlock(&dcache_lock);
+			break;
+		}
+		mntget(parent);
+		new_dentry = dget(mnt->mnt_mountpoint);
+		spin_unlock(&dcache_lock);
+		if (dentry != nd->dentry)
+			dput(dentry);
+		if (mnt != nd->mnt)
+			mntput(mnt);
+		dentry = new_dentry;
+		mnt = parent;
+	}
+	
+      exit:
+	if (dentry != nd->dentry) {
+		dput(dentry);
+	}
+	if (mnt != nd->mnt) {
+		mntput(mnt);
+	}
+	
+	if(retval == GR_NOTFOUND) {
+		read_lock(&gr_list_lock);
+
+		/*
+		   silly hack because dentries of mountpoints in the 
+		   kernel use non-physical inodes.  We set to the physical 
+		   root inode, since this is the only reason an acl could 
+		   not have been found.
+		*/
+
+		searchval->inode = 2;  
+		retval = (*searchfn) (searchval);
+		read_unlock(&gr_list_lock);
+	}							
+
+	if(retval == GR_NOTFOUND) {
+		security_alert("Warning: could find no match for [%.32s:%lu], "
+				"disabling gracl","acl not found!",
+				kdevname(nd->dentry->d_inode->i_dev), 
+				nd->dentry->d_inode->i_ino);
+		gr_status &= ~GR_READY;
+		retval = GR_ALLOW; /* We're broken, let it through and
+				      disable ourselves */
+	}
+	
+	return retval;
+}
+
+static __inline__ int
+chk_inherit(struct nameidata *nd)
+{
+	struct temp_file_label temp;
+	int retval = 0;
+
+	temp.mode = GR_INHERIT;
+
+	read_lock(&current->acl_lock);
+	if (chk_label(nd, &temp, &do_find_proc_obj) == GR_ALLOW)
+		retval = 1;
+	read_unlock(&current->acl_lock);
+	return retval;
+}
+
+static __inline__ int
+chk_auth(struct nameidata *nd)
+{
+	struct temp_file_label temp;
+	int retval = 0;
+
+	temp.mode = GR_AUTH;
+
+	read_lock(&current->acl_lock);
+	if (chk_label(nd, &temp, &do_find_proc_obj) == GR_ALLOW)
+		retval = 1;
+	else if (!current->uid || !current->gid || !current->euid
+		 || !current->egid || !current->suid || !current->sgid
+		 || !current->fsuid || !current->fsgid) {
+
+		temp.mode = GR_AUTH_IF_ROOT;
+		if (chk_label(nd, &temp, &do_find_proc_obj) == GR_ALLOW)
+			retval = 1;
+	}
+	read_unlock(&current->acl_lock);
+	return retval;
+}
+
+int
+gr_search_file(struct dentry *dentry, __u16 mode, struct vfsmount *mnt)
+{
+	int retval = GR_ALLOW;
+	struct temp_file_label searchval;
+	struct nameidata nd = {
+		dentry:dentry,
+		mnt:mnt
+	};
+
+	if (!(gr_status & GR_READY) || !dentry->d_inode || !mnt) return retval;
+
+	searchval.mode = mode;
+
+	read_lock(&current->acl_lock);
+	retval = chk_label(&nd, &searchval, &do_find_proc_obj);
+	read_unlock(&current->acl_lock);
+
+	return retval;
+}
+
+int
+gr_check_create(struct dentry *new_dentry, struct dentry *parent,
+		struct vfsmount *mnt, __u16 mode)
+{
+	struct name_entry *match;
+	struct acl_object_label *matchpo;
+	int retval = GR_NOTFOUND;
+	char *buffer;
+	char *pathname;
+
+	if (!(gr_status & GR_READY))
+		return GR_ALLOW;
+
+	buffer = (char *) get_free_page(GFP_KERNEL);
+	if (!buffer)
+		return GR_DENY;	/* OOM : can't let anything get through */
+
+	pathname = d_path(new_dentry, mnt, buffer, PAGE_SIZE);
+
+	read_lock(&gr_list_lock);
+
+	match = lookup_name_entry(pathname);
+
+	if (!match || !(match->mode & GR_EXISTS))
+		goto check_parent;
+
+	if (current->acl && (match->mode & GR_NAME_ACL_OBJECT)) {
+		struct acl_subject_label *curracl;
+		read_lock(&current->acl_lock);
+		curracl = (struct acl_subject_label *) current->acl;
+		if (curracl && ((matchpo =
+				 lookup_acl_obj_label(match->inode,
+						      match->device,
+						      curracl->pos)) != NULL)) {
+			if ((matchpo->mode & mode) != mode) {
+				read_unlock(&current->acl_lock);
+				read_unlock(&gr_list_lock);
+				retval = GR_DENY;
+				goto exit;
+			} else {
+				retval = GR_ALLOW;
+			}
+		} else {
+			security_alert("WARNING:Could not find an acl for "
+				       "[%.32s:%lu]", "acl not found!",
+				       kdevname(match->device), match->inode);
+			gr_status &= ~GR_READY;	/* PANIC: disable acl system */
+			retval = GR_ALLOW;
+		}
+		read_unlock(&current->acl_lock);
+	}
+
+      check_parent:
+	read_unlock(&gr_list_lock);
+	if (retval != GR_NOTFOUND)
+		goto exit;
+
+	retval = gr_search_file(parent, mode, mnt);
+
+      exit:
+	free_page((unsigned long) buffer);
+	return retval;
+}
+
+int
+gr_check_hidden_task(struct task_struct *task)
+{
+	struct acl_subject_label *acl;
+	int retval = 0;
+
+	if (!(gr_status & GR_READY) || !task->acl) return 0;
+
+	read_lock(&task->acl_lock);
+	acl = (struct acl_subject_label *) task->acl;
+
+	if (acl && !(acl->mode & GR_FIND)) {
+		struct acl_subject_label *curracl;
+		if (current->acl) {
+			read_lock(&current->acl_lock);
+			curracl = (struct acl_subject_label *) current->acl;
+			if (!curracl || !(curracl->mode & GR_VIEW)) 
+				retval = 1;
+			read_unlock(&current->acl_lock);
+		} else
+			retval = 1;
+	}
+
+	read_unlock(&task->acl_lock);
+
+	return retval;
+}
+
+int
+gr_check_protected_task(struct task_struct *tsk)
+{
+	struct acl_subject_label *acl;
+	int retval = 0;
+
+	if (!(gr_status & GR_READY) || !tsk) return 0;
+
+	read_lock(&tsk->acl_lock);
+	acl = (struct acl_subject_label *) tsk->acl;
+
+	if ((acl->mode & GR_PROTECTED)) {
+		struct acl_subject_label *curracl;
+		read_lock(&current->acl_lock);
+		curracl = (struct acl_subject_label *) current->acl;
+		if (!curracl || !(curracl->mode & GR_KILL))
+			retval = 1;
+	}
+	read_unlock(&tsk->acl_lock);
+
+	return retval;
+}
+
+__inline__ int
+gr_copy_label(struct task_struct *tsk)
+{
+	/* We don't need to lock task...because task is being created
+	 * in do_fork() so it can't be modified anywhere else as it has
+	 * yet to be a true process. see kernel/fork.c
+	 * Also pointer assignmetn is atomic, either current->acl will
+	 * be there or be NULL, there is no reason to lock*/
+	struct acl_subject_label *acl;
+	tsk->acl = current->acl;
+	tsk->acl_lock = RW_LOCK_UNLOCKED;
+	read_lock(&tasklist_lock);
+	read_lock(&current->p_pptr->acl_lock);
+	acl = (struct acl_subject_label *) current->acl;
+	if (acl && (acl->cap_raise_inherit || acl->cap_lower_inherit)) {
+		tsk->cap_effective |= acl->cap_raise_inherit;
+		tsk->cap_permitted |= acl->cap_raise_inherit;
+		tsk->cap_inheritable |= acl->cap_raise_inherit;
+		tsk->cap_effective &= ~acl->cap_lower_inherit;
+		tsk->cap_permitted &= ~acl->cap_lower_inherit;
+		tsk->cap_inheritable &= ~acl->cap_lower_inherit;
+	}
+	read_unlock(&current->p_pptr->acl_lock);
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+static int
+do_auth(struct task_struct *tsk)
+{
+#define GR_AUTH_MSG "Authorize yourself to GrSecurity please\n"
+
+	char *p = GR_AUTH_MSG;
+	int ret = 0;
+	if (!(tsk->tty) || (!tsk->tty->driver.write)) {
+		ret = 1;
+		goto out;
+	}
+	tsk->tty->driver.write(tsk->tty, 0, p, strlen(p));
+	tsk->acl = (void *) &auth_label;
+
+      out:
+	return ret;
+}
+
+static int
+do_set_proc_label(struct nameidata *nd, int mode)
+{
+	switch (mode) {
+	case GR_SET_AUTH:
+		return chk_auth(nd);
+		break;
+	case GR_SET_INHERIT:
+		return chk_inherit(nd);
+		break;
+	case GR_SET_PROC:
+		{
+			struct temp_file_label searchval;
+			if ((chk_label(nd, &searchval,
+				       &do_find_proc_subj)) == GR_ALLOW)
+				current->acl = (void *) searchval.mode;
+			else {
+				security_alert("Cannot find n acl for "
+					       "[%.32s:%lu]",
+					       "acl not found!",
+					       kdevname(searchval.device),
+					       searchval.inode);
+				gr_status &= ~GR_READY;	/* PANIC: 
+							   disable acl system */
+			}
+
+		}
+
+		break;
+	}
+	return 0;
+}
+
+static int
+do_inherit(struct task_struct *tsk)
+{
+	return 0;
+	/* Note: for copying due to fork() we use the gracl code in
+	 * kernel/fork.c. If we're inheriting then our current ACL
+	 * (that of the program calling execve) is the ACL we inherit, 
+	 * so no work needs to be done. Just return success 
+	 */
+}
+
+int
+gr_set_proc_label(struct dentry *dentry, struct vfsmount *mnt, char *filename)
+{
+	struct task_struct *tsk = current;
+	int retval = 0;
+	struct nameidata nd = {
+		dentry:dentry,
+		mnt:mnt
+	};
+
+	if (nd.dentry->d_inode) {
+		tsk->proc_info.inode = nd.dentry->d_inode->i_ino;
+		tsk->proc_info.device = nd.dentry->d_inode->i_dev;
+	}
+
+	else {
+		tsk->proc_info.inode = GR_NOFILE_INODE;
+		tsk->proc_info.device = GR_NOFILE_DEVICE;
+	}
+
+	if (!(gr_status & GR_READY) || !nd.dentry->d_inode || !nd.mnt)
+		return retval;
+
+	read_lock(&gr_list_lock);
+
+	if (do_set_proc_label(&nd, GR_SET_INHERIT)) {
+		read_unlock(&gr_list_lock);
+		return do_inherit(tsk);
+	} else if (do_set_proc_label(&nd, GR_SET_AUTH)) {
+		read_unlock(&gr_list_lock);
+		return do_auth(tsk);
+	} else
+		(void) do_set_proc_label(&nd, GR_SET_PROC);
+
+	read_unlock(&gr_list_lock);
+
+	return retval;
+}
+
+void
+gr_set_caps(void)
+{
+	struct acl_subject_label *curracl;
+
+	if (!(gr_status & GR_READY)) return;
+	
+	read_lock(&gr_list_lock);
+
+	if (!current->acl) return;
+
+	curracl = (struct acl_subject_label *) current->acl;
+
+	current->cap_permitted = cap_combine(current->cap_permitted,
+			curracl->cap_raise);
+	current->cap_permitted = cap_drop(current->cap_permitted,
+			curracl->cap_lower);
+	current->cap_effective = current->cap_permitted;
+	current->cap_inheritable = cap_combine(current->cap_inheritable,
+			curracl->cap_raise_inherit);
+	current->cap_inheritable = cap_drop(current->cap_inheritable,
+			curracl->cap_lower_inherit);
+
+	read_unlock(&gr_list_lock);
+
+	return;
+}
+
+int
+gr_in_auth_mode(void *acl)
+{
+	return (acl == &auth_label);
+}
+
+void
+gr_handle_delete(const ino_t ino, const kdev_t dev)
+{
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *matchps;
+	unsigned long i;
+
+	if (!(gr_status & GR_READY)) return;
+
+	read_lock(&gr_list_lock);
+
+	for (i = 0; (i < acl_subj_set.s_used) && ((matchpo = 
+	    lookup_acl_obj_label(ino, dev,(unsigned long) i)) != NULL); i++) {
+#ifdef CONFIG_GR_DEBUG
+		security_debug("Acl Object [%.32s:%lu] pos %lu "
+				"deleted", kdevname(dev), ino, i);
+#endif
+		matchpo->mode |= GR_DELETED;
+	}
+
+	if ((matchps = lookup_acl_subj_label(ino, dev)) != NULL) {
+#ifdef CONFIG_GR_DEBUG
+		security_debug("ACL subject [%.32s:%lu] deleted",
+			       kdevname(dev), ino);
+#endif
+		matchps->mode |= GR_DELETED;
+	}
+
+	read_unlock(&gr_list_lock);
+
+	return;
+}
+
+static __inline__ void
+move_acl_obj_label(struct acl_object_label *po,
+		   const ino_t newino, const kdev_t newdev)
+{
+	struct acl_object_label insert = {
+		inode:newino,
+		device:newdev,
+		mode:po->mode & ~GR_DELETED,
+		parent_pos:po->parent_pos,
+		//time:po->time
+	};
+
+	po->mode &= ~GR_EXISTS;
+	acl_obj_set.o_used--;
+	insert_acl_obj_label(&insert);
+
+	return;
+}
+
+static __inline__ void
+move_acl_subj_label(struct acl_subject_label *ps,
+		    const ino_t newino, const kdev_t newdev)
+{
+	struct task_struct *p;
+	struct acl_subject_label insert = {
+		inode:newino,
+		device:newdev,
+		mode:ps->mode & ~GR_DELETED,
+		cap_raise:ps->cap_raise,
+		cap_lower:ps->cap_lower,
+		cap_raise_inherit:ps->cap_raise_inherit,
+		cap_lower_inherit:ps->cap_lower_inherit,
+		pos:ps->pos
+	};
+
+	ps->mode &= ~GR_EXISTS;
+	acl_subj_set.s_used--;
+	insert_acl_subj_label(&insert);
+	read_lock(&tasklist_lock);
+	for_each_task(p) {
+		if (p->acl == ps) {
+			write_lock(&p->acl_lock);
+			if (p->acl == ps)
+				p->acl = lookup_acl_subj_label(newino, newdev);
+			write_unlock(&p->acl_lock);
+		}
+	}
+	read_unlock(&tasklist_lock);
+
+	return;
+}
+
+void
+gr_handle_create(const char *filename, const struct nameidata *nd)
+{
+	struct name_entry *matchn;
+	struct acl_subject_label *matchps;
+	struct acl_object_label *matchpo;
+	unsigned long i;
+	char *pathbuf;
+	char *pathname;
+
+	if (!(gr_status & GR_READY)) return;
+
+	if ((pathbuf = (char *) __get_free_page(GFP_KERNEL)) == NULL)
+		return;
+
+	pathname = d_path(nd->dentry, nd->mnt, pathbuf, PAGE_SIZE);
+
+	matchn = lookup_name_entry(pathname);
+
+	if (matchn) {
+		write_lock(&gr_list_lock);
+		if (matchn->mode & GR_NAME_ACL_SUBJECT) {
+			if ((matchps = lookup_acl_subj_label(matchn->inode,
+							     matchn->
+							     device)) != NULL) {
+#ifdef CONFIG_GR_DEBUG
+				security_debug("Process Subj ACL %.1024s "
+					       "recreated", filename);
+#endif
+				move_acl_subj_label(matchps,
+						    nd->dentry->d_inode->i_ino,
+						    nd->dentry->d_inode->i_dev);
+			}
+		}
+
+		for (i = 0; (i < acl_subj_set.s_used) && ((matchpo = 
+			lookup_acl_obj_label(matchn->inode, 
+			matchn->device, i)) != NULL); i++) {
+#ifdef CONFIG_GR_DEBUG
+			security_debug("Process Obj ACL %.1024s pos %lu"
+					" recreated", filename, i);
+#endif
+			move_acl_obj_label(matchpo, nd->dentry->d_inode->i_ino,
+					nd->dentry->d_inode->i_dev);
+		}
+
+		matchn->inode = nd->dentry->d_inode->i_ino;
+		matchn->device = nd->dentry->d_inode->i_dev;
+		write_unlock(&gr_list_lock);
+	}
+	free_page((unsigned long) pathbuf);
+
+	return;
+}
+
+static int
+grsecurity_reload(struct gr_arg *args)
+{
+	acl_subj_set.s_size = acl_obj_set.o_size = name_set.n_size = 0;
+	free_variables();
+	return grsecurity_init(args);
+}
+
+/* The following variables are needed for timer manipulation */
+static struct timer_list gr_badpw;
+static int failures = 0;
+static int during_wait = 0;
+
+static void
+gr_timer(unsigned long ignored)
+{
+	failures = 0;
+	during_wait = 0;
+	del_timer(&gr_badpw);
+
+	return;
+}
+
+int
+gr_proc_handler(ctl_table * table, int write, struct file *filp, void *buffer,
+		size_t * lenp)
+{
+	struct gr_arg *arg = (struct gr_arg *) buffer;
+	struct gr_arg usermode;
+	int error = sizeof (struct gr_arg);
+
+	if (*lenp != sizeof (struct gr_arg)) {
+		security_alert("Proc handler: being fed garbage %d bytes sent "
+			       "%d required", "more garbage", *lenp,
+			       sizeof (struct gr_arg));
+		return -EINVAL;
+	}
+	if (during_wait)
+		return -EPERM;
+
+	if (copy_from_user(&usermode, arg, sizeof (struct gr_arg)))
+		return -EFAULT;
+	/* Okay. 
+	 * We have our enough of the argument structure..(we have yet
+	 * to copy_from_user the tables themselves) . Copy the tables
+	 * only if we need them, i.e. for loading operations. */
+
+	switch (usermode.mode) {
+	case SHUTDOWN:
+		if ((gr_status & GR_READY) && !(chkpw(&usermode))) {
+			security_alert("shutdown auth success for " 
+					DEFAULTSECMSG, "shutdown successes",
+				       DEFAULTSECARGS);
+			gr_status &= ~GR_READY;
+			break;
+		} else if(gr_status & GR_READY){
+			security_alert("shutdown auth failure for "
+					DEFAULTSECMSG, "shutdown failures",
+					DEFAULTSECARGS);
+			error = -EPERM;
+		} else {
+			security_alert("Ignoring shutdown for disabled acl "
+					DEFAULTSECMSG,"ignored shutdown",
+					DEFAULTSECARGS);
+		}
+		break;
+	case ENABLE:
+		if (gr_disable) {
+			security_alert("%s at boot time, ignoring load "
+				       "request", "attempts to load "
+				       "gracl when disabled on boot "
+				       "time", GR_VERSION);
+			break;
+		} else if (!(gr_status & GR_READY) && 
+			!grsecurity_init(&usermode)) {
+			security_alert("Loaded %s", "loaded grsecurity", 
+					GR_VERSION);
+			break;
+		} else {
+			security_alert("Unable to load %s for " DEFAULTSECMSG 
+					"  ACL system may already be enabled.",
+					"load failures",GR_VERSION,
+					DEFAULTSECARGS);
+			break;
+		}
+	case GOD:
+		if (!(gr_status & GR_READY)) break;
+		
+		if (!(chkpw(&usermode))) {
+			security_alert("successful change to admin mode by "
+				       DEFAULTSECMSG, "", DEFAULTSECARGS);
+			spin_lock(&task_capability_lock);
+			read_lock(&tasklist_lock);
+			if (current->p_pptr) {
+				current->p_pptr->acl = (void *) &god_label;
+				current->p_pptr->cap_effective =
+					    current->p_pptr->
+					    cap_permitted = CAP_FULL_SET;
+			}
+			read_unlock(&tasklist_lock);
+			spin_unlock(&task_capability_lock);
+		} else {
+			security_alert("admin auth failure for " DEFAULTSECMSG,
+					"admin failures", DEFAULTSECARGS);
+			error = -EPERM;
+		}
+
+		break;
+	case RELOAD:
+		if (!(gr_status & GR_READY)) break;
+		
+		if (!(chkpw(&usermode))) {
+			security_alert("reload of gracl performed by "
+					DEFAULTSECMSG, "", DEFAULTSECARGS);
+			if (grsecurity_reload(&usermode)) {
+				security_alert("Reload of %s failed",
+						"Reload of gracl failed",
+						GR_VERSION);
+				error = -EINVAL;
+			}
+		} else {
+			security_alert("reload of gracl failed by "
+					DEFAULTSECMSG, "failed reloads",
+					DEFAULTSECARGS);
+			error = -EPERM;
+		}
+
+		break;
+	case AUTH:
+		if (!(gr_status & GR_READY)) break;
+		
+		if (!(chkpw(&usermode))) {
+			security_alert("successful authentication by "
+					DEFAULTSECMSG, "", DEFAULTSECARGS);
+			read_lock(&tasklist_lock);
+
+			if (current->p_pptr)
+				current->p_pptr->acl = NULL;
+
+			read_unlock(&tasklist_lock);
+
+			/* The parent invoked gradm, it is the
+			 * task that we must deal with */
+		} else {
+			security_alert("failed auth by " DEFAULTSECMSG, 
+					"failed auths", DEFAULTSECARGS);
+			error = -EPERM;
+		}
+
+		break;
+	default:
+		security_alert("Invalid value %d by " DEFAULTSECMSG, "",
+			       usermode.mode, DEFAULTSECARGS);
+		break;
+	}
+
+	if (error != -EPERM) return error;
+
+	failures++;
+
+	if (failures > CONFIG_GR_MAXTRIES) {
+		security_alert("Maximum pw attempts reached (%d), "
+				"locking password authentication",
+				"password attempt failed", CONFIG_GR_MAXTRIES);
+		init_timer(&gr_badpw);
+		gr_badpw.data = 0;
+		gr_badpw.function = gr_timer;
+		gr_badpw.expires = jiffies + CONFIG_GR_TIMEOUT * HZ;
+		add_timer(&gr_badpw);
+		during_wait = 1;
+	}
+
+	return error;
+}
diff -urN linux/grsecurity/grsecurity.c linux/grsecurity/grsecurity.c
--- linux/grsecurity/grsecurity.c	Wed Dec 31 19:00:00 1969
+++ linux/grsecurity/grsecurity.c	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,241 @@
+#include <linux/config.h>
+
+/*
+   initialize variables  These initial states are used in two situations:
+
+   1) certain features of grsecurity are disabled (if they are enabled, 
+      then they are handled below)
+   2) the sysctl feature is enabled, in which case everything is disabled
+      at bootup and users must echo values to /proc to set the features
+*/
+
+int grsec_enable_link = 0;
+int grsec_enable_dmesg = 0;
+int grsec_enable_fifo = 0;
+int grsec_enable_fd = 0;
+int grsec_enable_execve = 0;
+int grsec_enable_execlog = 0;
+int grsec_enable_suid = 0;
+int grsec_enable_suid_root = 0;
+int grsec_enable_signal = 0;
+int grsec_enable_forkfail = 0;
+int grsec_enable_time = 0;
+int grsec_enable_group = 0;
+int grsec_audit_gid = 0;
+int grsec_enable_chdir = 0;
+int grsec_enable_audit_ptrace = 0;
+int grsec_enable_audit_ipc = 0;
+int grsec_enable_mount = 0;
+int grsec_enable_kbmap = 0;
+int grsec_enable_chroot_sig = 0;
+int grsec_enable_chroot_fchdir = 0;
+int grsec_enable_chroot_mount = 0;
+int grsec_enable_chroot_double = 0;
+int grsec_enable_chroot_pivot = 0;
+int grsec_enable_chroot_chdir = 0;
+int grsec_enable_chroot_chmod = 0;
+int grsec_enable_chroot_mknod = 0;
+int grsec_enable_chroot_ptrace = 0;
+int grsec_enable_chroot_nice = 0;
+int grsec_enable_chroot_execlog = 0;
+int grsec_enable_chroot_caps = 0;
+int grsec_enable_tpe = 0;
+int grsec_tpe_gid = 0;
+int grsec_enable_tpe_glibc = 0;
+int grsec_enable_tpe_all = 0;
+int grsec_enable_ptrace = 0;
+int grsec_enable_ptrace_group = 0;
+int grsec_ptrace_gid = 0;
+int grsec_enable_randpid = 0;
+int grsec_enable_randid = 0;
+int grsec_enable_randsrc = 0;
+int grsec_enable_randrpc = 0;
+int grsec_enable_randping = 0;
+int grsec_enable_socket_all = 0;
+int grsec_socket_all_gid = 0;
+int grsec_enable_socket_client = 0;
+int grsec_socket_client_gid = 0;
+int grsec_enable_socket_server = 0;
+int grsec_socket_server_gid = 0;
+int grsec_lock = 0;
+
+/* 
+   handle the variables if parts of grsecurity are configured without sysctl 
+   we do this as a function since it runs on bootup
+*/
+
+void grsecurity_init(void)
+{
+#ifndef CONFIG_GRKERNSEC_SYSCTL
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+grsec_enable_group = 1;
+grsec_audit_gid = CONFIG_GRKERNSEC_AUDIT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+grsec_enable_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_PTRACE
+grsec_enable_audit_ptrace = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+grsec_enable_audit_ipc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+grsec_enable_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+grsec_enable_link = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+grsec_enable_dmesg = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+grsec_enable_fifo = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FD
+grsec_enable_fd = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+grsec_enable_execve = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+grsec_enable_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SUID
+grsec_enable_suid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SUID_ROOT
+grsec_enable_suid_root = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+grsec_enable_signal = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+grsec_enable_forkfail = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+grsec_enable_time = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_KBMAP
+grsec_enable_kbmap = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SIG
+grsec_enable_chroot_sig = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+grsec_enable_chroot_fchdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+grsec_enable_chroot_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+grsec_enable_chroot_double = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+grsec_enable_chroot_pivot = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+grsec_enable_chroot_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+grsec_enable_chroot_chmod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+grsec_enable_chroot_mknod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PTRACE
+grsec_enable_chroot_ptrace = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+grsec_enable_chroot_nice = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+grsec_enable_chroot_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+grsec_enable_chroot_caps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+grsec_enable_tpe = 1;
+grsec_tpe_gid= CONFIG_GRKERNSEC_TPE_GID;
+#ifdef CONFIG_GRKERNSEC_TPE_GLIBC
+grsec_enable_tpe_glibc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+grsec_enable_tpe_all = 1;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_PTRACE
+grsec_enable_ptrace = 1;
+#ifdef CONFIG_GRKERNSEC_PTRACE_GROUP
+grsec_enable_ptrace_group = 1;
+grsec_ptrace_gid = CONFIG_GRKERNSEC_PTRACE_GID;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+grsec_enable_randpid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDID
+grsec_enable_randid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+grsec_enable_randsrc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDRPC
+grsec_enable_randrpc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPING
+grsec_enable_randping = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+grsec_enable_socket_all = 1;
+grsec_socket_all_gid= CONFIG_GRKERNSEC_SOCKET_ALL_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+grsec_enable_socket_client = 1;
+grsec_socket_client_gid= CONFIG_GRKERNSEC_SOCKET_CLIENT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+grsec_enable_socket_server = 1;
+grsec_socket_server_gid= CONFIG_GRKERNSEC_SOCKET_SERVER_GID;
+#endif
+#endif
+
+return;
+}
+
+
+const char *captab_log[30] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_FS_MASK",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",  
+	"CAP_LEASE"
+};   
+
+
diff -urN linux/grsecurity/grsum.c linux/grsecurity/grsum.c
--- linux/grsecurity/grsum.c	Wed Dec 31 19:00:00 1969
+++ linux/grsecurity/grsum.c	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,227 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/gracl.h>
+
+/*
+Modified slightly for use in gracl by Michael Dalton <michael@grsecurity.net>
+Modified for kerneli by Andrew McDonald <andrew@mcdonald.org.uk>
+from:
+
+SHA-1 in C
+By Steve Reid <steve@edmweb.com>
+100% Public Domain
+Available from:
+ftp://ftp.zedz.net/pub/crypto/crypto/HASH/sha/sha1.c
+
+Test Vectors (from FIPS PUB 180-1)
+"abc"
+  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
+"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
+  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
+A million repetitions of "a"
+  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
+*/
+
+
+
+extern struct admin_pw pwent;
+
+void
+gr_SHA1Transform(unsigned long state[5], unsigned char buffer[64])
+{
+	unsigned long a, b, c, d, e;
+	typedef union {
+		unsigned char c[64];
+		unsigned long l[16];
+	} CHAR64LONG16;
+	CHAR64LONG16 *block;
+#ifdef SHA1HANDSOFF
+	static unsigned char workspace[64];
+	block = (CHAR64LONG16 *) workspace;
+	memcpy(block, buffer, 64);
+#else
+	block = (CHAR64LONG16 *) buffer;
+#endif
+	/* Copy context->state[] to working vars */
+	a = state[0];
+	b = state[1];
+	c = state[2];
+	d = state[3];
+	e = state[4];
+	/* 4 rounds of 20 operations each. Loop unrolled. */
+	R0(a, b, c, d, e, 0);
+	R0(e, a, b, c, d, 1);
+	R0(d, e, a, b, c, 2);
+	R0(c, d, e, a, b, 3);
+	R0(b, c, d, e, a, 4);
+	R0(a, b, c, d, e, 5);
+	R0(e, a, b, c, d, 6);
+	R0(d, e, a, b, c, 7);
+	R0(c, d, e, a, b, 8);
+	R0(b, c, d, e, a, 9);
+	R0(a, b, c, d, e, 10);
+	R0(e, a, b, c, d, 11);
+	R0(d, e, a, b, c, 12);
+	R0(c, d, e, a, b, 13);
+	R0(b, c, d, e, a, 14);
+	R0(a, b, c, d, e, 15);
+	R1(e, a, b, c, d, 16);
+	R1(d, e, a, b, c, 17);
+	R1(c, d, e, a, b, 18);
+	R1(b, c, d, e, a, 19);
+	R2(a, b, c, d, e, 20);
+	R2(e, a, b, c, d, 21);
+	R2(d, e, a, b, c, 22);
+	R2(c, d, e, a, b, 23);
+	R2(b, c, d, e, a, 24);
+	R2(a, b, c, d, e, 25);
+	R2(e, a, b, c, d, 26);
+	R2(d, e, a, b, c, 27);
+	R2(c, d, e, a, b, 28);
+	R2(b, c, d, e, a, 29);
+	R2(a, b, c, d, e, 30);
+	R2(e, a, b, c, d, 31);
+	R2(d, e, a, b, c, 32);
+	R2(c, d, e, a, b, 33);
+	R2(b, c, d, e, a, 34);
+	R2(a, b, c, d, e, 35);
+	R2(e, a, b, c, d, 36);
+	R2(d, e, a, b, c, 37);
+	R2(c, d, e, a, b, 38);
+	R2(b, c, d, e, a, 39);
+	R3(a, b, c, d, e, 40);
+	R3(e, a, b, c, d, 41);
+	R3(d, e, a, b, c, 42);
+	R3(c, d, e, a, b, 43);
+	R3(b, c, d, e, a, 44);
+	R3(a, b, c, d, e, 45);
+	R3(e, a, b, c, d, 46);
+	R3(d, e, a, b, c, 47);
+	R3(c, d, e, a, b, 48);
+	R3(b, c, d, e, a, 49);
+	R3(a, b, c, d, e, 50);
+	R3(e, a, b, c, d, 51);
+	R3(d, e, a, b, c, 52);
+	R3(c, d, e, a, b, 53);
+	R3(b, c, d, e, a, 54);
+	R3(a, b, c, d, e, 55);
+	R3(e, a, b, c, d, 56);
+	R3(d, e, a, b, c, 57);
+	R3(c, d, e, a, b, 58);
+	R3(b, c, d, e, a, 59);
+	R4(a, b, c, d, e, 60);
+	R4(e, a, b, c, d, 61);
+	R4(d, e, a, b, c, 62);
+	R4(c, d, e, a, b, 63);
+	R4(b, c, d, e, a, 64);
+	R4(a, b, c, d, e, 65);
+	R4(e, a, b, c, d, 66);
+	R4(d, e, a, b, c, 67);
+	R4(c, d, e, a, b, 68);
+	R4(b, c, d, e, a, 69);
+	R4(a, b, c, d, e, 70);
+	R4(e, a, b, c, d, 71);
+	R4(d, e, a, b, c, 72);
+	R4(c, d, e, a, b, 73);
+	R4(b, c, d, e, a, 74);
+	R4(a, b, c, d, e, 75);
+	R4(e, a, b, c, d, 76);
+	R4(d, e, a, b, c, 77);
+	R4(c, d, e, a, b, 78);
+	R4(b, c, d, e, a, 79);
+	/* Add the working vars back into context.state[] */
+	state[0] += a;
+	state[1] += b;
+	state[2] += c;
+	state[3] += d;
+	state[4] += e;
+	/* Wipe variables */
+	a = b = c = d = e = 0;
+}
+
+/* SHA1Init - Initialize new context */
+
+void
+gr_SHA1Init(struct gr_SHA1_CTX *context)
+{
+	/* SHA1 initialization constants */
+	context->state[0] = 0x67452301;
+	context->state[1] = 0xEFCDAB89;
+	context->state[2] = 0x98BADCFE;
+	context->state[3] = 0x10325476;
+	context->state[4] = 0xC3D2E1F0;
+	context->count[0] = context->count[1] = 0;
+}
+
+/* Run your data through this. */
+
+void
+gr_SHA1Update(struct gr_SHA1_CTX *context, unsigned char *data,
+	      unsigned int len)
+{
+	unsigned int i, j;
+
+	j = (context->count[0] >> 3) & 63;
+	if ((context->count[0] += len << 3) < (len << 3))
+		context->count[1]++;
+	context->count[1] += (len >> 29);
+	if ((j + len) > 63) {
+		memcpy(&context->buffer[j], data, (i = 64 - j));
+		gr_SHA1Transform(context->state, context->buffer);
+		for (; i + 63 < len; i += 64) {
+			gr_SHA1Transform(context->state, &data[i]);
+		}
+		j = 0;
+	} else
+		i = 0;
+	memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+/* Add padding and return the message digest. */
+
+void
+gr_SHA1Final(unsigned char digest[20], struct gr_SHA1_CTX *context)
+{
+	unsigned long i, j;
+	unsigned char finalcount[8];
+
+	for (i = 0; i < 8; i++) {
+		finalcount[i] =
+		    (unsigned char) ((context->count[(i >= 4 ? 0 : 1)]
+				      >> ((3 - (i & 3)) * 8)) & 255);
+		/* Endian independent */
+	}
+	gr_SHA1Update(context, (unsigned char *) "\200", 1);
+	while ((context->count[0] & 504) != 448) {
+		gr_SHA1Update(context, (unsigned char *) "\0", 1);
+	}
+	gr_SHA1Update(context, finalcount, 8);	/* Should cause a SHA1Transform() */
+	for (i = 0; i < 20; i++) {
+		digest[i] = (unsigned char)
+		    ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
+	}
+	/* Wipe variables */
+	i = j = 0;
+	memset(context->buffer, 0, 64);
+	memset(context->state, 0, 20);
+	memset(context->count, 0, 8);
+	memset(&finalcount, 0, 8);
+#ifdef GR_SHA1HANDSOFF		/* make SHA1Transform overwrite it's own static vars */
+	gr_SHA1Transform(context->state, context->buffer);
+#endif
+}
+
+int
+chkpw(struct gr_arg *entry)
+{
+	struct gr_SHA1_CTX context;
+	unsigned char temp_sum[GR_SHA_LEN];
+	
+	gr_SHA1Init(&context);
+	gr_SHA1Update(&context, pwent.salt, GR_SALT_LEN);
+	gr_SHA1Update(&context, entry->pw, strlen(entry->pw));
+	gr_SHA1Final(temp_sum, &context);
+	return memcmp(pwent.sum, temp_sum, GR_SHA_LEN);
+}
diff -urN linux/include/asm-i386/a.out.h linux/include/asm-i386/a.out.h
--- linux/include/asm-i386/a.out.h	Fri Jun 16 14:33:06 1995
+++ linux/include/asm-i386/a.out.h	Mon Jun  3 21:18:06 2002
@@ -19,7 +19,14 @@
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_GRKERNSEC_STACK
+#define STACK_TOP ( \
+	(current->flags & PF_STACKEXEC) \
+	? TASK_SIZE - _STK_LIM \
+	: TASK_SIZE)
+#else
 #define STACK_TOP	TASK_SIZE
+#endif
 
 #endif
 
diff -urN linux/include/asm-i386/pgtable.h linux/include/asm-i386/pgtable.h
--- linux/include/asm-i386/pgtable.h	Thu Nov 22 14:46:19 2001
+++ linux/include/asm-i386/pgtable.h	Mon Jun  3 21:18:06 2002
@@ -192,9 +192,26 @@
 #define _PAGE_CHG_MASK	(PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)
 
 #define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_ACCESSED)
+
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define PAGE_SHARED_EXEC  __pgprot(_PAGE_PRESENT | _PAGE_RW |_PAGE_USER |_PAGE_ACCESSED)
+#define PAGE_COPY_EXEC  __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define PAGE_READONLY_EXEC  __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#else
 #define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX
+#define PAGE_SHARED_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+#define PAGE_COPY_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#define PAGE_READONLY_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_ACCESSED) 
+#else
+#define PAGE_SHARED_NOEXEC    PAGE_SHARED_EXEC
+#define PAGE_COPY_NOEXEC      PAGE_COPY_EXEC
+#define PAGE_READONLY_NOEXEC  PAGE_READONLY_EXEC
+#endif
 
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
@@ -228,6 +245,15 @@
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define __P001  PAGE_READONLY_NOEXEC
+#define __P010  PAGE_COPY_NOEXEC
+#define __P011  PAGE_COPY_NOEXEC
+#define __P100  PAGE_READONLY_EXEC
+#define __P101  PAGE_READONLY_EXEC
+#define __P110  PAGE_COPY_EXEC
+#define __P111  PAGE_COPY_EXEC
+#else
 #define __P001	PAGE_READONLY
 #define __P010	PAGE_COPY
 #define __P011	PAGE_COPY
@@ -235,8 +261,18 @@
 #define __P101	PAGE_READONLY
 #define __P110	PAGE_COPY
 #define __P111	PAGE_COPY
+#endif
 
 #define __S000	PAGE_NONE
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define __S001  PAGE_READONLY_NOEXEC
+#define __S010  PAGE_SHARED_NOEXEC
+#define __S011  PAGE_SHARED_NOEXEC
+#define __S100  PAGE_READONLY_EXEC
+#define __S101  PAGE_READONLY_EXEC
+#define __S110  PAGE_SHARED_EXEC
+#define __S111  PAGE_SHARED_EXEC
+#else
 #define __S001	PAGE_READONLY
 #define __S010	PAGE_SHARED
 #define __S011	PAGE_SHARED
@@ -244,6 +280,7 @@
 #define __S101	PAGE_READONLY
 #define __S110	PAGE_SHARED
 #define __S111	PAGE_SHARED
+#endif
 
 /*
  * Define this if things work differently on an i386 and an i486:
diff -urN linux/include/asm-i386/processor.h linux/include/asm-i386/processor.h
--- linux/include/asm-i386/processor.h	Thu Nov 22 14:46:19 2001
+++ linux/include/asm-i386/processor.h	Mon Jun  3 21:18:06 2002
@@ -267,11 +267,25 @@
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+#ifdef CONFIG_GRKERNSEC_STACK
+#define MAGIC_SIGRETURN		(PAGE_OFFSET + 0xDE0000)
+#define MAGIC_RT_SIGRETURN	(PAGE_OFFSET + 0xDE0001)
+#endif
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+#ifdef CONFIG_GRKERNSEC_STACK
+extern struct linux_binfmt elf_format;
+#define TASK_UNMAPPED_BASE(size) ( \
+       current->binfmt == &elf_format && \
+       !(current->flags & PF_STACKEXEC) && \
+       (size) < 0x00ef0000UL \
+       ? 0x00110000UL \
+       : TASK_SIZE / 3 )     
+#else
 #define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
 
+#endif
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
  */
@@ -362,6 +376,13 @@
 	unsigned long __cacheline_filler[5];
 };
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+struct pax_fault_info {
+	unsigned long eip;
+	unsigned long count;
+};
+#endif
+
 struct thread_struct {
 	unsigned long	esp0;
 	unsigned long	eip;
@@ -372,6 +393,11 @@
 	unsigned long	debugreg[8];  /* %%db0-7 debug registers */
 /* fault info */
 	unsigned long	cr2, trap_no, error_code;
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+/* PaX fault info */
+	struct pax_fault_info pax_faults;
+#endif
+
 /* floating point info */
 	union i387_union	i387;
 /* virtual 86 mode info */
@@ -383,6 +409,18 @@
 	unsigned long	io_bitmap[IO_BITMAP_SIZE+1];
 };
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define INIT_THREAD  {						\
+	0,							\
+	0, 0, 0, 0, 						\
+	{ [0 ... 7] = 0 },	/* debugging registers */	\
+	0, 0, 0,						\
+	{0, 0},			/* PaX fault info */		\
+	{ { 0, }, },		/* 387 state */			\
+	0,0,0,0,0,0,						\
+	0,{~0,}			/* io permissions */		\
+}
+#else
 #define INIT_THREAD  {						\
 	0,							\
 	0, 0, 0, 0, 						\
@@ -392,6 +430,7 @@
 	0,0,0,0,0,0,						\
 	0,{~0,}			/* io permissions */		\
 }
+#endif
 
 #define INIT_TSS  {						\
 	0,0, /* back_link, __blh */				\
diff -urN linux/include/linux/a.out.h linux/include/linux/a.out.h
--- linux/include/linux/a.out.h	Thu Nov 22 14:46:18 2001
+++ linux/include/linux/a.out.h	Mon Jun  3 21:18:06 2002
@@ -37,6 +37,14 @@
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC        1       /* Enforce PAGE_EXEC */
+#define F_PAX_EMUTRAMP        2       /* Emulate trampolines */
+#define F_PAX_MPROTECT        4       /* Restrict mprotect() */
+#define F_PAX_RANDMMAP        8       /* Randomize mmap() base */   
+#endif
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
@@ -57,6 +65,9 @@
 	((exec).a_info = \
 	 ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
 
+#ifdef CONFIG_GRKERNSEC_STACK
+#define F_STACKEXEC	1
+#endif
 /* Code indicating object file or impure executable.  */
 #define OMAGIC 0407
 /* Code indicating pure executable.  */
diff -urN linux/include/linux/binfmts.h linux/include/linux/binfmts.h
--- linux/include/linux/binfmts.h	Thu Nov 22 14:46:19 2001
+++ linux/include/linux/binfmts.h	Mon Jun  3 21:18:06 2002
@@ -1,6 +1,7 @@
 #ifndef _LINUX_BINFMTS_H
 #define _LINUX_BINFMTS_H
 
+#include <linux/config.h>
 #include <linux/ptrace.h>
 #include <linux/capability.h>
 
@@ -30,6 +31,8 @@
 	int argc, envc;
 	char * filename;	/* Name of binary */
 	unsigned long loader, exec;
+        int tweak_fd_mask;
+        struct file *tweak_fd_null;
 };
 
 /*
diff -urN linux/include/linux/dcache.h linux/include/linux/dcache.h
--- linux/include/linux/dcache.h	Thu Nov 22 14:46:18 2001
+++ linux/include/linux/dcache.h	Mon Jun  3 21:18:06 2002
@@ -124,6 +124,10 @@
 					 */
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
 
+#define OBJECT_LEVEL_1	0x00010000
+#define OBJECT_LEVEL_2	0x00020000
+#define OBJECT_LEVEL_BITS (OBJECT_LEVEL_1 | OBJECT_LEVEL_2)
+
 extern spinlock_t dcache_lock;
 
 /**
diff -urN linux/include/linux/elf.h linux/include/linux/elf.h
--- linux/include/linux/elf.h	Thu Nov 22 14:48:29 2001
+++ linux/include/linux/elf.h	Mon Jun  3 21:18:06 2002
@@ -87,6 +87,9 @@
  */
 #define EM_ALPHA	0x9026
 
+#ifdef CONFIG_GRKERNSEC_STACK
+#define EF_STACKEXEC	1
+#endif
 /*
  * This is the old interim value for S/390 architecture
  */
@@ -255,6 +258,13 @@
 #define R_MIPS_LOVENDOR		100
 #define R_MIPS_HIVENDOR		127
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC               1       /* 0: Enforce PAGE_EXEC */
+#define EF_PAX_EMUTRAMP               2       /* 0: Emulate trampolines */
+#define EF_PAX_MPROTECT               4       /* 0: Restrict mprotect() */
+#define EF_PAX_RANDMMAP               8       /* 0: Randomize mmap() base */ 
+#endif
 
 /*
  * Sparc ELF relocation types
diff -urN linux/include/linux/fs.h linux/include/linux/fs.h
--- linux/include/linux/fs.h	Mon Feb 25 14:38:13 2002
+++ linux/include/linux/fs.h	Mon Jun  3 21:18:06 2002
@@ -1048,7 +1048,11 @@
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
+#ifdef CONFIG_GRKERNSEC_ACL
+extern int do_truncate(struct dentry *, loff_t start, struct vfsmount *);
+#else
 extern int do_truncate(struct dentry *, loff_t start);
+#endif
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
diff -urN linux/include/linux/gracl.h linux/include/linux/gracl.h
--- linux/include/linux/gracl.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/gracl.h	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,228 @@
+#ifndef GR_ACL_H
+#define GR_ACL_H
+#endif
+#include <linux/grsecurity.h>
+#include <linux/grdefs.h>
+
+/* * * * * * * * * * * * * * * * * * * * *
+ * GrSecurity ACL System
+ * Main header file
+ * Purpose: define most gracl data structures 
+ * * * * * * * * * * * * * * * * * * * * */
+
+/* Major status information */
+
+#define GR_VERSION  "grsecurity 2.0"
+
+enum {
+
+	SHUTDOWN = 0,
+	ENABLE = 1,
+	CHCAPS = 2,
+	AUTH = 3,
+	GOD = 4,
+	RELOAD = 5,
+	LEARN = 6,
+	/* Number of capabilities 
+	 * see include/linux/capability.h */
+	CAP_COUNT = 30
+};
+
+/* Internal status definitions
+ * gr_set_abel() in kernel/gracl.c
+ * */
+enum {
+	GR_SET_INHERIT,
+	GR_SET_AUTH,
+	GR_SET_PROC
+};
+
+/* Password setup definitions
+ * kernel/grhash.c */
+enum {
+	GR_PW_LEN = 128,
+	GR_SALT_LEN = 16,
+	GR_SHA_LEN = 20,
+};
+
+/* Begin Data Structures */
+
+struct admin_pw {
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];	/* 160-bit SHA hash of the password */
+};
+
+/* Time support will be implemented in grsecurity 1.9.6
+struct gr_time {
+	 long acl_time_init;
+	 long acl_time_expire;
+};
+*/
+
+struct acl_subject_label {
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	kernel_cap_t cap_raise;
+	kernel_cap_t cap_lower;
+	kernel_cap_t cap_raise_inherit;
+	kernel_cap_t cap_lower_inherit;
+	/* Keeps track of the capabilities to raise and lower. 
+	 * Have to store it this way because users my change the default
+	 * capabilities, and we want to change with them(but still
+	 * keep our custom raised/lowered caps) */
+	unsigned long pos;
+	/* .. used for process object
+	   hashing. Position (i.e.
+	   subject acl number 1..n)
+	   The reason positition is part of the hash is that multiple
+	   processes may have acls for the same file, and we need some way
+	   to preventa  collision from occurring in that case,
+	   BUT subject inodes/devices may change because of create/delete
+	   operations, so position is the only thing that won't change but
+	   will still identify the acl subject
+	 */
+};
+
+struct acl_object_label {
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	unsigned long parent_pos;
+	//struct gr_time time;
+};
+
+struct name_entry {
+	ino_t inode;
+	kdev_t device;
+	__u8 mode;
+	char *name;
+};
+
+struct acl_subject_db {
+	struct acl_subject_label *s_hash;
+	unsigned long s_size;
+	unsigned long s_used;
+};
+
+struct acl_object_db {
+	struct acl_object_label *o_hash;
+	unsigned long o_size;
+	unsigned long o_used;
+};
+
+struct name_db {
+	struct name_entry *n_hash;
+	unsigned long n_size;
+	unsigned long n_used;
+};
+
+struct temp_file_label {
+	ino_t inode;
+	kdev_t device;
+	unsigned long mode;
+};
+
+struct acl_info {
+	ino_t inode;
+	kdev_t device;
+	unsigned long pos;
+};
+
+struct temp_socket_label {
+	unsigned int port;
+	__u8 mode;
+};
+
+struct label_info {
+	ino_t inode;
+	kdev_t device;
+};
+
+struct cap_entry {
+	char *capname;
+	kernel_cap_t capval;
+};
+
+struct capset {
+	struct cap_entry table[CAP_COUNT];
+};
+
+/* Userspace Grsecurity ACL data structures */
+struct user_acl_subject_label {
+	char * filename;
+	unsigned short filename_len;
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	__u32 cap_raise;
+	__u32 cap_lower;
+	__u32 cap_raise_inherit;
+	__u32 cap_lower_inherit;
+	unsigned long pos;
+	
+	/* next 3 structures not used */
+
+        struct user_acl_object_label *proc_object;
+        struct user_acl_subject_label *prev;
+        struct user_acl_subject_label *next;
+};
+
+struct user_acl_subject_db {
+	struct user_acl_subject_label **s_table;
+	unsigned long s_entries;	/* Number of entries in table */
+};
+
+#define user_gr_time gr_time
+
+struct user_acl_object_label {
+	char * filename;
+	unsigned short filename_len;
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	unsigned long parent_pos;
+	
+	/* next two structures not used */
+
+ 	struct user_acl_object_label *prev;
+        struct user_acl_object_label *next;
+};
+
+struct user_acl_object_db {
+	struct user_acl_object_label **o_table;
+	unsigned long o_entries;
+};
+
+struct gr_arg {
+	struct user_acl_object_db obj_db;
+	struct user_acl_subject_db subj_db;
+	unsigned char pw[GR_PW_LEN];
+	__u16 mode;
+
+};
+
+/* End Data Structures Section */
+
+static __inline__ unsigned long
+fhash(const ino_t ino, const kdev_t dev, const unsigned long sz)
+{
+	return (ino ^ (dev * 797)) % sz;
+}
+
+static __inline__ unsigned long
+phash(const ino_t ino, const kdev_t dev,
+      const unsigned long parent_pos, const unsigned long sz)
+{
+	/* Okay...parent_pos is the subject acl # (0..n-1 for n subject acls)
+	 * We reuse fhash here for the parent_pos portion of phash() for
+	 * simplicity's sake */
+	return (fhash(ino, dev, ~0UL) ^ fhash((ino_t) (parent_pos), 0, ~0UL))
+	    % sz;
+}
+
+static __inline__ unsigned long
+nhash(const char *name, const unsigned long sz)
+{
+	return full_name_hash(name, strlen(name)) % sz;
+}
diff -urN linux/include/linux/grdefs.h linux/include/linux/grdefs.h
--- linux/include/linux/grdefs.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/grdefs.h	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,140 @@
+
+/* Begin Status/Return value declarations */
+
+enum {
+	GR_ALLOW = 0x01,
+	GR_DENY = 0x02,
+	GR_NOTFOUND = 0x04
+};
+
+/* Begin GrSecurity status declarations */
+
+enum {
+	GR_READY = 0x01,
+	GR_LEARNING = 0x02,
+	GR_STATUS_INIT = 0x00 // disabled state
+};
+
+/* Table Size Defaults (in the form of 2^GR_TABLE_SIZE). Since
+ * our tables are dynamic, this is just the starting point, set to
+ * a reasonable value for the predicted number of MAC labels */
+enum {
+	GR_TABLE_SIZE = PAGE_SIZE	/* One page by default */
+};
+
+/* Begin  ACL declarations */
+
+/* ACL Subject and Object mode flags */
+enum {
+	GR_FIND = 0x10,
+	GR_EXISTS = 0x20,	/* ACL exists....since our hash table 
+				   will have blank entries */
+	GR_INHERIT = 0x40,
+	GR_DELETED = 0x80
+};
+
+/* ACL Object-only mode flags */
+enum {
+	GR_READ = 0x01,
+	GR_APPEND = 0x02,
+	GR_WRITE = 0x04,
+	GR_EXEC = 0x08,
+	GR_AUTH = 0x100,
+	GR_AUTH_IF_ROOT = 0x200
+};
+
+/* ACL subject-only mode flags */
+enum {
+	GR_KILL = 0x01,
+	GR_VIEW = 0x02,
+	GR_INHERIT_ONCE = 0x04,
+	GR_INHERIT_NONE = 0x08,
+	GR_PROTECTED = 0x100
+};
+
+/* To be implemented : ID based rulesets */
+
+#if 0
+enum {
+	GR_UID = 0x01,
+	GR_GID = 0x02,
+	/* for ID acls(to distinguish between UID and GID) */
+	GR_ALL = 0x04,
+	/* for the 1 UID or GID * ACL the user is allowed to set */
+	GR_ID_TPE = 0x01,
+	GR_ID_FORKBOMB = 0x02,
+	GR_ID_PTRACE = 0x04,
+	GR_ID_EXECLOG = 0x08
+};
+
+enum {
+	/* For ID acls using ports. Specifies whether a port 
+	 * is for binding or connecting */
+	GR_SOCKET_BIND = 0x01,
+	GR_SOCKET_CONNECT = 0x02
+};
+#endif
+
+/* Name hash table declarations. Used when mapping filename->inode/dev
+ * and to tell whether a particular inode/dev/filename triplet has 
+ * a process subject, process label, and/or file label assigned to it */
+enum {
+	GR_NAME_ACL_SUBJECT = 0x01,
+	GR_NAME_ACL_OBJECT = 0x02,
+};
+
+/* If we have an acl for a file that did not exist at initialization,
+ * set the inode/dev pair to something that will not conflict with
+ * anything else (since device 0 is the NULL device we're fine :) 
+ * *NOTE* - To be Implemented */
+enum {
+	GR_NOFILE_INODE = 42,
+	GR_NOFILE_DEVICE = 0
+};
+
+#define PW_CONF		"/etc/grsec/pw"
+
+enum {
+	SET_AUTH = 1,
+	SET_INHERIT = 2,
+	SET_PROC = 3
+};
+
+enum {
+	ACL_SUBJ_LABEL_OFFSET = 2
+/* The first two labels, position 0 and 1, are authentication and god modes
+ * respectively, therefore all added process subject labels must begin
+ * at offset 2 */
+};
+
+/* Begin hash section */
+
+#define GR_SHA1HANDSOFF		/* Copies data before messing with it. */
+
+struct gr_SHA1_CTX {
+	unsigned long state[5];
+	unsigned long count[2];
+	unsigned char buffer[64];
+};
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+#ifdef __LITTLE_ENDIAN
+#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
+		|(rol(block->l[i],8)&0x00FF00FF))
+#else
+#define blk0(i) block->l[i]
+#endif				/* __LITTLE_ENDIAN */
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+			^block->l[(i+2)&15]^block->l[i&15],1))
+
+	/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+/* End hash section */
diff -urN linux/include/linux/grsecurity.h linux/include/linux/grsecurity.h
--- linux/include/linux/grsecurity.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/grsecurity.h	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,154 @@
+#ifndef GR_SECURITY_H
+#define GR_SECURITY_H
+
+/* * * * * * * * * * * * * * * * * * * *
+ * Main grsecurity header file
+ * * * * * * * * * * * * * * * * * * * */
+
+/* Because this header file is used by the other sections of the kernel
+ * it defines external functions. The actual code in kernel/gracl.c
+ * uses include/linux/gracl.h. We make sure that that code ignores our
+ * extern declarations to avoid conflicts */
+
+#ifndef GR_ACL_H
+
+#include <linux/dcache.h>
+#include <linux/sysctl.h>
+#include <linux/grdefs.h>
+
+extern int gr_disable;
+extern unsigned long gr_status;
+extern int gr_check_hidden_file(struct nameidata *nd);
+extern int gr_search_file(struct dentry *dentry, __u16 mode,
+			  struct vfsmount *mnt);
+extern int gr_search_id(uid_t uid, gid_t gid, __u8 mode);
+extern int gr_search_socket(uid_t uid, gid_t gid, __u8 mode, unsigned int port);
+extern int gr_set_proc_label(struct dentry *dentry, struct vfsmount *mnt,
+			     char *filename);
+extern int gr_check_hidden_task(struct task_struct *tsk);
+extern int gr_check_protected_task(struct task_struct *tsk);
+extern int gr_copy_label(struct task_struct *tsk);
+extern int gr_in_auth_mode(void *acl);
+extern int gr_proc_handler(ctl_table * table, int write, struct file *filp,
+			   void *buffer, size_t * lenp);
+extern void gr_handle_delete(const ino_t ino, const kdev_t dev);
+extern void gr_handle_create(const char *filename, const struct nameidata *nd);
+extern void gr_set_caps(void);
+extern int gr_check_create(struct dentry *new_dentry, struct dentry *parent,
+			   struct vfsmount *mnt, __u16 mode);
+#endif
+
+extern spinlock_t task_capability_lock;
+
+extern __u16 ip_randomid(void);
+
+extern int grsec_enable_link;
+extern int grsec_enable_fifo;
+extern int grsec_enable_fd;
+extern int grsec_enable_execve;
+extern int grsec_enable_forkbomb;
+extern int grsec_forkbomb_gid;
+extern int grsec_forkbomb_sec;
+extern int grsec_forkbomb_max;
+extern int grsec_enable_execlog;
+extern int grsec_enable_suid;
+extern int grsec_enable_suid_root;
+extern int grsec_enable_signal;
+extern int grsec_enable_forkfail;
+extern int grsec_enable_time;
+extern int grsec_enable_kbmap;
+extern int grsec_enable_dmesg;
+extern int grsec_enable_chroot_sig;
+extern int grsec_enable_chroot_mount;
+extern int grsec_enable_chroot_double;
+extern int grsec_enable_chroot_pivot;
+extern int grsec_enable_chroot_chdir;
+extern int grsec_enable_chroot_chmod;
+extern int grsec_enable_chroot_mknod;
+extern int grsec_enable_chroot_fchdir;
+extern int grsec_enable_chroot_ptrace;
+extern int grsec_enable_chroot_nice;
+extern int grsec_enable_chroot_execlog;
+extern int grsec_enable_chroot_caps;
+extern int grsec_enable_tpe;
+extern int grsec_tpe_gid;
+extern int grsec_enable_tpe_glibc;
+extern int grsec_enable_tpe_all;
+extern int grsec_enable_ptrace;
+extern int grsec_enable_ptrace_group;
+extern int grsec_ptrace_gid;
+extern int grsec_enable_sidcaps;
+extern int grsec_enable_randpid;
+extern int grsec_enable_randid;
+extern int grsec_enable_randsrc;
+extern int grsec_enable_randrpc;
+extern int grsec_enable_randping;
+extern int grsec_enable_socket_all;
+extern int grsec_socket_all_gid;
+extern int grsec_enable_socket_client;
+extern int grsec_socket_client_gid;
+extern int grsec_enable_socket_server;
+extern int grsec_socket_server_gid;
+extern int grsec_audit_gid;
+extern int grsec_enable_group;
+extern int grsec_enable_audit_ipc;
+extern int grsec_enable_audit_ptrace;
+extern int grsec_enable_mount;
+extern int grsec_enable_chdir;
+extern int grsec_lock;
+
+extern const char *captab_log[30];
+extern struct task_struct *child_reaper;
+
+#define proc_is_chrooted(tsk_a)  ((tsk_a->fs->root->d_inode->i_dev != \
+			  child_reaper->fs->root->d_inode->i_dev) || \
+			  (tsk_a->fs->root->d_inode->i_ino != \
+			  child_reaper->fs->root->d_inode->i_ino))
+
+#define have_same_root(tsk_a,tsk_b) ((tsk_a->fs->root->d_inode->i_dev == \
+			  tsk_b->fs->root->d_inode->i_dev) && \
+			  (tsk_a->fs->root->d_inode->i_ino == \
+			  tsk_b->fs->root->d_inode->i_ino))
+
+#define DEFAULTSECMSG "(%.16s:%d) UID(%d) EUID(%d), parent (%.16s:%d) " \
+		      "UID(%d) EUID(%d)"
+
+#define DEFAULTSECARGS current->comm, current->pid, current->uid, \
+		       current->euid, current->p_pptr->comm, \
+		       current->p_pptr->pid, current->p_pptr->uid, \
+		       current->p_pptr->euid
+
+#define CHROOTLONGCHECK t->pid && t->fs && t->fs->root && \
+			t->fs->root->d_inode && t->p_pptr && \
+              		current->pid && current->fs && current->fs->root && \
+			current->fs->root->d_inode && \
+              		current->p_pptr && child_reaper && child_reaper->pid && \
+			child_reaper->fs && child_reaper->fs->root && \
+			child_reaper->fs->root->d_inode && \
+			grsec_enable_chroot_sig
+
+#define is_tty_allowed_for_setid(t_uid,t_uid2,t_uid3,f_name) 		\
+        if(current->tty && (!t_uid || !t_uid2 || !t_uid3) && 		\
+	((grsec_enable_serial_deny && 	 				\
+        (current->tty->driver.type == TTY_DRIVER_TYPE_SERIAL)) || 	\
+	(grsec_enable_pseudo_deny && 					\
+        (current->tty->driver.type == TTY_DRIVER_TYPE_PTY)) || 		\
+	(grsec_enable_phys_deny && 					\
+        (current->tty->driver.type == TTY_DRIVER_TYPE_CONSOLE))) 	\
+        ) { 								\
+                security_alert("attempted " f_name " root on "		\
+				"illegal console by " DEFAULTSECMSG, 	\
+                                "attempted " f_name " roots", 		\
+                                DEFAULTSECARGS); 			\
+                return -EPERM; 						\
+        }
+
+#define GR_CHROOT_CAPS ( \
+	CAP_TO_MASK(CAP_FOWNER) | CAP_TO_MASK(CAP_SYS_RESOURCE) | \
+	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG))
+
+#endif
diff -urN linux/include/linux/grsum.h linux/include/linux/grsum.h
--- linux/include/linux/grsum.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/grsum.h	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,15 @@
+/* * * * * * * * * * * * * * * * * * * *
+ * SHA-1 hash used by grsecurity 
+ * See kernel/grhash.c 
+ * * * * * * * * * * * * * * * * * * * */
+
+extern void gr_SHA1Init(struct gr_SHA1_CTX *context);
+extern void gr_SHA1Update(struct gr_SHA1_CTX *context, unsigned char *data,
+			  unsigned int len);
+extern void gr_SHA1Final(unsigned char digest[20], struct gr_SHA1_CTX *context);
+
+extern int chkpw(struct gr_arg *entry);
+/* @entry - current password entry attempt
+ * returns a memcmp() of the current password vs. entry's password,
+ * therefore 0 is success and nonzero is failure
+ */
diff -urN linux/include/linux/kernel.h linux/include/linux/kernel.h
--- linux/include/linux/kernel.h	Mon Feb 25 14:38:13 2002
+++ linux/include/linux/kernel.h	Mon Jun  3 21:18:06 2002
@@ -127,6 +127,35 @@
 	((unsigned char *)&addr)[2], \
 	((unsigned char *)&addr)[3]
 
+#ifdef CONFIG_GRKERNSEC
+#define GR_FLOODTIME CONFIG_GRKERNSEC_FLOODTIME
+#define GR_FLOODBURST CONFIG_GRKERNSEC_FLOODBURST
+#else
+#define GR_FLOODTIME 30
+#define GR_FLOODBURST 4
+#endif
+
+#define security_alert(normal_msg,flood_msg,args...) \
+({ \
+	static unsigned long warning_time = 0, no_flood_yet = 0; \
+	static spinlock_t security_alert_lock = SPIN_LOCK_UNLOCKED; \
+	\
+	spin_lock(&security_alert_lock); \
+	if(!warning_time || jiffies - warning_time > GR_FLOODTIME * HZ) { \
+	    warning_time = jiffies; no_flood_yet++; \
+	    printk(KERN_ALERT "grsec: " normal_msg "\n", ## args); \
+	} else if (no_flood_yet >= GR_FLOODBURST) { \
+	    warning_time = jiffies; no_flood_yet = 0; \
+	    printk(KERN_ALERT "grsec: more " flood_msg \
+		    ", logging disabled for %d seconds\n",GR_FLOODTIME); \
+	} \
+	\
+	spin_unlock(&security_alert_lock); \
+})
+
+#define security_debug(normal_msg,args...) \
+	printk(KERN_DEBUG "gracl: " normal_msg "\n", ## args)
+
 #define HIPQUAD(addr) \
 	((unsigned char *)&addr)[3], \
 	((unsigned char *)&addr)[2], \
diff -urN linux/include/linux/mm.h linux/include/linux/mm.h
--- linux/include/linux/mm.h	Fri Dec 21 12:42:03 2001
+++ linux/include/linux/mm.h	Mon Jun  3 21:18:06 2002
@@ -103,7 +103,11 @@
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define VM_STACK_FLAGS  0x00000133 
+#else
 #define VM_STACK_FLAGS	0x00000177
+#endif
 
 #define VM_READHINTMASK			(VM_SEQ_READ | VM_RAND_READ)
 #define VM_ClearReadHint(v)		(v)->vm_flags &= ~VM_READHINTMASK
diff -urN linux/include/linux/proc_fs.h linux/include/linux/proc_fs.h
--- linux/include/linux/proc_fs.h	Thu Nov 22 14:46:23 2001
+++ linux/include/linux/proc_fs.h	Mon Jun  3 21:18:06 2002
@@ -137,6 +137,9 @@
 extern struct proc_dir_entry *proc_mknod(const char *,mode_t,
 		struct proc_dir_entry *,kdev_t);
 extern struct proc_dir_entry *proc_mkdir(const char *,struct proc_dir_entry *);
+#ifdef CONFIG_GRKERNSEC_PROC
+extern struct proc_dir_entry *proc_priv_mkdir(const char *, mode_t mode, struct proc_dir_entry *);
+#endif
 
 static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
 	mode_t mode, struct proc_dir_entry *base, 
diff -urN linux/include/linux/sched.h linux/include/linux/sched.h
--- linux/include/linux/sched.h	Fri Dec 21 12:42:03 2001
+++ linux/include/linux/sched.h	Mon Jun  3 21:18:06 2002
@@ -225,6 +226,12 @@
 	unsigned long cpu_vm_mask;
 	unsigned long swap_address;
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+	unsigned long delta_mmap;		/* PaX: randomized offset */
+	unsigned long delta_exec;		/* PaX: randomized offset */
+	unsigned long delta_stack;		/* PaX: randomized offset */
+#endif
+ 
 	unsigned dumpable:1;
 
 	/* Architecture-specific MM context */
@@ -278,6 +285,14 @@
 extern struct user_struct root_user;
 #define INIT_USER (&root_user)
 
+#ifdef CONFIG_GRKERNSEC_ACL
+struct proc_label_info
+{
+	ino_t inode;
+	kdev_t device;
+};
+#endif
+
 struct task_struct {
 	/*
 	 * offsets of these are hardcoded elsewhere - touch with care
@@ -401,6 +416,12 @@
 	int (*notifier)(void *priv);
 	void *notifier_data;
 	sigset_t *notifier_mask;
+
+#ifdef CONFIG_GRKERNSEC_ACL
+	volatile void * acl;
+	struct proc_label_info proc_info;
+	rwlock_t acl_lock;
+#endif
 	
 /* Thread group tracking */
    	u32 parent_exec_id;
@@ -430,6 +451,13 @@
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
+#if defined(CONFIG_GRKERNSEC_PAX) || defined(CONFIG_GRKERNSEC_PAX_RANDMMAP)
+#define PF_PAX_PAGEEXEC       0x01000000      /* PaX: Enforce PAGE_EXEC */
+#define PF_PAX_EMUTRAMP       0x02000000      /* PaX: Emulate trampolines */
+#define PF_PAX_MPROTECT       0x04000000      /* PaX: Restrict mprotect() */
+#define PF_PAX_RANDMMAP       0x08000000      /* PaX: Randomize mmap() base */
+#endif
+
 /*
  * Ptrace flags
  */
@@ -437,6 +465,9 @@
 #define PT_PTRACED	0x00000001
 #define PT_TRACESYS	0x00000002
 #define PT_DTRACE	0x00000004	/* delayed trace (used on m68k, i386) */
+#ifdef CONFIG_GRKERNSEC_STACK
+#define PF_STACKEXEC    0x01000000
+#endif
 #define PT_TRACESYSGOOD	0x00000008
 #define PT_PTRACE_CAP	0x00000010	/* ptracer can follow suid-exec */
 
@@ -460,6 +491,52 @@
  *  INIT_TASK is used to set up the first task table, touch at
  * your own risk!. Base=0, limit=0x1fffff (=2MB)
  */
+#ifdef CONFIG_GRKERNSEC_ACL
+#define INIT_TASK(tsk)	\
+{									\
+    state:		0,						\
+    flags:		0,						\
+    sigpending:		0,						\
+    addr_limit:		KERNEL_DS,					\
+    exec_domain:	&default_exec_domain,				\
+    lock_depth:		-1,						\
+    counter:		DEF_COUNTER,					\
+    nice:		DEF_NICE,					\
+    policy:		SCHED_OTHER,					\
+    mm:			NULL,						\
+    active_mm:		&init_mm,					\
+    cpus_runnable:	-1,						\
+    cpus_allowed:	-1,						\
+    run_list:		LIST_HEAD_INIT(tsk.run_list),			\
+    next_task:		&tsk,						\
+    prev_task:		&tsk,						\
+    p_opptr:		&tsk,						\
+    p_pptr:		&tsk,						\
+    thread_group:	LIST_HEAD_INIT(tsk.thread_group),		\
+    wait_chldexit:	__WAIT_QUEUE_HEAD_INITIALIZER(tsk.wait_chldexit),\
+    real_timer:		{						\
+	function:		it_real_fn				\
+    },									\
+    cap_effective:	CAP_INIT_EFF_SET,				\
+    cap_inheritable:	CAP_INIT_INH_SET,				\
+    cap_permitted:	CAP_FULL_SET,					\
+    keep_capabilities:	0,						\
+    rlim:		INIT_RLIMITS,					\
+    user:		INIT_USER,					\
+    comm:		"swapper",					\
+    thread:		INIT_THREAD,					\
+    fs:			&init_fs,					\
+    files:		&init_files,					\
+    sigmask_lock:	SPIN_LOCK_UNLOCKED,				\
+    sig:		&init_signals,					\
+    pending:		{ NULL, &tsk.pending.head, {{0}}},		\
+    blocked:		{{0}},						\
+    alloc_lock:		SPIN_LOCK_UNLOCKED,				\
+    journal_info:	NULL,                                           \
+    acl:               NULL,                                            \
+    acl_lock:          RW_LOCK_UNLOCKED,                                \
+}
+#else
 #define INIT_TASK(tsk)	\
 {									\
     state:		0,						\
@@ -500,8 +577,12 @@
     pending:		{ NULL, &tsk.pending.head, {{0}}},		\
     blocked:		{{0}},						\
     alloc_lock:		SPIN_LOCK_UNLOCKED,				\
-    journal_info:	NULL,						\
+    journal_info:	NULL,                                           \
 }
+#endif
+
+
+
 
 
 #ifndef INIT_TASK_SIZE
@@ -723,6 +804,10 @@
 	return 0;
 }
 
+#ifdef CONFIG_GRKERNSEC_ACL_CAPLOG
+extern const char *captab_log[30];
+#endif
+
 /*
  * capable() checks for a particular capability.  
  * New privilege checks should use this interface, rather than suser() or
@@ -740,6 +825,16 @@
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
+#ifdef CONFIG_GRKERNSEC_ACL_CAPLOG
+	if(!current->euid && !current->uid)
+		printk(KERN_INFO "grsec: %s not raised for "
+			"(%.16s:%d) UID(%d) EUID(%d), parent (%.16s:%d) "
+                        "UID(%d) EUID(%d)\n", captab_log[cap],
+			current->comm, current->pid, current->uid,
+			current->euid, current->p_pptr->comm,
+			current->p_pptr->pid, current->p_pptr->uid,
+			current->p_pptr->euid);
+#endif
 	return 0;
 }
 
diff -urN linux/include/linux/spinlock.h linux/include/linux/spinlock.h
--- linux/include/linux/spinlock.h	Thu Nov 22 14:46:19 2001
+++ linux/include/linux/spinlock.h	Mon Jun  3 21:18:06 2002
@@ -41,7 +41,7 @@
 #elif !defined(spin_lock_init) /* !SMP and spin_lock_init not previously
                                   defined (e.g. by including asm/spinlock.h */
 
-#define DEBUG_SPINLOCKS	0	/* 0 == no debugging, 1 == maintain lock state, 2 == full debug */
+#define DEBUG_SPINLOCKS	0     /* 0 == no debugging, 1 == maintain lock state, 2 == full debug */
 
 #if (DEBUG_SPINLOCKS < 1)
 
diff -urN linux/include/linux/sysctl.h linux/include/linux/sysctl.h
--- linux/include/linux/sysctl.h	Mon Nov 26 08:29:17 2001
+++ linux/include/linux/sysctl.h	Mon Jun  3 21:18:06 2002
@@ -124,6 +124,7 @@
 	KERN_CORE_USES_PID=52,		/* int: use core or core.%pid */
 	KERN_TAINTED=53,	/* int: various kernel tainted flags */
 	KERN_CADPID=54,		/* int: PID of the process to notify on CAD */
+        KERN_GRSECURITY=68,              /* grsecurity */
 };
 
 
diff -urN linux/include/net/inetpeer.h linux/include/net/inetpeer.h
--- linux/include/net/inetpeer.h	Mon Feb 25 14:38:13 2002
+++ linux/include/net/inetpeer.h	Mon Jun  3 21:18:06 2002
@@ -15,6 +15,9 @@
 #include <linux/spinlock.h>
 #include <asm/atomic.h>
 
+extern int grsec_enable_randid;
+extern __u16 ip_randomid(void);
+
 struct inet_peer
 {
 	struct inet_peer	*avl_left, *avl_right;
@@ -58,7 +61,12 @@
 	__u16 id;
 
 	spin_lock_bh(&inet_peer_idlock);
-	id = p->ip_id_count++;
+
+	if(grsec_enable_randid)
+		id = htons(ip_randomid());
+	else
+		id = p->ip_id_count++;
+
 	spin_unlock_bh(&inet_peer_idlock);
 	return id;
 }
diff -urN linux/include/net/ip.h linux/include/net/ip.h
--- linux/include/net/ip.h	Thu Nov 22 14:47:15 2001
+++ linux/include/net/ip.h	Mon Jun  3 21:18:06 2002
@@ -196,7 +196,11 @@
 		 * does not change, they drop every other packet in
 		 * a TCP stream using header compression.
 		 */
-		iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
+
+		if(grsec_enable_randid)
+			iph->id = htons(ip_randomid());
+		else
+			iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
 	} else
 		__ip_select_ident(iph, dst);
 }
diff -urN linux/init/main.c linux/init/main.c
--- linux/init/main.c	Mon Feb 25 14:38:13 2002
+++ linux/init/main.c	Mon Jun  3 21:18:06 2002
@@ -27,6 +27,7 @@
 #include <linux/iobuf.h>
 #include <linux/bootmem.h>
 #include <linux/tty.h>
+#include <linux/grsecurity.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -110,6 +112,13 @@
 extern void perfmon_init(void);
 #endif
 
+extern void grsecurity_init(void);
+
+#ifdef CONFIG_GRKERNSEC_ACL
+static __init int gr_setup(char *line);
+#endif
+
+
 /*
  * Boot command-line arguments
  */
@@ -311,6 +320,20 @@
 
 __setup("root=", root_dev_setup);
 
+#ifdef CONFIG_GRKERNSEC_ACL
+static int __init gr_setup(char *str) 
+{
+#ifdef CONFIG_GR_DEBUG
+	security_debug("got %.3s at startup",str);
+#endif
+	if(  *str == '0' || ( !(strcmp(str,"off")) )  ) 
+		gr_disable = 1;
+	return 1;
+}
+__setup("gracl",gr_setup);
+#endif
+
+
 static int __init checksetup(char *line)
 {
 	struct kernel_param *p;
@@ -625,6 +648,7 @@
 	 *	make syscalls (and thus be locked).
 	 */
 	smp_init();
+	grsecurity_init();
 	rest_init();
 }
 
diff -urN linux/ipc/msg.c linux/ipc/msg.c
--- linux/ipc/msg.c	Fri Sep 14 17:17:00 2001
+++ linux/ipc/msg.c	Mon Jun  3 21:18:06 2002
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -326,6 +329,11 @@
 		msg_unlock(id);
 	}
 	up(&msg_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) && grsec_enable_audit_ipc) || 
+	   (grsec_enable_audit_ipc && !grsec_enable_group)) && (ret >= 0) && (msgflg & IPC_CREAT))
+		printk(KERN_INFO "grsec: message queue created by " DEFAULTSECMSG "\n", DEFAULTSECARGS);
+
 	return ret;
 }
 
@@ -560,6 +570,11 @@
 		break;
 	}
 	case IPC_RMID:
+
+		if((grsec_enable_group && in_group_p(grsec_audit_gid) && grsec_enable_audit_ipc) || 
+		   (grsec_enable_audit_ipc && !grsec_enable_group))
+			printk(KERN_INFO "grsec: message queue of uid:%d euid:%d removed by " DEFAULTSECMSG "\n", ipcp->uid,ipcp->cuid, DEFAULTSECARGS);
+
 		freeque (msqid); 
 		break;
 	}
diff -urN linux/ipc/sem.c linux/ipc/sem.c
--- linux/ipc/sem.c	Sun Sep 30 15:26:42 2001
+++ linux/ipc/sem.c	Mon Jun  3 21:18:06 2002
@@ -62,6 +62,7 @@
 #include <linux/spinlock.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -181,6 +183,11 @@
 	}
 
 	up(&sem_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) && grsec_enable_audit_ipc) || 
+	   (grsec_enable_audit_ipc && !grsec_enable_group)) && (err >= 0) && (semflg & IPC_CREAT))
+		printk(KERN_INFO "grsec: semaphore created by " DEFAULTSECMSG "\n", DEFAULTSECARGS);
+
 	return err;
 }
 
@@ -727,14 +734,20 @@
 
 	switch(cmd){
 	case IPC_RMID:
+		if((grsec_enable_group && in_group_p(grsec_audit_gid) && grsec_enable_audit_ipc) || 
+		   (grsec_enable_audit_ipc && !grsec_enable_group))
+			printk(KERN_INFO "grsec: semaphore of uid:%d euid:%d removed by " DEFAULTSECMSG "\n", ipcp->uid, ipcp->cuid, DEFAULTSECARGS);
+
 		freeary(semid);
 		err = 0;
 		break;
 	case IPC_SET:
 		ipcp->uid = setbuf.uid;
 		ipcp->gid = setbuf.gid;
+
 		ipcp->mode = (ipcp->mode & ~S_IRWXUGO)
 				| (setbuf.mode & S_IRWXUGO);
+
 		sma->sem_ctime = CURRENT_TIME;
 		sem_unlock(semid);
 		err = 0;
diff -urN linux/ipc/shm.c linux/ipc/shm.c
--- linux/ipc/shm.c	Fri Dec 21 12:42:04 2001
+++ linux/ipc/shm.c	Mon Jun  3 21:18:06 2002
@@ -23,6 +23,7 @@
 #include <linux/mman.h>
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 #include "util.h"
 
@@ -202,7 +203,9 @@
 	if(id == -1) 
 		goto no_id;
 	shp->shm_perm.key = key;
+
 	shp->shm_flags = (shmflg & S_IRWXUGO);
+
 	shp->shm_cprid = current->pid;
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
@@ -252,6 +255,12 @@
 		shm_unlock(id);
 	}
 	up(&shm_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	   grsec_enable_audit_ipc) || (grsec_enable_audit_ipc && 
+	   !grsec_enable_group)) && (err >= 0) && (shmflg & IPC_CREAT))
+		printk(KERN_INFO "grsec: shared memory of size %d created by " DEFAULTSECMSG "\n", size, DEFAULTSECARGS);
+
 	return err;
 }
 
@@ -507,6 +516,11 @@
 			err=-EPERM;
 			goto out_unlock_up;
 		}
+
+		if(((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+		   grsec_enable_audit_ipc) || (grsec_enable_audit_ipc && !grsec_enable_group)) && !err)
+			 printk(KERN_INFO "grsec: shared memory of uid:%d euid:%d removed by " DEFAULTSECMSG "\n", shp->shm_perm.uid, shp->shm_perm.cuid, DEFAULTSECARGS);
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
diff -urN linux/kernel/capability.c linux/kernel/capability.c
--- linux/kernel/capability.c	Sat Jun 24 00:06:37 2000
+++ linux/kernel/capability.c	Mon Jun  3 21:18:06 2002
@@ -7,6 +7,7 @@
 
 #include <linux/mm.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
 
@@ -186,6 +187,17 @@
      /* verify the _new_Effective_ is a subset of the _new_Permitted_ */
      if (!cap_issubset(effective, permitted)) {
              goto out;
+     }
+
+     if(grsec_enable_chroot_caps && proc_is_chrooted(current) &&
+	!have_same_root(current,target)) {
+	     security_alert("denied capset of (%.16s:%d) within chroot jail" 
+			    " (%.32s:%lu) by " DEFAULTSECMSG, "denied chroot capsets",
+			    target->comm, target->pid, 
+			    kdevname(current->fs->root->d_inode->i_dev), 
+			    current->fs->root->d_inode->i_ino,
+			    DEFAULTSECARGS);
+	     goto out;
      }
 
      /* having verified that the proposed changes are legal,
diff -urN linux/kernel/fork.c linux/kernel/fork.c
--- linux/kernel/fork.c	Mon Feb 25 14:38:13 2002
+++ linux/kernel/fork.c	Mon Jun  3 21:18:06 2002
@@ -20,6 +20,7 @@
 #include <linux/vmalloc.h>
 #include <linux/completion.h>
 #include <linux/personality.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -92,32 +93,43 @@
 
 	spin_lock(&lastpid_lock);
 	if((++last_pid) & 0xffff8000) {
-		last_pid = 300;		/* Skip daemons etc. */
+		if(!grsec_enable_randpid || (current->p_pptr->pid < 1))
+			last_pid = 300;		/* Skip daemons etc. */
 		goto inside;
 	}
-	if(last_pid >= next_safe) {
+	if(last_pid >= (grsec_enable_randpid && (current->p_pptr->pid >= 1))?2:next_safe) {
 inside:
-		next_safe = PID_MAX;
+		if(!grsec_enable_randpid || (current->p_pptr->pid < 1))
+			next_safe = PID_MAX;
 		read_lock(&tasklist_lock);
 	repeat:
+		if (grsec_enable_randpid && (current->p_pptr->pid >= 1)) {
+			do {
+				last_pid = ip_randomid() % PID_MAX;
+			} while (last_pid <= 1);
+		}
+
 		for_each_task(p) {
 			if(p->pid == last_pid	||
 			   p->pgrp == last_pid	||
 			   p->tgid == last_pid	||
 			   p->session == last_pid) {
-				if(++last_pid >= next_safe) {
+				if((!grsec_enable_randpid || (current->p_pptr->pid < 1)) &&
+				++last_pid >= next_safe) {
 					if(last_pid & 0xffff8000)
 						last_pid = 300;
 					next_safe = PID_MAX;
 				}
 				goto repeat;
 			}
-			if(p->pid > last_pid && next_safe > p->pid)
-				next_safe = p->pid;
-			if(p->pgrp > last_pid && next_safe > p->pgrp)
-				next_safe = p->pgrp;
-			if(p->session > last_pid && next_safe > p->session)
-				next_safe = p->session;
+			if(!grsec_enable_randpid || (current->p_pptr->pid < 1)){
+				if(p->pid > last_pid && next_safe > p->pid)
+					next_safe = p->pid;
+				if(p->pgrp > last_pid && next_safe > p->pgrp)
+					next_safe = p->pgrp;
+				if(p->session > last_pid && next_safe > p->session)
+					next_safe = p->session;
+			}
 		}
 		read_unlock(&tasklist_lock);
 	}
@@ -671,6 +683,11 @@
 		goto bad_fork_cleanup_fs;
 	if (copy_mm(clone_flags, p))
 		goto bad_fork_cleanup_sighand;
+#if CONFIG_GRKERNSEC_ACL
+	if (gr_copy_label(p))
+	    goto bad_fork_cleanup_sighand;
+#endif
+
 	retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);
 	if (retval)
 		goto bad_fork_cleanup_mm;
@@ -757,6 +774,10 @@
 	free_uid(p->user);
 bad_fork_free:
 	free_task_struct(p);
+
+	if(grsec_enable_forkfail)
+    		security_alert("failed fork with errno %d by " DEFAULTSECMSG,
+                  	       "failed forks",retval, DEFAULTSECARGS);
 	goto fork_out;
 }
 
diff -urN linux/kernel/ksyms.c linux/kernel/ksyms.c
--- linux/kernel/ksyms.c	Mon Feb 25 14:38:13 2002
+++ linux/kernel/ksyms.c	Mon Jun  3 21:18:06 2002
@@ -47,6 +47,7 @@
 #include <linux/in6.h>
 #include <linux/completion.h>
 #include <linux/seq_file.h>
+#include <linux/grsecurity.h>
 #include <asm/checksum.h>
 
 #if defined(CONFIG_PROC_FS)
@@ -559,3 +560,5 @@
 
 EXPORT_SYMBOL(tasklist_lock);
 EXPORT_SYMBOL(pidhash);
+
+EXPORT_SYMBOL(captab_log);
diff -urN linux/kernel/printk.c linux/kernel/printk.c
--- linux/kernel/printk.c	Mon Feb 25 14:38:13 2002
+++ linux/kernel/printk.c	Mon Jun  3 21:18:06 2002
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -294,7 +295,9 @@
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
-	if ((type != 3) && !capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) && grsec_enable_dmesg)
+		return -EPERM;
+	else if ((type != 3) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	return do_syslog(type, buf, len);
 }
diff -urN linux/kernel/sched.c linux/kernel/sched.c
--- linux/kernel/sched.c	Fri Dec 21 12:42:04 2001
+++ linux/kernel/sched.c	Mon Jun  3 21:18:06 2002
@@ -29,6 +29,7 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -874,6 +875,13 @@
 			return -EPERM;
 		if (increment < -40)
 			increment = -40;
+
+		if(grsec_enable_chroot_nice && proc_is_chrooted(current)){
+			security_alert("attempted priority change by "
+				DEFAULTSECMSG, "attempted priority changes",
+				DEFAULTSECARGS);
+			return -EPERM;
+		}
 	}
 	if (increment > 40)
 		increment = 40;
diff -urN linux/kernel/signal.c linux/kernel/signal.c
--- linux/kernel/signal.c	Wed Nov 21 19:26:27 2001
+++ linux/kernel/signal.c	Mon Jun  3 21:18:06 2002
@@ -13,6 +13,8 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -526,8 +528,36 @@
 		goto out_nolock;
 
 	spin_lock_irqsave(&t->sigmask_lock, flags);
+
+	if(CHROOTLONGCHECK && !( sig == SIGALRM || sig == SIGIO || 
+	   !proc_is_chrooted(current) || have_same_root(current,t) ||
+	   (t->pid == current->p_pptr->pid && sig == SIGCHLD) ) ) {
+		security_alert("denied signal %d out of chroot jail (%.32s:%lu) of %d.%d "
+			     "by " DEFAULTSECMSG " to " DEFAULTSECMSG,
+			     "denied signals in chroot",sig,kdevname(current->fs->root->d_inode->i_dev),
+			     current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			     current->fs->root->d_inode->i_gid,DEFAULTSECARGS,
+			     t->comm,t->pid,t->uid,t->euid,t->p_pptr->comm,
+			     t->p_pptr->pid,t->p_pptr->uid,t->p_pptr->euid);
+		goto out;
+	}
+
 	handle_stop_signal(sig, t);
 
+	if(grsec_enable_signal && ((sig == SIGSEGV) || (sig == SIGILL) || 
+	   (sig == SIGABRT) || (sig == SIGBUS))) {
+		if(t->pid == current->pid) {
+			security_alert("signal %d sent to " DEFAULTSECMSG,"signal warnings",sig,
+					t->comm,t->pid,t->uid,t->euid,t->p_pptr->comm,t->p_pptr->pid,
+					t->p_pptr->uid,t->p_pptr->euid);
+		} else {
+			security_alert("signal %d sent to " DEFAULTSECMSG " by "
+			   		DEFAULTSECMSG, "signal warnings", sig,
+					t->comm,t->pid,t->uid,t->euid,t->p_pptr->comm,t->p_pptr->pid,
+					t->p_pptr->uid,t->p_pptr->euid, DEFAULTSECARGS);
+		}
+	} 
+
 	/* Optimize away the signal, if it's a signal that can be
 	   handled immediately (ie non-blocked and untraced) and
 	   that is ignored (either explicitly or by default).  */
@@ -592,6 +622,9 @@
 		retval = -ESRCH;
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
+#ifdef CONFIG_GRKERNSEC_ACL
+			if( !(gr_check_protected_task(p)) || current->pid == 1)
+#endif
 			if (p->pgrp == pgrp) {
 				int err = send_sig_info(sig, info, p);
 				if (retval)
@@ -619,6 +652,9 @@
 		retval = -ESRCH;
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
+#ifdef CONFIG_GRKERNSEC_ACL
+			if( !(gr_check_protected_task(p)) || current->pid == 1)
+#endif
 			if (p->leader && p->session == sess) {
 				int err = send_sig_info(sig, info, p);
 				if (retval)
@@ -640,6 +676,9 @@
 	p = find_task_by_pid(pid);
 	error = -ESRCH;
 	if (p)
+#ifdef CONFIG_GRKERNSEC_ACL
+		if( !(gr_check_protected_task(p)) || current->pid == 1)
+#endif
 		error = send_sig_info(sig, info, p);
 	read_unlock(&tasklist_lock);
 	return error;
@@ -663,6 +702,9 @@
 
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
+#ifdef CONFIG_GRKERNSEC_ACL
+			if(!(gr_check_protected_task(p) || current->pid == 1))
+#endif
 			if (p->pid > 1 && p != current) {
 				int err = send_sig_info(sig, info, p);
 				++count;
diff -urN linux/kernel/sys.c linux/kernel/sys.c
--- linux/kernel/sys.c	Mon Feb 25 14:38:13 2002
+++ linux/kernel/sys.c	Mon Jun  3 21:18:06 2002
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/utsname.h>
@@ -14,6 +15,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -220,6 +222,15 @@
 		}
 		if (error == -ESRCH)
 			error = 0;
+
+		if(grsec_enable_chroot_nice && (!have_same_root(p,current)
+		   || (have_same_root(p,current) && (niceval < p->nice) && proc_is_chrooted(current)))) {
+			security_alert("attempted priority change of "
+				"process (%.16s:%d) by " DEFAULTSECMSG,
+				"attempted priority changes",p->comm,p->pid,DEFAULTSECARGS);
+			return -ESRCH; /* be stealthy */
+		}
+
 		if (niceval < p->nice && !capable(CAP_SYS_NICE))
 			error = -EACCES;
 		else
@@ -380,6 +391,10 @@
 	int new_rgid = old_rgid;
 	int new_egid = old_egid;
 
+	if((grsec_enable_suid_root && current->uid && (!rgid || !egid)) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setregid(rgid=%d/egid=%d) by " DEFAULTSECMSG
+		       "\n",rgid,egid, DEFAULTSECARGS);
+
 	if (rgid != (gid_t) -1) {
 		if ((old_rgid == rgid) ||
 		    (current->egid==rgid) ||
@@ -421,6 +436,10 @@
 {
 	int old_egid = current->egid;
 
+	if((grsec_enable_suid_root && current->uid && !gid) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setgid(%d) by " DEFAULTSECMSG "\n",gid, 
+			DEFAULTSECARGS);
+
 	if (capable(CAP_SETGID))
 	{
 		if(old_egid != gid)
@@ -540,6 +559,10 @@
 	new_euid = old_euid = current->euid;
 	old_suid = current->suid;
 
+	if((grsec_enable_suid_root && current->uid && (!ruid || !euid)) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setreuid(ruid=%d/euid=%d) by " DEFAULTSECMSG
+		       "\n",ruid,euid, DEFAULTSECARGS);
+
 	if (ruid != (uid_t) -1) {
 		new_ruid = ruid;
 		if ((old_ruid != ruid) &&
@@ -599,7 +622,11 @@
 	old_ruid = new_ruid = current->uid;
 	old_suid = current->suid;
 	new_suid = old_suid;
-	
+
+	if((grsec_enable_suid_root && current->uid && !uid) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setuid(%d) by " DEFAULTSECMSG "\n", uid,
+			DEFAULTSECARGS);
+
 	if (capable(CAP_SETUID)) {
 		if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
 			return -EAGAIN;
@@ -633,6 +660,10 @@
 	int old_euid = current->euid;
 	int old_suid = current->suid;
 
+	if((grsec_enable_suid_root && current->uid && (!ruid || !euid || !suid)) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setresuid(ruid=%d/suid=%d/euid=%d) by "
+			DEFAULTSECMSG "\n", ruid, suid, euid, DEFAULTSECARGS);
+
 	if (!capable(CAP_SETUID)) {
 		if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
 		    (ruid != current->euid) && (ruid != current->suid))
@@ -683,6 +714,10 @@
  */
 asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
+	if((grsec_enable_suid_root && current->uid && (!rgid || !egid || !sgid)) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setresgid(rgid=%d/sgid=%d/egid=%d) by "
+			DEFAULTSECMSG "\n", rgid, sgid, egid, DEFAULTSECARGS);
+
 	if (!capable(CAP_SETGID)) {
 		if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
 		    (rgid != current->egid) && (rgid != current->sgid))
@@ -732,6 +767,10 @@
 {
 	int old_fsuid;
 
+	if((grsec_enable_suid_root && current->uid && !uid) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setfsuid(%d) by " DEFAULTSECMSG "\n", uid,
+			DEFAULTSECARGS);
+
 	old_fsuid = current->fsuid;
 	if (uid == current->uid || uid == current->euid ||
 	    uid == current->suid || uid == current->fsuid || 
@@ -774,6 +813,10 @@
 {
 	int old_fsgid;
 
+	if((grsec_enable_suid_root && current->uid && !gid) || grsec_enable_suid)
+		printk(KERN_INFO "grsec: setfsgid(%d) by " DEFAULTSECMSG "\n", gid,
+			DEFAULTSECARGS);
+
 	old_fsgid = current->fsgid;
 	if (gid == current->gid || gid == current->egid ||
 	    gid == current->sgid || gid == current->fsgid || 
@@ -971,6 +1014,10 @@
 		return -EINVAL;
 	if(copy_from_user(current->groups, grouplist, gidsetsize * sizeof(gid_t)))
 		return -EFAULT;
+
+	if(grsec_enable_suid)
+		printk(KERN_INFO "grsec: setgroups by " DEFAULTSECMSG "\n", DEFAULTSECARGS);
+
 	current->ngroups = gidsetsize;
 	return 0;
 }
diff -urN linux/kernel/sysctl.c linux/kernel/sysctl.c
--- linux/kernel/sysctl.c	Fri Dec 21 12:42:04 2001
+++ linux/kernel/sysctl.c	Mon Jun  3 21:18:06 2002
@@ -38,6 +38,7 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
+#include <linux/grsecurity.h>
 
 /* External variables not in a header file. */
 extern int panic_timeout;
@@ -117,6 +118,9 @@
 static ctl_table debug_table[];
 static ctl_table dev_table[];
 extern ctl_table random_table[];
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_ACL)
+static ctl_table grsecurity_table[];
+#endif
 
 /* /proc declarations: */
 
@@ -256,8 +260,233 @@
 	{KERN_S390_USER_DEBUG_LOGGING,"userprocess_debug",
 	 &sysctl_userprocess_debug,sizeof(int),0644,NULL,&proc_dointvec},
 #endif
+#if defined(CONFIG_GRKERNSEC_SYSCTL) || defined(CONFIG_GRKERNSEC_ACL)
+	{KERN_GRSECURITY, "grsecurity", NULL, 0, 0500, grsecurity_table},
+#endif
+	{0}
+};
+
+#if !defined(CONFIG_GRKERNSEC_SYSCTL) && defined(CONFIG_GRKERNSEC_ACL)
+enum
+{
+	GS_ACL = 1
+};
+
+static ctl_table grsecurity_table[] = {
+	{GS_ACL,"acl", NULL, sizeof(int), 0600, NULL, &gr_proc_handler},
+	{0}
+};
+#endif
+
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+enum {GS_LINK=1,GS_FIFO, GS_FD, GS_EXECVE, GS_EXECLOG, 
+GS_SUID, GS_SUID_ROOT, GS_SIGNAL, GS_FORKFAIL, 
+GS_TIME, GS_KBMAP, GS_CHROOT_SIG, GS_CHROOT_MNT, GS_CHROOT_FCHDIR, 
+GS_CHROOT_DBL, GS_CHROOT_PVT, GS_CHROOT_CD, GS_CHROOT_CM, GS_CHROOT_MK, 
+GS_CHROOT_PT, GS_CHROOT_NI, GS_CHROOT_EXECLOG, GS_CHROOT_CAPS, GS_TPE, 
+GS_TPE_GID, GS_TPE_GLIBC, GS_TPE_ALL, GS_PTRACE, GS_PTRACE_GRP, 
+GS_PTRACE_GID, GS_SIDCAPS, GS_RANDPID, GS_RANDID, GS_RANDSRC, GS_RANDPING, 
+GS_SOCKET_ALL, GS_SOCKET_ALL_GID, GS_SOCKET_CLIENT, 
+GS_SOCKET_CLIENT_GID, GS_SOCKET_SERVER, GS_SOCKET_SERVER_GID, 
+GS_TTY, GS_TTYS, GS_PTY, GS_GROUP, GS_GID, GS_ACHDIR, GS_AMOUNT, GS_AIPC, 
+GS_APTC, GS_DMSG, GS_RANDRPC, GS_ACL, GS_LOCK};
+
+static ctl_table grsecurity_table[] = {
+#ifdef CONFIG_GRKERNSEC_LINK
+	{GS_LINK, "linking_restrictions", &grsec_enable_link, sizeof (int),
+	 0600, NULL, &proc_dointvec}, 
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	{GS_FIFO, "fifo_restrictions", &grsec_enable_fifo, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_FD
+	{GS_FD, "secure_fds", &grsec_enable_fd, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	{GS_EXECVE, "execve_limiting", &grsec_enable_execve, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	{GS_EXECLOG, "exec_logging", &grsec_enable_execlog, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SUID
+	{GS_SUID, "suid_logging", &grsec_enable_suid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SUID_ROOT
+	{GS_SUID_ROOT, "suid_root_logging", &grsec_enable_suid_root, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	{GS_SIGNAL, "signal_logging", &grsec_enable_signal, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	{GS_FORKFAIL, "forkfail_logging", &grsec_enable_forkfail, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	{GS_TIME, "timechange_logging", &grsec_enable_time, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_KBMAP
+	{GS_KBMAP, "secure_kbmap", &grsec_enable_kbmap, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_SIG
+	{GS_CHROOT_SIG, "chroot_restrict_sigs", &grsec_enable_chroot_sig, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	{GS_CHROOT_MNT, "chroot_deny_mount", &grsec_enable_chroot_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	{GS_CHROOT_FCHDIR, "chroot_deny_fchdir", &grsec_enable_chroot_fchdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	{GS_CHROOT_DBL, "chroot_deny_chroot", &grsec_enable_chroot_double, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	{GS_CHROOT_PVT, "chroot_deny_pivot", &grsec_enable_chroot_pivot, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	{GS_CHROOT_CD, "chroot_deny_chdir", &grsec_enable_chroot_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	{GS_CHROOT_CM, "chroot_deny_chmod", &grsec_enable_chroot_chmod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	{GS_CHROOT_MK, "chroot_deny_mknod", &grsec_enable_chroot_mknod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PTRACE
+	{GS_CHROOT_PT, "chroot_deny_ptrace", &grsec_enable_chroot_ptrace, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	{GS_CHROOT_NI, "chroot_restrict_nice", &grsec_enable_chroot_nice, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	{GS_CHROOT_EXECLOG, "chroot_execlog",
+	 &grsec_enable_chroot_execlog, sizeof (int),
+         0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	{GS_CHROOT_CAPS, "chroot_caps", &grsec_enable_chroot_caps, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	{GS_TPE, "tpe", &grsec_enable_tpe, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_TPE_GID, "tpe_gid", &grsec_tpe_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_GLIBC
+	{GS_TPE_GLIBC, "tpe_glibc", &grsec_enable_tpe_glibc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	{GS_TPE_ALL, "tpe_restrict_all", &grsec_enable_tpe_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_PTRACE
+	{GS_PTRACE, "restrict_ptrace", &grsec_enable_ptrace, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_PTRACE_GROUP
+	{GS_PTRACE_GRP, "allow_ptrace_group", &grsec_enable_ptrace_group, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_PTRACE_GID, "ptrace_gid", &grsec_ptrace_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+	{GS_RANDPID, "rand_pids", &grsec_enable_randpid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDID
+	{GS_RANDID, "rand_ip_ids", &grsec_enable_randid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+	{GS_RANDSRC, "rand_tcp_src_ports", &grsec_enable_randsrc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPING
+	{GS_RANDPING, "altered_pings", &grsec_enable_randping, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	{GS_SOCKET_ALL, "socket_all", &grsec_enable_socket_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_ALL_GID, "socket_all_gid",
+	 &grsec_socket_all_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	{GS_SOCKET_CLIENT, "socket_client", 
+	 &grsec_enable_socket_client, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_CLIENT_GID, "socket_client_gid", 
+	 &grsec_socket_client_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	{GS_SOCKET_SERVER, "socket_server", 
+	 &grsec_enable_socket_server, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_SERVER_GID, "socket_server_gid",
+	 &grsec_socket_server_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	{GS_GROUP, "audit_group", &grsec_enable_group, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_GID, "audit_gid",
+	 &grsec_audit_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	{GS_ACHDIR, "audit_chdir", &grsec_enable_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	{GS_AMOUNT, "audit_mount", &grsec_enable_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	{GS_AIPC, "audit_ipc", &grsec_enable_audit_ipc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_PTRACE
+	{GS_APTC, "audit_ptrace", &grsec_enable_audit_ptrace, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	{GS_AIPC, "dmesg", &grsec_enable_dmesg, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDRPC
+	{GS_RANDRPC, "rand_rpc", &grsec_enable_randrpc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_ACL
+	{GS_ACL,"acl", NULL, sizeof(int), 0600, NULL, &gr_proc_handler},
+#endif
+	{GS_LOCK, "grsec_lock", &grsec_lock, sizeof (int), 0600, NULL,
+	 &proc_dointvec},
 	{0}
 };
+#endif
 
 static ctl_table vm_table[] = {
 	{VM_BDFLUSH, "bdflush", &bdf_prm, 9*sizeof(int), 0644, NULL,
@@ -390,6 +619,13 @@
 
 static inline int ctl_perm(ctl_table *table, int op)
 {
+	if((table->ctl_name == KERN_GRSECURITY) && grsec_lock && (op & 002)) {
+		security_alert("attempt to modify grsecurity sysctl value : "
+			       "%.32s by " DEFAULTSECMSG, "attempted sysctl changes",
+			       table->de->name, DEFAULTSECARGS);
+		return -EACCES;
+	}
+
 	return test_perm(table->mode, op);
 }
 
@@ -828,6 +1064,15 @@
 	}
 	
 	i = (int *) table->data;
+
+        if((table->ctl_name == KERN_GRSECURITY) && grsec_lock && write) {
+                security_alert("attempt to modify grsecurity "
+                        "sysctl value: %.32s by " DEFAULTSECMSG,
+                        "attempted sysctl changes", 
+                        table->de->name, DEFAULTSECARGS);
+                return -EACCES;
+        }
+
 	vleft = table->maxlen / sizeof(int);
 	left = *lenp;
 	
diff -urN linux/kernel/time.c linux/kernel/time.c
--- linux/kernel/time.c	Mon Feb 25 14:38:13 2002
+++ linux/kernel/time.c	Mon Jun  3 21:18:06 2002
@@ -27,6 +27,7 @@
 #include <linux/mm.h>
 #include <linux/timex.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -87,6 +88,10 @@
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
 	write_unlock_irq(&xtime_lock);
+
+	if(grsec_enable_time)
+		security_alert("time set by " DEFAULTSECMSG, "time sets", DEFAULTSECARGS);
+
 	return 0;
 }
 
@@ -163,6 +168,9 @@
 		 * globally block out interrupts when it runs.
 		 */
 		do_settimeofday(tv);
+
+		if(grsec_enable_time)
+			security_alert("time set by " DEFAULTSECMSG, "time sets", DEFAULTSECARGS);
 	}
 	return 0;
 }
diff -urN linux/mm/mmap.c linux/mm/mmap.c
--- linux/mm/mmap.c	Mon Feb 25 14:38:14 2002
+++ linux/mm/mmap.c	Mon Jun  3 21:18:06 2002
@@ -14,6 +14,8 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/personality.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -429,6 +433,23 @@
 	 */
 	vm_flags = calc_vm_flags(prot,flags) | mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+#ifdef CONFIG_GRKERNSEC_PAX
+	if (current->flags & PF_PAX_PAGEEXEC) {
+		if (!file)
+			vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+		if ((current->flags & PF_PAX_MPROTECT) && !file)
+			vm_flags &= ~VM_MAYEXEC;
+		if ((current->flags & PF_PAX_MPROTECT) && !(prot & PROT_EXEC))
+			vm_flags &= ~VM_MAYEXEC;
+#endif
+
+	} else {
+		if (prot & (PROT_READ | PROT_WRITE)) /* they imply PROT_EXEC on IA-32 */
+			vm_flags |= VM_EXEC;
+	}
+#endif
 	/* mlock MCL_FUTURE? */
 	if (vm_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
@@ -476,6 +497,53 @@
 			break;
 		}
 	}
+	if(grsec_enable_tpe && grsec_enable_tpe_glibc) {
+		if(grsec_enable_tpe_all && current->uid) {
+			if(file && (prot & PROT_EXEC) &&
+			   !(((!(file->f_dentry->d_parent->d_inode->i_uid) &&
+			   !(file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) &&
+			   !(file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH)) ||
+			   ((file->f_dentry->d_parent->d_inode->i_uid == current->uid) &&
+			   !(file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) &&
+			   !(file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH))))){
+				security_alert("denied exec of %.32s by " 
+						DEFAULTSECMSG " reason: tried to mmap binary", 
+						"denied execs", file->f_dentry->d_name.name, 
+						DEFAULTSECARGS);
+				return -EACCES;
+				goto out;
+			}
+		} else if(!grsec_enable_tpe_all && in_group_p(grsec_tpe_gid)) {
+			if(file && (prot & PROT_EXEC) &&
+			   ((file->f_dentry->d_parent->d_inode->i_uid) ||
+           		   (!(file->f_dentry->d_parent->d_inode->i_uid) &&
+           		   ((file->f_dentry->d_parent->d_inode->i_mode & S_IWGRP) ||
+			   (file->f_dentry->d_parent->d_inode->i_mode & S_IWOTH))))) {
+				security_alert("denied exec of %.32s by " 
+						DEFAULTSECMSG " reason: tried to mmap binary", 
+						"denied execs", file->f_dentry->d_name.name, 
+						DEFAULTSECARGS);
+				return -EACCES;
+				goto out;
+			}
+		}
+	}
+#ifdef CONFIG_GRKERNSEC_ACL
+	if(file && ( !gr_in_auth_mode((void *)current->acl)) )
+		if( (gr_search_file(file->f_dentry,GR_EXEC,file->f_vfsmnt))
+				== GR_DENY)
+		{
+			if(prot & PROT_EXEC) {
+				security_alert("attempt to mmap %ld %d executable "
+						"by " DEFAULTSECMSG,"mmap exec attempts",
+						file->f_dentry->d_inode->i_ino,
+						file->f_dentry->d_inode->i_dev,
+						DEFAULTSECARGS);
+				return -EACCES;
+			} else
+				vm_flags &= ~VM_MAYEXEC;
+		}
+#endif
 
 	/* Clear old maps */
 	error = -ENOMEM;
@@ -601,7 +669,30 @@
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
+#if defined(CONFIG_GRKERNSEC_STACK)
+        addr = TASK_UNMAPPED_BASE(len);
+	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE(len));
+#else
+        addr = TASK_UNMAPPED_BASE;
 	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE);
+#endif
+
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	/* PaX: randomize base address if requested */
+	if (current->flags & PF_PAX_RANDMMAP) {
+		addr = 0x100000UL + ((0xFFUL << PAGE_SHIFT) & current->mm->delta_mmap);
+		for (vma = find_vma(current->mm, addr); addr + len <= 0x01000000UL; vma = vma->vm_next) {
+			/* At this point:  (!vma || addr < vma->vm_end). */
+			if (TASK_SIZE - len < addr)
+				return -ENOMEM;
+			if (!vma || (addr + len <= vma->vm_start && addr + len < 0x01000000UL))
+				return addr;
+			addr = vma->vm_end;
+		}
+		addr = PAGE_ALIGN(TASK_UNMAPPED_BASE) + current->mm->delta_mmap;
+	}
+#endif
 
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
@@ -1050,6 +1141,18 @@
 				MAP_FIXED|MAP_PRIVATE) | mm->def_flags;
 
 	flags |= VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX
+       if (current->flags & PF_PAX_PAGEEXEC) {
+               flags &= ~VM_EXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+              if (current->flags & PF_PAX_MPROTECT)
+                      flags &= ~VM_MAYEXEC;
+#endif
+	}
+#endif
+
 
 	/* Can we just expand an old anonymous mapping? */
 	if (rb_parent && vma_merge(mm, prev, rb_parent, addr, addr + len, flags))
diff -urN linux/mm/mprotect.c linux/mm/mprotect.c
--- linux/mm/mprotect.c	Mon Sep 17 18:30:23 2001
+++ linux/mm/mprotect.c	Mon Jun  3 21:18:06 2002
@@ -300,6 +300,12 @@
 			goto out;
 		}
 
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((current->flags & PF_PAX_MPROTECT) && (prot & PROT_WRITE) && (vma->vm_flags & VM_MAYEXEC)) {
+			newflags &= ~VM_MAYWRITE;
+		}
+#endif
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
diff -urN linux/net/ipv4/Makefile linux/net/ipv4/Makefile
--- linux/net/ipv4/Makefile	Fri Dec 21 12:42:05 2001
+++ linux/net/ipv4/Makefile	Mon Jun  3 21:18:06 2002
@@ -13,7 +13,7 @@
 
 obj-y     := utils.o route.o inetpeer.o proc.o protocol.o \
 	     ip_input.o ip_fragment.o ip_forward.o ip_options.o \
-	     ip_output.o ip_sockglue.o \
+	     ip_id.o ip_output.o ip_sockglue.o \
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o tcp_minisocks.o \
 	     tcp_diag.o raw.o udp.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     sysctl_net_ipv4.o fib_frontend.o fib_semantics.o fib_hash.o
diff -urN linux/net/ipv4/af_inet.c linux/net/ipv4/af_inet.c
--- linux/net/ipv4/af_inet.c	Fri Dec 21 12:42:05 2001
+++ linux/net/ipv4/af_inet.c	Mon Jun  3 21:18:06 2002
@@ -83,6 +83,7 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -374,7 +375,10 @@
 	else
 		sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
 
-	sk->protinfo.af_inet.id = 0;
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = 0;
 
 	sock_init_data(sock,sk);
 
diff -urN linux/net/ipv4/icmp.c linux/net/ipv4/icmp.c
--- linux/net/ipv4/icmp.c	Mon Feb 25 14:38:14 2002
+++ linux/net/ipv4/icmp.c	Mon Jun  3 21:18:06 2002
@@ -87,6 +87,7 @@
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/grsecurity.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <net/checksum.h>
@@ -738,6 +739,10 @@
 
 		icmp_param.data.icmph=*skb->h.icmph;
 		icmp_param.data.icmph.type=ICMP_ECHOREPLY;
+
+		if(grsec_enable_randping)
+			icmp_param.data.icmph.un.echo.id = skb->h.icmph->un.echo.id;
+
 		icmp_param.skb=skb;
 		icmp_param.offset=0;
 		icmp_param.data_len=skb->len;
diff -urN linux/net/ipv4/ip_id.c linux/net/ipv4/ip_id.c
--- linux/net/ipv4/ip_id.c	Wed Dec 31 19:00:00 1969
+++ linux/net/ipv4/ip_id.c	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,144 @@
+/*
+ * This code is based on OpenBSD's ip_id.c, by Niels Provos.
+ * Ported to Linux 2.2 by Salvatore Sanfilippo.
+ * Ported to Linux 2.4 by Brad Spengler.
+ *
+ * 26-10-1999: Ported from OpenBSD's ip_id.c version 1.2
+ * (previous versions seems to be predictable
+ * after David Wagner's auditing)
+ * Salvatore Sanfilippo <antirez@invece.org>
+ *
+ */
+
+/*
+ * Copyright 1998 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ * Theo de Raadt <deraadt@openbsd.org> came up with the idea of using
+ * such a mathematical system to generate more random (yet non-repeating)
+ * ids to solve the resolver/named problem.  But Niels designed the
+ * actual system based on the constraints.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    This product includes software developed by Niels Provos.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
+
+#define RU_OUT 180
+#define RU_MAX 30000
+#define RU_GEN 2
+#define RU_N 32749
+#define RU_AGEN 7
+#define RU_M 31104
+#define PFAC_N 3
+const static __u16 pfacts[PFAC_N] = { 2,3,2729 };
+
+static __u16 ru_x;
+static __u16 ru_seed, ru_seed2;
+static __u16 ru_a, ru_b;
+static __u16 ru_g;
+static __u16 ru_counter = 0;
+static __u16 ru_msb = 0;
+static __u32 ru_reseed;
+static __u32 tmp;
+
+static __u16 pmod(u_int16_t, u_int16_t, u_int16_t);
+static void ip_initid (void);
+__u16 ip_randomip (void);
+
+static __u16 pmod(__u16 gen, __u16 exp, __u16 mod) {
+	__u16 s, t, u;
+
+	s = 1;
+	t = gen;
+	u = exp;
+
+	while(u) {
+		if (u & 1)
+			s = (s*t) % mod;
+		u >>=1;
+		t = (t*t) % mod;
+	}
+	return(s);
+}
+
+static void ip_initid (void) { 	
+	__u16 j, i;
+	int noprime = 1;
+
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	ru_x = (tmp & 0xFFFF) % RU_M;
+	ru_seed = (tmp >> 16) & 0x7FFF;
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	ru_seed2 = tmp & 0x7FFF;
+	
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	
+	ru_b = (tmp & 0xfffe) | 1;
+	ru_a = pmod(RU_AGEN, (tmp >> 16) & 0xfffe, RU_M);
+	while (ru_b % 3 == 0)
+		ru_b += 2;
+
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	j = tmp % RU_N;
+	tmp = tmp >> 16;
+	
+	while(noprime) {
+		for (i=0; i<PFAC_N; i++)
+			if(j%pfacts[i] == 0)
+				break;
+		
+		if (i>=PFAC_N)
+			noprime = 0;
+		else
+			j = (j+1) % RU_N;
+	}
+
+	ru_g = pmod(RU_GEN,j,RU_N);
+	ru_counter = 0;
+	ru_reseed = jiffies + (RU_OUT * HZ);
+	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000;
+}
+
+__u16 ip_randomid (void) {
+	int i, n;
+	
+	if (ru_counter >= RU_MAX || jiffies > ru_reseed)
+		ip_initid();
+
+	if (!tmp)
+		get_random_bytes((void *) &tmp, sizeof(tmp));
+
+	n = tmp & 0x3; tmp = tmp >> 2;
+	if (ru_counter + n >= RU_MAX)
+		ip_initid();
+	for (i=0; i <= n; i++)
+		ru_x = (ru_a*ru_x + ru_b) % RU_M;
+	ru_counter += i;
+	
+	return (ru_seed ^ pmod(ru_g,ru_seed2 ^ ru_x, RU_N)) | ru_msb;
+}
diff -urN linux/net/ipv4/ip_output.c linux/net/ipv4/ip_output.c
--- linux/net/ipv4/ip_output.c	Wed Oct 17 17:16:39 2001
+++ linux/net/ipv4/ip_output.c	Mon Jun  3 21:18:06 2002
@@ -77,6 +77,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/mroute.h>
 #include <linux/netlink.h>
+#include <linux/grsecurity.h>
 
 /*
  *      Shall we try to damage output packets if routing dev changes?
@@ -510,7 +511,11 @@
 	 *	Begin outputting the bytes.
 	 */
 
-	id = sk->protinfo.af_inet.id++;
+	if(grsec_enable_randid) { 
+		id = htons(ip_randomid());	
+		sk->protinfo.af_inet.id = id;
+	} else
+		id = sk->protinfo.af_inet.id++;
 
 	do {
 		char *data;
diff -urN linux/net/ipv4/netfilter/Config.in linux/net/ipv4/netfilter/Config.in
--- linux/net/ipv4/netfilter/Config.in	Mon Feb 25 14:38:14 2002
+++ linux/net/ipv4/netfilter/Config.in	Mon Jun  3 21:18:06 2002
@@ -25,6 +25,7 @@
   dep_tristate '  LENGTH match support' CONFIG_IP_NF_MATCH_LENGTH $CONFIG_IP_NF_IPTABLES
   dep_tristate '  TTL match support' CONFIG_IP_NF_MATCH_TTL $CONFIG_IP_NF_IPTABLES
   dep_tristate '  tcpmss match support' CONFIG_IP_NF_MATCH_TCPMSS $CONFIG_IP_NF_IPTABLES
+  dep_tristate '  stealth match support' CONFIG_IP_NF_MATCH_STEALTH $CONFIG_IP_NF_IPTABLES
   if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ]; then
     dep_tristate '  Connection state match support' CONFIG_IP_NF_MATCH_STATE $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES 
   fi
diff -urN linux/net/ipv4/netfilter/Makefile linux/net/ipv4/netfilter/Makefile
--- linux/net/ipv4/netfilter/Makefile	Mon Feb 25 14:38:14 2002
+++ linux/net/ipv4/netfilter/Makefile	Mon Jun  3 21:18:06 2002
@@ -64,6 +64,7 @@
 obj-$(CONFIG_IP_NF_MATCH_STATE) += ipt_state.o
 obj-$(CONFIG_IP_NF_MATCH_UNCLEAN) += ipt_unclean.o
 obj-$(CONFIG_IP_NF_MATCH_TCPMSS) += ipt_tcpmss.o
+obj-$(CONFIG_IP_NF_MATCH_STEALTH) += ipt_stealth.o
 
 # targets
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
diff -urN linux/net/ipv4/netfilter/ipt_stealth.c linux/net/ipv4/netfilter/ipt_stealth.c
--- linux/net/ipv4/netfilter/ipt_stealth.c	Wed Dec 31 19:00:00 1969
+++ linux/net/ipv4/netfilter/ipt_stealth.c	Mon Jun  3 21:18:06 2002
@@ -0,0 +1,102 @@
+/* Kernel module to add stealth support.
+ *
+ * Copyright (C) 2002 Brad Spengler  <spender@grsecurity.net>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/inet.h>
+#include <linux/stddef.h>
+
+#include <net/ip.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+MODULE_LICENSE("GPL");
+
+#define TH_FIN  0x01
+#define TH_SYN  0x02
+#define TH_RST  0x04
+#define TH_ACK  0x10
+#define TH_ECE  0x40
+#define TH_CWR  0x80
+
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const void *matchinfo,
+      int offset,
+      const void *hdr,
+      u_int16_t datalen,
+      int *hotdrop)
+{
+	struct iphdr *ip = skb->nh.iph;
+	struct iphdr *udpip = (struct iphdr*)skb->data;
+        struct udphdr *uh = (struct udphdr*)(skb->data+(udpip->ihl<<2));
+	struct tcphdr *th = (struct tcphdr*)(skb->data+(ip->ihl<<2));
+	struct sock *sk = NULL;
+	u_int8_t tcpflags;
+
+	if(ip->protocol == IPPROTO_TCP) {
+		tcpflags = (((u_int8_t *)th)[13] & ~(TH_ECE|TH_CWR));
+		if(tcpflags & TH_SYN)		
+			sk = tcp_v4_lookup_listener(ip->daddr, ntohs(th->dest), ((struct rtable*)skb->dst)->rt_iif);	
+	} else if(ip->protocol == IPPROTO_UDP)
+		sk = udp_v4_lookup(udpip->saddr, uh->source, udpip->daddr, uh->dest, skb->dev->ifindex);
+	else
+		return 0;
+
+	if(sk != NULL)
+		return 0;
+	else
+		return 1;
+}
+
+/* Called when user tries to insert an entry of this type. */
+static int
+checkentry(const char *tablename,
+           const struct ipt_ip *ip,
+           void *matchinfo,
+           unsigned int matchsize,
+           unsigned int hook_mask)
+{
+        if (matchsize != IPT_ALIGN(0))
+                return 0;
+
+	if((ip->proto == IPPROTO_TCP && !(ip->invflags & IPT_INV_PROTO)) ||
+		((ip->proto == IPPROTO_UDP) && !(ip->invflags & IPT_INV_PROTO)))
+			return 1;
+
+
+	printk("stealth: Only works on TCP and UDP\n");
+        return 0;
+}
+
+
+static struct ipt_match stealth_match
+= { { NULL, NULL }, "stealth", &match, &checkentry, NULL, THIS_MODULE };
+
+static int __init init(void)
+{
+	return ipt_register_match(&stealth_match);
+}
+
+static void __exit fini(void)
+{
+	ipt_unregister_match(&stealth_match);
+}
+
+module_init(init);
+module_exit(fini);
diff -urN linux/net/ipv4/tcp_ipv4.c linux/net/ipv4/tcp_ipv4.c
--- linux/net/ipv4/tcp_ipv4.c	Mon Feb 25 14:38:14 2002
+++ linux/net/ipv4/tcp_ipv4.c	Mon Jun  3 21:18:06 2002
@@ -62,6 +62,7 @@
 #include <linux/inet.h>
 #include <linux/stddef.h>
 #include <linux/ipsec.h>
+#include <linux/grsecurity.h>
 
 extern int sysctl_ip_dynaddr;
 
@@ -211,9 +212,15 @@
 
 		spin_lock(&tcp_portalloc_lock);
 		rover = tcp_port_rover;
-		do {	rover++;
-			if ((rover < low) || (rover > high))
-				rover = low;
+                do {
+			if(grsec_enable_randsrc) {
+				rover = low + (ip_randomid() % (high - low));
+			} else {
+				rover++;
+				if ((rover < low) || (rover > high))
+					rover = low;
+			}
+
 			head = &tcp_bhash[tcp_bhashfn(rover)];
 			spin_lock(&head->lock);
 			for (tb = head->chain; tb; tb = tb->next)
@@ -725,7 +732,11 @@
 	tp->ext_header_len = 0;
 	if (sk->protinfo.af_inet.opt)
 		tp->ext_header_len = sk->protinfo.af_inet.opt->optlen;
-	sk->protinfo.af_inet.id = tp->write_seq^jiffies;
+
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = tp->write_seq^jiffies;
 
 	tp->mss_clamp = 536;
 
@@ -1450,7 +1461,11 @@
 	newtp->ext_header_len = 0;
 	if (newsk->protinfo.af_inet.opt)
 		newtp->ext_header_len = newsk->protinfo.af_inet.opt->optlen;
-	newsk->protinfo.af_inet.id = newtp->write_seq^jiffies;
+
+	if(grsec_enable_randid)
+		newsk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		newsk->protinfo.af_inet.id = newtp->write_seq^jiffies;
 
 	tcp_sync_mss(newsk, dst->pmtu);
 	newtp->advmss = dst->advmss;
diff -urN linux/net/ipv4/udp.c linux/net/ipv4/udp.c
--- linux/net/ipv4/udp.c	Mon Feb 25 14:38:14 2002
+++ linux/net/ipv4/udp.c	Mon Jun  3 21:18:06 2002
@@ -87,6 +87,7 @@
 #include <net/ip.h>
 #include <net/protocol.h>
 #include <linux/skbuff.h>
+#include <linux/grsecurity.h>
 #include <net/sock.h>
 #include <net/udp.h>
 #include <net/icmp.h>
@@ -738,7 +739,11 @@
 	sk->daddr = rt->rt_dst;
 	sk->dport = usin->sin_port;
 	sk->state = TCP_ESTABLISHED;
-	sk->protinfo.af_inet.id = jiffies;
+
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = jiffies;
 
 	sk_dst_set(sk, &rt->u.dst);
 	return(0);
diff -urN linux/net/netsyms.c linux/net/netsyms.c
--- linux/net/netsyms.c	Mon Feb 25 14:38:14 2002
+++ linux/net/netsyms.c	Mon Jun  3 21:18:06 2002
@@ -24,6 +24,7 @@
 #include <net/checksum.h>
 #include <linux/etherdevice.h>
 #include <net/route.h>
+#include <linux/grsecurity.h>
 #ifdef CONFIG_HIPPI
 #include <linux/hippidevice.h>
 #endif
@@ -587,5 +588,18 @@
 
 EXPORT_SYMBOL(net_call_rx_atomic);
 EXPORT_SYMBOL(softnet_data);
+
+#if defined(CONFIG_IP_NF_MATCH_STEALTH) || defined(CONFIG_IP_NF_MATCH_STEALTH_MODULE)
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+#if !defined (CONFIG_IPV6_MODULE) && !defined (CONFIG_KHTTPD) && !defined (CONFIG_KHTTPD_MODULE)
+EXPORT_SYMBOL(tcp_v4_lookup_listener);
+#endif
+EXPORT_SYMBOL(udp_v4_lookup);
+#endif
+
+EXPORT_SYMBOL(ip_randomid);
+EXPORT_SYMBOL(grsec_enable_randid);
+EXPORT_SYMBOL(grsec_enable_randsrc);
+EXPORT_SYMBOL(grsec_enable_randrpc);
 
 #endif  /* CONFIG_NET */
diff -urN linux/net/socket.c linux/net/socket.c
--- linux/net/socket.c	Fri Dec 21 12:42:06 2001
+++ linux/net/socket.c	Mon Jun  3 21:18:06 2002
@@ -84,6 +84,8 @@
 #include <net/sock.h>
 #include <net/scm.h>
 #include <linux/netfilter.h>
+#include <linux/grsecurity.h>
+
 
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static loff_t sock_lseek(struct file *file, loff_t offset, int whence);
@@ -912,6 +914,15 @@
 	int retval;
 	struct socket *sock;
 
+	if(grsec_enable_socket_all && (in_group_p(grsec_socket_all_gid)) 
+	   && (family != AF_UNIX) && (family != AF_LOCAL)) {
+		security_alert("attempted socket(%d,%d,%d) by "
+			DEFAULTSECMSG,"attempted sockets",family,type,protocol,
+			DEFAULTSECARGS);
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
@@ -1009,6 +1020,13 @@
 	char address[MAX_SOCK_ADDR];
 	int err;
 
+	if(grsec_enable_socket_server && (in_group_p(grsec_socket_server_gid))
+	   && umyaddr && (umyaddr->sa_family != AF_UNIX) && (umyaddr->sa_family != AF_LOCAL)){
+		security_alert("attempted bind() by " DEFAULTSECMSG,
+				"attempted binds", DEFAULTSECARGS);
+		return -EACCES;
+	}
+
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
 		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
@@ -1116,6 +1134,15 @@
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
 	int err;
+
+	if(grsec_enable_socket_client && (in_group_p(grsec_socket_client_gid))
+	   && uservaddr && (uservaddr->sa_family != AF_UNIX) && (uservaddr->sa_family != AF_LOCAL)){
+		security_alert("attempted connect() to fd %d by "
+				DEFAULTSECMSG, "attempted connects", fd, 
+				DEFAULTSECARGS);
+		err = -EACCES;
+		goto out;
+	}
 
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
diff -urN linux/net/sunrpc/xprt.c linux/net/sunrpc/xprt.c
--- linux/net/sunrpc/xprt.c	Fri Dec 21 12:42:06 2001
+++ linux/net/sunrpc/xprt.c	Mon Jun  3 21:18:06 2002
@@ -59,6 +59,7 @@
 #include <linux/unistd.h>
 #include <linux/sunrpc/clnt.h>
 #include <linux/file.h>
+#include <linux/grsecurity.h>
 
 #include <net/sock.h>
 #include <net/checksum.h>
@@ -1383,7 +1384,13 @@
 	req->rq_timeout = xprt->timeout;
 	req->rq_task	= task;
 	req->rq_xprt    = xprt;
-	req->rq_xid     = xid++;
+
+	if(grsec_enable_randrpc) {
+		req->rq_xid = ip_randomid();
+		req->rq_xid = (req->rq_xid << 16) | ip_randomid();
+	} else
+		req->rq_xid = xid++;
+
 	if (!xid)
 		xid++;
 }
