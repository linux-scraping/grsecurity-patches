diff -urN linux/Documentation/Configure.help linux/Documentation/Configure.help
--- linux/Documentation/Configure.help	2002-08-02 20:39:42.000000000 -0400
+++ linux/Documentation/Configure.help	2002-08-31 11:24:07.000000000 -0400
@@ -2493,6 +2493,20 @@
   If you want to compile it as a module, say M here and read
   <file:Documentation/modules.txt>.  If unsure, say `N'.
 
+stealth networking support
+CONFIG_IP_NF_MATCH_STEALTH
+  Enabling this option will drop all syn packets coming to unserved tcp
+  ports as well as all packets coming to unserved udp ports.  If you
+  are using your system to route any type of packets (ie. via NAT)
+  you should put this module at the end of your ruleset, since it will 
+  drop packets that aren't going to ports that are listening on your 
+  machine itself, it doesn't take into account that the packet might be 
+  destined for someone on your internal network if you're using NAT for 
+  instance.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
 MAC address match support
 CONFIG_IP_NF_MATCH_MAC
   MAC matching allows you to match packets based on the source
@@ -20527,6 +20541,644 @@
 
   "Area6" will work for most boards. For ADX, select "Area5".
 
+Grsecurity
+CONFIG_GRKERNSEC
+  If you say Y here, you will be able to configure many features that
+  will enhance the security of your system.  It is highly recommended
+  that you say Y here and read through the help for each option so
+  you fully understand the features and can evaluate their usefulness
+  for your machine.
+
+Additional security levels
+CONFIG_GRKERNSEC_LOW
+
+  Low additional security
+  -----------------------------------------------------------------------
+  If you choose this option, several of the grsecurity options will
+  be enabled that will give you greater protection against a number
+  of attacks, while assuring that none of your software will have any 
+  conflicts with the additional security measures.  If you run a lot of 
+  unusual software, or you are having problems with the higher security 
+  levels, you should say Y here.  With this option, the following features
+  are enabled:
+  
+  linking restrictions
+  fifo restrictions
+  random pids
+  enforcing nproc on execve()
+  restricted dmesg
+  random ip ids
+  enforced chdir("/") on chroot
+
+  Medium additional security
+  -----------------------------------------------------------------------
+  If you say Y here, several features in addition to those included in the 
+  low additional security level will be enabled.  These features provide
+  even more security to your system, though in rare cases they may
+  be incompatible with very old or poorly written software.  If you 
+  enable this option, make sure that your auth service (identd) is 
+  running as gid 10 (usually group wheel). With this option the following 
+  features (in addition to those provided in the low additional security 
+  level) will be enabled:
+
+  random tcp source ports
+  altered ping ids
+  failed fork logging
+  time change logging
+  signal logging
+  deny mounts in chroot
+  deny double chrooting
+  deny mknod in chroot
+  /proc restrictions with special gid set to 10 (usually wheel)
+  pax's random mmap
+
+  High additional security
+  ----------------------------------------------------------------------
+  If you say Y here, many of the features of grsecurity will be enabled,
+  that will protect you against virtually all kinds of attacks against
+  your system.  The much hightened security comes at a cost of an 
+  increased chance of incompatabilities with rare software on your 
+  machine.  It is highly recommended that you view 
+  <http://grsecurity.net/features.htm> and read about each option.  Since 
+  this security level enabled PaX, you should also view 
+  <http://pageexec.virtualave.net> and read about the PaX project.  While 
+  you are there, download chpax.c and run chpax -p on binaries that cause 
+  problems with PaX.  Also remember that since the /proc restrictions are 
+  enabled, you must run your identd as group wheel (gid 10).  The 
+  grsecurity ACL system is also enabled in this level.  To learn how to 
+  correctly configure it, view the ACL documentation on 
+  <http://grsecurity.net>.  This security level enables the following 
+  features in addition to those listed in the low and medium security 
+  levels:
+
+  additional /proc restrictions
+  signal restrictions in chroot
+  chmod restrictions in chroot
+  no ptrace in chroot
+  priority restrictions in chroot
+  PaX - random mmap, noexec on all memory pages, restricted mprotect
+  fixed mmap restrictions
+  mount/unmount/remount logging
+  protect capability-aware processes
+
+Customized additional security
+CONFIG_GRKERNSEC_CUSTOM
+  If you say Y here, you will be able to configure every grsecurity 
+  option, which allows you to enable many more features that aren't 
+  covered in the basic security levels.  These additional features include 
+  TPE, socket restrictions, and the sysctl system for grsecurity.  It is 
+  advised that you read through the help for each option to determine its 
+  usefulness in your situation.
+
+Enforce non-executable pages
+CONFIG_GRKERNSEC_PAX_NOEXEC
+  By design the IA-32 architecture does not allow for protecting
+  memory pages against execution, i.e. if a page is readable (such
+  as the stack or heap) it is also executable.  There is a well
+  known exploit technique that makes use of this fact and a common
+  programming mistake where an attacker can introduce executable
+  code of his choice somewhere in the attacked program's memory
+  (typically the stack or the heap) and then execute it.  If the
+  attacked program was running with different (typically higher)
+  privileges than that of the attacker, then he can elevate his
+  own privilege level (e.g. get a root shell, write to files for
+  which he does not have write access to, etc).
+
+  There are two implementations provided here, each with its own
+  impact on performance and usability.  You should enable at least
+  one of them to enforce the non-executable flag on memory pages
+  thereby making it harder to execute 'foreign' code in a program.
+
+  This will also break programs that rely on the old behaviour and
+  expect that dynamically allocated memory via the malloc() family
+  of functions is executable (which it is not).  Notable examples
+  are the XFree86 4.x server, the java runtime and wine.
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis.  chpax is available at
+  <http://pageexec.virtualave.net>
+
+Paging based non-executable pages
+CONFIG_GRKERNSEC_PAX_PAGEEXEC
+  This implementation is based on the paging feature of the CPU
+  and has a variable performance impact on applications depending
+  on their memory usage pattern.  You should carefully evaluate
+  your applications before using this feature in production.
+
+Segmentation based non-executable pages
+CONFIG_GRKERNSEC_PAX_SEGMEXEC
+  This implementation is based on the segmentation feature of the
+  CPU and has little performance impact, however applications will
+  be limited to a 1.5 GB address space instead of the normal 3 GB.
+
+Emulate trampolines
+CONFIG_GRKERNSEC_PAX_EMUTRAMP
+  There are some programs and libraries that for one reason or
+  another attempt to execute special small code snippets from
+  non-executable memory pages.  Most notable examples are the
+  signal handler return code generated by the kernel itself and
+  the GCC trampolines.
+
+  If you enabled CONFIG_GRKERNSEC_PAX_PAGEEXEC or 
+  CONFIG_GRKERNSEC_PAX_SEGMEXEC then such programs will no longer
+  work under your kernel.
+
+  As a remedy you can say Y here and use the 'chpax' utility to
+  enable trampoline emulation for the affected programs yet still
+  have the protection provided by the non-executable pages.
+
+  Alternatively you can say N here and use the 'chpax' utility
+  to disable CONFIG_GRKERNSEC_PAX_PAGEEXEC and 
+  CONFIG_GRKERNSEC_PAX_SEGMEXEC for the affected files.
+
+  NOTE: enabling this feature *may* open up a loophole in the
+  protection provided by non-executable pages that an attacker
+  could abuse.  Therefore the best solution is to not have any
+  files on your system that would require this option.  This can
+  be achieved by not using libc5 (which relies on the kernel
+  signal handler return code) and not using or rewriting programs
+  that make use of the nested function implementation of GCC.
+  Skilled users can just fix GCC itself so that it implements
+  nested function calls in a way that does not interfere with PaX.
+
+Restrict mprotect()
+CONFIG_GRKERNSEC_PAX_MPROTECT
+  Enabling this option will prevent programs from
+   - changing the executable status of memory pages that were
+     not originally created as executable,
+   - making read-only executable pages writable again,
+   - creating executable pages from anonymous memory.
+
+  You should say Y here to complete the protection provided by
+  the enforcement of non-executable pages.
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis. chpax is available at
+  <http://pageexec.virtualave.net>
+
+Full Address Space Layout Randomization (ASLR)
+CONFIG_GRKERNSEC_PAX_RANDMMAP
+  By saying Y here the kernel will somewhat randomize the address
+  space layout of programs at each execution (the top of the stack, the
+  base address for mmap() requests that do not specify one themselves
+  and the base address of dynamic ELF executables).
+
+  As a result all dynamically loaded libraries will appear at random
+  addresses and therefore be harder to exploit by a technique where
+  an attacker attempts to execute library code for his purposes
+  (e.g. spawn a shell from an exploited program that is running at
+  an elevated privilege level).
+
+  Furthermore, if a program is relinked as a dynamic ELF file, its
+  base address layout will be randomized as well, completing the full
+  randomization of the address space.  Attacking such programs becomes
+  a guess game.
+
+  It is strongly recommended to say Y here as address space layout
+  randomization has negligible impact on performance yet it provides
+  a very effective protection.
+
+  NOTE: you can use the 'chpax' utility to enable/disable this
+  feature on a per file basis.  chpax is available at
+  <http://pageexec.virtualave.net>
+
+Deny access to /dev/kmem
+CONFIG_GRKERNSEC_KMEM
+  If you say Y here, /dev/kmem won't be allowed to be opened.
+  This keeps it from being read from or written to via both mmap and
+  ioctl.  If you have module support disabled, enabling this feature
+  will close up the two ways currently used to insert malicious code into
+  the running kernel.  It is still possible to insert code into the 
+  kernel via /dev/mem, however, so we highly recommend that you use 
+  grsecurity's ACL system, as it protects against this by default. This 
+  option is not known to cause any software incompatibilities, therefore 
+  it is recommended that you say Y here.
+
+Proc Restrictions
+CONFIG_GRKERNSEC_PROC
+  If you say Y here, the permissions of the /proc filesystem
+  will be altered to enhance system security and privacy.  Depending
+  upon the options you choose, you can either restrict users to see
+  only the processes they themselves run, or choose a group that can
+  view all processes and files normally restricted to root if you choose
+  the "restrict to user only" option.  NOTE: If you're running identd as 
+  a non-root user, you will have to run it as the group you specify here.
+
+Restrict /proc to user only
+CONFIG_GRKERNSEC_PROC_USER
+  If you say Y here, non-root users will only be able to view their own 
+  processes, and restricts them from viewing network-related information,  
+  and viewing kernel symbol and module information.
+
+Restrict /proc to user and group
+CONFIG_GRKERNSEC_PROC_USERGROUP
+  If you say Y here, you will be able to select a group that will be
+  able to view all processes, network-related information, and
+  kernel and symbol information.  This option is useful if you want
+  to run identd as a non-root user.
+
+Remove mem and maps support
+CONFIG_GRKERNSEC_PROC_MEMMAP
+  If you say Y here, the /proc/<pid>/mem and /proc/<pid>/maps files
+  will no longer be accessible.  If you use PaX it is greatly
+  recommended that you say Y here as it closes up a hole that makes the 
+  full ASLR useless for suid binaries.  No legitimate programs should have
+  to use either of the two files.
+
+Additional proc restrictions
+CONFIG_GRKERNSEC_PROC_ADD
+  If you say Y here, additional restrictions will be placed on
+  /proc that keep normal users from viewing cpu and device information.
+
+Dmesg(8) Restriction
+CONFIG_GRKERNSEC_DMESG
+  If you say Y here, non-root users will not be able to use dmesg(8)
+  to view up to the last 4kb of messages in the kernel's log buffer.
+  If the sysctl option is enabled, a sysctl option with name "dmesg" is 
+  created.
+
+Linking restrictions
+CONFIG_GRKERNSEC_LINK
+  If you say Y here, /tmp race exploits will be prevented, since users
+  will no longer be able to follow symlinks owned by other users in 
+  world-writeable +t directories (i.e. /tmp), unless the owner of the 
+  symlink is the owner of the directory. users will also not be
+  able to hardlink to files they do not own.  If the sysctl option is
+  enabled, a sysctl option with name "linking_restrictions" is created.
+
+FIFO restrictions
+CONFIG_GRKERNSEC_FIFO
+  If you say Y here, users will not be able to write to FIFOs they don't
+  own in world-writeable +t directories (i.e. /tmp), unless the owner of
+  the FIFO is the same owner of the directory it's held in.  If the sysctl
+  option is enabled, a sysctl option with name "fifo_restrictions" is 
+  created.
+
+Exec process limiting
+CONFIG_GRKERNSEC_EXECVE
+  If you say Y here, users with a resource limit on processes will
+  have the value checked during execve() calls.  The current system
+  only checks the system limit during fork() calls.  If the sysctl option
+  is enabled, a sysctl option with name "execve_limiting" is created.
+
+Single group for auditing
+CONFIG_GRKERNSEC_AUDIT_GROUP
+  If you say Y here, the exec, chdir, (un)mount, and ipc logging features
+  will only operate on a group you specify.  This option is recommended
+  if you only want to watch certain users instead of having a large
+  amount of logs from the entire system.  If the sysctl option is enabled,
+  a sysctl option with name "audit_group" is created.
+
+GID for auditing
+CONFIG_GRKERNSEC_AUDIT_GID
+  Here you can choose the GID that will be the target of kernel auditing.
+  Remember to add the users you want to log to the GID specified here.
+  If the sysctl option is enabled, whatever you choose here won't matter. 
+  You'll have to specify the GID in your bootup script by echoing the GID 
+  to the proper /proc entry.  View the help on the sysctl option for more 
+  information.  If the sysctl option is enabled, a sysctl option with name 
+  "audit_gid" is created.
+
+Chdir logging
+CONFIG_GRKERNSEC_AUDIT_CHDIR
+  If you say Y here, all chdir() calls will be logged.  If the sysctl 
+  option is enabled, a sysctl option with name "audit_chdir" is created.
+
+(Un)Mount logging
+CONFIG_GRKERNSEC_AUDIT_MOUNT
+  If you say Y here, all mounts and unmounts will be logged.  If the 
+  sysctl option is enabled, a sysctl option with name "audit_mount" is 
+  created.
+
+IPC logging
+CONFIG_GRKERNSEC_AUDIT_IPC
+  If you say Y here, creation and removal of message queues, semaphores,
+  and shared memory will be logged.  If the sysctl option is enabled, a
+  sysctl option with name "audit_ipc" is created.
+
+Exec logging
+CONFIG_GRKERNSEC_EXECLOG
+  If you say Y here, all execve() calls will be logged (since the
+  other exec*() calls are frontends to execve(), all execution
+  will be logged).  Useful for shell-servers that like to keep track
+  of their users.  If the sysctl option is enabled, a sysctl option with
+  name "exec_logging" is created.
+  WARNING: This option when enabled will produce a LOT of logs, especially
+  on an active system.
+
+Signal logging
+CONFIG_GRKERNSEC_SIGNAL
+  If you say Y here, certain important signals will be logged, such as
+  SIGSEGV, which will as a result inform you of when a error in a program
+  occurred, which in some cases could mean a possible exploit attempt.
+  If the sysctl option is enabled, a sysctl option with name 
+  "signal_logging" is created.
+
+Fork failure logging
+CONFIG_GRKERNSEC_FORKFAIL
+  If you say Y here, all failed fork() attempts will be logged.
+  This could suggest a fork bomb, or someone attempting to overstep
+  their process limit.  If the sysctl option is enabled, a sysctl option
+  with name "forkfail_logging" is created.
+
+Time change logging
+CONFIG_GRKERNSEC_TIME
+  If you say Y here, any changes of the system clock will be logged.
+  If the sysctl option is enabled, a sysctl option with name 
+  "timechange_logging" is created.
+
+Chroot jail restrictions
+CONFIG_GRKERNSEC_CHROOT
+  If you say Y here, you will be able to choose several options that will
+  make breaking out of a chrooted jail much more difficult.  If you
+  encounter no software incompatibilities with the following options, it
+  is recommended that you enable each one.
+
+Protect outside processes
+CONFIG_GRKERNSEC_CHROOT_FINDTASK
+  If you say Y here, processes inside a chroot will not be able to
+  kill, ptrace, capget, setpgid, getpgid, getsid, or view any process 
+  outside of the chroot.  If the sysctl option is enabled, a sysctl
+  option with name "chroot_findtask" is created.
+
+Deny mounts in chroot
+CONFIG_GRKERNSEC_CHROOT_MOUNT
+  If you say Y here, processes inside a chroot will not be able to
+  mount or remount filesystems.  If the sysctl option is enabled, a 
+  sysctl option with name "chroot_deny_mount" is created.
+
+Deny pivot_root in chroot
+CONFIG_GRKERNSEC_CHROOT_PIVOT
+  If you say Y here, processes inside a chroot will not be able to use
+  a function called pivot_root() that was introduced in Linux 2.3.41.  It 
+  works similar to chroot in that it changes the root filesystem.  This 
+  function could be misused in a chrooted process to attempt to break out 
+  of the chroot, and therefore should not be allowed.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_pivot" is 
+  created.
+
+Deny double-chroots
+CONFIG_GRKERNSEC_CHROOT_DOUBLE
+  If you say Y here, processes inside a chroot will not be able to chroot
+  again.  This is a widely used method of breaking out of a chroot jail
+  and should not be allowed.  If the sysctl option is enabled, a sysctl
+  option with name "chroot_deny_chroot" is created.
+
+Deny fchdir outside of chroot
+CONFIG_GRKERNSEC_CHROOT_FCHDIR
+  If you say Y here, a well-known method of breaking chroots by fchdir'ing 
+  to a file descriptor of the chrooting process that points to the 
+  outside filesystem will be stopped.  If the sysctl option is enabled,
+  a sysctl option with name "chroot_deny_fchdir" is created.
+
+Enforce chdir("/") on all chroots
+CONFIG_GRKERNSEC_CHROOT_CHDIR
+  If you say Y here, the current working directory of all newly-chrooted
+  applications will be set to the the root directory of the chroot.
+  The man page on chroot(2) states:
+  Note that this call does not change  the  current  working
+  directory,  so  that `.' can be outside the tree rooted at
+  `/'.  In particular, the  super-user  can  escape  from  a
+  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.  
+
+  It is recommended that you say Y here, since it's not known to break
+  any software.  If the sysctl option is enabled, a sysctl option with
+  name "chroot_enforce_chdir" is created.
+
+Deny (f)chmod +s in chroot
+CONFIG_GRKERNSEC_CHROOT_CHMOD
+  If you say Y here, processes inside a chroot will not be able to chmod
+  or fchmod files to make them have suid or sgid bits.  This protects 
+  against another published method of breaking a chroot.  If the sysctl 
+  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+  created.
+
+Deny mknod in chroot
+CONFIG_GRKERNSEC_CHROOT_MKNOD
+  If you say Y here, processes inside a chroot will not be allowed to
+  mknod.  The problem with using mknod inside a chroot is that it
+  would allow an attacker to create a device entry that is the same
+  as one on the physical root of your system, which could range from
+  anyhing from the console device to a device for your harddrive (which
+  they could then use to wipe the drive or steal data).  It is recommended
+  that you say Y here, unless you run into software incompatibilities.
+  If the sysctl option is enabled, a sysctl option with name
+  "chroot_deny_mknod" is created.
+
+Restrict priority changes in chroot
+CONFIG_GRKERNSEC_CHROOT_NICE
+  If you say Y here, processes inside a chroot will not be able to raise
+  the priority of processes in the chroot, or alter the priority of 
+  processes outside the chroot.  This provides more security than simply
+  removing CAP_SYS_NICE from the process' capability set.  If the
+  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+  is created.
+
+Log all execs within chroot
+CONFIG_GRKERNSEC_CHROOT_EXECLOG
+  If you say Y here, all executions inside a chroot jail will be logged 
+  to syslog.  If the sysctl option is enabled, a sysctl option with name
+  "chroot_execlog" is created.
+
+Chroot jail capability restrictions
+CONFIG_GRKERNSEC_CHROOT_CAPS
+  If you say Y here, the capabilities on all root processes within a
+  chroot jail will be lowered to stop module insertion, raw i/o,
+  system and net admin tasks, rebooting the system, modifying immutable 
+  files, and changing the system time.  This is left an option because it 
+  can break some apps.  Disable this if your chrooted apps are having
+  problems performing those kinds of tasks.  If the sysctl option is 
+  enabled, a sysctl option with name "chroot_caps" is created.
+
+Trusted path execution
+CONFIG_GRKERNSEC_TPE
+  If you say Y here, you will be able to choose a gid to add to the
+  supplementary groups of users you want to mark as "untrusted."
+  These users will not be able to execute any files that are not in
+  root-owned directories writeable only by root.  If the sysctl option
+  is enabled, a sysctl option with name "tpe" is created.
+
+Group for trusted path execution
+CONFIG_GRKERNSEC_TPE_GID
+  Here you can choose the GID to enable trusted path protection for.
+  Remember to add the users you want protection enabled for to the GID 
+  specified here.  If the sysctl option is enabled, whatever you choose
+  here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "tpe_gid" is created.
+
+Partially restrict non-root users
+CONFIG_GRKERNSEC_TPE_ALL
+  If you say Y here, All non-root users other than the ones in the 
+  group specified in the main TPE option will only be allowed to
+  execute files in directories they own that are not group or
+  world-writeable, or in directories owned by root and writeable only by
+  root.  If the sysctl option is enabled, a sysctl option with name 
+  "tpe_restrict_all" is created.
+
+Randomized PIDs
+CONFIG_GRKERNSEC_RANDPID
+  If you say Y here, all PIDs created on the system will be
+  pseudo-randomly generated.  This is extremely effective along
+  with the /proc restrictions to disallow an attacker from guessing
+  pids of daemons, etc.  PIDs are also used in some cases as part
+  of a naming system for temporary files, so this option would keep
+  those filenames from being predicted as well.  We also use code
+  to make sure that PID numbers aren't reused too soon.  If the sysctl
+  option is enabled, a sysctl option with name "rand_pids" is created.
+
+Randomized IP IDs
+CONFIG_GRKERNSEC_RANDID
+  If you say Y here, all the id field on all outgoing packets
+  will be randomized.  This hinders os fingerprinters and
+  keeps your machine from being used as a bounce for an untraceable
+  portscan.  Ids are used for fragmented packets, fragments belonging
+  to the same packet have the same id.  By default linux only
+  increments the id value on each packet sent to an individual host.
+  We use a port of the OpenBSD random ip id code to achieve the
+  randomness, while keeping the possibility of id duplicates to
+  near none.  If the sysctl option is enabled, a sysctl option with name
+  "rand_ip_ids" is created.
+
+Randomized TCP source ports
+CONFIG_GRKERNSEC_RANDSRC
+  If you say Y here, situations where a source port is generated on the
+  fly for the TCP protocol (ie. with connect() ) will be altered so that
+  the source port is generated at random, instead of a simple incrementing
+  algorithm.  If the sysctl option is enabled, a sysctl option with name
+  "rand_tcp_src_ports" is created.
+
+Randomized RPC XIDs
+CONFIG_GRKERNSEC_RANDRPC
+  If you say Y here, the method of determining XIDs for RPC requests will
+  be randomized, instead of using linux's default behavior of simply
+  incrementing the XID.  If you want your RPC connections to be more
+  secure, say Y here.  If the sysctl option is enabled, a sysctl option 
+  with name "rand_rpc" is created.
+
+Altered Ping IDs
+CONFIG_GRKERNSEC_RANDPING
+  If you say Y here, the way Linux handles echo replies will be changed
+  so that the reply uses an ID equal to the ID of the echo request.
+  This will help in confusing OS detection.  If the sysctl option is
+  enabled, a sysctl option with name "altered_pings" is created.
+
+Socket restrictions
+CONFIG_GRKERNSEC_SOCKET
+  If you say Y here, you will be able to choose from several options.
+  If you assign a GID on your system and add it to the supplementary
+  groups of users you want to restrict socket access to, this patch
+  will perform up to three things, based on the option(s) you choose.
+
+Deny all socket access
+CONFIG_GRKERNSEC_SOCKET_ALL
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine or run server
+  applications from your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_all" is created.
+
+Group for disabled socket access
+CONFIG_GRKERNSEC_SOCKET_ALL_GID
+  Here you can choose the GID to disable socket access for. Remember to 
+  add the users you want socket access disabled for to the GID 
+  specified here.  If the sysctl option is enabled, whatever you choose
+  here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_all_gid" is created.
+
+Deny all client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to connect to other hosts from your machine, but will be
+  able to run servers.  If this option is enabled, all users in the group
+  you specify will have to use passive mode when initiating ftp transfers
+  from the shell on your machine.  If the sysctl option is enabled, a
+  sysctl option with name "socket_client" is created.
+
+Group for disabled client socket access
+CONFIG_GRKERNSEC_SOCKET_CLIENT_GID
+  Here you can choose the GID to disable client socket access for. 
+  Remember to add the users you want client socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, whatever you 
+  choose here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_client_gid" is created.
+
+Deny all server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER
+  If you say Y here, you will be able to choose a GID of whose users will
+  be unable to run server applications from your machine.  If the sysctl 
+  option is enabled, a sysctl option with name "socket_server" is created.
+
+Group for disabled server socket access
+CONFIG_GRKERNSEC_SOCKET_SERVER_GID
+  Here you can choose the GID to disable server socket access for. 
+  Remember to add the users you want server socket access disabled for to 
+  the GID specified here.  If the sysctl option is enabled, whatever you 
+  choose here won't matter. You'll have to specify the GID in your bootup 
+  script by echoing the GID to the proper /proc entry.  View the help
+  on the sysctl option for more information.  If the sysctl option is
+  enabled, a sysctl option with name "socket_server_gid" is created.
+
+Sysctl support
+CONFIG_GRKERNSEC_SYSCTL
+  If you say Y here, you will be able to change the options that
+  grsecurity runs with at bootup, without having to recompile your
+  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+  to enable (1) or disable (0) various features.  All the sysctl entries
+  are mutable until the "grsec_lock" entry is set to a non-zero value.
+  All features are disabled by default. Please note that this option could 
+  reduce the effectiveness of the added security of this patch if an ACL 
+  system is not put in place.  Your init scripts should be read-only, and 
+  root should not have access to adding modules or performing raw i/o 
+  operations.  All options should be set at startup, and the grsec_lock 
+  entry should be set to a non-zero value after all the options are set.  
+  *THIS IS EXTREMELY IMPORTANT*
+
+Number of burst messages
+CONFIG_GRKERNSEC_FLOODBURST
+  This option allows you to choose the maximum number of messages allowed
+  within the flood time interval you chose in a separate option.  The 
+  default should be suitable for most people, however if you find that 
+  many of your logs are being interpreted as flooding, you may want to 
+  raise this value.
+
+Seconds in between log messages
+CONFIG_GRKERNSEC_FLOODTIME
+  This option allows you to enforce the number of seconds between
+  grsecurity log messages.  The default should be suitable for most 
+  people, however, if you choose to change it, choose a value small enough
+  to allow informative logs to be produced, but large enough to
+  prevent flooding.
+
+ACL Debugging Messages
+CONFIG_GR_DEBUG
+  This option allows the grsecurity ACL system to print debugging messages 
+  as an aid to finding problems in your ACL sets.
+
+Extra ACL Debugging Messages
+CONFIG_GR_SUPERDEBUG
+  This option allows you to enable additional debugging messages that can 
+  also help you in finding problems in your ACL sets or to gain a better 
+  understanding of the internal workings of the ACL system.
+
+Maximum tries before password lockout
+CONFIG_GR_MAXTRIES
+  This option enforces the maximum number of times a user can attempt
+  to authorize themselves with the grsecurity ACL system before being
+  denied the ability to attempt authorization again for a specified time.  
+  The lower the number, the harder it will be to brute-force a password.
+
+Time to wait after max password tries, in seconds
+CONFIG_GR_TIMEOUT
+  This option specifies the time the user must wait after attempting to 
+  authorize to the ACL system with the maximum number of invalid 
+  passwords.  The higher the number, the harder it will be to brute-force 
+  a password.
+
 #
 # m68k-specific kernel options
 # Documented by Chris Lawrence <mailto:quango@themall.net> et al.
diff -urN linux/Makefile linux/Makefile
--- linux/Makefile	2002-08-02 20:39:46.000000000 -0400
+++ linux/Makefile	2002-08-31 11:24:07.000000000 -0400
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 19
-EXTRAVERSION =
+EXTRAVERSION = -grsec
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -123,9 +123,10 @@
 
 CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
 NETWORKS	=net/network.o
+GRSECURITY	=grsecurity/grsec.o
 
 LIBS		=$(TOPDIR)/lib/lib.a
-SUBDIRS		=kernel drivers mm fs net ipc lib
+SUBDIRS		=kernel drivers mm fs net ipc lib grsecurity
 
 DRIVERS-n :=
 DRIVERS-y :=
@@ -263,7 +264,7 @@
 
 export	CPPFLAGS CFLAGS CFLAGS_KERNEL AFLAGS AFLAGS_KERNEL
 
-export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS
+export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS GRSECURITY
 
 .S.s:
 	$(CPP) $(AFLAGS) $(AFLAGS_KERNEL) -traditional -o $*.s $<
@@ -282,6 +283,7 @@
 		$(CORE_FILES) \
 		$(DRIVERS) \
 		$(NETWORKS) \
+		$(GRSECURITY) \
 		$(LIBS) \
 		--end-group \
 		-o vmlinux
diff -urN linux/arch/alpha/config.in linux/arch/alpha/config.in
--- linux/arch/alpha/config.in	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/alpha/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -423,3 +423,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/alpha/kernel/osf_sys.c linux/arch/alpha/kernel/osf_sys.c
--- linux/arch/alpha/kernel/osf_sys.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/alpha/kernel/osf_sys.c	2002-08-31 11:24:07.000000000 -0400
@@ -240,6 +240,13 @@
 		if (!file)
 			goto out;
 	}
+
+	if(gr_handle_mmap(file, prot)) {
+		fput(file);
+		ret = -EACCES;
+		goto out;
+	}
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	down_write(&current->mm->mmap_sem);
 	ret = do_mmap(file, addr, len, prot, flags, off);
diff -urN linux/arch/alpha/kernel/ptrace.c linux/arch/alpha/kernel/ptrace.c
--- linux/arch/alpha/kernel/ptrace.c	2001-09-18 20:03:51.000000000 -0400
+++ linux/arch/alpha/kernel/ptrace.c	2002-08-31 11:24:07.000000000 -0400
@@ -13,6 +13,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/slab.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -273,6 +274,10 @@
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out_notsk;
+
+	if(gr_handle_ptrace(child))
+		goto out;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out;
diff -urN linux/arch/arm/config.in linux/arch/arm/config.in
--- linux/arch/arm/config.in	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/arm/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -655,3 +655,12 @@
 dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
 dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/cris/config.in linux/arch/cris/config.in
--- linux/arch/cris/config.in	2002-02-25 14:37:52.000000000 -0500
+++ linux/arch/cris/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -254,3 +254,12 @@
   int ' Profile shift count' CONFIG_PROFILE_SHIFT 2
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/i386/config.in linux/arch/i386/config.in
--- linux/arch/i386/config.in	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -426,3 +426,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux/arch/i386/kernel/entry.S	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/kernel/entry.S	2002-08-31 11:24:07.000000000 -0400
@@ -45,6 +45,7 @@
 #include <linux/linkage.h>
 #include <asm/segment.h>
 #include <asm/smp.h>
+#include <asm/page.h>
 
 EBX		= 0x00
 ECX		= 0x04
@@ -381,8 +382,52 @@
 	jmp error_code
 
 ENTRY(page_fault)
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	ALIGN
+	pushl $ SYMBOL_NAME(pax_do_page_fault)
+	pushl %ds
+	pushl %eax
+	xorl %eax,%eax
+	pushl %ebp
+	pushl %edi
+	pushl %esi
+	pushl %edx
+	decl %eax			# eax = -1
+	pushl %ecx
+	pushl %ebx
+	cld
+	movl %es,%ecx
+	movl ORIG_EAX(%esp), %esi	# get the error code
+	movl ES(%esp), %edi		# get the function address
+	movl %eax, ORIG_EAX(%esp)
+	movl %ecx, ES(%esp)
+	movl %esp,%edx
+	pushl %esi			# push the error code
+	pushl %edx			# push the pt_regs pointer
+	movl $(__KERNEL_DS),%edx
+	movl %edx,%ds
+	movl %edx,%es
+	GET_CURRENT(%ebx)
+	call *%edi
+	addl $8,%esp
+	decl %eax
+	jnz ret_from_exception
+
+	popl %ebx
+	popl %ecx
+	popl %edx
+	popl %esi
+	popl %edi
+	popl %ebp
+	popl %eax
+	popl %ds
+	popl %es
+	addl $4,%esp
+	jmp system_call
+#else
 	pushl $ SYMBOL_NAME(do_page_fault)
 	jmp error_code
+#endif
 
 ENTRY(machine_check)
 	pushl $0
diff -urN linux/arch/i386/kernel/head.S linux/arch/i386/kernel/head.S
--- linux/arch/i386/kernel/head.S	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/kernel/head.S	2002-08-31 11:24:07.000000000 -0400
@@ -435,8 +435,13 @@
 	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
 	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
 	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	.quad 0x60c5fa000000ffff	/* 0x33 user   1.5GB code at 0x600000000 */
+	.quad 0x00c5f2000000ffff	/* 0x3b user   1.5GB code at 0x00000000 */
+#else
 	.quad 0x0000000000000000	/* not used */
 	.quad 0x0000000000000000	/* not used */
+#endif
 	/*
 	 * The APM segments have byte granularity and their bases
 	 * and limits are set at run time.
diff -urN linux/arch/i386/kernel/ldt.c linux/arch/i386/kernel/ldt.c
--- linux/arch/i386/kernel/ldt.c	2001-10-17 17:46:29.000000000 -0400
+++ linux/arch/i386/kernel/ldt.c	2002-08-31 11:24:07.000000000 -0400
@@ -88,6 +88,16 @@
 			goto out;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->flags & PF_PAX_SEGMEXEC) {
+		unsigned int lim = ldt_info.limit & 0xFFFFFUL;
+		if (ldt_info.limit_in_pages)
+			lim = (lim << PAGE_SHIFT) | ~PAGE_MASK;
+		if (lim > TASK_SIZE/2 || ldt_info.base_addr > TASK_SIZE/2-lim)
+			got out;
+	}
+#endif
+
 	/*
 	 * the GDT index of the LDT is allocated dynamically, and is
 	 * limited by MAX_LDT_DESCRIPTORS.
diff -urN linux/arch/i386/kernel/ptrace.c linux/arch/i386/kernel/ptrace.c
--- linux/arch/i386/kernel/ptrace.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/kernel/ptrace.c	2002-08-31 11:24:07.000000000 -0400
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -101,6 +102,12 @@
 			value |= get_stack_long(child, EFL_OFFSET) & ~FLAG_MASK;
 			break;
 	}
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((child->flags & PF_PAX_SEGMEXEC) && (regno >> 2) == CS && value != 0x33)
+		return -EIO;
+#endif
+
 	if (regno > GS*4)
 		regno -= 2*4;
 	put_stack_long(child, regno - sizeof(struct pt_regs), value);
@@ -177,6 +184,9 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if(gr_handle_ptrace(child))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN linux/arch/i386/kernel/signal.c linux/arch/i386/kernel/signal.c
--- linux/arch/i386/kernel/signal.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/kernel/signal.c	2002-08-31 11:24:07.000000000 -0400
@@ -7,6 +7,7 @@
  *  2000-06-20  Pentium III FXSR, SSE support by Gareth Hughes
  */
 
+#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -221,6 +222,15 @@
 	COPY(eip);
 	COPY_SEG_STRICT(cs);
 	COPY_SEG_STRICT(ss);
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if (current->flags & PF_PAX_SEGMEXEC) {
+		regs->xcs = __USER_CS;
+		regs->xds = __USER_DS;
+		regs->xes = __USER_DS;
+		regs->xss = __USER_DS;
+	}
+#endif
 	
 	{
 		unsigned int tmpflags;
diff -urN linux/arch/i386/kernel/sys_i386.c linux/arch/i386/kernel/sys_i386.c
--- linux/arch/i386/kernel/sys_i386.c	2001-03-19 15:35:09.000000000 -0500
+++ linux/arch/i386/kernel/sys_i386.c	2002-08-31 11:24:07.000000000 -0400
@@ -18,6 +18,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -48,6 +49,11 @@
 	int error = -EBADF;
 	struct file * file = NULL;
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR)
+		return -EINVAL;
+#endif
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
@@ -55,8 +61,14 @@
 			goto out;
 	}
 
+	if(gr_handle_mmap(file, prot)) {
+		fput(file);
+		error = -EACCES;
+		goto out;
+	}
+
 	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	error = do_mmap(file, addr, len, prot, flags, pgoff << PAGE_SHIFT);
 	up_write(&current->mm->mmap_sem);
 
 	if (file)
diff -urN linux/arch/i386/kernel/traps.c linux/arch/i386/kernel/traps.c
--- linux/arch/i386/kernel/traps.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/kernel/traps.c	2002-08-31 11:24:07.000000000 -0400
@@ -49,6 +49,7 @@
 
 #include <linux/irq.h>
 #include <linux/module.h>
+#include <linux/grsecurity.h>
 
 asmlinkage int system_call(void);
 asmlinkage void lcall7(void);
@@ -514,10 +515,14 @@
 {
 	unsigned int condition;
 	struct task_struct *tsk = current;
+	unsigned long eip = regs->eip;
 	siginfo_t info;
 
 	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
 
+	if ((eip >= PAGE_OFFSET) && (regs->eflags & TF_MASK))
+		goto clear_TF;
+
 	/* Mask out spurious debug traps due to lazy DR7 setting */
 	if (condition & (DR_TRAP0|DR_TRAP1|DR_TRAP2|DR_TRAP3)) {
 		if (!tsk->thread.debugreg[7])
diff -urN linux/arch/i386/mm/fault.c linux/arch/i386/mm/fault.c
--- linux/arch/i386/mm/fault.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/i386/mm/fault.c	2002-08-31 11:24:07.000000000 -0400
@@ -4,6 +4,7 @@
  *  Copyright (C) 1995  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -19,6 +20,8 @@
 #include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/unistd.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -128,6 +131,8 @@
 asmlinkage void do_invalid_op(struct pt_regs *, unsigned long);
 extern unsigned long idt;
 
+static void pax_report_fault(struct pt_regs *regs, unsigned long address, unsigned long error_code);
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
@@ -138,23 +143,31 @@
  *	bit 1 == 0 means read, 1 means write
  *	bit 2 == 0 means kernel, 1 means user-mode
  */
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+#else
 asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)
+#endif
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
+#ifndef CONFIG_GRKERNSEC_PAX_PAGEEXEC
 	unsigned long address;
+#endif
 	unsigned long page;
 	unsigned long fixup;
 	int write;
 	siginfo_t info;
 
+#ifndef CONFIG_GRKERNSEC_PAX_PAGEEXEC
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
 
 	/* It's safe to allow irq's after cr2 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
 		local_irq_enable();
+#endif
 
 	tsk = current;
 
@@ -212,21 +225,25 @@
 good_area:
 	info.si_code = SEGV_ACCERR;
 	write = 0;
-	switch (error_code & 3) {
+	switch (error_code & 7) {
 		default:	/* 3: write, present */
 #ifdef TEST_VERIFY_AREA
 			if (regs->cs == KERNEL_CS)
 				printk("WP fault at %08lx\n", regs->eip);
 #endif
 			/* fall through */
+		case 7:		/* PaX: write, present, some protection violation */
 		case 2:		/* write, not present */
+		case 6:
 			if (!(vma->vm_flags & VM_WRITE))
 				goto bad_area;
 			write++;
 			break;
 		case 1:		/* read, present */
 			goto bad_area;
+		case 5:		/* PaX: read, present, protection violation */
 		case 0:		/* read, not present */
+		case 4:
 			if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
 				goto bad_area;
 	}
@@ -270,6 +287,15 @@
 
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+		if ((current->flags & PF_PAX_SEGMEXEC) && address >= TASK_SIZE/2)
+		{
+			pax_report_fault(regs, address, error_code);
+			return;
+		}
+#endif
+
 		tsk->thread.cr2 = address;
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_no = 14;
@@ -401,3 +427,300 @@
 		return;
 	}
 }
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+/* PaX: called with the page_table_lock spinlock held */
+static inline pte_t * pax_get_pte(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd || !pgd_present(*pgd))
+		return 0;
+	pmd = pmd_offset(pgd, address);
+	if (!pmd || !pmd_present(*pmd))
+		return 0;
+	return pte_offset(pmd, address);
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->eip = fault address)
+ *
+ * returns 0 when access should be allowed
+ *         1 when task should be killed
+ *         2 when sigreturn trampoline was detected
+ *         3 when rt_sigreturn trampoline was detected
+ *         4 when gcc trampoline was detected
+ */
+static int pax_handle_read_fault(struct pt_regs *regs)
+{
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	static const unsigned char trans[8] = {6, 1, 2, 0, 13, 5, 3, 4};
+	int err;
+	
+	if (!(current->flags & PF_PAX_EMUTRAMP))
+		return 1;
+
+	{ /* PaX: sigreturn emulation */
+		unsigned char pop, mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = __get_user(pop, (unsigned char *)(regs->eip));
+		err |= __get_user(mov, (unsigned char *)(regs->eip + 1));
+		err |= __get_user(nr, (unsigned long *)(regs->eip + 2));
+		err |= __get_user(sys, (unsigned short *)(regs->eip + 6));
+
+		if (!err) {
+			if (pop == 0x58 &&
+			    mov == 0xb8 &&
+			    nr == __NR_sigreturn &&
+			    sys == 0x80cd)
+			{
+				regs->esp += 4;
+				regs->eax = nr;
+				regs->eip += 8;
+				return 2;
+			}
+		}
+	}
+
+	{ /* PaX: rt_sigreturn emulation */
+		unsigned char mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = __get_user(mov, (unsigned char *)(regs->eip));
+		err |= __get_user(nr, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(sys, (unsigned short *)(regs->eip + 5));
+
+		if (!err) {
+			if (mov == 0xb8 &&
+			    nr == __NR_rt_sigreturn &&
+			    sys == 0x80cd)
+			{
+				regs->eax = nr;
+				regs->eip += 7;
+				return 3;
+			}
+		}
+	}
+
+	{ /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2, ret;
+
+		err = __get_user(mov1, (unsigned char *)(regs->eip));
+		err |= __get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(mov2, (unsigned char *)(regs->eip + 5));
+		err |= __get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= __get_user(jmp, (unsigned short *)(regs->eip + 10));
+		err |= __get_user(ret, (unsigned long *)(regs->esp));
+
+		if (!err) {
+			unsigned short call;
+
+			err = __get_user(call, (unsigned short *)(ret-2));
+			if (!err) {
+				if ((mov1 & 0xF8) == 0xB8 &&
+				    (mov2 & 0xF8) == 0xB8 &&
+				    (mov1 & 0x07) != (mov2 & 0x07) &&
+				    (jmp & 0xF8FF) == 0xE0FF &&
+				    (mov2 & 0x07) == ((jmp>>8) & 0x07) &&
+				    (call & 0xF8FF) == 0xD0FF &&
+				    (regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]]))
+				{
+					((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+					((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+					regs->eip = addr2;
+					return 4;
+				}
+			}
+		}
+	}
+
+	{ /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2, ret;
+
+		err = __get_user(mov, (unsigned char *)(regs->eip));
+		err |= __get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= __get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= __get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= __get_user(ret, (unsigned long *)(regs->esp));
+
+		if (!err) {
+			unsigned short call;
+
+			err = __get_user(call, (unsigned short *)(ret-2));
+			if (!err) {
+				if ((mov & 0xF8) == 0xB8 &&
+				    jmp == 0xE9 &&
+				    (call & 0xF8FF) == 0xD0FF &&
+				    (regs->eip == ((unsigned long*)regs)[trans[(call>>8) & 0x07]]))
+				{
+					((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+					regs->eip += addr2 + 10;
+					return 4;
+				}
+			}
+		}
+	}
+#endif
+
+	return 1; /* PaX in action */
+}
+#endif
+
+#if defined(CONFIG_GRKERNSEC_PAX_PAGEEXEC) || defined(CONFIG_GRKERNSEC_PAX_SEGMEXEC)
+static void pax_report_fault(struct pt_regs *regs, unsigned long address, unsigned long error_code)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char* buffer = (char*)__get_free_page(GFP_ATOMIC);
+	char* path=NULL;
+	unsigned long i;
+
+	if (buffer) {
+		struct vm_area_struct* vma;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
+				break;
+			}
+			vma = vma->vm_next;
+		}
+		if (vma)
+			path = d_path(vma->vm_file->f_dentry, vma->vm_file->f_vfsmnt, buffer, PAGE_SIZE);
+		up_read(&mm->mmap_sem);
+	}
+	printk(KERN_ERR "PAX: terminating task: %.930s(%.16s):%d, uid/euid: %u/%u, "
+			"EIP: %08lX, ESP: %08lX\n", path, tsk->comm, tsk->pid,
+			tsk->uid, tsk->euid, regs->eip, regs->esp);
+	if (buffer) free_page((unsigned long)buffer);
+	printk(KERN_ERR "PAX: bytes at EIP: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (__get_user(c, (unsigned char*)(regs->eip+i))) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%02x ", c);
+	}
+	printk("\n");
+
+	tsk->thread.cr2 = address;
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = 14;
+	force_sig(SIGKILL,tsk);
+}
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+/*
+ * PaX: handle the extra page faults or pass it down to the original handler
+ *
+ * returns 0 when nothing special was detected
+ *         1 when sigreturn trampoline (syscall) has to be emulated
+ */
+asmlinkage int pax_do_page_fault(struct pt_regs *regs, unsigned long error_code)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long address;
+	pte_t *pte;
+	unsigned char pte_mask;
+	int ret;
+
+	__asm__("movl %%cr2,%0":"=r" (address));
+
+	/* It's safe to allow irq's after cr2 has been saved */
+	if (regs->eflags & X86_EFLAGS_IF)
+		local_irq_enable();
+
+	if (unlikely((error_code & 5) != 5 ||
+		     address >= TASK_SIZE ||
+		     !(current->flags & PF_PAX_PAGEEXEC) ||
+		     regs->xcs != 0x23 ||
+		     (VM_MASK & regs->eflags)))
+	{
+		do_page_fault(regs, error_code, address);
+		return 0;
+	}
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely((error_code == 5) && (regs->eip == address))) { 
+		/* instruction fetch attempt from a protected page in user mode */
+		ret = pax_handle_read_fault(regs);
+		switch (ret) {
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+		case 0:
+			break;
+		case 4:
+			return 0;
+		case 3:
+		case 2: return 1;
+		
+		case 1:
+#endif
+
+		default:
+			pax_report_fault(regs, address, error_code);
+			return 0;
+		}
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & 2) << (_PAGE_BIT_DIRTY-1));
+
+again:
+	spin_lock(&mm->page_table_lock);
+	pte = pax_get_pte(mm, address);
+	if (unlikely(!pte || !(pte_val(*pte) & _PAGE_PRESENT) || pte_exec(*pte))) {
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		return 0;
+	}
+
+	if (unlikely((error_code == 7) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		goto again;
+	}
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+		"orb %2,%1\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*   
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's   
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+ * the best thing in omitting it is that we gain around 15-20% speed in 
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+
+		"invlpg %0\n"
+#endif
+
+		"testb $0,%0\n"
+		"xorb %3,%1\n"
+		:
+		: "m" (*(char*)address), "m" (*(char*)pte) , "q" (pte_mask) , "i" (_PAGE_USER)
+		: "memory", "cc");
+	spin_unlock(&mm->page_table_lock);
+	return 0;
+}
+#endif
diff -urN linux/arch/ia64/config.in linux/arch/ia64/config.in
--- linux/arch/ia64/config.in	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/ia64/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -279,3 +279,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/ia64/kernel/ptrace.c linux/arch/ia64/kernel/ptrace.c
--- linux/arch/ia64/kernel/ptrace.c	2002-08-02 20:39:42.000000000 -0400
+++ linux/arch/ia64/kernel/ptrace.c	2002-08-31 11:24:07.000000000 -0400
@@ -15,6 +15,7 @@
 #include <linux/ptrace.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1118,6 +1119,9 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN linux/arch/ia64/kernel/sys_ia64.c linux/arch/ia64/kernel/sys_ia64.c
--- linux/arch/ia64/kernel/sys_ia64.c	2001-11-09 17:26:17.000000000 -0500
+++ linux/arch/ia64/kernel/sys_ia64.c	2002-08-31 11:24:07.000000000 -0400
@@ -15,6 +15,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/highuid.h>
+#include <linux/grsecurity.h>
 
 #include <asm/shmparam.h>
 #include <asm/uaccess.h>
@@ -214,6 +215,11 @@
 		goto out;
 	}
 
+	if (gr_handle_mmap(file, prot)) {
+		addr = -EACCES;
+		goto out;
+	}
+
 	down_write(&current->mm->mmap_sem);
 	addr = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
 	up_write(&current->mm->mmap_sem);
diff -urN linux/arch/m68k/config.in linux/arch/m68k/config.in
--- linux/arch/m68k/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/m68k/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -565,3 +565,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/mips/config.in linux/arch/mips/config.in
--- linux/arch/mips/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/mips/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -632,3 +632,12 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/mips64/config.in linux/arch/mips64/config.in
--- linux/arch/mips64/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/mips64/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -336,3 +336,12 @@
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/parisc/config.in linux/arch/parisc/config.in
--- linux/arch/parisc/config.in	2001-04-17 20:19:25.000000000 -0400
+++ linux/arch/parisc/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -208,3 +208,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/ppc/config.in linux/arch/ppc/config.in
--- linux/arch/ppc/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/ppc/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -402,3 +402,12 @@
 bool 'Include kgdb kernel debugger' CONFIG_KGDB
 bool 'Include xmon kernel debugger' CONFIG_XMON
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/ppc/kernel/ptrace.c linux/arch/ppc/kernel/ptrace.c
--- linux/arch/ppc/kernel/ptrace.c	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/ppc/kernel/ptrace.c	2002-08-31 11:24:07.000000000 -0400
@@ -28,6 +28,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -186,6 +187,9 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+	if (gr_handle_ptrace(child))
+		goto out_tsk;
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN linux/arch/ppc/kernel/syscalls.c linux/arch/ppc/kernel/syscalls.c
--- linux/arch/ppc/kernel/syscalls.c	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/ppc/kernel/syscalls.c	2002-08-31 11:24:07.000000000 -0400
@@ -38,6 +38,7 @@
 #include <linux/ipc.h>
 #include <linux/utsname.h>
 #include <linux/file.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -202,6 +203,12 @@
 			goto out;
 	}
 	
+	if (gr_handle_mmap(file, prot)) {
+		fput(file);
+		ret = -EACCES;
+		goto out;
+	}
+
 	down_write(&current->mm->mmap_sem);
 	ret = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
 	up_write(&current->mm->mmap_sem);
diff -urN linux/arch/s390/config.in linux/arch/s390/config.in
--- linux/arch/s390/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/s390/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -75,3 +75,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/s390x/config.in linux/arch/s390x/config.in
--- linux/arch/s390x/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/s390x/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -77,3 +77,11 @@
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
 
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sh/config.in linux/arch/sh/config.in
--- linux/arch/sh/config.in	2002-02-25 14:37:56.000000000 -0500
+++ linux/arch/sh/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -386,3 +386,12 @@
    bool 'Early printk support' CONFIG_SH_EARLY_PRINTK
 fi
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sparc/config.in linux/arch/sparc/config.in
--- linux/arch/sparc/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/sparc/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -271,3 +271,12 @@
 
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/arch/sparc/kernel/ptrace.c linux/arch/sparc/kernel/ptrace.c
--- linux/arch/sparc/kernel/ptrace.c	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/sparc/kernel/ptrace.c	2002-08-31 11:24:07.000000000 -0400
@@ -17,6 +17,7 @@
 #include <linux/user.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -310,6 +311,9 @@
 		goto out;
 	}
 
+	if(gr_handle_ptrace(child))
+		goto out_tsk;
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urN linux/arch/sparc/kernel/sys_sparc.c linux/arch/sparc/kernel/sys_sparc.c
--- linux/arch/sparc/kernel/sys_sparc.c	2001-04-13 23:15:55.000000000 -0400
+++ linux/arch/sparc/kernel/sys_sparc.c	2002-08-31 11:24:07.000000000 -0400
@@ -20,6 +20,7 @@
 #include <linux/utsname.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -240,6 +241,12 @@
 	if (len > TASK_SIZE - PAGE_SIZE || addr + len > TASK_SIZE - PAGE_SIZE)
 		goto out_putf;
 
+	if (gr_handle_mmap(file, prot)) {
+		fput(file);
+		retval = -EACCES;
+		goto out;
+	}
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 
 	down_write(&current->mm->mmap_sem);
diff -urN linux/arch/sparc64/config.in linux/arch/sparc64/config.in
--- linux/arch/sparc64/config.in	2002-08-02 20:39:43.000000000 -0400
+++ linux/arch/sparc64/config.in	2002-08-31 11:24:07.000000000 -0400
@@ -308,3 +308,12 @@
 fi
 
 endmenu
+
+mainmenu_option next_comment
+comment 'Grsecurity'
+bool 'Grsecurity' CONFIG_GRKERNSEC
+if [ "$CONFIG_GRKERNSEC" = "y" ]; then
+    source grsecurity/Config.in
+fi
+endmenu
+
diff -urN linux/drivers/char/mem.c linux/drivers/char/mem.c
--- linux/drivers/char/mem.c	2002-08-02 20:39:43.000000000 -0400
+++ linux/drivers/char/mem.c	2002-08-31 11:24:07.000000000 -0400
@@ -21,6 +21,7 @@
 #include <linux/raw.h>
 #include <linux/tty.h>
 #include <linux/capability.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -46,6 +47,9 @@
 			    const char * buf, size_t count, loff_t *ppos)
 {
 	ssize_t written;
+#ifdef CONFIG_GRKERNSEC_KMEM
+		return -EPERM;
+#endif
 
 	written = 0;
 #if defined(__sparc__) || defined(__mc68000__)
@@ -200,9 +204,19 @@
 	/*
 	 * Don't dump addresses that are not real memory to a core file.
 	 */
-	if (offset >= __pa(high_memory) || (file->f_flags & O_SYNC))
+	if (offset >= __pa(high_memory) || (file->f_flags & O_SYNC)) {
 		vma->vm_flags |= VM_IO;
 
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+		/* it turned out to be device memory (eg. video RAM), don't apply PaX */
+		if (!(vma->vm_flags & VM_EXEC)) {
+			vma->vm_flags |= VM_EXEC | VM_MAYEXEC;
+			vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+		}                                                                                                          
+#endif
+
+	}
+
 	if (remap_page_range(vma->vm_start, offset, vma->vm_end-vma->vm_start,
 			     vma->vm_page_prot))
 		return -EAGAIN;
@@ -292,6 +306,9 @@
 
 		wrote = do_write_mem(file, (void*)p, p, buf, wrote, ppos);
 
+#ifdef CONFIG_GRKERNSEC_KMEM
+	if(wrote == -EPERM) return -EPERM;
+#endif
 		p += wrote;
 		buf += wrote;
 		count -= wrote;
@@ -401,7 +418,7 @@
 			count = size;
 
 		zap_page_range(mm, addr, count);
-        	zeromap_page_range(addr, count, PAGE_COPY);
+	        zeromap_page_range(addr, count, vma->vm_page_prot); 
 
 		size -= count;
 		buf += count;
@@ -579,7 +596,12 @@
 			filp->f_op = &mem_fops;
 			break;
 		case 2:
+#ifdef CONFIG_GRKERNSEC_KMEM
+			security_alert(GR_KMEM_MSG, GR_KMEM_FLD, DEFAULTSECARGS);
+			return -EPERM;
+#else
 			filp->f_op = &kmem_fops;
+#endif
 			break;
 		case 3:
 			filp->f_op = &null_fops;
diff -urN linux/drivers/pci/proc.c linux/drivers/pci/proc.c
--- linux/drivers/pci/proc.c	2001-11-16 21:38:39.000000000 -0500
+++ linux/drivers/pci/proc.c	2002-08-31 11:24:08.000000000 -0400
@@ -562,7 +562,15 @@
 		pci_for_each_dev(dev) {
 			pci_proc_attach_device(dev);
 		}
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+		entry = create_proc_entry("pci", S_IRUSR, NULL);
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+		entry = create_proc_entry("pci", S_IRUSR | S_IRGRP, NULL);
+#endif
+#else
 		entry = create_proc_entry("pci", 0, NULL);
+#endif
 		if (entry)
 			entry->proc_fops = &proc_pci_operations;
 	}
diff -urN linux/fs/binfmt_aout.c linux/fs/binfmt_aout.c
--- linux/fs/binfmt_aout.c	2001-11-02 20:39:20.000000000 -0500
+++ linux/fs/binfmt_aout.c	2002-08-31 11:24:08.000000000 -0400
@@ -5,6 +5,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/config.h>
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -113,10 +114,12 @@
 /* If the size of the dump file exceeds the rlimit, then see what would happen
    if we wrote the stack, but not the data area.  */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_dsize+dump.u_ssize);
 	if ((dump.u_dsize+dump.u_ssize) >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE);
 	if ((dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
@@ -124,10 +127,12 @@
 
 /* Make sure we have enough room to write the stack and data areas. */
 #ifdef __sparc__
+	gr_learn_resource(current, RLIMIT_CORE, dump.u_ssize);
 	if ((dump.u_ssize) >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 #else
+	gr_learn_resource(current, RLIMIT_CORE, (dump.u_ssize+1) * PAGE_SIZE);
 	if ((dump.u_ssize+1) * PAGE_SIZE >
 	    current->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
@@ -276,6 +281,8 @@
 	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
+
+	gr_learn_resource(current, RLIMIT_DATA, ex.a_data + ex.a_bss);
 	if (ex.a_data + ex.a_bss > rlim)
 		return -ENOMEM;
 
@@ -307,6 +314,24 @@
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->flags |= PF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->flags |= PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))        
+			current->flags |= PF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -393,7 +418,7 @@
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -urN linux/fs/binfmt_elf.c linux/fs/binfmt_elf.c
--- linux/fs/binfmt_elf.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/binfmt_elf.c	2002-08-31 11:24:08.000000000 -0400
@@ -11,6 +11,7 @@
 
 #include <linux/module.h>
 
+#include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/stat.h>
 #include <linux/sched.h>
@@ -33,6 +34,7 @@
 #include <linux/smp_lock.h>
 #include <linux/compiler.h>
 #include <linux/highmem.h>
+#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
@@ -598,7 +600,59 @@
 	current->mm->end_data = 0;
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	current->mm->delta_mmap = 0;
+	current->mm->delta_exec = 0;
+	current->mm->delta_stack = 0;
+#endif
+
 	current->flags &= ~PF_FORKNOEXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (!(elf_ex.e_flags & EF_PAX_PAGEEXEC))
+		current->flags |= PF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	if (elf_ex.e_flags & EF_PAX_EMUTRAMP)
+		current->flags |= PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	if (!(elf_ex.e_flags & EF_PAX_MPROTECT))
+		current->flags |= PF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	if (!(elf_ex.e_flags & EF_PAX_RANDMMAP)) {
+		unsigned long delta;
+		current->flags |= PF_PAX_RANDMMAP;
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define pax_delta_mask(delta, shift) \
+	((delta & ((1UL << (8*sizeof(unsigned long) - 5 - shift)) - 1)) << shift)
+#else
+#define pax_delta_mask(delta, shift) \
+	((delta & ((1UL << (8*sizeof(unsigned long) - 4 - shift)) - 1)) << shift)
+#endif
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_mmap = pax_delta_mask(delta, PAGE_SHIFT);
+
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_exec = pax_delta_mask(delta, PAGE_SHIFT);
+
+		get_random_bytes(&delta, sizeof(delta));
+		current->mm->delta_stack = pax_delta_mask(delta, PAGE_SHIFT);
+#undef pax_delta_mask
+	}
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if (!(elf_ex.e_flags & EF_PAX_SEGMEXEC) && !(current->flags & PF_PAX_PAGEEXEC))
+		current->flags |= PF_PAX_SEGMEXEC;
+#endif
+
 	elf_entry = (unsigned long) elf_ex.e_entry;
 
 	/* Do this so that we can load the interpreter, if need be.  We will
@@ -644,16 +698,24 @@
 		if (elf_ppnt->p_flags & PF_W) elf_prot |= PROT_WRITE;
 		if (elf_ppnt->p_flags & PF_X) elf_prot |= PROT_EXEC;
 
-		elf_flags = MAP_PRIVATE|MAP_DENYWRITE|MAP_EXECUTABLE;
+		elf_flags = MAP_PRIVATE|MAP_DENYWRITE;
 
 		vaddr = elf_ppnt->p_vaddr;
 		if (elf_ex.e_type == ET_EXEC || load_addr_set) {
-			elf_flags |= MAP_FIXED;
+			elf_flags |= MAP_FIXED|MAP_EXECUTABLE;
 		} else if (elf_ex.e_type == ET_DYN) {
 			/* Try and get dynamic programs out of the way of the default mmap
 			   base, as well as whatever program they might try to exec.  This
 		           is because the brk will follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if (current->flags & PF_PAX_RANDMMAP) {
+				load_bias = ELF_PAGESTART(0x08048000 - vaddr + current->mm->delta_exec);
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
@@ -1003,8 +1065,11 @@
 #undef DUMP_SEEK
 
 #define DUMP_WRITE(addr, nr)	\
+	do { \
+	gr_learn_resource(current, RLIMIT_CORE, size + (nr)); \
 	if ((size += (nr)) > limit || !dump_write(file, (addr), (nr))) \
-		goto end_coredump;
+		goto end_coredump; \
+	} while (0);
 #define DUMP_SEEK(off)	\
 	if (!dump_seek(file, (off))) \
 		goto end_coredump;
diff -urN linux/fs/buffer.c linux/fs/buffer.c
--- linux/fs/buffer.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/buffer.c	2002-08-31 11:24:08.000000000 -0400
@@ -1772,6 +1772,9 @@
 	int err;
 
 	err = -EFBIG;
+
+	gr_learn_resource(current, RLIMIT_FSIZE, (unsigned long) size);
+
         limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
 	if (limit != RLIM_INFINITY && size > (loff_t)limit) {
 		send_sig(SIGXFSZ, current, 0);
diff -urN linux/fs/exec.c linux/fs/exec.c
--- linux/fs/exec.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/exec.c	2002-08-31 11:35:48.000000000 -0400
@@ -41,6 +41,9 @@
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
+#include <linux/major.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
@@ -278,7 +281,12 @@
 	lru_cache_add(page);
 	flush_dcache_page(page);
 	flush_page_to_ram(page);
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page,
+		(tsk->flags & PF_PAX_PAGEEXEC)?PAGE_COPY_NOEXEC:PAGE_COPY))));
+#else
 	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, PAGE_COPY))));
+#endif
 	tsk->mm->rss++;
 	spin_unlock(&tsk->mm->page_table_lock);
 
@@ -313,8 +321,14 @@
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = STACK_TOP;
-		mpnt->vm_page_prot = PAGE_COPY;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+		if (!(current->flags & PF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(mpnt->vm_flags | VM_EXEC) & 0x0f];
+		else
+#endif
+		mpnt->vm_page_prot = protection_map[mpnt->vm_flags & 0x0f];
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
@@ -564,6 +578,26 @@
 	}
 	current->comm[i] = '\0';
 
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	current->flags &= ~PF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_EMUTRAMP
+	current->flags &= ~PF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	current->flags &= ~PF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	current->flags &= ~PF_PAX_RANDMMAP;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	current->flags &= ~PF_PAX_SEGMEXEC;
+#endif
+
 	flush_thread();
 
 	de_thread(current);
@@ -661,6 +695,16 @@
 			cap_set_full(bprm->cap_effective);
 	}
 
+	if(gr_acl_is_enabled() && (current->ptrace & PT_PTRACED) && 
+		(permission(bprm->file->f_dentry->d_inode, MAY_WRITE) ||
+		!gr_search_file(bprm->file->f_dentry, GR_WRITE, bprm->file->f_vfsmnt))) {
+		security_alert(GR_PTRACE_EXEC_ACL_MSG, GR_PTRACE_EXEC_ACL_FLD,
+			kdevname(bprm->file->f_dentry->d_inode->i_dev),
+			bprm->file->f_dentry->d_inode->i_ino, bprm->filename, 
+			DEFAULTSECARGS);
+		return -EACCES;
+	}
+
 	memset(bprm->buf,0,BINPRM_BUF_SIZE);
 	return kernel_read(bprm->file,0,bprm->buf,BINPRM_BUF_SIZE);
 }
@@ -866,7 +910,34 @@
 	if (IS_ERR(file))
 		return retval;
 
+	gr_learn_resource(current, RLIMIT_NPROC, atomic_read(&current->user->processes));
+
+	if(grsec_enable_execve && current->user && 
+	  (atomic_read(&current->user->processes) > current->rlim[RLIMIT_NPROC].rlim_cur)) {
+		security_alert(GR_NPROC_MSG, GR_NPROC_FLD, DEFAULTSECARGS);
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+
+	if(!gr_search_file(file->f_dentry,GR_EXEC,file->f_vfsmnt)) {
+		security_alert(GR_EXEC_ACL_MSG, GR_EXEC_ACL_FLD,
+	                       filename, DEFAULTSECARGS);
+		allow_write_access(file);
+		fput(file);
+		return -EACCES;
+	}
+
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	{
+		unsigned short delta;
+		get_random_bytes(&delta, sizeof(delta));
+		bprm.p -= (delta & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+	}
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
 
 	bprm.file = file;
@@ -890,11 +961,43 @@
 	if (retval < 0) 
 		goto out; 
 
+	if(!gr_tpe_allow(file) || !gr_tpe_all_allow(file)) {
+		security_alert(GR_EXEC_TPE_MSG, GR_EXEC_TPE_FLD,
+				filename, DEFAULTSECARGS);
+		retval = -EACCES;
+		goto out;
+	}
+
+	if(gr_check_crash_exec(file)) {
+		retval = -EACCES;
+		goto out;
+	}
+
+	if (grsec_enable_chroot_execlog && proc_is_chrooted(current))
+		security_audit(GR_EXEC_CHROOT_MSG, filename,
+				kdevname(current->fs->root->d_inode->i_dev),
+				current->fs->root->d_inode->i_ino,
+				DEFAULTSECARGS);
+	else if ((in_group_p(grsec_audit_gid) && grsec_enable_group && 
+	         grsec_enable_execlog) || (grsec_enable_execlog && !grsec_enable_group))
+		gr_handle_exec_args(&bprm, argv);
+
 	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
 	if (retval < 0) 
 		goto out; 
 
 	bprm.exec = bprm.p;
+
+	if(current->pid < 2) /* Init is the first real process, so its 
+		   		acl lock is NOT initialized on fork.
+			        see its exec in init/main.c 
+			        This also applies to swapper */
+		current->acl_lock = RW_LOCK_UNLOCKED;
+
+	gr_set_proc_label(file->f_dentry, file->f_vfsmnt, filename);
+	gr_set_proc_res();
+	gr_set_caps();	
+
 	retval = copy_strings(bprm.envc, envp, &bprm);
 	if (retval < 0) 
 		goto out; 
@@ -948,6 +1051,7 @@
 	if (!current->mm->dumpable)
 		goto fail;
 	current->mm->dumpable = 0;
+	gr_learn_resource(current, RLIMIT_CORE, binfmt->min_coredump);
 	if (current->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)
 		goto fail;
 
@@ -969,7 +1073,7 @@
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, file->f_vfsmnt) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
diff -urN linux/fs/fcntl.c linux/fs/fcntl.c
--- linux/fs/fcntl.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/fcntl.c	2002-08-31 11:24:08.000000000 -0400
@@ -67,6 +67,7 @@
 	write_lock(&files->file_lock);
 	
 	error = -EINVAL;
+	gr_learn_resource(current, RLIMIT_NOFILE, orig_start);
 	if (orig_start >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
@@ -86,6 +87,7 @@
 	}
 	
 	error = -EMFILE;
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd);
 	if (newfd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
@@ -148,6 +150,7 @@
 	if (newfd == oldfd)
 		goto out_unlock;
 	err = -EBADF;
+	gr_learn_resource(current, RLIMIT_NOFILE, newfd);
 	if (newfd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out_unlock;
 	get_file(file);			/* We are now finished with oldfd */
diff -urN linux/fs/locks.c linux/fs/locks.c
--- linux/fs/locks.c	2001-10-11 10:52:18.000000000 -0400
+++ linux/fs/locks.c	2002-08-31 11:24:08.000000000 -0400
@@ -137,6 +137,7 @@
 static struct file_lock *locks_alloc_lock(int account)
 {
 	struct file_lock *fl;
+	if(account) gr_learn_resource(current, RLIMIT_LOCKS, current->locks);
 	if (account && current->locks >= current->rlim[RLIMIT_LOCKS].rlim_cur)
 		return NULL;
 	fl = kmem_cache_alloc(filelock_cache, SLAB_KERNEL);
diff -urN linux/fs/namei.c linux/fs/namei.c
--- linux/fs/namei.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/namei.c	2002-08-31 13:14:04.000000000 -0400
@@ -22,6 +22,7 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#include <linux/grsecurity.h>
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
@@ -343,6 +344,20 @@
 		current->state = TASK_RUNNING;
 		schedule();
 	}
+
+        if(grsec_enable_link && S_ISLNK(dentry->d_inode->i_mode) &&
+	   (dentry->d_parent->d_inode->i_mode & S_ISVTX) &&
+	   dentry->d_parent->d_inode->i_uid != dentry->d_inode->i_uid &&
+	   (dentry->d_parent->d_inode->i_mode & S_IWOTH) &&
+	   current->fsuid != dentry->d_inode->i_uid) {
+		security_alert(GR_SYMLINK_MSG, GR_SYMLINK_FLD,
+			dentry->d_parent->d_name.name, dentry->d_name.name,
+			kdevname(dentry->d_inode->i_dev), dentry->d_inode->i_ino,
+			dentry->d_inode->i_uid, dentry->d_inode->i_gid, DEFAULTSECARGS);
+		path_release(nd);
+		return -EACCES;
+        }
+
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
@@ -641,6 +656,13 @@
 			}
 		}
 return_base:
+		if(!gr_search_file(nd->dentry,GR_FIND,nd->mnt)) {
+			security_alert(GR_HIDDEN_ACL_MSG, GR_HIDDEN_ACL_FLD,
+				kdevname(nd->dentry->d_inode->i_dev),
+				nd->dentry->d_inode->i_ino,DEFAULTSECARGS);
+			path_release(nd);
+			return -ENOENT; /* Fake that it's not there */
+		}
 		return 0;
 out_dput:
 		dput(dentry);
@@ -973,6 +995,19 @@
 	return error;
 }
 
+
+static __inline__ __u16 to_grflags(const int mode)
+{
+	__u16 retval = 0;
+	if(mode & O_APPEND)
+		retval |= GR_APPEND;
+	else if(mode & FMODE_WRITE)
+		retval |= GR_WRITE;
+	if(mode & FMODE_READ)
+		retval |= GR_READ;
+	return retval;
+}
+
 /*
  *	open_namei()
  *
@@ -994,7 +1029,10 @@
 	struct dentry *dentry;
 	struct dentry *dir;
 	int count = 0;
-
+	int gr_flag;
+	
+	gr_flag = to_grflags(flag);
+	
 	acc_mode = ACC_MODE(flag);
 
 	/*
@@ -1005,7 +1043,19 @@
 			error = path_walk(pathname, nd);
 		if (error)
 			return error;
+
 		dentry = nd->dentry;
+
+		if (gr_search_file(dentry, gr_flag, nd->mnt) != gr_flag) {
+			security_alert(GR_OPEN_ACL_MSG, GR_OPEN_ACL_FLD,
+					pathname, gr_flag & GR_READ ? " reading"
+					: "", gr_flag & GR_WRITE ? " writing" 
+					: gr_flag & GR_APPEND ? " appending" 
+					: "", DEFAULTSECARGS);
+			error = -EACCES;
+			goto exit;
+		}
+
 		goto ok;
 	}
 
@@ -1039,6 +1089,21 @@
 
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
+		gr_flag |= GR_WRITE; 
+				     /* Creating a file is
+				      *  write operation 
+				      *  at the least */
+		if(gr_check_create(dentry,nd->dentry,nd->mnt,gr_flag) != gr_flag) {
+			security_alert(GR_OPEN_ACL_MSG, GR_OPEN_ACL_FLD,
+				pathname, gr_flag & GR_READ ? " reading"
+				: "", gr_flag & GR_WRITE ? " writing" 
+				: gr_flag & GR_APPEND ? " appending" 
+				: "", DEFAULTSECARGS);
+			error = -EACCES;
+			up(&dir->d_inode->i_sem);
+			goto exit_dput;
+		}
+
 		error = vfs_create(dir->d_inode, dentry,
 				   mode & ~current->fs->umask);
 		up(&dir->d_inode->i_sem);
@@ -1049,12 +1114,41 @@
 		/* Don't check for write permission, don't truncate */
 		acc_mode = 0;
 		flag &= ~O_TRUNC;
+
+		gr_handle_create(nd->dentry, nd->mnt);
+
 		goto ok;
 	}
 
 	/*
 	 * It already exists.
 	 */
+
+	if (gr_search_file(dentry, gr_flag, nd->mnt) != gr_flag) {
+		security_alert(GR_OPEN_ACL_MSG, GR_OPEN_ACL_FLD,
+			pathname, gr_flag & GR_READ ? " reading"
+			: "", gr_flag & GR_WRITE ? " writing" 
+			: gr_flag & GR_APPEND ? " appending" 
+			: "", DEFAULTSECARGS);
+		error = -EACCES;
+		up(&dir->d_inode->i_sem);
+		goto exit_dput;
+	}
+
+	inode = dentry->d_inode;
+	if (grsec_enable_fifo && S_ISFIFO(inode->i_mode) && !(flag & O_EXCL)
+	    && (dir->d_inode->i_mode & S_ISVTX) &&
+	    (inode->i_uid != dir->d_inode->i_uid) &&
+	    (current->fsuid != inode->i_uid)) {
+		up(&dir->d_inode->i_sem);
+		if(!permission(inode, acc_mode))
+			security_alert(GR_FIFO_MSG, GR_FIFO_FLD,
+				dentry->d_parent->d_name.name,dentry->d_name.name,
+				inode->i_uid, inode->i_gid, DEFAULTSECARGS);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	up(&dir->d_inode->i_sem);
 
 	error = -EEXIST;
@@ -1144,7 +1238,7 @@
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry,0,nd->mnt);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1175,6 +1269,21 @@
 	 * stored in nd->last.name and we will have to putname() it when we
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
+
+	if(grsec_enable_link && S_ISLNK(dentry->d_inode->i_mode) &&
+	  (dentry->d_parent->d_inode->i_mode & S_ISVTX) &&
+	  dentry->d_parent->d_inode->i_uid != dentry->d_inode->i_uid &&
+	  (dentry->d_parent->d_inode->i_mode & S_IWOTH) &&
+	  current->fsuid != dentry->d_inode->i_uid) {
+	  	security_alert(GR_SYMLINK_MSG, GR_SYMLINK_FLD,
+			 dentry->d_parent->d_name.name, dentry->d_name.name, 
+			 kdevname(dentry->d_inode->i_dev), 
+			 dentry->d_inode->i_ino, dentry->d_inode->i_uid,
+			 dentry->d_inode->i_gid, DEFAULTSECARGS);
+		error = -EACCES;
+		goto exit_dput;
+	}
+
 	UPDATE_ATIME(dentry->d_inode);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
 	dput(dentry);
@@ -1258,6 +1367,7 @@
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	char grdevmode;
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1274,6 +1384,34 @@
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && proc_is_chrooted(current)) {
+		switch (mode & S_IFMT) {
+			case S_IFREG: 	grdevmode = 'r';	break;
+			case S_IFCHR: 	grdevmode = 'c';	break;
+			case S_IFBLK:	grdevmode = 'b';	break;
+			case S_IFSOCK:	grdevmode = 's';	break;
+			default:	grdevmode = 'u';
+		}
+		security_alert(GR_MKNOD_CHROOT_MSG, GR_MKNOD_CHROOT_FLD,
+			       grdevmode,kdevname(dev),tmp,
+			       kdevname(current->fs->root->d_inode->i_dev),
+			       current->fs->root->d_inode->i_ino,
+			       current->fs->root->d_inode->i_uid,
+			       current->fs->root->d_inode->i_gid,
+			       DEFAULTSECARGS);
+		error = -EPERM;
+		dput(dentry);
+		goto out_dput;
+	}
+
+	if(!gr_check_create(dentry, nd.dentry, nd.mnt,GR_WRITE)) {
+		security_alert(GR_MKNOD_ACL_MSG, GR_MKNOD_ACL_FLD,
+				filename, DEFAULTSECARGS);
+		error = -EACCES;
+		dput(dentry);
+		goto out_dput;
+	}
+	
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
@@ -1287,8 +1425,13 @@
 		default:
 			error = -EINVAL;
 		}
+
+		if(!error)
+			gr_handle_create(dentry, nd.mnt);
+
 		dput(dentry);
 	}
+out_dput:
 	up(&nd.dentry->d_inode->i_sem);
 	path_release(&nd);
 out:
@@ -1341,8 +1484,21 @@
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_mkdir(nd.dentry->d_inode, dentry,
+			error = 0;
+
+			if(!gr_check_create(dentry,nd.dentry,nd.mnt,GR_WRITE))
+			{
+				security_alert(GR_MKDIR_ACL_MSG, GR_MKDIR_ACL_FLD,
+						pathname, DEFAULTSECARGS);
+				error = -EACCES;
+						
+			}
+			if(!error)
+				error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
+			if(!error)
+				gr_handle_create(dentry, nd.mnt);
+			
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1426,6 +1582,8 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1451,7 +1609,23 @@
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
-		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		error = 0;
+		if(dentry->d_inode) {
+			saved_ino = dentry->d_inode->i_ino;
+			saved_dev = dentry->d_inode->i_dev;
+		
+			if(!gr_search_file(dentry,GR_WRITE,nd.mnt)) {
+				security_alert(GR_RMDIR_ACL_MSG, GR_RMDIR_ACL_FLD,
+						pathname, DEFAULTSECARGS);
+				error = -EACCES;
+			}
+		}
+
+		if(!error)
+			error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		if(!error && (saved_dev || saved_ino))
+			gr_handle_delete(saved_ino,saved_dev);
+
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1495,6 +1669,8 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	ino_t saved_ino = 0;
+	kdev_t saved_dev = 0;
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1514,7 +1690,22 @@
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
-		error = vfs_unlink(nd.dentry->d_inode, dentry);
+		error = 0;
+		if(dentry->d_inode) {
+			saved_ino = dentry->d_inode->i_ino;
+			saved_dev = dentry->d_inode->i_dev;
+
+			if(!gr_search_file(dentry,GR_WRITE, nd.mnt)) {
+				security_alert(GR_UNLINK_ACL_MSG, GR_UNLINK_ACL_FLD,
+                				name, DEFAULTSECARGS);
+				error = -EACCES;
+			}
+		}
+
+		if(!error)
+			error = vfs_unlink(nd.dentry->d_inode, dentry);
+		if(!error && (saved_ino || saved_dev))
+			gr_handle_delete(saved_ino,saved_dev);
 	exit2:
 		dput(dentry);
 	}
@@ -1579,7 +1770,15 @@
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
-			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
+			error = 0;
+			if(!gr_check_create(dentry, nd.dentry, nd.mnt, GR_WRITE)) {
+				security_alert(GR_SYMLINK_ACL_MSG, GR_SYMLINK_ACL_FLD,
+					from, to, DEFAULTSECARGS);
+				error = -EACCES;
+			}
+
+			if(!error)	
+				error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1670,7 +1869,27 @@
 		new_dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
-			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+			error = 0;
+			if(grsec_enable_link && current->fsuid != old_nd.dentry->d_inode->i_uid &&
+		  	   (!S_ISREG(old_nd.dentry->d_inode->i_mode) ||
+		  	   (old_nd.dentry->d_inode->i_mode & S_ISUID) ||
+	          	   ((old_nd.dentry->d_inode->i_mode & (S_ISGID | S_IXGRP)) == 
+		  	   (S_ISGID | S_IXGRP)) || (permission(old_nd.dentry->d_inode,
+		  	   MAY_READ | MAY_WRITE))) && !capable(CAP_FOWNER) && current->uid) {
+				security_alert(GR_HARDLINK_MSG, GR_HARDLINK_FLD,
+						oldname,old_nd.dentry->d_inode->i_uid,
+						old_nd.dentry->d_inode->i_gid,newname,DEFAULTSECARGS);
+				error = -EPERM;
+			}
+			if(!error && (!gr_search_file(old_nd.dentry,GR_WRITE,old_nd.mnt) 
+				|| !gr_check_create(new_dentry, nd.dentry, nd.mnt, GR_WRITE))) {
+				security_alert(GR_LINK_ACL_MSG, GR_LINK_ACL_FLD,
+						oldname, newname, DEFAULTSECARGS);
+				error = -EPERM;
+			}
+			if(!error)
+				error = vfs_link(old_nd.dentry, 
+						nd.dentry->d_inode, new_dentry);
 			dput(new_dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1855,6 +2074,7 @@
 static inline int do_rename(const char * oldname, const char * newname)
 {
 	int error = 0;
+	__u8 gr_noreplace = 0;
 	struct dentry * old_dir, * new_dir;
 	struct dentry * old_dentry, *new_dentry;
 	struct nameidata oldnd, newnd;
@@ -1906,10 +2126,35 @@
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
-	lock_kernel();
-	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
-	unlock_kernel();
+	error = 0;
+	if(!new_dentry->d_inode) {
+		gr_noreplace = 1;
+		if(!gr_check_create(new_dentry,newnd.dentry,newnd.mnt,GR_WRITE)
+			|| !gr_search_file(old_dentry,GR_WRITE,oldnd.mnt)) {
+			security_alert(GR_RENAME_ACL_MSG, GR_RENAME_ACL_FLD,
+					oldname, newname, DEFAULTSECARGS);
+			error = -EACCES;
+		}
+	} else if (!gr_search_file(old_dentry,GR_WRITE,oldnd.mnt)
+			|| !gr_search_file(new_dentry, GR_WRITE, newnd.mnt)) {
+		security_alert(GR_RENAME_ACL_MSG, GR_RENAME_ACL_FLD,
+				oldname, newname, DEFAULTSECARGS);
+		error = -EACCES;
+	}
+
+	if(!error) {
+		if(gr_acl_is_enabled()) {
+			error = gr_handle_rename(old_dir->d_inode,
+					new_dir->d_inode, old_dentry,
+					new_dentry, oldnd.mnt,
+					gr_noreplace);
+		} else {	
+			lock_kernel();
+			error = vfs_rename(old_dir->d_inode, old_dentry,
+					   new_dir->d_inode, new_dentry);
+			unlock_kernel();
+		}
+	}
 
 	dput(new_dentry);
 exit4:
diff -urN linux/fs/namespace.c linux/fs/namespace.c
--- linux/fs/namespace.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/namespace.c	2002-08-31 11:24:08.000000000 -0400
@@ -15,6 +15,8 @@
 #include <linux/quotaops.h>
 #include <linux/acct.h>
 #include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -320,6 +322,11 @@
 			lock_kernel();
 			retval = do_remount_sb(sb, MS_RDONLY, 0);
 			unlock_kernel();
+
+			if(grsec_enable_mount && (retval >= 0))
+				security_audit(GR_REMOUNT_AUDIT_MSG,
+					mnt->mnt_devname, DEFAULTSECARGS);
+
 		}
 		up_write(&sb->s_umount);
 		return retval;
@@ -345,6 +352,11 @@
 	}
 	spin_unlock(&dcache_lock);
 	up_write(&current->namespace->sem);
+
+	if (grsec_enable_mount && (retval >=0))
+		security_audit(GR_UNMOUNT_AUDIT_MSG,
+				mnt->mnt_devname, DEFAULTSECARGS);
+
 	return retval;
 }
 
@@ -735,6 +747,16 @@
 	if (retval)
 		return retval;
 
+	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+		security_alert(GR_MOUNT_CHROOT_MSG, GR_MOUNT_CHROOT_FLD,
+			dev_name,dir_name, kdevname(current->fs->root->d_inode->i_dev),
+			current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		retval = -EPERM;
+		path_release(&nd);
+		return retval;
+	}
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -746,6 +768,11 @@
 		retval = do_add_mount(&nd, type_page, flags, mnt_flags,
 				      dev_name, data_page);
 	path_release(&nd);
+
+	if(grsec_enable_mount && (retval >= 0))
+		security_audit(GR_MOUNT_AUDIT_MSG, dev_name,
+				dir_name, DEFAULTSECARGS);
+
 	return retval;
 }
 
@@ -916,6 +943,14 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+		security_alert(GR_PIVOT_CHROOT_MSG, GR_PIVOT_CHROOT_FLD,
+			new_root,put_old, kdevname(current->fs->root->d_inode->i_dev),
+			current->fs->root->d_inode->i_ino,current->fs->root->d_inode->i_uid,
+			current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		return -EPERM;
+	}
+
 	lock_kernel();
 
 	name = getname(new_root);
diff -urN linux/fs/open.c linux/fs/open.c
--- linux/fs/open.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/open.c	2002-08-31 11:24:08.000000000 -0400
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/iobuf.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -95,7 +96,7 @@
 	write_unlock(&files->file_lock);
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, struct vfsmount *mnt)
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
@@ -105,6 +106,13 @@
 	if (length < 0)
 		return -EINVAL;
 
+	if(!gr_search_file(dentry,GR_WRITE,mnt)) {
+		security_alert(GR_TRUNCATE_ACL_MSG, GR_TRUNCATE_ACL_FLD,
+			kdevname(dentry->d_inode->i_dev),
+			dentry->d_inode->i_ino, DEFAULTSECARGS);
+		return -EACCES;
+	}
+
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
@@ -163,7 +171,7 @@
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		error = do_truncate(nd.dentry, length, nd.mnt);
 	}
 	put_write_access(inode);
 
@@ -215,7 +223,7 @@
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, file->f_vfsmnt);
 out_putf:
 	fput(file);
 out:
@@ -269,6 +277,14 @@
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+       if(!gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) {
+               security_alert(GR_ATIME_ACL_MSG, GR_ATIME_ACL_FLD,
+               		kdevname(nd.dentry->d_inode->i_dev),
+			nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+	       error = -EACCES;
+	       goto dput_and_out;
+       }
+
 	/* Don't worry, the checks are done in inode_change_ok() */
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (times) {
@@ -314,6 +330,14 @@
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+	if(!gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) {
+		security_alert(GR_ATIME_ACL_MSG, GR_ATIME_ACL_FLD,
+			kdevname(nd.dentry->d_inode->i_dev),
+			nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	/* Don't worry, the checks are done in inode_change_ok() */
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (utimes) {
@@ -371,6 +395,14 @@
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		
+		if(!res && !gr_search_file(nd.dentry,GR_READ,nd.mnt)) {
+			security_alert(GR_ACCESS_ACL_MSG, GR_ACCESS_ACL_FLD,
+				kdevname(nd.dentry->d_inode->i_dev),
+				nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+			res =  -EACCES;
+		}
+
 		path_release(&nd);
 	}
 
@@ -403,6 +435,19 @@
 	if (error)
 		goto dput_and_out;
 
+	if(!gr_search_file(nd.dentry,GR_FIND,nd.mnt)) {
+		security_alert(GR_CHDIR_ACL_MSG, GR_CHDIR_ACL_FLD,
+			kdevname(nd.dentry->d_inode->i_dev),
+			nd.dentry->d_inode->i_ino,DEFAULTSECARGS);
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
+	if((grsec_enable_group && in_group_p(grsec_audit_gid) && 
+	   grsec_enable_chdir) || (grsec_enable_chdir && !grsec_enable_group))
+		security_audit(GR_CHDIR_AUDIT_MSG, filename,
+				DEFAULTSECARGS);
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -433,6 +478,20 @@
 		goto out_putf;
 
 	error = permission(inode, MAY_EXEC);
+
+	if(!error && grsec_enable_chroot_fchdir && proc_is_chrooted(current) && 
+	   ((file->f_vfsmnt->mnt_root->d_inode->i_dev != current->fs->root->d_inode->i_dev) ||
+	   (file->f_vfsmnt->mnt_root->d_inode->i_ino != current->fs->root->d_inode->i_ino))) {
+		security_alert(GR_FCHDIR_CHROOT_MSG, GR_FCHDIR_CHROOT_FLD,
+				file->f_dentry->d_name.name, DEFAULTSECARGS);
+		error = -EACCES;
+	}
+
+	if(!error && ((grsec_enable_group && in_group_p(grsec_audit_gid) && 
+	   grsec_enable_chdir) || (grsec_enable_chdir && !grsec_enable_group)))
+		security_audit(GR_FCHDIR_AUDIT_MSG, fd,
+				dentry->d_name.name, DEFAULTSECARGS);
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -467,8 +526,25 @@
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+	if(grsec_enable_chroot_double && proc_is_chrooted(current)) {
+		security_alert(GR_CHROOT_CHROOT_MSG, GR_CHROOT_CHROOT_FLD,
+			       kdevname(current->fs->root->d_inode->i_dev),
+			       current->fs->root->d_inode->i_ino,name, DEFAULTSECARGS);
+			goto dput_and_out;
+	}
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
+
+	if(grsec_enable_chroot_caps && proc_is_chrooted(current) && (current->pid > 1)) {
+		cap_drop(current->cap_permitted,GR_CHROOT_CAPS);
+		cap_drop(current->cap_inheritable,GR_CHROOT_CAPS);
+		cap_drop(current->cap_effective,GR_CHROOT_CAPS);
+	}
+
+	if (grsec_enable_chroot_chdir)
+		set_fs_pwd(current->fs, nd.mnt, nd.dentry);
+
 	error = 0;
 dput_and_out:
 	path_release(&nd);
@@ -497,8 +573,29 @@
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+	if(!gr_search_file(dentry,GR_WRITE,file->f_vfsmnt)) {
+		security_alert(GR_FCHMOD_ACL_MSG, GR_FCHMOD_ACL_FLD,
+			kdevname(dentry->d_inode->i_dev),
+                        dentry->d_inode->i_ino,DEFAULTSECARGS);
+		err = -EACCES;
+		goto out_putf;
+	}
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if(grsec_enable_chroot_chmod && ((mode & S_ISUID) || (mode & S_ISGID))
+	   && proc_is_chrooted(current)) {
+		security_alert(GR_FCHMOD_CHROOT_MSG, GR_FCHMOD_CHROOT_FLD,
+			   kdevname(inode->i_dev),inode->i_ino,inode->i_uid,inode->i_gid,mode,
+			   kdevname(current->fs->root->d_inode->i_dev),current->fs->root->d_inode->i_ino,
+			   current->fs->root->d_inode->i_uid,current->fs->root->d_inode->i_gid,
+			   DEFAULTSECARGS);
+		err = -EPERM;
+		goto out_putf;
+	}	    
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	err = notify_change(dentry, &newattrs);
@@ -529,8 +626,31 @@
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+	if(!gr_search_file(nd.dentry,GR_WRITE,nd.mnt)) {
+		security_alert(GR_CHMOD_ACL_MSG, GR_CHMOD_ACL_FLD,
+				kdevname(nd.dentry->d_inode->i_dev), 
+				nd.dentry->d_inode->i_ino, filename, 
+				DEFAULTSECARGS); 
+		error = -EACCES;
+		goto dput_and_out;
+	}
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
+
+	if (grsec_enable_chroot_chmod && ((mode & S_ISUID) || (mode & S_ISGID))
+	    && proc_is_chrooted(current)) {
+		security_alert(GR_CHMOD_CHROOT_MSG, GR_CHMOD_CHROOT_FLD,
+			   kdevname(inode->i_dev),inode->i_ino,filename,
+			   inode->i_uid,inode->i_gid,
+			   mode,kdevname(current->fs->root->d_inode->i_dev),
+			   current->fs->root->d_inode->i_ino,
+			   current->fs->root->d_inode->i_uid,
+			   current->fs->root->d_inode->i_gid, DEFAULTSECARGS);
+		    error = -EACCES;
+		    goto dput_and_out;
+	}
+
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	error = notify_change(nd.dentry, &newattrs);
@@ -541,7 +661,7 @@
 	return error;
 }
 
-static int chown_common(struct dentry * dentry, uid_t user, gid_t group)
+static int chown_common(struct dentry * dentry, uid_t user, gid_t group, struct vfsmount *mnt)
 {
 	struct inode * inode;
 	int error;
@@ -558,6 +678,15 @@
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+	if(!gr_search_file(dentry,GR_WRITE,mnt)) {
+		security_alert(GR_CHOWN_ACL_MSG, GR_CHOWN_ACL_FLD,
+			kdevname(dentry->d_inode->i_dev),
+			dentry->d_inode->i_ino,
+			user, group, DEFAULTSECARGS);
+		error = -EACCES;
+		goto out;
+	}
+
 	if (user == (uid_t) -1)
 		user = inode->i_uid;
 	if (group == (gid_t) -1)
@@ -608,7 +737,7 @@
 
 	error = user_path_walk(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -621,7 +750,7 @@
 
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
-		error = chown_common(nd.dentry, user, group);
+		error = chown_common(nd.dentry, user, group, nd.mnt);
 		path_release(&nd);
 	}
 	return error;
@@ -635,7 +764,8 @@
 
 	file = fget(fd);
 	if (file) {
-		error = chown_common(file->f_dentry, user, group);
+		error = chown_common(file->f_dentry, user,
+				group, file->f_vfsmnt);
 		fput(file);
 	}
 	return error;
@@ -755,6 +885,7 @@
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
+	gr_learn_resource(current, RLIMIT_NOFILE, fd);
 	if (fd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
diff -urN linux/fs/proc/base.c linux/fs/proc/base.c
--- linux/fs/proc/base.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/proc/base.c	2002-08-31 11:24:08.000000000 -0400
@@ -25,6 +25,7 @@
 #include <linux/string.h>
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
+#include <linux/grsecurity.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -554,8 +555,10 @@
 #ifdef CONFIG_SMP
   E(PROC_PID_CPU,	"cpu",		S_IFREG|S_IRUGO),
 #endif
+#ifndef CONFIG_GRKERNSEC_PROC_MEMMAP
   E(PROC_PID_MAPS,	"maps",		S_IFREG|S_IRUGO),
   E(PROC_PID_MEM,	"mem",		S_IFREG|S_IRUSR|S_IWUSR),
+#endif
   E(PROC_PID_CWD,	"cwd",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_ROOT,	"root",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_EXE,	"exe",		S_IFLNK|S_IRWXUGO),
@@ -710,10 +713,16 @@
 	get_task_struct(task);
 	inode->u.proc_i.task = task;
 	inode->i_uid = 0;
+#ifndef CONFIG_GRKERNSEC_PROC_USERGROUP
 	inode->i_gid = 0;
+#else
+	inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#endif
 	if (ino == PROC_PID_INO || task_dumpable(task)) {
 		inode->i_uid = task->euid;
+#ifndef CONFIG_GRKERNSEC_PROC_USERGROUP
 		inode->i_gid = task->egid;
+#endif
 	}
 
 out:
@@ -1019,13 +1028,24 @@
 	if (!task)
 		goto out;
 
+	if(gr_check_hidden_task(task)) {
+		free_task_struct(task);
+		goto out;
+	}
+
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
 
 	free_task_struct(task);
 
 	if (!inode)
 		goto out;
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP;
+#else
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
+#endif
 	inode->i_op = &proc_base_inode_operations;
 	inode->i_fop = &proc_base_operations;
 	inode->i_nlink = 3;
@@ -1065,6 +1085,10 @@
 		int pid = p->pid;
 		if (!pid)
 			continue;
+		if(gr_pid_is_chrooted(p))
+			continue;
+		if(gr_check_hidden_task(p)) 
+			continue;
 		if (--index >= 0)
 			continue;
 		pids[nr_pids] = pid;
diff -urN linux/fs/proc/generic.c linux/fs/proc/generic.c
--- linux/fs/proc/generic.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/proc/generic.c	2002-08-31 11:24:08.000000000 -0400
@@ -493,6 +493,29 @@
 	return ent;
 }
 
+#ifdef CONFIG_GRKERNSEC_PROC
+struct proc_dir_entry *proc_priv_mkdir(const char *name, struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry *ent;
+	mode_t mode = 0;
+
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	mode = S_IFDIR | S_IRUSR | S_IXUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	mode = S_IFDIR | S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP;
+#endif
+
+	ent = proc_create(&parent, name, mode, 2);
+	if (ent) {
+		ent->proc_fops = &proc_dir_operations;
+		ent->proc_iops = &proc_dir_inode_operations;
+
+		proc_register(parent, ent);
+	}
+	return ent;
+}
+#endif
+
 struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,
 					 struct proc_dir_entry *parent)
 {
diff -urN linux/fs/proc/inode.c linux/fs/proc/inode.c
--- linux/fs/proc/inode.c	2001-11-17 14:24:32.000000000 -0500
+++ linux/fs/proc/inode.c	2002-08-31 11:24:08.000000000 -0400
@@ -152,7 +152,11 @@
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
+#ifdef CONFIG_GRKERNSEC_PROC_USERGROUP
+			inode->i_gid = CONFIG_GRKERNSEC_PROC_GID;
+#else
 			inode->i_gid = de->gid;
+#endif
 		}
 		if (de->size)
 			inode->i_size = de->size;
diff -urN linux/fs/proc/proc_misc.c linux/fs/proc/proc_misc.c
--- linux/fs/proc/proc_misc.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/proc/proc_misc.c	2002-08-31 11:24:08.000000000 -0400
@@ -542,6 +542,7 @@
 void __init proc_misc_init(void)
 {
 	struct proc_dir_entry *entry;
+	int gr_mode = 0;
 	static struct {
 		char *name;
 		int (*read_proc)(char*,char**,off_t,int,int*,void*);
@@ -556,41 +557,74 @@
 #ifdef CONFIG_STRAM_PROC
 		{"stram",	stram_read_proc},
 #endif
-#ifdef CONFIG_MODULES
+#if defined(CONFIG_MODULES) && !defined(CONFIG_GRKERNSEC_PROC)
 		{"modules",	modules_read_proc},
 #endif
 		{"stat",	kstat_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"devices",	devices_read_proc},
+#endif
 		{"partitions",	partitions_read_proc},
-#if !defined(CONFIG_ARCH_S390)
+#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_GRKERNSEC_PROC_ADD)
 		{"interrupts",	interrupts_read_proc},
 #endif
 		{"filesystems",	filesystems_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"dma",		dma_read_proc},
 		{"ioports",	ioports_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#endif
 #ifdef CONFIG_SGI_DS1286
 		{"rtc",		ds1286_read_proc},
 #endif
 		{"locks",	locks_read_proc},
 		{"swaps",	swaps_read_proc},
+#ifndef CONFIG_GRKERNSEC_PROC_ADD
 		{"iomem",	memory_read_proc},
+#endif
 		{"execdomains",	execdomains_read_proc},
 		{NULL,}
 	};
 	for (p = simple_ones; p->name; p++)
 		create_proc_read_entry(p->name, 0, NULL, p->read_proc, NULL);
 
+#ifdef CONFIG_GRKERNSEC_PROC_USER
+	gr_mode = S_IRUSR;
+#elif CONFIG_GRKERNSEC_PROC_USERGROUP
+	gr_mode = S_IRUSR | S_IRGRP;
+#endif
+
+#if defined(CONFIG_GRKERNSEC_PROC) && defined(CONFIG_MODULES)
+	create_proc_read_entry("modules", gr_mode, NULL, &modules_read_proc, NULL);
+#endif
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_proc_read_entry("devices", gr_mode, NULL, &devices_read_proc, NULL);
+	create_proc_read_entry("dma", gr_mode, NULL, &dma_read_proc, NULL);
+	create_proc_read_entry("ioports", gr_mode, NULL, &ioports_read_proc, NULL);
+	create_proc_read_entry("cmdline", gr_mode, NULL, &cmdline_read_proc, NULL);
+	create_proc_read_entry("iomem", gr_mode, NULL, &memory_read_proc, NULL);   
+#if !defined(CONFIG_ARCH_S390)
+	create_proc_read_entry("interrupts", gr_mode, NULL, &interrupts_read_proc, NULL);
+#endif
+#endif
+
 	proc_symlink("mounts", NULL, "self/mounts");
 
 	/* And now for trickier ones */
 	entry = create_proc_entry("kmsg", S_IRUSR, &proc_root);
 	if (entry)
 		entry->proc_fops = &proc_kmsg_operations;
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	create_seq_entry("cpuinfo", gr_mode, &proc_cpuinfo_operations);
+	create_seq_entry("slabinfo", gr_mode, &proc_slabinfo_operations);
+#else
 	create_seq_entry("cpuinfo", 0, &proc_cpuinfo_operations);
 	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
+#endif
+
 #ifdef CONFIG_MODULES
-	create_seq_entry("ksyms", 0, &proc_ksyms_operations);
+	create_seq_entry("ksyms", gr_mode, &proc_ksyms_operations);
 #endif
 	proc_root_kcore = create_proc_entry("kcore", S_IRUSR, NULL);
 	if (proc_root_kcore) {
diff -urN linux/fs/proc/proc_tty.c linux/fs/proc/proc_tty.c
--- linux/fs/proc/proc_tty.c	2000-04-21 18:17:57.000000000 -0400
+++ linux/fs/proc/proc_tty.c	2002-08-31 11:24:08.000000000 -0400
@@ -174,7 +174,11 @@
 	if (!proc_mkdir("tty", 0))
 		return;
 	proc_tty_ldisc = proc_mkdir("tty/ldisc", 0);
+#ifdef CONFIG_GRKERNSEC_PROC
+	proc_tty_driver = proc_priv_mkdir("tty/driver", 0);
+#else
 	proc_tty_driver = proc_mkdir("tty/driver", 0);
+#endif
 
 	create_proc_read_entry("tty/ldiscs", 0, 0, tty_ldiscs_read_proc,NULL);
 	create_proc_read_entry("tty/drivers", 0, 0, tty_drivers_read_proc,NULL);
diff -urN linux/fs/proc/root.c linux/fs/proc/root.c
--- linux/fs/proc/root.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/proc/root.c	2002-08-31 11:24:08.000000000 -0400
@@ -37,13 +37,21 @@
 		return;
 	}
 	proc_misc_init();
+#ifdef CONFIG_GRKERNSEC_PROC
+	proc_net = proc_priv_mkdir("net", 0);
+#else
 	proc_net = proc_mkdir("net", 0);
+#endif
 #ifdef CONFIG_SYSVIPC
 	proc_mkdir("sysvipc", 0);
 #endif
 #ifdef CONFIG_SYSCTL
+#ifdef CONFIG_GRKERNSEC_PROC
+	proc_sys_root = proc_priv_mkdir("sys", 0);
+#else
 	proc_sys_root = proc_mkdir("sys", 0);
 #endif
+#endif
 #if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)
 	proc_mkdir("sys/fs", 0);
 	proc_mkdir("sys/fs/binfmt_misc", 0);
@@ -67,7 +75,12 @@
 #ifdef CONFIG_PPC_RTAS
 	proc_rtas_init();
 #endif
+
+#ifdef CONFIG_GRKERNSEC_PROC_ADD
+	proc_bus = proc_priv_mkdir("bus", 0);
+#else
 	proc_bus = proc_mkdir("bus", 0);
+#endif
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry)
diff -urN linux/fs/readdir.c linux/fs/readdir.c
--- linux/fs/readdir.c	2002-08-02 20:39:45.000000000 -0400
+++ linux/fs/readdir.c	2002-08-31 11:24:08.000000000 -0400
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/file.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -181,6 +182,7 @@
 struct readdir_callback {
 	struct old_linux_dirent * dirent;
 	int count;
+	struct nameidata nd;
 };
 
 static int fillonedir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -188,9 +190,20 @@
 {
 	struct readdir_callback * buf = (struct readdir_callback *) __buf;
 	struct old_linux_dirent * dirent;
+	ino_t old_ino;
 
 	if (buf->count)
 		return -EINVAL;
+	if(buf->nd.dentry->d_inode) {
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+		if(!gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt)) {
+			buf->nd.dentry->d_inode->i_ino = old_ino;
+			return 0;
+		}
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+	    
 	buf->count++;
 	dirent = buf->dirent;
 	put_user(ino, &dirent->d_ino);
@@ -215,6 +228,9 @@
 	buf.count = 0;
 	buf.dirent = dirent;
 
+	buf.nd.dentry = file->f_dentry;
+	buf.nd.mnt = file->f_vfsmnt;
+
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (error >= 0)
 		error = buf.count;
@@ -242,6 +258,7 @@
 	struct linux_dirent * previous;
 	int count;
 	int error;
+	struct nameidata nd;
 };
 
 static int filldir(void * __buf, const char * name, int namlen, loff_t offset,
@@ -250,10 +267,22 @@
 	struct linux_dirent * dirent;
 	struct getdents_callback * buf = (struct getdents_callback *) __buf;
 	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
+	ino_t old_ino;
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if(buf->nd.dentry && buf->nd.dentry->d_inode) {
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+		if(!gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt)) {
+			buf->nd.dentry->d_inode->i_ino = old_ino;
+			return 0;
+		}
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+
 	dirent = buf->previous;
 	if (dirent)
 		put_user(offset, &dirent->d_off);
@@ -286,6 +315,9 @@
 	buf.count = count;
 	buf.error = 0;
 
+	buf.nd.dentry = file->f_dentry;
+	buf.nd.mnt = file->f_vfsmnt;
+
 	error = vfs_readdir(file, filldir, &buf);
 	if (error < 0)
 		goto out_putf;
@@ -320,6 +352,7 @@
 	struct linux_dirent64 * previous;
 	int count;
 	int error;
+	struct nameidata nd;
 };
 
 static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,
@@ -328,10 +361,22 @@
 	struct linux_dirent64 * dirent, d;
 	struct getdents_callback64 * buf = (struct getdents_callback64 *) __buf;
 	int reclen = ROUND_UP64(NAME_OFFSET(dirent) + namlen + 1);
+	ino_t old_ino;
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+	if(buf->nd.dentry->d_inode) {
+		old_ino = buf->nd.dentry->d_inode->i_ino;
+		buf->nd.dentry->d_inode->i_ino = ino;
+		if(!gr_search_file(buf->nd.dentry,GR_FIND,buf->nd.mnt)) {
+			buf->nd.dentry->d_inode->i_ino = old_ino;
+			return 0;
+		}
+		buf->nd.dentry->d_inode->i_ino = old_ino;
+	}
+	
 	dirent = buf->previous;
 	if (dirent) {
 		d.d_off = offset;
@@ -369,6 +414,9 @@
 	buf.count = count;
 	buf.error = 0;
 
+	buf.nd.mnt = file->f_vfsmnt;
+	buf.nd.dentry = file->f_dentry;
+
 	error = vfs_readdir(file, filldir64, &buf);
 	if (error < 0)
 		goto out_putf;
diff -urN linux/grsecurity/Config.in linux/grsecurity/Config.in
--- linux/grsecurity/Config.in	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/Config.in	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,268 @@
+choice 'Security level' \
+        "Low		CONFIG_GRKERNSEC_LOW \
+         Medium		CONFIG_GRKERNSEC_MID \
+         High		CONFIG_GRKERNSEC_HI \
+	  Customized	CONFIG_GRKERNSEC_CUSTOM" Customized
+if [ "$CONFIG_GRKERNSEC_LOW" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_RANDSRC n
+define_bool CONFIG_GRKERNSEC_RANDRPC n
+define_bool CONFIG_GRKERNSEC_RANDPING n
+define_bool CONFIG_GRKERNSEC_FORKFAIL n
+define_bool CONFIG_GRKERNSEC_TIME n
+define_bool CONFIG_GRKERNSEC_SIGNAL n
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE n
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT n
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD n
+define_bool CONFIG_GRKERNSEC_PROC n
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP n
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK n
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_NOEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_PAGEEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_SEGMEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_EMUTRAMP n
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GR_DEBUG n
+define_bool CONFIG_GR_SUPERDEBUG n
+define_int CONFIG_GR_MAXTRIES 3
+define_int CONFIG_GR_TIMEOUT 30
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+fi
+if [ "$CONFIG_GRKERNSEC_MID" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_KMEM n
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP n
+define_bool CONFIG_GRKERNSEC_PROC_ADD n
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD n
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE n
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK n
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_NOEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_PAGEEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_SEGMEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_EMUTRAMP n
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT n
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS n
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GR_DEBUG n
+define_bool CONFIG_GR_SUPERDEBUG n
+define_int CONFIG_GR_MAXTRIES 3
+define_int CONFIG_GR_TIMEOUT 30
+
+define_int  CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_RANDSRC y
+define_bool CONFIG_GRKERNSEC_RANDRPC y
+define_bool CONFIG_GRKERNSEC_RANDPING y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP y
+fi
+if [ "$CONFIG_GRKERNSEC_HI" = "y" ]; then
+define_int CONFIG_GRKERNSEC_FLOODTIME 30
+define_int  CONFIG_GRKERNSEC_FLOODBURST 4
+define_bool CONFIG_GRKERNSEC_LINK y
+define_bool CONFIG_GRKERNSEC_FIFO y
+define_bool CONFIG_GRKERNSEC_RANDPID y
+define_bool CONFIG_GRKERNSEC_EXECVE y
+define_bool CONFIG_GRKERNSEC_DMESG y
+define_bool CONFIG_GRKERNSEC_RANDID y
+define_bool CONFIG_GRKERNSEC_RANDSRC y
+define_bool CONFIG_GRKERNSEC_RANDRPC y
+define_bool CONFIG_GRKERNSEC_RANDPING y
+define_bool CONFIG_GRKERNSEC_FORKFAIL y
+define_bool CONFIG_GRKERNSEC_TIME y
+define_bool CONFIG_GRKERNSEC_SIGNAL y
+define_bool CONFIG_GRKERNSEC_CHROOT_MOUNT y
+define_bool CONFIG_GRKERNSEC_CHROOT_PIVOT y
+define_bool CONFIG_GRKERNSEC_CHROOT_DOUBLE y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_MKNOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_CAPS y
+define_bool CONFIG_GRKERNSEC_CHROOT_FINDTASK y
+define_bool CONFIG_GRKERNSEC_PROC y
+define_bool CONFIG_GRKERNSEC_PROC_MEMMAP y
+define_bool CONFIG_GRKERNSEC_PROC_USERGROUP y
+define_int  CONFIG_GRKERNSEC_PROC_GID 10
+define_bool CONFIG_GRKERNSEC_KMEM y
+
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT n
+define_bool CONFIG_GR_DEBUG n
+define_bool CONFIG_GR_SUPERDEBUG n
+define_int CONFIG_GR_MAXTRIES 3
+define_int CONFIG_GR_TIMEOUT 30
+
+define_int CONFIG_GR_MAXTRIES 3
+define_int CONFIG_GR_TIMEOUT 30
+define_bool CONFIG_GRKERNSEC_PROC_ADD y
+define_bool CONFIG_GRKERNSEC_CHROOT_FCHDIR y
+define_bool CONFIG_GRKERNSEC_CHROOT_CHMOD y
+define_bool CONFIG_GRKERNSEC_CHROOT_NICE y
+define_bool CONFIG_GRKERNSEC_PAX_RANDMMAP y
+if [ "$CONFIG_X86" = "y" ]; then
+define_bool CONFIG_GRKERNSEC_PAX_NOEXEC y
+define_bool CONFIG_GRKERNSEC_PAX_PAGEEXEC n
+define_bool CONFIG_GRKERNSEC_PAX_SEGMEXEC y
+define_bool CONFIG_GRKERNSEC_PAX_EMUTRAMP n
+define_bool CONFIG_GRKERNSEC_PAX_MPROTECT y
+fi
+define_bool CONFIG_GRKERNSEC_AUDIT_MOUNT y
+fi
+if [ "$CONFIG_GRKERNSEC_CUSTOM" = "y" ]; then
+mainmenu_option next_comment
+comment 'Buffer Overflow Protection'
+if [ "$CONFIG_X86" = "y" ]; then
+  bool 'Enforce non-executable pages' CONFIG_GRKERNSEC_PAX_NOEXEC
+  if [ "$CONFIG_GRKERNSEC_PAX_NOEXEC" = "y" ]; then
+    bool 'Paging based non-executable pages' CONFIG_GRKERNSEC_PAX_PAGEEXEC
+    bool 'Segmentation based non-executable pages' CONFIG_GRKERNSEC_PAX_SEGMEXEC
+    if [ "$CONFIG_GRKERNSEC_PAX_PAGEEXEC" = "y" -o "$CONFIG_GRKERNSEC_PAX_SEGMEXEC" = "y" ]; then
+      bool '   Emulate trampolines' CONFIG_GRKERNSEC_PAX_EMUTRAMP
+      bool '   Restrict mprotect()' CONFIG_GRKERNSEC_PAX_MPROTECT
+    fi
+  fi
+fi
+bool 'Full Address Space Layout Randomization (ASLR)' CONFIG_GRKERNSEC_PAX_RANDMMAP
+bool 'Deny access to /dev/kmem' CONFIG_GRKERNSEC_KMEM
+endmenu
+mainmenu_option next_comment
+comment 'ACL options'
+bool 'ACL Debugging Messages' CONFIG_GR_DEBUG
+if [ "$CONFIG_GR_DEBUG" = "y" ]; then
+	bool 'Extra ACL Debugging Messages' CONFIG_GR_SUPERDEBUG
+fi	
+int 'Maximum tries before password lockout' CONFIG_GR_MAXTRIES 3
+int 'Time to wait after max password tries, in seconds' CONFIG_GR_TIMEOUT 30
+endmenu
+mainmenu_option next_comment
+comment 'Filesystem Protections'
+bool 'Proc restrictions' CONFIG_GRKERNSEC_PROC
+if [ "$CONFIG_GRKERNSEC_PROC" != "n" ]; then
+bool '   Restrict to user only' CONFIG_GRKERNSEC_PROC_USER
+if [ "$CONFIG_GRKERNSEC_PROC_USER" != "n" ]; then
+bool '      Additional restrictions' CONFIG_GRKERNSEC_PROC_ADD
+bool '      Remove mem and maps support' CONFIG_GRKERNSEC_PROC_MEMMAP
+fi
+if [ "$CONFIG_GRKERNSEC_PROC_USER" != "y" ]; then
+bool '   Allow special group' CONFIG_GRKERNSEC_PROC_USERGROUP
+if [ "$CONFIG_GRKERNSEC_PROC_USERGROUP" != "n" ]; then
+int  '   GID for special group' CONFIG_GRKERNSEC_PROC_GID 1001
+bool '      Additional restrictions' CONFIG_GRKERNSEC_PROC_ADD
+bool '      Remove mem and maps support' CONFIG_GRKERNSEC_PROC_MEMMAP
+fi
+fi
+fi
+bool 'Linking restrictions' CONFIG_GRKERNSEC_LINK
+bool 'FIFO restrictions' CONFIG_GRKERNSEC_FIFO
+bool 'Chroot jail restrictions' CONFIG_GRKERNSEC_CHROOT
+if [ "$CONFIG_GRKERNSEC_CHROOT" != "n" ]; then
+bool '   Deny mounts' CONFIG_GRKERNSEC_CHROOT_MOUNT
+bool '   Deny double-chroots' CONFIG_GRKERNSEC_CHROOT_DOUBLE
+bool '   Deny pivot_root in chroot' CONFIG_GRKERNSEC_CHROOT_PIVOT
+bool '   Enforce chdir("/") on all chroots' CONFIG_GRKERNSEC_CHROOT_CHDIR
+bool '   Deny fchdir outside of chroot' CONFIG_GRKERNSEC_CHROOT_FCHDIR
+bool '   Deny (f)chmod +s' CONFIG_GRKERNSEC_CHROOT_CHMOD
+bool '   Deny mknod' CONFIG_GRKERNSEC_CHROOT_MKNOD
+bool '   Protect outside processes' CONFIG_GRKERNSEC_CHROOT_FINDTASK
+bool '   Restrict priority changes' CONFIG_GRKERNSEC_CHROOT_NICE
+fi
+bool 'Capability restrictions within chroot' CONFIG_GRKERNSEC_CHROOT_CAPS
+endmenu
+mainmenu_option next_comment
+comment 'Kernel Auditing'
+bool 'Single group for auditing' CONFIG_GRKERNSEC_AUDIT_GROUP
+if [ "$CONFIG_GRKERNSEC_AUDIT_GROUP" != "n" ]; then
+int  '   GID for auditing' CONFIG_GRKERNSEC_AUDIT_GID 1007
+fi
+bool 'Exec logging' CONFIG_GRKERNSEC_EXECLOG
+bool 'Log execs within chroot' CONFIG_GRKERNSEC_CHROOT_EXECLOG
+bool 'Chdir logging' CONFIG_GRKERNSEC_AUDIT_CHDIR
+bool '(Un)Mount logging' CONFIG_GRKERNSEC_AUDIT_MOUNT
+bool 'IPC logging' CONFIG_GRKERNSEC_AUDIT_IPC
+bool 'Signal logging' CONFIG_GRKERNSEC_SIGNAL
+bool 'Fork failure logging' CONFIG_GRKERNSEC_FORKFAIL
+bool 'Time change logging' CONFIG_GRKERNSEC_TIME
+endmenu
+mainmenu_option next_comment
+comment 'Executable Protections'
+bool 'Exec process limiting' CONFIG_GRKERNSEC_EXECVE
+bool 'Dmesg(8) restriction' CONFIG_GRKERNSEC_DMESG
+bool 'Randomized PIDs' CONFIG_GRKERNSEC_RANDPID
+bool 'Trusted path execution' CONFIG_GRKERNSEC_TPE
+if [ "$CONFIG_GRKERNSEC_TPE" != "n" ]; then
+bool '   Partially restrict non-root users' CONFIG_GRKERNSEC_TPE_ALL
+int  '   GID for untrusted users:' CONFIG_GRKERNSEC_TPE_GID 1005
+fi
+endmenu
+mainmenu_option next_comment
+comment 'Network Protections'
+bool 'Randomized IP IDs' CONFIG_GRKERNSEC_RANDID
+bool 'Randomized TCP source ports' CONFIG_GRKERNSEC_RANDSRC
+bool 'Randomized RPC XIDs' CONFIG_GRKERNSEC_RANDRPC
+bool 'Altered Ping IDs' CONFIG_GRKERNSEC_RANDPING
+bool 'Socket restrictions' CONFIG_GRKERNSEC_SOCKET
+if [ "$CONFIG_GRKERNSEC_SOCKET" != "n" ]; then
+bool '  Deny any sockets to group' CONFIG_GRKERNSEC_SOCKET_ALL
+if [ "$CONFIG_GRKERNSEC_SOCKET_ALL" != "n" ]; then
+int  '   GID to deny all sockets for:' CONFIG_GRKERNSEC_SOCKET_ALL_GID 1004
+fi
+bool '  Deny client sockets to group' CONFIG_GRKERNSEC_SOCKET_CLIENT
+if [ "$CONFIG_GRKERNSEC_SOCKET_CLIENT" != "n" ]; then
+int  '   GID to deny client sockets for:' CONFIG_GRKERNSEC_SOCKET_CLIENT_GID 1003
+fi
+bool '  Deny server sockets to group' CONFIG_GRKERNSEC_SOCKET_SERVER
+if [ "$CONFIG_GRKERNSEC_SOCKET_SERVER" != "n" ]; then
+int  '   GID to deny server sockets for:' CONFIG_GRKERNSEC_SOCKET_SERVER_GID 1002
+fi
+fi
+endmenu
+if [ "$CONFIG_SYSCTL" != "n" ]; then
+mainmenu_option next_comment
+comment 'Sysctl support'
+bool 'Sysctl support' CONFIG_GRKERNSEC_SYSCTL
+endmenu
+fi
+mainmenu_option next_comment
+comment 'Miscellaneous Features'
+int 'Seconds in between log messages (minimum)' CONFIG_GRKERNSEC_FLOODTIME 30
+int 'Number of messages in a burst (maximum)' CONFIG_GRKERNSEC_FLOODBURST 4
+endmenu
+fi
diff -urN linux/grsecurity/Makefile linux/grsecurity/Makefile
--- linux/grsecurity/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/Makefile	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,12 @@
+#
+# grsecurity (c) 2002 Brad Spengler, Michael Dalton
+# 
+# all grsecurity-related code is released under the
+# GNU General Public License (GPL) http://www.gnu.org
+#
+
+O_TARGET := grsec.o
+
+obj-y = grsecurity.o grsum.o gracl.o gracl_ip.o gracl_segv.o ip_id.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux/grsecurity/gracl.c linux/grsecurity/gracl.c
--- linux/grsecurity/gracl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/gracl.c	2002-08-31 14:29:47.000000000 -0400
@@ -0,0 +1,1800 @@
+/* 
+ * grsecurity/gracl.c
+ * Copyright Michael Dalton, Brad Spengler 2000, 2001, 2002
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+#include <linux/grsum.h>
+#include <linux/sysctl.h>
+
+static struct acl_subject_db acl_subj_set;
+static struct acl_object_db acl_obj_set;
+static struct name_db name_set;
+
+static struct admin_pw pwent; /* password entry */
+
+rwlock_t gr_list_lock = RW_LOCK_UNLOCKED;
+spinlock_t gr_proc_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned long gr_status = GR_STATUS_INIT;
+
+#ifdef CONFIG_GRKERNSEC
+int gr_disable = 0;
+#else
+int gr_disable = 1;
+#endif
+
+/* The special mode : admin(called god_label for historical reasons) mode */
+
+static struct acl_subject_label god_label;
+static struct acl_subject_label root_label;
+
+extern int gr_init_uidset(void);
+extern void gr_free_uidset(void);
+extern void gr_remove_uid(uid_t uid);
+extern int gr_find_uid(uid_t uid);
+
+static unsigned long table_sizes[] = {
+	7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 
+	32749, 65521, 131071, 262139, 524287, 1048573, 2097143,
+	4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 
+	268435399, 536870909, 1073741789, 2147483647
+};
+
+
+static const char * captab_log[29] = {
+	"CAP_CHOWN",
+	"CAP_DAC_OVERRIDE",
+	"CAP_DAC_READ_SEARCH",
+	"CAP_FOWNER",
+	"CAP_FSETID",
+	"CAP_KILL",
+	"CAP_SETGID",
+	"CAP_SETUID",
+	"CAP_SETPCAP",
+	"CAP_LINUX_IMMUTABLE",
+	"CAP_NET_BIND_SERVICE",
+	"CAP_NET_BROADCAST",
+	"CAP_NET_ADMIN",
+	"CAP_NET_RAW",
+	"CAP_IPC_LOCK",
+	"CAP_IPC_OWNER",
+	"CAP_SYS_MODULE",
+	"CAP_SYS_RAWIO",
+	"CAP_SYS_CHROOT",
+	"CAP_SYS_PTRACE",
+	"CAP_SYS_PACCT",
+	"CAP_SYS_ADMIN",
+	"CAP_SYS_BOOT",
+	"CAP_SYS_NICE",
+	"CAP_SYS_RESOURCE",
+	"CAP_SYS_TIME",
+	"CAP_SYS_TTY_CONFIG",
+	"CAP_MKNOD",
+	"CAP_LEASE"
+};
+
+#ifdef CONFIG_GR_SUPERDEBUG
+static void list_procs(void);
+static void list_names(void);
+#endif
+
+static __inline__ char * d_real_path(struct dentry * dentry, struct vfsmount * vfsmnt,
+					char * buf, int buflen)
+{
+	char *res;
+	struct vfsmount *rootmnt;
+	struct dentry *root;
+	read_lock(&child_reaper->fs->lock);
+	rootmnt = mntget(child_reaper->fs->rootmnt);
+	root = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+	spin_lock(&dcache_lock);
+	res = __d_path(dentry, vfsmnt, root, rootmnt, buf, buflen);
+	spin_unlock(&dcache_lock);
+	dput(root);
+	mntput(rootmnt);
+	return res;
+}
+
+__inline__ struct acl_subject_label *
+lookup_acl_subj_label(const ino_t ino, const kdev_t dev)
+{
+	unsigned long index = fhash(ino, dev, acl_subj_set.s_size);
+	struct acl_subject_label *match;
+	__u8 i = 0;
+
+	match = &acl_subj_set.s_hash[index];
+
+	while (((match->mode & GR_EXISTS) || (match->mode & GR_DELETED)) &&
+	       (match->inode != ino || match->device != dev)) {
+		index = (index + (1 << i)) % acl_subj_set.s_size;
+		i = (i + 1) % 32;
+		match = &acl_subj_set.s_hash[index];
+	}
+
+	return ((match->mode & GR_EXISTS) && (match->inode == ino) && 
+		(match->device == dev)) ? match : NULL;
+}
+
+static __inline__ struct acl_object_label *
+lookup_acl_obj_label(const ino_t ino, const kdev_t dev,
+		     const unsigned long parent_pos)
+{
+	unsigned long index = phash(ino, dev, parent_pos, acl_obj_set.o_size);
+	struct acl_object_label *match;
+	__u8 i = 0;
+
+	match = &acl_obj_set.o_hash[index];
+
+	while (((match->mode & GR_EXISTS) || (match->mode & GR_DELETED)) 
+					 && (match->inode != ino ||
+					     match->device != dev ||
+					     match->parent_pos != parent_pos)) {
+		index = (index + (1 << i)) % acl_obj_set.o_size;
+		match = &acl_obj_set.o_hash[index];
+		i = (i + 1) % 32;
+	}
+	
+	return ((match->mode & GR_EXISTS) && (match->inode == ino) && 
+		(match->device == dev) && (match->parent_pos == parent_pos)) 
+		? match : NULL;
+}
+
+static __inline__ struct name_entry *
+lookup_name_entry(const char *name)
+{
+	unsigned long index = nhash(name, name_set.n_size);
+	struct name_entry *match;
+	__u8 i = 0;
+
+	match = &name_set.n_hash[index];
+
+	while ((match->mode & GR_EXISTS) && (strcmp(match->name, name)) != 0) {
+		index = (index + (1 << i)) % name_set.n_size;
+		match = &name_set.n_hash[index];
+		i = (i + 1) % 32;
+	}
+
+	return ((match->mode & GR_EXISTS) && (strcmp(name, match->name)) == 0) ? match : NULL;
+}
+
+/* The following routines perform insertion into the tables after
+ * the add_{type} process the config file */
+
+static int
+insert_name_entry(char *name, ino_t ino, kdev_t dev, __u8 mode)
+{
+	unsigned long index = nhash(name, name_set.n_size);
+	struct name_entry *curr;
+	__u8 i = 0;
+
+	curr = &name_set.n_hash[index];
+
+	while ((curr->mode & GR_EXISTS) && strcmp(name, curr->name)) {
+		index = (index + (1 << i)) % name_set.n_size;
+		curr = &name_set.n_hash[index];
+		i = (i + 1) % 32;
+	}
+
+	/* Duplicate entries are actually expected here..the same filename
+	 * might be associated with a process subject acl and a file acl
+	 * for instance */
+
+	curr->inode = ino;
+	curr->device = dev;
+	curr->mode |= mode;
+
+	curr->name = name;
+
+	name_set.n_used++;
+
+	return 0;
+}
+
+static int
+insert_acl_obj_label(struct acl_object_label *obj)
+{
+	unsigned long index = phash(obj->inode, obj->device, obj->parent_pos,
+					acl_obj_set.o_size);
+	struct acl_object_label *curr;
+	__u8 i = 0;
+
+	curr = &acl_obj_set.o_hash[index];
+
+	while (curr->mode & GR_EXISTS) {
+		index = (index + (1 << i)) % acl_obj_set.o_size;
+		curr = &acl_obj_set.o_hash[index];
+		i = (i + 1) % 32;
+	}
+
+	memcpy(curr, obj, sizeof(struct acl_object_label));
+	++acl_obj_set.o_used;
+
+	return 0;
+
+}
+
+static int
+insert_acl_subj_label(struct acl_subject_label *obj)
+{
+	unsigned long index = fhash(obj->inode, obj->device, acl_subj_set.s_size);
+	struct acl_subject_label *curr;
+	__u8 i = 0;
+
+	curr = &acl_subj_set.s_hash[index];
+
+	while (curr->mode & GR_EXISTS) {
+		index = (index + (1 << i)) % acl_subj_set.s_size;
+		curr = &acl_subj_set.s_hash[index];
+		i = (i + 1) % 32;
+	}
+
+	memcpy(curr, obj, sizeof(struct acl_subject_label));
+	++acl_subj_set.s_used;
+
+	return 0;
+
+}
+
+/* Create a table(requesting size close to 2^pwr entrie of member size)
+ * and replace the current table size with the new one.
+ * We use prime table sizes until we reach the bounds of 32-bit word machines 
+ * Once we reach there we simply double the table size */
+
+static void *
+create_table(unsigned long *len, unsigned long member)
+{
+	void * newtable = NULL;
+	unsigned int pwr = 0;
+	while ((pwr < ((sizeof(table_sizes)/sizeof(table_sizes[0])) - 1)) && 
+			table_sizes[pwr] <= (2 * (*len)))
+		pwr++;
+
+	if(table_sizes[pwr] <= (2 * (*len)))
+		return newtable;
+
+	if((table_sizes[pwr] * member) <= PAGE_SIZE)
+		newtable = kmalloc(table_sizes[pwr] * member, GFP_KERNEL);
+	else
+		newtable = vmalloc(table_sizes[pwr] * member);
+
+	*len = table_sizes[pwr];
+
+	return newtable;
+}
+
+
+#ifdef CONFIG_GR_SUPERDEBUG
+static void
+list_names(void)
+{
+	unsigned long i;
+	struct name_entry *curr;
+
+	for (i = 0; i < name_set.n_size; i++) {
+		curr = &name_set.n_hash[i];
+		if(!(curr->mode & GR_EXISTS)) continue;
+
+		security_debug(GR_LISTNAMES_DEBUG_MSG,
+				i, curr->inode,
+				kdevname(curr->device),
+				curr->mode, curr->name);
+	}
+
+	return;
+}
+
+static void
+list_procs(void)
+{
+	unsigned long i;
+	struct acl_subject_label *curr;
+	struct acl_object_label *curr2;
+	for (i = 0; i < acl_subj_set.s_size; i++) {
+		curr = &acl_subj_set.s_hash[i];
+		if (!(curr->mode & GR_EXISTS)) continue;
+		security_debug(GR_LISTPROCSS_DEBUG_MSG,
+				i, curr->inode,
+				kdevname(curr->device),
+				curr->mode, curr->pos);
+	}
+	for (i = 0; i < acl_obj_set.o_size; i++) {
+		curr2 = &acl_obj_set.o_hash[i];
+		if (!(curr2->mode & GR_EXISTS)) continue;
+		security_debug(GR_LISTPROCSO_DEBUG_MSG, i,
+			       curr2->inode, kdevname(curr2->device),
+			       curr2->mode, curr2->parent_pos);
+	}
+
+	return;
+}
+
+#endif
+
+static int
+init_variables(unsigned long acl_obj_size, unsigned long acl_subj_size)
+{
+	acl_subj_set.s_size = acl_subj_size;
+	acl_obj_set.o_size = acl_obj_size;
+	name_set.n_size = (acl_obj_size + acl_subj_size);
+
+	if(!gr_init_uidset()) return 1;
+
+	/* We only want 50% full tables for now */
+
+	acl_subj_set.s_hash = create_table(&acl_subj_set.s_size,
+			sizeof (struct acl_subject_label));
+	acl_obj_set.o_hash = create_table(&acl_obj_set.o_size,
+			sizeof (struct acl_object_label));
+	name_set.n_hash = create_table(&name_set.n_size, 
+			sizeof (struct name_entry));
+
+	if (!acl_subj_set.s_hash || !acl_obj_set.o_hash || !name_set.n_hash)
+		return 1;
+	memset(acl_subj_set.s_hash, 0,
+	       sizeof (struct acl_subject_label) * acl_subj_set.s_size);
+	memset(acl_obj_set.o_hash, 0,
+	       sizeof (struct acl_object_label) * acl_obj_set.o_size);
+	memset(name_set.n_hash, 0,
+	       sizeof (struct name_entry) * name_set.n_size);
+
+	acl_subj_set.s_used = acl_obj_set.o_used = name_set.n_used = 0;
+
+	return 0;
+}
+
+static void
+free_user_acl(struct gr_arg *args)
+{
+	unsigned long i;
+	struct user_acl_subject_label ** s_tmp = args->subj_db.s_table;
+	struct user_acl_object_label ** o_tmp = args->obj_db.o_table;
+
+	for(i=0;i<args->subj_db.s_entries;i++, s_tmp++)
+		kfree(*s_tmp);
+	kfree(args->subj_db.s_table);
+
+	for(i=0;i<args->obj_db.o_entries;i++, o_tmp++)
+		kfree(*o_tmp);
+	kfree(args->obj_db.o_table);
+
+	return;
+}
+
+static int
+parse_args(struct gr_arg *args)
+{
+	unsigned long pos;
+	struct user_acl_subject_label ** s_tmp = args->subj_db.s_table;
+	struct user_acl_object_label ** o_tmp = args->obj_db.o_table;
+
+	/* We must at least have admin, gradm, and / specified */
+
+	if (args->subj_db.s_entries < 3)
+		return -EINVAL;
+
+	for (pos = 0; pos < args->subj_db.s_entries; pos++, s_tmp++) {
+		struct user_acl_subject_label *s_curr = *s_tmp;
+		struct acl_subject_label s_temp = {
+			inode:s_curr->inode,
+			device:s_curr->device,
+			mode:s_curr->mode,
+			pos:s_curr->pos,
+			resmask:s_curr->resmask,
+			ip_type:s_curr->ip_type,
+			ip_num:s_curr->ip_num,
+			ips:s_curr->ips
+		};
+
+		memcpy(s_temp.res, s_curr->res, sizeof(s_curr->res));
+		memcpy(s_temp.ip_proto, s_curr->ip_proto, sizeof(s_curr->ip_proto));
+
+		/* Bleh: converting __u32 to kernel_cap_t ... and 
+		 * kernel_cap_t is either __u32 or a struct depending on
+		 * your funktitude, so we use those kinky macros in capability.h
+		 */
+		cap_t(s_temp.cap_lower) = to_cap_t(s_curr->cap_lower);
+		cap_t(s_temp.cap_raise_inherit) = 
+			to_cap_t(s_curr->cap_raise_inherit);
+		cap_t(s_temp.cap_lower_inherit) = 
+			to_cap_t(s_curr->cap_lower_inherit);
+
+		if (!(strcmp(s_curr->filename, "god")))
+			god_label = s_temp;
+		else if (!(strcmp(s_curr->filename, "/")))
+			root_label = s_temp;
+		insert_name_entry(s_curr->filename, s_curr->inode, s_curr->device,
+				  GR_NAME_ACL_SUBJECT | GR_EXISTS);
+		insert_acl_subj_label(&s_temp);
+	}
+
+	for (pos = 0;pos < args->obj_db.o_entries; pos++, o_tmp++) {
+
+		struct user_acl_object_label *o_curr = *o_tmp;
+		struct acl_object_label o_temp = {
+			inode:o_curr->inode,
+			device:o_curr->device,
+			mode:o_curr->mode,
+			parent_pos:o_curr->parent_pos
+		};
+
+		insert_name_entry(o_curr->filename, o_curr->inode, o_curr->device,
+				  GR_NAME_ACL_OBJECT | GR_EXISTS);
+		insert_acl_obj_label(&o_temp);
+	}
+
+	return 0;
+}
+
+static void
+free_variables(void)
+{
+	unsigned long i, x;
+	struct name_entry * ntmp;
+	struct acl_subject_label * stmp;
+
+	if(acl_subj_set.s_hash) {
+		for(i = 0; i < acl_subj_set.s_size ; i++) {
+			stmp = &acl_subj_set.s_hash[i];
+			if(stmp->ips) {
+				for(x = 0; x < stmp->ip_num; x++)
+					kfree(*(stmp->ips + x));
+				kfree(stmp->ips);
+			}
+		}
+		if((acl_subj_set.s_size * sizeof(struct acl_subject_label)) <= PAGE_SIZE)
+			kfree(acl_subj_set.s_hash);
+		else
+			vfree(acl_subj_set.s_hash);
+	}
+	if(acl_obj_set.o_hash) {
+		if((acl_obj_set.o_size * sizeof(struct acl_object_label)) <= PAGE_SIZE)
+			kfree(acl_obj_set.o_hash);
+		else
+			vfree(acl_obj_set.o_hash);
+	}
+	if(name_set.n_hash) {
+		for(i = 0; i < name_set.n_size ; i++) {
+			ntmp = &name_set.n_hash[i];
+			if(ntmp->name)
+				kfree(ntmp->name);
+		}
+		if((name_set.n_size * sizeof(struct name_entry)) <= PAGE_SIZE)
+			kfree(name_set.n_hash);
+		else
+			vfree(name_set.n_hash);
+	}
+
+	gr_free_uidset();	
+
+	return;
+}
+
+static void
+grsecurity_disable(void)
+{
+	struct task_struct * task;
+
+	read_lock(&tasklist_lock);
+	write_lock(&gr_list_lock);
+	for_each_task(task)
+		task->acl = NULL;
+	write_unlock(&gr_list_lock);
+	read_unlock(&tasklist_lock);
+
+	memset(&name_set, 0, sizeof(struct name_db));
+	memset(&acl_obj_set, 0, sizeof(struct acl_object_db));
+	memset(&acl_subj_set, 0, sizeof(struct acl_subject_db));
+	memset(&god_label, 0, sizeof(struct acl_subject_label)); 
+	memset(&root_label, 0, sizeof(struct acl_subject_label));
+		
+	free_variables();
+	return;
+}
+
+static int
+copy_user_acl(struct gr_arg *arg)
+{
+	struct user_acl_object_label ** o_kerntable, ** o_tmp, ** o_utmp;
+	struct user_acl_subject_label ** s_kerntable, ** s_tmp, ** s_utmp;
+	struct acl_ip_label ** i_tmp;
+	unsigned long s_num = 1, o_num = 1, i_num = 1, x;
+	int err = 0;
+
+	if ((o_tmp = o_kerntable = (struct user_acl_object_label **)
+			kmalloc(arg->obj_db.o_entries * sizeof 
+			(struct user_acl_object_label *), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	if ((s_tmp = s_kerntable = (struct user_acl_subject_label **)
+			kmalloc(arg->subj_db.s_entries * sizeof 
+			(struct user_acl_subject_label *), GFP_KERNEL)) == NULL) {
+		kfree(o_kerntable);
+		return -ENOMEM;
+	}
+
+	s_utmp = arg->subj_db.s_table;
+	o_utmp = arg->obj_db.o_table;
+
+	for(;o_num <= arg->obj_db.o_entries;o_num++,o_kerntable++,o_utmp++) {
+		if ((*o_kerntable = (struct user_acl_object_label *)kmalloc(sizeof 
+			(struct user_acl_object_label), GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(*o_kerntable, *o_utmp, 
+	     		sizeof (struct user_acl_object_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		if (((*o_kerntable)->filename = (char *)kmalloc
+			((*o_kerntable)->filename_len, GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user((*o_kerntable)->filename, 
+			(*o_utmp)->filename, (*o_kerntable)->filename_len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+	
+	}
+	for(;s_num <= arg->subj_db.s_entries;s_num++,s_kerntable++,s_utmp++) {
+		if ((*s_kerntable = kmalloc(sizeof (struct user_acl_subject_label),
+		    GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user(*s_kerntable, *s_utmp,
+		 		sizeof (struct user_acl_subject_label))) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+ 		if (((*s_kerntable)->filename = (char *)kmalloc((*s_kerntable)->filename_len, 
+		    GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+		if (copy_from_user((*s_kerntable)->filename, (*s_utmp)->filename, 
+	     			(*s_kerntable)->filename_len)) {
+			err = -EFAULT;
+			goto cleanup;
+		}
+		/* add in ip acls */
+
+		if(!(*s_kerntable)->ip_num) {
+			(*s_kerntable)->ips = NULL;
+			continue;
+		}
+
+		if ((i_tmp = (struct acl_ip_label **) kmalloc((*s_kerntable)->ip_num * sizeof (struct acl_ip_label *), GFP_KERNEL)) == NULL) {
+			err = -ENOMEM;
+			goto cleanup;
+		}
+
+		(*s_kerntable)->ips = i_tmp;
+
+		for(i_num = 1; i_num <= (*s_kerntable)->ip_num; i_num++) {
+	 		if ((*(i_tmp + i_num - 1) = (struct acl_ip_label *) kmalloc(sizeof(struct acl_ip_label), GFP_KERNEL)) == NULL) {
+				err = -ENOMEM;
+				goto cleanup;
+			}
+			if (copy_from_user(*(i_tmp + i_num - 1), *((*s_utmp)->ips + i_num - 1), sizeof(struct acl_ip_label))) {
+				err = -EFAULT;
+				goto cleanup;
+			}
+		}	
+
+	}
+
+	arg->subj_db.s_table = s_tmp;
+	arg->obj_db.o_table = o_tmp;
+#ifdef CONFIG_GR_DEBUG
+	security_debug(GR_LISTACLS1_DEBUG_MSG);
+	security_debug(GR_LISTACLS2_DEBUG_MSG, arg->subj_db.s_entries,
+			arg->obj_db.o_entries);
+	{
+		unsigned long i;
+		for(i = 0; i < arg->subj_db.s_entries; i++,s_tmp++) {
+			if(!((*s_tmp)->mode & GR_EXISTS))
+				continue;
+			security_debug(GR_LISTACLSS_DEBUG_MSG,
+					(*s_tmp)->filename, i, (*s_tmp)->inode,
+					(*s_tmp)->device);
+		}
+		for(i = 0; i < arg->obj_db.o_entries; i++,o_tmp++) {
+			if(!((*o_tmp)->mode & GR_EXISTS))
+				continue;
+			security_debug(GR_LISTACLSO_DEBUG_MSG,
+					(*o_tmp)->filename, i, (*o_tmp)->inode,
+					(*o_tmp)->device);
+		}
+	}
+#endif
+	goto return_err;
+cleanup:
+	o_kerntable = o_tmp;
+	s_kerntable = s_tmp;
+
+	while(--o_num) {
+		if(*o_kerntable) {
+			if((*o_kerntable)->filename)
+				kfree((*o_kerntable)->filename);
+			kfree(*o_kerntable);
+		}
+		o_kerntable++;
+	}
+
+	kfree(o_tmp);
+
+	while(--s_num) {
+		if(*s_kerntable) {
+			if((*s_kerntable)->filename)
+				kfree((*s_kerntable)->filename);
+			if((*s_kerntable)->ips) {
+				if(s_num == 1) { // last subject processed	
+					while(--i_num)
+						kfree(*((*s_kerntable)->ips + i_num));
+				} else {
+					for(x = 0; x < (*s_kerntable)->ip_num; x++)
+						kfree(*((*s_kerntable)->ips + x));
+				}		
+				kfree((*s_kerntable)->ips);
+			}
+			kfree(*s_kerntable);
+		}
+		s_kerntable++;
+	}
+	kfree(s_tmp);	
+return_err:	
+	return err;
+
+}
+
+static int
+add_pw_conf(void)
+{
+	struct file *filp;
+	int retval;
+
+	mm_segment_t old_fs = get_fs();
+	filp = filp_open(PW_CONF, O_RDONLY, O_RDONLY);
+	if ((IS_ERR(filp)) || (filp == NULL) || (!(filp->f_op->read))) {
+		security_alert(GR_PWCONF_ACL_MSG, GR_PWCONF_ACL_FLD, PW_CONF);
+		return 1;
+	}
+	filp->f_pos = 0;
+	set_fs(KERNEL_DS);
+	retval = filp->f_op->read(filp, (unsigned char *) &pwent, sizeof (pwent),
+				  &filp->f_pos);
+	set_fs(old_fs);
+	if (retval != (sizeof (pwent))) {
+		security_alert(GR_INVPW_ACL_MSG, GR_INVPW_ACL_FLD,
+			       retval, sizeof (pwent));
+		retval = 1;
+	} else
+		retval = 0;
+	filp_close(filp, NULL);
+
+	return retval;
+}
+
+static int
+grsecurity_init(struct gr_arg *args)
+{
+	int error = 0;
+
+	error = copy_user_acl(args);
+	if(error)
+		return error;
+	if (init_variables(args->obj_db.o_entries, args->subj_db.s_entries)) {
+		security_alert(GR_INITF_ACL_MSG, GR_INITF_ACL_FLD, GR_VERSION);
+		error = -1;
+		free_variables();
+	} else if (add_pw_conf()) {
+		security_alert(GR_PWF_ACL_MSG, GR_PWF_ACL_FLD, GR_VERSION);
+		error = -2;
+		free_variables();
+	} 
+	else if (parse_args(args)) {
+		security_alert(GR_PARSEF_ACL_MSG, GR_PARSEF_ACL_FLD, GR_VERSION);
+		error = -3;
+		free_variables();
+	}
+
+	free_user_acl(args);
+
+	if (!error) {
+
+#ifdef CONFIG_GR_SUPERDEBUG
+		list_procs();
+		list_names();
+#endif
+
+		if((error = gr_set_acls()))
+			goto out;
+
+		gr_status |= GR_READY;
+	} else {
+		security_alert(GR_DISABLED_ACL_MSG, GR_DISABLED_ACL_FLD, GR_VERSION);
+	}
+out:
+	return error;
+}
+
+/* * * * * * * * * * * * * * * * * * * * * * *
+ * Begin Misc Section 
+ * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Searching stuff, program exit cleanup, and sysctl parsing */
+
+/* do_find_{type} - checks to see if an entry is defined based on its
+ * arguments, usually an inode/dev passed via  temp_file_label structure,
+ * and in the case of process objects, the parent's "position" in the config
+ * file as well */
+
+static __inline__ int
+do_find_proc_obj(struct temp_file_label *curr)
+{
+	struct acl_object_label *match;
+	struct acl_subject_label *proc;
+
+	proc = (struct acl_subject_label *) current->acl;
+	match = lookup_acl_obj_label(curr->inode, curr->device, proc->pos);
+
+	if (!match)
+		return GR_NOTFOUND;
+	else
+		return (match->mode & curr->mode);
+}
+
+static __inline__ int
+do_find_proc_subj(struct temp_file_label *curr)
+{
+
+	struct acl_subject_label *retval = NULL;
+
+	retval = lookup_acl_subj_label(curr->inode, curr->device);
+	if (retval) {
+		curr->mode = (unsigned long) retval;
+		return GR_ALLOW;
+	} else {
+		curr->mode = (unsigned long) NULL;
+		return GR_NOTFOUND;
+	}
+}
+
+/* chk_label checks to see if an acl is defined for a file or any of its
+ * parent directories by calling searchfn. */
+
+static __inline__ int
+do_lookup(struct dentry *dentry,
+	   struct temp_file_label *searchval,
+	   int (*searchfn) (struct temp_file_label *))
+{
+	int retval = GR_NOTFOUND;
+
+	searchval->inode = dentry->d_inode->i_ino;
+	searchval->device = dentry->d_inode->i_dev;
+
+	read_lock(&gr_list_lock);
+	retval = (*searchfn) (searchval);
+	read_unlock(&gr_list_lock);
+
+	return retval;
+}
+
+static __inline__ int
+chk_label(struct dentry * dentry, struct vfsmount * mnt,
+	  struct temp_file_label *searchval,
+	  int (*searchfn) (struct temp_file_label *))
+{
+	struct dentry *root;
+	struct vfsmount *rootmnt;
+	int retval = GR_NOTFOUND;
+
+	read_lock(&child_reaper->fs->lock);
+	rootmnt = mntget(child_reaper->fs->rootmnt);
+	root = dget(child_reaper->fs->root);
+	read_unlock(&child_reaper->fs->lock);
+	spin_lock(&dcache_lock);
+
+	for (;;) {
+		if (dentry == root && mnt == rootmnt)
+			break;
+		if (dentry == mnt->mnt_root || IS_ROOT(dentry)) {
+			if (mnt->mnt_parent == mnt)
+				break;
+			
+			if((retval = do_lookup(dentry, searchval, searchfn)) != GR_NOTFOUND) 
+				goto out;
+
+			dentry = mnt->mnt_mountpoint;
+			mnt = mnt->mnt_parent;
+			continue;
+		}
+
+		if((retval = do_lookup(dentry, searchval, searchfn)) != GR_NOTFOUND) 
+			goto out;
+
+		dentry = dentry->d_parent;
+	}
+
+	retval = do_lookup(dentry, searchval, searchfn);
+
+	if(unlikely(retval == GR_NOTFOUND))
+		retval = do_lookup(root, searchval, searchfn);
+
+out:
+	spin_unlock(&dcache_lock);
+	dput(root);
+	mntput(rootmnt);	
+
+	return retval;
+}
+
+static __inline__ int
+chk_inherit(struct dentry * dentry, struct vfsmount * mnt)
+{
+	struct temp_file_label temp;
+	int retval = 0;
+
+	temp.mode = GR_INHERIT;
+
+	read_lock(&current->acl_lock);
+	if (chk_label(dentry, mnt, &temp, &do_find_proc_obj) == temp.mode)
+		retval = 1;
+	read_unlock(&current->acl_lock);
+	return retval;
+}
+
+static __inline__ void
+gr_log_learn(struct acl_subject_label * curracl, struct dentry * dentry,
+		struct vfsmount * mnt, char * pathname, __u16 mode)
+{
+	security_audit(GR_LEARN_AUDIT_MSG, curracl->device, curracl->inode,
+			dentry->d_inode ? (unsigned long)dentry->d_inode->i_dev : 0UL,
+			dentry->d_inode ? dentry->d_inode->i_ino : 0UL,
+			pathname, mode);
+
+	return;
+}
+
+int
+gr_search_file(struct dentry *dentry, __u16 mode, struct vfsmount *mnt)
+{
+	int retval = mode;
+	struct temp_file_label searchval;
+	struct acl_subject_label * curracl;
+
+	if (!(gr_status & GR_READY)) return retval;
+
+	/* if the file doesn't exist, just return.  The kernel will figure
+	   it out sooner or later and return -ENOENT.  For places where
+	   we should check non-existant files, we have gr_check_create */
+
+	if (!dentry->d_inode) return retval;
+
+	searchval.mode = mode;
+
+	read_lock(&current->acl_lock);
+	curracl = (struct acl_subject_label *) current->acl;
+	retval = chk_label(dentry, mnt, &searchval, &do_find_proc_obj);
+	read_unlock(&current->acl_lock);
+
+	if ((curracl->mode & GR_LEARN) && (retval != mode)) {
+		char * buffer;
+		char * pathname;
+
+		retval = mode;
+	
+		if(!(buffer = (char *) __get_free_page(GFP_KERNEL)))
+			goto out;
+
+		pathname = d_real_path(dentry, mnt, buffer, PAGE_SIZE);
+	
+		gr_log_learn(curracl, dentry, mnt, pathname, mode);
+
+		free_page((unsigned long) buffer);
+	}
+
+out:
+	return retval;
+}
+
+int gr_check_root(struct dentry * dentry, struct vfsmount * mnt, const __u16 mode)
+{
+	struct acl_subject_label * curracl;
+	struct temp_file_label searchval;
+	int retval;
+
+	searchval.mode = mode;
+
+	if(!(gr_status & GR_READY)) return 0;
+
+	write_lock(&current->acl_lock);
+	curracl = (struct acl_subject_label *) current->acl;
+	current->acl = &root_label;
+	retval = chk_label(dentry, mnt, &searchval, &do_find_proc_obj);
+	current->acl = curracl;
+	write_unlock(&current->acl_lock);
+
+	return retval;
+}
+
+int
+gr_check_create(struct dentry *new_dentry, struct dentry *parent,
+		struct vfsmount *mnt, __u16 mode)
+{
+	struct name_entry *match;
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *curracl;
+	int retval = GR_NOTFOUND;
+	char *buffer;
+	char *pathname;
+
+	if (!(gr_status & GR_READY))
+		return mode;
+
+	if(!(buffer = (char *) __get_free_page(GFP_KERNEL)))
+		return 0;	/* OOM : can't let anything get through */
+
+	pathname = d_real_path(new_dentry, mnt, buffer, PAGE_SIZE);
+
+	read_lock(&gr_list_lock);
+
+	match = lookup_name_entry(pathname);
+
+	if (!match)
+		goto check_parent;
+
+	if (match->mode & GR_NAME_ACL_OBJECT) {
+		read_lock(&current->acl_lock);
+		curracl = (struct acl_subject_label *) current->acl;
+		if (((matchpo = lookup_acl_obj_label(match->inode,
+						      match->device,
+						      curracl->pos)) != NULL)) {
+			if ((matchpo->mode & mode) != mode) {
+				read_unlock(&current->acl_lock);
+				read_unlock(&gr_list_lock);
+				retval = 0;
+				if(curracl->mode & GR_LEARN) {
+					gr_log_learn(curracl, new_dentry, mnt, pathname, mode);
+					retval = mode;
+				}
+				goto exit;
+			}
+			retval = mode;
+		}
+		read_unlock(&current->acl_lock);
+	}
+
+check_parent:
+	read_unlock(&gr_list_lock);
+	if (retval != GR_NOTFOUND)
+		goto exit;
+
+	read_lock(&current->acl_lock);
+	curracl = (struct acl_subject_label *) current->acl;
+	read_unlock(&current->acl_lock);
+
+	if(curracl->mode & GR_LEARN) {
+		gr_log_learn(curracl, new_dentry, mnt, pathname, mode);
+		retval = mode;
+		goto exit;
+	}
+
+	retval = gr_search_file(parent, mode, mnt);
+
+exit:
+	free_page((unsigned long) buffer);
+	return retval;
+}
+
+int
+gr_check_hidden_task(struct task_struct *task)
+{
+	struct acl_subject_label *acl;
+	int retval = 0;
+
+	if (!(gr_status & GR_READY)) return 0;
+
+	read_lock(&task->acl_lock);
+	acl = (struct acl_subject_label *) task->acl;
+	read_unlock(&task->acl_lock);
+
+	if (!(acl->mode & GR_FIND)) {
+		struct acl_subject_label *curracl;
+		read_lock(&current->acl_lock);
+		curracl = (struct acl_subject_label *) current->acl;
+		read_unlock(&current->acl_lock);
+		if (!(curracl->mode & GR_VIEW)) 
+			retval = 1;
+	}
+
+	return retval;
+}
+
+int
+gr_check_protected_task(struct task_struct *tsk)
+{
+	struct acl_subject_label *acl;
+	int retval = 0;
+
+	if (!(gr_status & GR_READY) || !tsk) return 0;
+
+	read_lock(&tsk->acl_lock);
+	acl = (struct acl_subject_label *) tsk->acl;
+	read_unlock(&tsk->acl_lock);
+
+	if ((acl->mode & GR_PROTECTED)) {
+		struct acl_subject_label *curracl;
+		read_lock(&current->acl_lock);
+		curracl = (struct acl_subject_label *) current->acl;
+		read_unlock(&current->acl_lock);
+		if (!(curracl->mode & GR_KILL))
+			retval = 1;
+	}
+
+	return retval;
+}
+
+__inline__ void gr_copy_label(struct task_struct *tsk)
+{
+	/* We don't need to lock task...because task is being created
+	 * in do_fork() so it can't be modified anywhere else as it has
+	 * yet to be a true process. see kernel/fork.c */
+
+	if(!(gr_status & GR_READY)) return;
+
+	tsk->acl_lock = RW_LOCK_UNLOCKED;
+	tsk->acl_admin = 0;
+
+	read_lock(&current->acl_lock);
+	tsk->acl = current->acl;
+	read_unlock(&current->acl_lock);
+	
+	return;
+}
+
+static int
+do_set_proc_label(struct dentry * dentry, struct vfsmount * mnt, int mode)
+{
+	switch (mode) {
+	case GR_SET_INHERIT:
+		return chk_inherit(dentry, mnt);
+		break;
+	case GR_SET_PROC:
+		{
+			struct temp_file_label searchval;
+			if ((chk_label(dentry, mnt, &searchval,
+				       &do_find_proc_subj)) == GR_ALLOW) {
+				write_lock(&current->acl_lock);
+				current->acl = (void *) searchval.mode;
+				write_unlock(&current->acl_lock);
+			}
+		}
+
+		break;
+	}
+	return 0;
+}
+
+void
+gr_set_proc_label(struct dentry *dentry, struct vfsmount *mnt, const char *filename)
+{
+	struct task_struct *tsk = current;
+
+	tsk->acl_admin = 0;
+
+	if (!(gr_status & GR_READY))
+		return;
+
+	if (!do_set_proc_label(dentry, mnt, GR_SET_INHERIT))
+		(void) do_set_proc_label(dentry, mnt, GR_SET_PROC);
+
+	return;
+}
+
+inline int gr_is_capable(int cap)
+{
+	struct acl_subject_label * curracl;
+
+	if(!(gr_status & GR_READY)) return 1;
+
+	read_lock(&current->acl_lock);
+	curracl = (struct acl_subject_label *) current->acl;
+
+	if(!cap_raised(curracl->cap_lower, cap))
+		goto out_unlock;
+
+	if((curracl->mode & GR_LEARN) && cap_raised(current->cap_effective, cap)) {
+		security_audit(GR_LEARN_AUDIT_MSG, curracl->device,
+			curracl->inode, 0UL, 0UL, "", cap);
+		goto out_unlock;
+	}
+
+	read_unlock(&current->acl_lock);
+
+	if((cap >= 0) && (cap < 29) && cap_raised(current->cap_effective, cap))
+		security_audit(GR_CAP_AUDIT_MSG, captab_log[cap], DEFAULTSECARGS);
+
+	return 0;
+out_unlock:
+	read_unlock(&current->acl_lock);
+	return 1;	
+}
+
+void gr_set_caps(void)
+{
+	struct acl_subject_label * curracl;
+
+	if(!(gr_status & GR_READY)) return;
+
+	write_lock(&current->acl_lock);
+	curracl = (struct acl_subject_label *) current->acl;
+
+	curracl->cap_lower = cap_drop(curracl->cap_lower, 
+					curracl->cap_raise_inherit);
+	curracl->cap_lower = cap_combine(curracl->cap_lower, 
+					curracl->cap_lower_inherit);
+	write_unlock(&current->acl_lock);
+
+	return;
+}
+
+int gr_acl_is_enabled(void)
+{
+	return (gr_status & GR_READY);
+}
+
+static void
+do_handle_delete(const ino_t ino, const kdev_t dev)
+{
+	struct acl_object_label *matchpo;
+	struct acl_subject_label *matchps;
+	unsigned long i;
+
+	for (i = 0; i < acl_subj_set.s_used; i++) {
+		if ((matchpo = lookup_acl_obj_label(ino, dev, i)) != NULL) {
+#ifdef CONFIG_GR_DEBUG
+			security_debug(GR_OBJDEL_DEBUG_MSG,
+					kdevname(dev), ino, i);
+#endif
+			matchpo->mode |= GR_DELETED;
+		}
+	}
+
+	if ((matchps = lookup_acl_subj_label(ino, dev)) != NULL) {
+#ifdef CONFIG_GR_DEBUG
+		security_debug(GR_SUBJDEL_DEBUG_MSG,
+			       kdevname(dev), ino);
+#endif
+		matchps->mode |= GR_DELETED;
+	}
+
+	return;
+}
+
+void
+gr_handle_delete(const ino_t ino, const kdev_t dev)
+{
+	if (!(gr_status & GR_READY)) return;
+
+	read_lock(&gr_list_lock);
+	do_handle_delete(ino, dev);
+	read_unlock(&gr_list_lock);
+
+	return;
+}
+
+static __inline__ void
+move_acl_obj_label(struct acl_object_label *po,
+		   const ino_t newino, const kdev_t newdev)
+{
+	struct acl_object_label insert = {
+		inode:newino,
+		device:newdev,
+		mode:po->mode & ~GR_DELETED,
+		parent_pos:po->parent_pos,
+	};
+
+	po->mode &= ~GR_EXISTS;
+	acl_obj_set.o_used--;
+	insert_acl_obj_label(&insert);
+
+	return;
+}
+
+static __inline__ void
+move_acl_subj_label(struct acl_subject_label *ps,
+		    const ino_t newino, const kdev_t newdev)
+{
+	struct task_struct *p;
+	struct acl_subject_label insert = {
+		inode:newino,
+		device:newdev,
+		mode:ps->mode & ~GR_DELETED,
+		cap_lower:ps->cap_lower,
+		cap_raise_inherit:ps->cap_raise_inherit,
+		cap_lower_inherit:ps->cap_lower_inherit,
+		pos:ps->pos
+	};
+
+	ps->mode &= ~GR_EXISTS;
+	acl_subj_set.s_used--;
+	insert_acl_subj_label(&insert);
+	read_lock(&tasklist_lock);
+	for_each_task(p) {
+		write_lock(&p->acl_lock);
+		if (p->acl == ps)
+			p->acl = lookup_acl_subj_label(newino, newdev);
+		write_unlock(&p->acl_lock);
+	}
+	read_unlock(&tasklist_lock);
+
+	return;
+}
+
+static void
+do_handle_create(const char * pathname, struct name_entry *matchn,
+		 const struct dentry * dentry, const struct vfsmount * mnt)
+{
+	struct acl_subject_label *matchps;
+	struct acl_object_label *matchpo;
+	unsigned long i;
+
+	if ((matchn->mode & GR_NAME_ACL_SUBJECT) &&
+	   ((matchps = lookup_acl_subj_label(matchn->inode,
+					     matchn->device)) != NULL)) {
+#ifdef CONFIG_GR_DEBUG
+		security_debug(GR_SUBJREC_DEBUG_MSG, pathname);
+#endif
+		move_acl_subj_label(matchps, dentry->d_inode->i_ino,
+				    dentry->d_inode->i_dev);
+		goto out;
+	}
+
+	for (i = 0; i < acl_subj_set.s_used; i++) {
+ 		if ((matchpo = lookup_acl_obj_label(matchn->inode, 
+					matchn->device, i)) != NULL) {
+#ifdef CONFIG_GR_DEBUG
+			security_debug(GR_OBJREC_DEBUG_MSG,
+					pathname, i);
+#endif
+			move_acl_obj_label(matchpo, dentry->d_inode->i_ino,
+					dentry->d_inode->i_dev);
+			}
+	}
+
+out:
+	matchn->inode = dentry->d_inode->i_ino;
+	matchn->device = dentry->d_inode->i_dev;
+
+	return;
+}
+
+void
+gr_handle_create(struct dentry * dentry, struct vfsmount * mnt)
+{
+	struct name_entry *matchn;
+	char *pathbuf;
+	char *pathname;
+
+	if (!(gr_status & GR_READY)) return;
+
+	if ((pathbuf = (char *) __get_free_page(GFP_KERNEL)) == NULL)
+		return;
+
+	pathname = d_real_path(dentry, mnt, pathbuf, PAGE_SIZE);
+
+	matchn = lookup_name_entry(pathname);
+
+	if (matchn) {
+		write_lock(&gr_list_lock);
+		do_handle_create(pathname,matchn, dentry, mnt);
+		write_unlock(&gr_list_lock);
+	}
+
+	free_page((unsigned long) pathbuf);
+
+	return;
+}
+
+int
+gr_handle_rename(struct inode * old_dir, struct inode * new_dir,
+		 struct dentry * old_dentry, 
+		 struct dentry * new_dentry,
+		 struct vfsmount * mnt, const __u8 noreplace)
+{
+	struct name_entry *matchn;
+	char *pathbuf;
+	char *pathname;
+	int error = 0;
+
+
+	pathbuf = (char *) __get_free_page(GFP_KERNEL);
+
+	if(!pathbuf) return -ENOMEM;
+
+	lock_kernel();
+	error = vfs_rename(old_dir, old_dentry, new_dir, new_dentry);
+	unlock_kernel();
+
+	if(error)
+		goto out_nolock;
+
+	write_lock(&gr_list_lock);
+
+	if(!noreplace)
+		do_handle_delete(new_dentry->d_inode->i_ino,
+				 new_dentry->d_inode->i_dev);
+	do_handle_delete(old_dentry->d_inode->i_ino,
+			 old_dentry->d_inode->i_dev);
+
+	pathname = d_real_path(old_dentry, mnt, pathbuf, PAGE_SIZE);
+	matchn = lookup_name_entry(pathname);
+	if (matchn)
+		do_handle_create(pathname, matchn, old_dentry, mnt);
+
+	write_unlock(&gr_list_lock);
+out_nolock:
+	free_page((unsigned long) pathbuf);
+	return error;
+}	
+
+/* The following variables are needed for timer manipulation */
+static struct timer_list gr_badpw;
+static int failures = 0;
+static int during_wait = 0;
+
+static void
+gr_timer(unsigned long ignored)
+{
+	failures = 0;
+	during_wait = 0;
+	del_timer(&gr_badpw);
+
+	return;
+}
+
+int
+gr_proc_handler(ctl_table * table, int write, struct file *filp, void *buffer,
+		size_t * lenp)
+{
+	struct gr_arg *arg;
+	struct gr_arg usermode;
+	int error = sizeof (struct gr_arg);
+
+	if (!write) return -EPERM;
+
+	spin_lock(&gr_proc_lock);
+
+	arg = (struct gr_arg *) buffer;
+
+	if (*lenp != sizeof (struct gr_arg)) {
+		security_alert(GR_PROC_ACL_MSG, GR_PROC_ACL_FLD,
+			       *lenp, sizeof (struct gr_arg));
+		error = -EINVAL;
+		goto out;
+	}
+	if (during_wait) {
+		error = -EPERM;
+		goto out;
+	}
+
+	if (copy_from_user(&usermode, arg, sizeof (struct gr_arg))) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	/* ensure pw is null terminated */
+
+	usermode.pw[GR_PW_LEN - 1] = '\0';
+
+	/* Okay. 
+	 * We have our enough of the argument structure..(we have yet
+	 * to copy_from_user the tables themselves) . Copy the tables
+	 * only if we need them, i.e. for loading operations. */
+
+	switch (usermode.mode) {
+	case SHUTDOWN:
+		if ((gr_status & GR_READY) && !(chkpw(&usermode,&pwent))) {
+			gr_status &= ~GR_READY;
+			security_alert(GR_SHUTS_ACL_MSG, GR_SHUTS_ACL_FLD,
+				       DEFAULTSECARGS);
+			grsecurity_disable();
+			memset(&usermode, 0, sizeof(struct gr_arg));
+			memset(&pwent, 0, sizeof(struct admin_pw)); 
+		} else if(gr_status & GR_READY) {
+			security_alert(GR_SHUTF_ACL_MSG, GR_SHUTF_ACL_FLD,
+					DEFAULTSECARGS);
+			error = -EPERM;
+		} else
+			security_alert(GR_SHUTI_ACL_MSG, GR_SHUTI_ACL_FLD,
+					DEFAULTSECARGS);
+		break;
+	case ENABLE:
+		if (gr_disable)
+			security_alert(GR_ENABLEI_ACL_MSG, GR_ENABLEI_ACL_FLD,
+				       GR_VERSION);
+		else if (!(gr_status & GR_READY) && 
+			!grsecurity_init(&usermode))
+			security_alert(GR_ENABLE_ACL_MSG, GR_ENABLE_ACL_FLD,
+					GR_VERSION);
+		else
+			security_alert(GR_ENABLEF_ACL_MSG, GR_ENABLEF_ACL_FLD,
+					GR_VERSION, DEFAULTSECARGS);
+		break;
+	case RELOAD:
+		if (gr_disable || !(gr_status & GR_READY))
+			security_alert(GR_RELOADI_ACL_MSG, GR_RELOADI_ACL_FLD);
+		else if (!(chkpw(&usermode, &pwent))) {
+			gr_status &= ~GR_READY;
+			grsecurity_disable();
+			if(!grsecurity_init(&usermode))
+				security_alert(GR_RELOAD_ACL_MSG, 
+						GR_RELOAD_ACL_FLD, GR_VERSION);
+			else
+				security_alert(GR_RELOADF_ACL_MSG, 
+						GR_RELOADF_ACL_FLD, GR_VERSION,
+						DEFAULTSECARGS);
+		} else {
+			security_alert(GR_RELOADF_ACL_MSG, 
+					GR_RELOADF_ACL_FLD, GR_VERSION,
+					DEFAULTSECARGS);
+			error = -EPERM;
+		}
+		break;
+	case SEGVMOD:
+		if (!(gr_status & GR_READY)) {
+			security_alert(GR_SEGVMODI_ACL_MSG, GR_SEGVMODI_ACL_FLD,
+					DEFAULTSECARGS);
+			break;
+		}
+
+		if (!(chkpw(&usermode, &pwent))) {
+			security_alert(GR_SEGVMODS_ACL_MSG, GR_SEGVMODS_ACL_FLD,
+					DEFAULTSECARGS);
+			if(usermode.segv_device && usermode.segv_inode) {
+				struct acl_subject_label * segvacl; 
+				write_lock(&gr_list_lock);
+				segvacl = lookup_acl_subj_label(usermode.segv_inode, usermode.segv_device);
+				if(segvacl) {
+					segvacl->crashes = 0;
+					segvacl->expires = 0;
+				}
+				write_unlock(&gr_list_lock);
+			} else if (gr_find_uid(usermode.segv_uid) >= 0) {
+				gr_remove_uid(usermode.segv_uid);
+			}
+		} else {
+			security_alert(GR_SEGVMODF_ACL_MSG, GR_SEGVMODF_ACL_FLD,
+					DEFAULTSECARGS);
+			error = -EPERM;
+		}
+		break;
+	case GOD:
+		if (!(gr_status & GR_READY)) {
+			security_alert(GR_ADMINI_ACL_MSG, GR_ADMINI_ACL_FLD,
+					DEFAULTSECARGS);
+			break;
+		}
+		
+		if (!(chkpw(&usermode, &pwent))) {
+			security_alert(GR_ADMINS_ACL_MSG, GR_ADMINS_ACL_FLD,
+				       DEFAULTSECARGS);
+			read_lock(&tasklist_lock);
+			if (current->p_pptr) {
+				write_lock(&current->p_pptr->acl_lock);
+				current->p_pptr->acl = (void *) &god_label;
+				write_unlock(&current->p_pptr->acl_lock);
+				current->p_pptr->acl_admin = 1;
+			}
+			read_unlock(&tasklist_lock);
+		} else {
+			security_alert(GR_ADMINF_ACL_MSG, GR_ADMINF_ACL_FLD,
+					DEFAULTSECARGS);
+			error = -EPERM;
+		}
+
+		break;
+	default:
+		security_alert(GR_INVMODE_ACL_MSG, GR_INVMODE_ACL_FLD,
+			       usermode.mode, DEFAULTSECARGS);
+		break;
+	}
+
+	if (error != -EPERM)
+		goto out;
+
+	failures++;
+
+	if (failures > CONFIG_GR_MAXTRIES) {
+		security_alert(GR_MAXPW_ACL_MSG, GR_MAXPW_ACL_FLD,
+				CONFIG_GR_MAXTRIES);
+		init_timer(&gr_badpw);
+		gr_badpw.data = 0;
+		gr_badpw.function = gr_timer;
+		gr_badpw.expires = jiffies + CONFIG_GR_TIMEOUT * HZ;
+		add_timer(&gr_badpw);
+		during_wait = 1;
+	}
+
+
+out:
+	spin_unlock(&gr_proc_lock);
+	return error;
+}
+
+void gr_set_proc_res(void)
+{
+	struct acl_subject_label * proc;
+	unsigned short i;
+
+	if (!(gr_status & GR_READY)) return;
+
+	read_lock(&tasklist_lock);
+	read_lock(&current->acl_lock);
+	proc = (struct acl_subject_label *) current->acl;
+
+	if(proc->mode & GR_LEARN) {
+		read_unlock(&current->acl_lock);
+		read_unlock(&tasklist_lock);
+		return;
+	}
+
+	for(i = 0; i < RLIM_NLIMITS; i++) {
+		if(!(proc->resmask & (1 << i)))
+			continue;
+
+		current->rlim[i].rlim_cur = proc->res[i].rlim_cur;
+		current->rlim[i].rlim_max = proc->res[i].rlim_max;
+	}
+
+	read_unlock(&current->acl_lock);
+	read_unlock(&tasklist_lock);
+
+	return;
+}
+
+struct file * gr_find_proc_file(struct task_struct * task)
+{
+	struct mm_struct * mm;
+	struct vm_area_struct * vma;
+	struct file * result = NULL;
+
+	task_lock(task);
+	mm = task->mm;
+	if (mm)
+		atomic_inc(&mm->mm_users);
+	task_unlock(task);
+	if (!mm)
+		goto out;
+	down_read(&mm->mmap_sem);
+
+	for(vma = mm->mmap; vma; vma = vma->vm_next) {
+		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
+			result = vma->vm_file;
+			break;
+		}
+	}
+	up_read(&mm->mmap_sem);
+	mmput(mm);
+out:
+	return result;
+}
+
+int gr_set_acls(void) {
+	struct task_struct *task;
+	unsigned short i;
+
+	read_lock(&tasklist_lock);
+	for_each_task(task) {
+		struct acl_subject_label *curr = NULL;
+		struct file * filp;
+
+		if((filp = gr_find_proc_file(task))) {
+			struct temp_file_label searchval;
+			if ((chk_label(filp->f_dentry, filp->f_vfsmnt,
+			     &searchval, &do_find_proc_subj)) == GR_ALLOW) {
+
+				write_lock(&task->acl_lock);
+				task->acl = (void *) searchval.mode;
+				curr = (struct acl_subject_label *) task->acl;
+				write_unlock(&task->acl_lock);
+				
+				if(!(curr->mode & GR_LEARN))
+				for(i = 0; i < RLIM_NLIMITS; i++) {
+					if(!(curr->resmask & (1 << i)))
+						continue;
+
+					task->rlim[i].rlim_cur = curr->res[i].rlim_cur;
+					task->rlim[i].rlim_max = curr->res[i].rlim_max;
+				}
+
+			} else {
+				read_unlock(&tasklist_lock);
+				security_alert(GR_DEFACL_MSG, GR_DEFACL_FLD,
+					task->comm, task->pid);
+				return 1;
+			}
+		} else {
+			// it's a kernel process
+			write_lock(&task->acl_lock);
+			curr = lookup_acl_subj_label(child_reaper->fs->root->d_inode->i_ino,
+					child_reaper->fs->root->d_inode->i_dev);
+			task->acl = curr;
+			write_unlock(&task->acl_lock);
+		}
+	}
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+inline void gr_learn_resource(struct task_struct * task, int res, unsigned long wanted)
+{
+	struct acl_subject_label *acl;
+	unsigned long res_add;	
+
+	if(!(gr_status & GR_READY) || !wanted) return;
+
+	read_lock(&task->acl_lock);
+	acl = (struct acl_subject_label *) task->acl;
+	
+	if(!acl || !(acl->mode & GR_LEARN)) {
+		read_unlock(&task->acl_lock);
+		return;
+	}
+
+	if(!(acl->resmask & (1 << (unsigned short)res))) {
+		read_unlock(&task->acl_lock);
+		return;
+	}
+
+	if((res >= RLIMIT_CPU) && (res <= RLIMIT_LOCKS) &&
+	   (wanted >= acl->res[res].rlim_cur))
+	{
+		read_unlock(&task->acl_lock);
+
+		res_add = wanted;		
+
+		switch(res) {
+		case RLIMIT_CPU: res_add += GR_RLIM_CPU_BUMP; break;
+		case RLIMIT_FSIZE: res_add += GR_RLIM_FSIZE_BUMP; break;
+		case RLIMIT_DATA: res_add += GR_RLIM_DATA_BUMP; break;
+		case RLIMIT_STACK: res_add += GR_RLIM_STACK_BUMP; break;
+		case RLIMIT_CORE: res_add += GR_RLIM_CORE_BUMP; break;
+		case RLIMIT_RSS: res_add += GR_RLIM_RSS_BUMP; break;
+		case RLIMIT_NPROC: res_add += GR_RLIM_NPROC_BUMP; break;
+		case RLIMIT_NOFILE: res_add += GR_RLIM_NOFILE_BUMP; break;
+		case RLIMIT_MEMLOCK: res_add += GR_RLIM_MEMLOCK_BUMP; break;
+		case RLIMIT_AS: res_add += GR_RLIM_AS_BUMP; break;
+		case RLIMIT_LOCKS: res_add += GR_RLIM_LOCKS_BUMP; break;
+		}
+
+		write_lock(&task->acl_lock);
+	
+		acl->res[res].rlim_cur = res_add;
+	
+		if(wanted > acl->res[res].rlim_max)
+			acl->res[res].rlim_max = res_add;
+	
+		write_unlock(&task->acl_lock);
+
+		security_audit(GR_LEARN_AUDIT_MSG, acl->device,
+				acl->inode, acl->res[res].rlim_cur,
+				acl->res[res].rlim_max, "", res);
+	} else {
+		read_unlock(&task->acl_lock);
+	}		
+
+	return;
+}
+
+extern struct proc_dir_entry * proc_sys_root;
+
+int gr_handle_sysctl(struct ctl_table * table, int mode)
+{
+	struct proc_dir_entry * tmp;
+	struct nameidata nd;
+	const char * proc_sys = "/proc/sys";
+	char * path;	
+	unsigned short len = 0, pos = 0, depth = 0, i;
+	int err = 0;
+
+	/* convert the requested sysctl entry into a pathname */
+
+	for(tmp = table->de; tmp != proc_sys_root; tmp = tmp->parent) {
+		len += strlen(tmp->name);
+		len++;
+		depth++;
+	}	
+
+	if((len + depth + strlen(proc_sys) + 1) > PATH_MAX)
+		return 0; // deny
+
+	path = kmalloc(PATH_MAX, GFP_KERNEL);
+
+	if(!path) return 0;
+
+	memset(path, 0, PATH_MAX);
+
+	memcpy(path, proc_sys, strlen(proc_sys));
+
+	pos += strlen(proc_sys);
+
+	for(; depth > 0; depth--) {
+		path[pos] = '/';
+		pos++;
+		for(i = 1, tmp = table->de; tmp != proc_sys_root; tmp = tmp->parent) {
+			if(depth == i) {
+				memcpy(path + pos, tmp->name, strlen(tmp->name));
+				pos += strlen(tmp->name);
+			}
+			i++;
+		}
+	}
+
+	if (path_init(path, LOOKUP_FOLLOW, &nd))
+		err = path_walk(path, &nd);
+
+	if(err) 
+		goto out;
+	
+	err = gr_search_file(nd.dentry, mode, nd.mnt);
+	path_release(&nd);
+
+out:
+	kfree(path);
+	return err;
+}
+
+inline int gr_handle_ptrace(struct task_struct * task)
+{
+	struct file * filp;
+
+	if(!(gr_status & GR_READY)) return 0;
+
+	if((filp = gr_find_proc_file(task)) && 
+	   (permission(filp->f_dentry->d_inode, MAY_WRITE) ||
+	   !gr_search_file(filp->f_dentry, GR_WRITE, filp->f_vfsmnt))) {
+		security_alert(GR_PTRACE_ACL_MSG, GR_PTRACE_ACL_FLD,	
+				task->comm, task->pid, DEFAULTSECARGS);
+		return 1;
+	}
+
+	return 0;
+}
+
+inline int gr_handle_mmap(struct file * filp, unsigned long prot)
+{
+	if(!(gr_status & GR_READY)) return 0;
+
+	if(filp && (prot & PROT_EXEC) &&
+	   gr_check_root(filp->f_dentry, filp->f_vfsmnt, GR_WRITE)) {
+		security_alert(GR_WRITLIB_ACL_MSG, GR_WRITLIB_ACL_FLD,
+				kdevname(filp->f_dentry->d_inode->i_dev),
+				filp->f_dentry->d_inode->i_ino,
+				DEFAULTSECARGS);
+		return 1;
+	}
+
+	return 0;
+}
diff -urN linux/grsecurity/gracl_ip.c linux/grsecurity/gracl_ip.c
--- linux/grsecurity/gracl_ip.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/gracl_ip.c	2002-08-31 14:26:18.000000000 -0400
@@ -0,0 +1,104 @@
+/* 
+ * grsecurity/gracl_ip.c
+ * Copyright Brad Spengler 2002
+ *
+ */
+
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/smp_lock.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+
+int gr_search_socket(int domain, int type, int protocol)
+{
+	struct acl_subject_label * curr;
+
+	if(!gr_acl_is_enabled()) return 1;
+
+	if((domain < 0) || (type < 0) || (protocol < 0) ||
+	   (domain >= NPROTO) || (type >= SOCK_MAX) || (protocol > 255))
+		return 1; // let the kernel handle it
+
+	if(domain != PF_INET)
+		return 1; // we don't regulate anything else
+
+	read_lock(&current->acl_lock);
+	curr = (struct acl_subject_label *) current->acl;
+
+	if(!curr->ips)
+		goto exit_unlock;
+
+	if((curr->ip_type & (1 << type)) &&
+	   (curr->ip_proto[protocol / 32] & (1 << (protocol % 32))))
+		goto exit_unlock;
+
+	if(curr->mode & GR_LEARN)
+		goto exit_unlock;  //  we'll log when they use bind or connect
+
+	read_unlock(&current->acl_lock);
+	return 0;
+exit_unlock:
+	read_unlock(&current->acl_lock);
+	return 1;
+}
+
+int gr_search_connectbind(int mode, struct socket * sock, 
+					struct sockaddr_in * addr)
+{
+	struct acl_subject_label * curr;
+	struct acl_ip_label * ip;
+	unsigned long i;
+	unsigned long ip_addr = 0;
+	__u16 ip_port = 0;
+
+	if(!gr_acl_is_enabled()) return 1;
+
+	read_lock(&current->acl_lock);
+	curr = (struct acl_subject_label *) current->acl;
+
+	if(!curr->ips) return 1;
+
+	if(addr->sin_family != PF_INET) return 1;
+
+	ip_addr = addr->sin_addr.s_addr;
+	ip_port = ntohs(addr->sin_port);
+
+	for(i = 0; i < curr->ip_num; i++) {
+		ip = *(curr->ips + i);
+		if((ip->mode & mode) &&
+		   (ip_port >= ip->low) &&
+		   (ip_port <= ip->high) &&
+		   ((ntohl(ip_addr) & ip->netmask) == (ntohl(ip->addr) & ip->netmask)) &&
+		   (ip->proto[sock->sk->protocol / 32] & (1 << (sock->sk->protocol % 32))) && 
+		   (ip->type & (1 << sock->type)))
+			return 1;
+	}
+
+	if(curr->mode & GR_LEARN) {
+		security_audit(GR_IP_LEARN_MSG, curr->device, curr->inode,
+				NIPQUAD(ip_addr), ip_port, sock->type,
+				sock->sk->protocol, mode);
+		return 1;
+	}
+
+	read_unlock(&current->acl_lock);
+
+	if(mode == GR_BIND)
+		security_alert(GR_BIND_ACL_MSG, GR_BIND_ACL_FLD,
+				NIPQUAD(ip_addr), ip_port, sock->type, 
+				sock->sk->protocol, DEFAULTSECARGS);
+	else if(mode == GR_CONNECT)
+		security_alert(GR_CONNECT_ACL_MSG, GR_CONNECT_ACL_FLD,
+				NIPQUAD(ip_addr), ip_port, sock->type, 
+				sock->sk->protocol, DEFAULTSECARGS);
+		
+	return 0;
+}
diff -urN linux/grsecurity/gracl_segv.c linux/grsecurity/gracl_segv.c
--- linux/grsecurity/gracl_segv.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/gracl_segv.c	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,331 @@
+/* 
+ * grsecurity/gracl_segv.c
+ * Copyright Brad Spengler 2002
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/mman.h>
+#include <net/sock.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/gracl.h>
+
+static struct crash_uid * uid_set;
+static unsigned short uid_used;
+static rwlock_t gr_uid_lock = RW_LOCK_UNLOCKED;
+extern rwlock_t gr_list_lock;
+extern __inline__ struct acl_subject_label * 
+	lookup_acl_subj_label(ino_t inode, kdev_t dev);
+
+int gr_init_uidset(void)
+{
+	uid_set = kmalloc(GR_UIDTABLE_MAX, GFP_KERNEL);
+	uid_used = 0;
+	
+	return uid_set ? 1 : 0;
+}
+
+void gr_free_uidset(void)
+{
+	if(uid_set)
+		kfree(uid_set);
+
+	return;
+}
+
+int gr_find_uid(uid_t uid)
+{
+	struct crash_uid * tmp = uid_set;
+	uid_t buid;
+	int low = 0, high = uid_used, mid;
+
+	while (high > low) {
+		mid = (low + high) >> 1;
+		buid = tmp[mid].uid;
+		if(buid == uid)
+			return mid;
+		if(buid > uid)
+			high = mid - 1;
+		if(buid < uid)
+			low = mid + 1;
+	}
+
+	return -1;
+}
+
+static __inline__ void gr_insertsort(void)
+{
+	unsigned short i, j;
+	struct crash_uid index;
+
+	for(i = 1; i < uid_used; i++) {
+		index = uid_set[i];
+		j = i;
+		while ((j > 0) && uid_set[j-1].uid > index.uid) {
+			uid_set[j] = uid_set[j-1];
+			j--;
+		}
+		uid_set[j] = index;
+	}
+
+	return;
+} 
+
+static __inline__ void gr_insert_uid(uid_t uid, unsigned long expires)
+{
+	int loc;
+
+	if(uid_used == GR_UIDTABLE_MAX)
+		return;
+
+	loc = gr_find_uid(uid);
+
+	if(loc >= 0) {
+		uid_set[loc].expires = expires;
+		return;
+	}
+
+	uid_set[uid_used].uid = uid;
+	uid_set[uid_used].expires = expires;
+	uid_used++;
+	
+	gr_insertsort();
+
+	return;
+}
+
+void gr_remove_uid(unsigned short loc)
+{
+	unsigned short i;
+
+	for(i = loc + 1; i < uid_used; i++)
+		uid_set[i - i] = uid_set[i];
+
+	uid_used--;
+
+	return;
+}
+
+int gr_check_crash_uid(uid_t uid)
+{
+	int loc;
+
+	if (!gr_acl_is_enabled()) return 0;
+
+	read_lock(&gr_uid_lock);
+	loc = gr_find_uid(uid);
+	read_unlock(&gr_uid_lock);
+
+	if(loc < 0) return 0;
+
+	write_lock(&gr_uid_lock);
+	if(uid_set[loc].expires < jiffies)
+		gr_remove_uid(loc);
+	else {
+		write_unlock(&gr_uid_lock);
+		return 1;
+	}
+
+	write_unlock(&gr_uid_lock);
+	return 0;
+}
+
+static __inline__ int proc_is_setxid(struct task_struct * task)
+{
+	if(task->uid != task->euid || task->uid != task->suid ||
+	   task->uid != task->fsuid)
+		return 1;
+	if(task->gid != task->egid || task->gid != task->sgid ||
+	   task->gid != task->fsgid)
+		return 1;
+
+	return 0;
+}
+static __inline__ int gr_fake_force_sig(int sig, struct task_struct * t)
+{
+	unsigned long int flags;
+
+	spin_lock_irqsave(&t->sigmask_lock, flags);
+	if (t->sig == NULL) {
+		spin_unlock_irqrestore(&t->sigmask_lock, flags);
+		return -ESRCH;
+	}
+
+	if (t->sig->action[sig-1].sa.sa_handler == SIG_IGN)
+		t->sig->action[sig-1].sa.sa_handler = SIG_DFL;
+	sigdelset(&t->blocked, sig);
+	recalc_sigpending(t);
+	spin_unlock_irqrestore(&t->sigmask_lock, flags);
+
+	return send_sig_info(sig, (void*)1L, t);
+}
+	
+static __inline__ unsigned long get_crash_ip(struct task_struct * task)
+{
+	int i;
+	struct inode * inode;
+	struct sock * sk;
+	unsigned long addr = 0;
+	int socks;
+
+	for(i = 0, socks = 0; i < task->files->max_fds; i++) {
+		if(!task->files->fd[i] ||
+		   !task->files->fd[i]->f_dentry ||
+		   !task->files->fd[i]->f_dentry->d_inode) continue;
+
+		inode = task->files->fd[i]->f_dentry->d_inode;
+
+		if(!S_ISSOCK(inode->i_mode)) continue;
+		if(!inode->u.socket_i.sk) continue;
+
+		sk = inode->u.socket_i.sk;
+
+		if(sk->family != AF_INET || sk->state != TCP_ESTABLISHED ||
+		   sk->protocol != IPPROTO_TCP || sk->type != SOCK_STREAM) 
+			continue;
+
+		addr = sk->daddr;
+		socks++;
+	}
+
+	if(socks == 1) {
+		/* Ok, we know it's a network daemon that forks on each
+		   connection, or there only happens to be one connected
+		   user (lucky us).  Return their address. */
+		return addr;
+	}
+	
+	return 0;
+}
+
+inline void gr_handle_crash(struct task_struct * task, int sig)
+{
+	struct acl_subject_label * curr;
+	struct acl_subject_label * curr2;
+	struct task_struct * tsk;
+	unsigned long addr;
+
+	if(sig != SIGSEGV && sig != SIGKILL && sig != SIGBUS &&
+	   sig != SIGILL) return;
+
+	if(!gr_acl_is_enabled()) return;
+
+
+	write_lock(&task->acl_lock);
+	curr = (struct acl_subject_label *) task->acl;
+
+	if(!(curr->resmask & (1 << GR_CRASH_RES))) {
+		write_unlock(&task->acl_lock);
+		return;
+	}
+
+	if(curr->expires < jiffies) {
+		curr->expires = 0;
+		curr->crashes = 0;
+	}
+
+	curr->crashes++;
+	if(!curr->expires)
+		curr->expires = jiffies + (curr->res[GR_CRASH_RES].rlim_max * HZ);
+
+	if((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) && 
+	   (curr->expires > jiffies)) {
+		read_lock(&tasklist_lock);
+ 		if(task->uid && proc_is_setxid(task)) {
+			security_alert(GR_SEGVSTART_ACL_MSG, GR_SEGVSTART_ACL_FLD,
+				task->comm, task->pid, task->uid, task->euid,
+				task->p_pptr->comm, task->p_pptr->pid, 
+				task->p_pptr->uid, task->p_pptr->euid,
+				task->uid, curr->res[GR_CRASH_RES].rlim_max);
+			write_lock(&gr_uid_lock);
+			gr_insert_uid(task->uid, curr->expires);
+			write_unlock(&gr_uid_lock);
+			curr->expires = 0;
+			curr->crashes = 0;
+			write_unlock(&task->acl_lock);
+			for_each_task(tsk) {
+				if(tsk != task && tsk->uid == task->uid)
+					gr_fake_force_sig(SIGKILL, tsk);
+			}
+		} else {
+			addr = get_crash_ip(task);
+			if (addr) {
+				security_alert(GR_SEGVIP_ACL_MSG, GR_SEGVIP_ACL_FLD, 
+					NIPQUAD(addr), task->comm, task->pid,
+					task->uid, task->euid, 
+					task->p_pptr->comm, task->p_pptr->pid, 
+					task->p_pptr->uid, task->p_pptr->euid,
+					kdevname(curr->device), curr->inode,
+					curr->res[GR_CRASH_RES].rlim_max);
+			} else {
+				security_alert(GR_SEGVNOSUID_ACL_MSG, GR_SEGVNOSUID_ACL_FLD, 
+					task->comm, task->pid, task->uid, task->euid,
+					task->p_pptr->comm, task->p_pptr->pid, 
+					task->p_pptr->uid, task->p_pptr->euid,
+					kdevname(curr->device), curr->inode,
+					curr->res[GR_CRASH_RES].rlim_max);
+			}
+			for_each_task(tsk) {
+				read_lock(&tsk->acl_lock);
+				curr2 = (struct acl_subject_label *) tsk->acl;
+				read_unlock(&tsk->acl_lock);
+				if(tsk != task && curr2->device == curr->device &&
+				   curr2->inode == curr->inode)
+					gr_fake_force_sig(SIGKILL, tsk);
+			}
+			write_unlock(&task->acl_lock);
+		}				
+		read_unlock(&tasklist_lock);
+	} else {
+		write_unlock(&task->acl_lock);
+	}
+
+	return;
+}
+
+int gr_check_crash_exec(struct file * filp)
+{
+	struct acl_subject_label * curr;
+	struct inode * inode;
+
+	if(!gr_acl_is_enabled()) return 0;
+
+	if(!filp->f_dentry || !filp->f_dentry->d_inode) return 0;
+
+	inode = filp->f_dentry->d_inode;
+
+	write_lock(&gr_list_lock);
+	curr = lookup_acl_subj_label(inode->i_ino, inode->i_dev);
+
+	if(!curr) goto out_success;
+
+	if(!(curr->resmask & (1 << GR_CRASH_RES))) goto out_success;		
+
+	if(!curr->crashes && !curr->expires) goto out_success;
+
+	if((curr->crashes >= curr->res[GR_CRASH_RES].rlim_cur) && 
+	   (curr->expires > jiffies))
+		goto out_failure;
+	else if(curr->expires < jiffies) {
+		curr->crashes = 0;
+		curr->expires = 0;
+	}
+
+out_success:
+	write_unlock(&gr_list_lock);
+	return 0;
+out_failure:
+	write_unlock(&gr_list_lock);
+	return 1;
+}
+
diff -urN linux/grsecurity/grsecurity.c linux/grsecurity/grsecurity.c
--- linux/grsecurity/grsecurity.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/grsecurity.c	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,233 @@
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/grsecurity.h>
+
+/*
+   initialize variables  These initial states are used in two situations:
+
+   1) certain features of grsecurity are disabled (if they are enabled, 
+      then they are handled below)
+   2) the sysctl feature is enabled, in which case everything is disabled
+      at bootup and users must echo values to /proc to set the features
+*/
+
+int grsec_enable_link = 0;
+int grsec_enable_dmesg = 0;
+int grsec_enable_fifo = 0;
+int grsec_enable_execve = 0;
+int grsec_enable_execlog = 0;
+int grsec_enable_signal = 0;
+int grsec_enable_forkfail = 0;
+int grsec_enable_time = 0;
+int grsec_enable_group = 0;
+int grsec_audit_gid = 0;
+int grsec_enable_chdir = 0;
+int grsec_enable_audit_ipc = 0;
+int grsec_enable_mount = 0;
+int grsec_enable_chroot_findtask = 0;
+int grsec_enable_chroot_fchdir = 0;
+int grsec_enable_chroot_mount = 0;
+int grsec_enable_chroot_double = 0;
+int grsec_enable_chroot_pivot = 0;
+int grsec_enable_chroot_chdir = 0;
+int grsec_enable_chroot_chmod = 0;
+int grsec_enable_chroot_mknod = 0;
+int grsec_enable_chroot_nice = 0;
+int grsec_enable_chroot_execlog = 0;
+int grsec_enable_chroot_caps = 0;
+int grsec_enable_tpe = 0;
+int grsec_tpe_gid = 0;
+int grsec_enable_tpe_all = 0;
+int grsec_enable_randpid = 0;
+int grsec_enable_randid = 0;
+int grsec_enable_randsrc = 0;
+int grsec_enable_randrpc = 0;
+int grsec_enable_randping = 0;
+int grsec_enable_socket_all = 0;
+int grsec_socket_all_gid = 0;
+int grsec_enable_socket_client = 0;
+int grsec_socket_client_gid = 0;
+int grsec_enable_socket_server = 0;
+int grsec_socket_server_gid = 0;
+int grsec_lock = 0;
+
+/* 
+   handle the variables if parts of grsecurity are configured without sysctl 
+   we do this as a function since it runs on bootup
+*/
+
+void grsecurity_init(void)
+{
+#ifndef CONFIG_GRKERNSEC_SYSCTL
+grsec_lock = 1;
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+grsec_enable_group = 1;
+grsec_audit_gid = CONFIG_GRKERNSEC_AUDIT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+grsec_enable_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+grsec_enable_audit_ipc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+grsec_enable_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_LINK
+grsec_enable_link = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+grsec_enable_dmesg = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+grsec_enable_fifo = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+grsec_enable_execve = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+grsec_enable_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+grsec_enable_signal = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+grsec_enable_forkfail = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+grsec_enable_time = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+grsec_enable_chroot_findtask = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+grsec_enable_chroot_fchdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+grsec_enable_chroot_mount = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+grsec_enable_chroot_double = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+grsec_enable_chroot_pivot = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+grsec_enable_chroot_chdir = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+grsec_enable_chroot_chmod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+grsec_enable_chroot_mknod = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+grsec_enable_chroot_nice = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+grsec_enable_chroot_execlog = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+grsec_enable_chroot_caps = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+grsec_enable_tpe = 1;
+grsec_tpe_gid= CONFIG_GRKERNSEC_TPE_GID;
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+grsec_enable_tpe_all = 1;
+#endif
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+grsec_enable_randpid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDID
+grsec_enable_randid = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+grsec_enable_randsrc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDRPC
+grsec_enable_randrpc = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPING
+grsec_enable_randping = 1;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+grsec_enable_socket_all = 1;
+grsec_socket_all_gid= CONFIG_GRKERNSEC_SOCKET_ALL_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+grsec_enable_socket_client = 1;
+grsec_socket_client_gid= CONFIG_GRKERNSEC_SOCKET_CLIENT_GID;
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+grsec_enable_socket_server = 1;
+grsec_socket_server_gid= CONFIG_GRKERNSEC_SOCKET_SERVER_GID;
+#endif
+#endif
+
+return;
+}
+
+void gr_handle_exec_args(struct linux_binprm * bprm, char ** argv)
+{
+	char grarg[64];
+	__u8 execlen = 0;
+	unsigned int i;
+
+	for(i = 0; i < bprm->argc && execlen < 63; i++) {
+		strncat(grarg, argv[i], 63 - execlen);  // null terminates
+		execlen = strlen(grarg);
+		strcat(grarg, " ");
+		execlen++;	
+	}
+
+	security_audit(GR_EXEC_AUDIT_MSG, 
+			kdevname(bprm->file->f_dentry->d_inode->i_dev),
+			bprm->file->f_dentry->d_inode->i_ino, grarg, 
+			DEFAULTSECARGS);
+	return;
+}
+
+int gr_tpe_allow(struct file * file)
+{
+	struct inode * inode = file->f_dentry->d_parent->d_inode;
+
+	if(current->uid && grsec_enable_tpe && in_group_p(grsec_tpe_gid) && 
+	   (inode->i_uid || (!inode->i_uid && ((inode->i_mode & S_IWGRP) ||
+	   (inode->i_mode & S_IWOTH)))))
+		return 0;
+
+	return 1;
+}
+
+int gr_tpe_all_allow(struct file * file)
+{
+	struct inode * inode = file->f_dentry->d_parent->d_inode;
+
+	if(current->uid && grsec_enable_tpe && grsec_enable_tpe_all && 
+	   ((inode->i_uid && (inode->i_uid != current->uid)) ||
+	   (inode->i_mode & S_IWGRP) || (inode->i_mode & S_IWOTH)))
+		return 0;
+
+	return 1;
+}
+
+int gr_pid_is_chrooted(struct task_struct *p)
+{
+	if(!grsec_enable_chroot_findtask) return 0;
+
+	if(p && p->fs && p->fs->root && p->fs->root->d_inode &&
+	   child_reaper && child_reaper->fs && child_reaper->fs->root &&
+	   child_reaper->fs->root->d_inode && current && current->fs &&
+	   current->fs->root && current->fs->root->d_inode) {
+		if(proc_is_chrooted(current) && !have_same_root(current, p))
+				return 1;
+	}
+
+	return 0;
+}
+
diff -urN linux/grsecurity/grsum.c linux/grsecurity/grsum.c
--- linux/grsecurity/grsum.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/grsum.c	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,227 @@
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/gracl.h>
+
+/*
+Modified slightly for use in gracl by Michael Dalton <michael@grsecurity.net>
+Modified for kerneli by Andrew McDonald <andrew@mcdonald.org.uk>
+from:
+
+SHA-1 in C
+By Steve Reid <steve@edmweb.com>
+100% Public Domain
+Available from:
+ftp://ftp.zedz.net/pub/crypto/crypto/HASH/sha/sha1.c
+
+Test Vectors (from FIPS PUB 180-1)
+"abc"
+  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
+"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
+  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
+A million repetitions of "a"
+  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
+*/
+
+void
+gr_SHA1Transform(unsigned long state[5], unsigned char buffer[64])
+{
+	unsigned long a, b, c, d, e;
+	typedef union {
+		unsigned char c[64];
+		unsigned long l[16];
+	} CHAR64LONG16;
+	CHAR64LONG16 *block;
+	static unsigned char workspace[64];
+	block = (CHAR64LONG16 *) workspace;
+	memcpy(block, buffer, 64);
+	/* Copy context->state[] to working vars */
+	a = state[0];
+	b = state[1];
+	c = state[2];
+	d = state[3];
+	e = state[4];
+	/* 4 rounds of 20 operations each. Loop unrolled. */
+	R0(a, b, c, d, e, 0);
+	R0(e, a, b, c, d, 1);
+	R0(d, e, a, b, c, 2);
+	R0(c, d, e, a, b, 3);
+	R0(b, c, d, e, a, 4);
+	R0(a, b, c, d, e, 5);
+	R0(e, a, b, c, d, 6);
+	R0(d, e, a, b, c, 7);
+	R0(c, d, e, a, b, 8);
+	R0(b, c, d, e, a, 9);
+	R0(a, b, c, d, e, 10);
+	R0(e, a, b, c, d, 11);
+	R0(d, e, a, b, c, 12);
+	R0(c, d, e, a, b, 13);
+	R0(b, c, d, e, a, 14);
+	R0(a, b, c, d, e, 15);
+	R1(e, a, b, c, d, 16);
+	R1(d, e, a, b, c, 17);
+	R1(c, d, e, a, b, 18);
+	R1(b, c, d, e, a, 19);
+	R2(a, b, c, d, e, 20);
+	R2(e, a, b, c, d, 21);
+	R2(d, e, a, b, c, 22);
+	R2(c, d, e, a, b, 23);
+	R2(b, c, d, e, a, 24);
+	R2(a, b, c, d, e, 25);
+	R2(e, a, b, c, d, 26);
+	R2(d, e, a, b, c, 27);
+	R2(c, d, e, a, b, 28);
+	R2(b, c, d, e, a, 29);
+	R2(a, b, c, d, e, 30);
+	R2(e, a, b, c, d, 31);
+	R2(d, e, a, b, c, 32);
+	R2(c, d, e, a, b, 33);
+	R2(b, c, d, e, a, 34);
+	R2(a, b, c, d, e, 35);
+	R2(e, a, b, c, d, 36);
+	R2(d, e, a, b, c, 37);
+	R2(c, d, e, a, b, 38);
+	R2(b, c, d, e, a, 39);
+	R3(a, b, c, d, e, 40);
+	R3(e, a, b, c, d, 41);
+	R3(d, e, a, b, c, 42);
+	R3(c, d, e, a, b, 43);
+	R3(b, c, d, e, a, 44);
+	R3(a, b, c, d, e, 45);
+	R3(e, a, b, c, d, 46);
+	R3(d, e, a, b, c, 47);
+	R3(c, d, e, a, b, 48);
+	R3(b, c, d, e, a, 49);
+	R3(a, b, c, d, e, 50);
+	R3(e, a, b, c, d, 51);
+	R3(d, e, a, b, c, 52);
+	R3(c, d, e, a, b, 53);
+	R3(b, c, d, e, a, 54);
+	R3(a, b, c, d, e, 55);
+	R3(e, a, b, c, d, 56);
+	R3(d, e, a, b, c, 57);
+	R3(c, d, e, a, b, 58);
+	R3(b, c, d, e, a, 59);
+	R4(a, b, c, d, e, 60);
+	R4(e, a, b, c, d, 61);
+	R4(d, e, a, b, c, 62);
+	R4(c, d, e, a, b, 63);
+	R4(b, c, d, e, a, 64);
+	R4(a, b, c, d, e, 65);
+	R4(e, a, b, c, d, 66);
+	R4(d, e, a, b, c, 67);
+	R4(c, d, e, a, b, 68);
+	R4(b, c, d, e, a, 69);
+	R4(a, b, c, d, e, 70);
+	R4(e, a, b, c, d, 71);
+	R4(d, e, a, b, c, 72);
+	R4(c, d, e, a, b, 73);
+	R4(b, c, d, e, a, 74);
+	R4(a, b, c, d, e, 75);
+	R4(e, a, b, c, d, 76);
+	R4(d, e, a, b, c, 77);
+	R4(c, d, e, a, b, 78);
+	R4(b, c, d, e, a, 79);
+	/* Add the working vars back into context.state[] */
+	state[0] += a;
+	state[1] += b;
+	state[2] += c;
+	state[3] += d;
+	state[4] += e;
+	/* Wipe variables */
+	a = b = c = d = e = 0;
+}
+
+/* SHA1Init - Initialize new context */
+
+void
+gr_SHA1Init(struct gr_SHA1_CTX *context)
+{
+	/* SHA1 initialization constants */
+	context->state[0] = 0x67452301;
+	context->state[1] = 0xEFCDAB89;
+	context->state[2] = 0x98BADCFE;
+	context->state[3] = 0x10325476;
+	context->state[4] = 0xC3D2E1F0;
+	context->count[0] = context->count[1] = 0;
+}
+
+/* Run your data through this. */
+
+void
+gr_SHA1Update(struct gr_SHA1_CTX *context, unsigned char *data,
+	      unsigned int len)
+{
+	unsigned int i, j;
+
+	j = (context->count[0] >> 3) & 63;
+	if ((context->count[0] += len << 3) < (len << 3))
+		context->count[1]++;
+	context->count[1] += (len >> 29);
+	if ((j + len) > 63) {
+		memcpy(&context->buffer[j], data, (i = 64 - j));
+		gr_SHA1Transform(context->state, context->buffer);
+		for (; i + 63 < len; i += 64) {
+			gr_SHA1Transform(context->state, &data[i]);
+		}
+		j = 0;
+	} else
+		i = 0;
+	memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+/* Add padding and return the message digest. */
+
+void
+gr_SHA1Final(unsigned char digest[20], struct gr_SHA1_CTX *context)
+{
+	unsigned long i, j;
+	unsigned char finalcount[8];
+
+	for (i = 0; i < 8; i++) {
+		finalcount[i] =
+		    (unsigned char) ((context->count[(i >= 4 ? 0 : 1)]
+				      >> ((3 - (i & 3)) * 8)) & 255);
+		/* Endian independent */
+	}
+	gr_SHA1Update(context, (unsigned char *) "\200", 1);
+	while ((context->count[0] & 504) != 448) {
+		gr_SHA1Update(context, (unsigned char *) "\0", 1);
+	}
+	gr_SHA1Update(context, finalcount, 8);	/* Should cause a SHA1Transform() */
+	for (i = 0; i < 20; i++) {
+		digest[i] = (unsigned char)
+		    ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
+	}
+	/* Wipe variables */
+	i = j = 0;
+	memset(context->buffer, 0, 64);
+	memset(context->state, 0, 20);
+	memset(context->count, 0, 8);
+	memset(&finalcount, 0, 8);
+	gr_SHA1Transform(context->state, context->buffer);
+}
+
+int
+chkpw(struct gr_arg *entry, struct admin_pw * pwent)
+{
+	struct gr_SHA1_CTX context;
+	unsigned char temp_sum[GR_SHA_LEN];
+	int retval = 0;	
+	int dummy = 0;
+	unsigned int i;
+
+	gr_SHA1Init(&context);
+	gr_SHA1Update(&context, pwent->salt, GR_SALT_LEN);
+	gr_SHA1Update(&context, entry->pw, strlen(entry->pw));
+	gr_SHA1Final(temp_sum, &context);
+
+	memset(entry->pw, 0, GR_PW_LEN);
+
+	for(i = 0; i < GR_SHA_LEN; i++)
+		if(pwent->sum[i] != temp_sum[i])
+			retval = 1;
+		else
+			dummy = 1; // waste a cycle
+	return retval;
+}
diff -urN linux/grsecurity/ip_id.c linux/grsecurity/ip_id.c
--- linux/grsecurity/ip_id.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/grsecurity/ip_id.c	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,144 @@
+/*
+ * This code is based on OpenBSD's ip_id.c, by Niels Provos.
+ * Ported to Linux 2.2 by Salvatore Sanfilippo.
+ * Ported to Linux 2.4 by Brad Spengler.
+ *
+ * 26-10-1999: Ported from OpenBSD's ip_id.c version 1.2
+ * (previous versions seems to be predictable
+ * after David Wagner's auditing)
+ * Salvatore Sanfilippo <antirez@invece.org>
+ *
+ */
+
+/*
+ * Copyright 1998 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ * Theo de Raadt <deraadt@openbsd.org> came up with the idea of using
+ * such a mathematical system to generate more random (yet non-repeating)
+ * ids to solve the resolver/named problem.  But Niels designed the
+ * actual system based on the constraints.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    This product includes software developed by Niels Provos.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
+
+#define RU_OUT 180
+#define RU_MAX 30000
+#define RU_GEN 2
+#define RU_N 32749
+#define RU_AGEN 7
+#define RU_M 31104
+#define PFAC_N 3
+const static __u16 pfacts[PFAC_N] = { 2,3,2729 };
+
+static __u16 ru_x;
+static __u16 ru_seed, ru_seed2;
+static __u16 ru_a, ru_b;
+static __u16 ru_g;
+static __u16 ru_counter = 0;
+static __u16 ru_msb = 0;
+static __u32 ru_reseed;
+static __u32 tmp;
+
+static __u16 pmod(u_int16_t, u_int16_t, u_int16_t);
+static void ip_initid (void);
+__u16 ip_randomip (void);
+
+static __u16 pmod(__u16 gen, __u16 exp, __u16 mod) {
+	__u16 s, t, u;
+
+	s = 1;
+	t = gen;
+	u = exp;
+
+	while(u) {
+		if (u & 1)
+			s = (s*t) % mod;
+		u >>=1;
+		t = (t*t) % mod;
+	}
+	return(s);
+}
+
+static void ip_initid (void) { 	
+	__u16 j, i;
+	int noprime = 1;
+
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	ru_x = (tmp & 0xFFFF) % RU_M;
+	ru_seed = (tmp >> 16) & 0x7FFF;
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	ru_seed2 = tmp & 0x7FFF;
+	
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	
+	ru_b = (tmp & 0xfffe) | 1;
+	ru_a = pmod(RU_AGEN, (tmp >> 16) & 0xfffe, RU_M);
+	while (ru_b % 3 == 0)
+		ru_b += 2;
+
+	get_random_bytes((void *) &tmp, sizeof(tmp));
+	j = tmp % RU_N;
+	tmp = tmp >> 16;
+	
+	while(noprime) {
+		for (i=0; i<PFAC_N; i++)
+			if(j%pfacts[i] == 0)
+				break;
+		
+		if (i>=PFAC_N)
+			noprime = 0;
+		else
+			j = (j+1) % RU_N;
+	}
+
+	ru_g = pmod(RU_GEN,j,RU_N);
+	ru_counter = 0;
+	ru_reseed = jiffies + (RU_OUT * HZ);
+	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000;
+}
+
+__u16 ip_randomid (void) {
+	int i, n;
+	
+	if (ru_counter >= RU_MAX || jiffies > ru_reseed)
+		ip_initid();
+
+	if (!tmp)
+		get_random_bytes((void *) &tmp, sizeof(tmp));
+
+	n = tmp & 0x3; tmp = tmp >> 2;
+	if (ru_counter + n >= RU_MAX)
+		ip_initid();
+	for (i=0; i <= n; i++)
+		ru_x = (ru_a*ru_x + ru_b) % RU_M;
+	ru_counter += i;
+	
+	return (ru_seed ^ pmod(ru_g,ru_seed2 ^ ru_x, RU_N)) | ru_msb;
+}
diff -urN linux/include/asm-i386/a.out.h linux/include/asm-i386/a.out.h
--- linux/include/asm-i386/a.out.h	1995-06-16 14:33:06.000000000 -0400
+++ linux/include/asm-i386/a.out.h	2002-08-31 14:12:05.000000000 -0400
@@ -19,7 +19,19 @@
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define __STACK_TOP ((current->flags & PF_PAX_SEGMEXEC)?TASK_SIZE/2:TASK_SIZE)
+#else
+#define __STACK_TOP	TASK_SIZE
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+#define __DELTA_STACK (current->mm->delta_stack)
+#else
+#define __DELTA_STACK 0UL
+#endif
+
+#define STACK_TOP	(__STACK_TOP - __DELTA_STACK)
 
 #endif
 
diff -urN linux/include/asm-i386/elf.h linux/include/asm-i386/elf.h
--- linux/include/asm-i386/elf.h	2001-11-22 14:48:29.000000000 -0500
+++ linux/include/asm-i386/elf.h	2002-08-31 14:12:55.000000000 -0400
@@ -55,7 +55,11 @@
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE		((current->flags & PF_PAX_SEGMEXEC)?TASK_SIZE/3:TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+#endif
 
 /* Wow, the "main" arch needs arch dependent functions too.. :) */
 
diff -urN linux/include/asm-i386/mman.h linux/include/asm-i386/mman.h
--- linux/include/asm-i386/mman.h	2000-03-14 20:45:20.000000000 -0500
+++ linux/include/asm-i386/mman.h	2002-08-31 11:24:08.000000000 -0400
@@ -18,6 +18,8 @@
 #define MAP_LOCKED	0x2000		/* pages are locked */
 #define MAP_NORESERVE	0x4000		/* don't check for reservations */
 
+#define MAP_MIRROR	0x8000
+
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
diff -urN linux/include/asm-i386/pgtable.h linux/include/asm-i386/pgtable.h
--- linux/include/asm-i386/pgtable.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/asm-i386/pgtable.h	2002-08-31 14:12:05.000000000 -0400
@@ -197,6 +197,16 @@
 #define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+#define PAGE_SHARED_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+#define PAGE_COPY_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#define PAGE_READONLY_NOEXEC  __pgprot(_PAGE_PRESENT | _PAGE_ACCESSED) 
+#else
+#define PAGE_SHARED_NOEXEC    PAGE_SHARED
+#define PAGE_COPY_NOEXEC      PAGE_COPY
+#define PAGE_READONLY_NOEXEC  PAGE_READONLY
+#endif
+
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define __PAGE_KERNEL_NOCACHE \
@@ -229,18 +239,18 @@
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
+#define __P001  PAGE_READONLY_NOEXEC
+#define __P010  PAGE_COPY_NOEXEC
+#define __P011  PAGE_COPY_NOEXEC
 #define __P100	PAGE_READONLY
 #define __P101	PAGE_READONLY
 #define __P110	PAGE_COPY
 #define __P111	PAGE_COPY
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
+#define __S001  PAGE_READONLY_NOEXEC
+#define __S010  PAGE_SHARED_NOEXEC
+#define __S011  PAGE_SHARED_NOEXEC
 #define __S100	PAGE_READONLY
 #define __S101	PAGE_READONLY
 #define __S110	PAGE_SHARED
diff -urN linux/include/asm-i386/processor.h linux/include/asm-i386/processor.h
--- linux/include/asm-i386/processor.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/asm-i386/processor.h	2002-08-31 14:12:05.000000000 -0400
@@ -274,7 +274,12 @@
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define TASK_UNMAPPED_BASE	((current->flags & PF_PAX_SEGMEXEC)?TASK_SIZE/6:TASK_SIZE/3)
+#else
 #define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#endif
 
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
diff -urN linux/include/asm-i386/segment.h linux/include/asm-i386/segment.h
--- linux/include/asm-i386/segment.h	1997-12-01 13:34:12.000000000 -0500
+++ linux/include/asm-i386/segment.h	2002-08-31 14:12:05.000000000 -0400
@@ -1,10 +1,17 @@
 #ifndef _ASM_SEGMENT_H
 #define _ASM_SEGMENT_H
 
+#include <linux/config.h>
+
 #define __KERNEL_CS	0x10
 #define __KERNEL_DS	0x18
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define __USER_CS	((current->flags & PF_PAX_SEGMEXEC)?0x33:0x23)
+#define __USER_DS	((current->flags & PF_PAX_SEGMEXEC)?0x3B:0x2B)
+#else
 #define __USER_CS	0x23
 #define __USER_DS	0x2B
+#endif
 
 #endif
diff -urN linux/include/linux/a.out.h linux/include/linux/a.out.h
--- linux/include/linux/a.out.h	2001-11-22 14:46:18.000000000 -0500
+++ linux/include/linux/a.out.h	2002-08-31 14:12:05.000000000 -0400
@@ -37,6 +37,13 @@
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC 1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP 2	/* Emulate trampolines */
+#define F_PAX_MPROTECT 4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP 8	/* Randomize mmap() base */   
+#define F_PAX_SEGMEXEC 32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -urN linux/include/linux/binfmts.h linux/include/linux/binfmts.h
--- linux/include/linux/binfmts.h	2001-11-22 14:46:19.000000000 -0500
+++ linux/include/linux/binfmts.h	2002-08-31 14:12:05.000000000 -0400
@@ -1,6 +1,7 @@
 #ifndef _LINUX_BINFMTS_H
 #define _LINUX_BINFMTS_H
 
+#include <linux/config.h>
 #include <linux/ptrace.h>
 #include <linux/capability.h>
 
diff -urN linux/include/linux/elf.h linux/include/linux/elf.h
--- linux/include/linux/elf.h	2001-11-22 14:48:29.000000000 -0500
+++ linux/include/linux/elf.h	2002-08-31 14:12:55.000000000 -0400
@@ -255,6 +255,12 @@
 #define R_MIPS_LOVENDOR		100
 #define R_MIPS_HIVENDOR		127
 
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC               1       /* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP               2       /* Emulate trampolines */
+#define EF_PAX_MPROTECT               4       /* Restrict mprotect() */
+#define EF_PAX_RANDMMAP               8       /* Randomize mmap() base */ 
+#define EF_PAX_SEGMEXEC		      32      /* Segmentation based non-executable pages */
 
 /*
  * Sparc ELF relocation types
diff -urN linux/include/linux/fs.h linux/include/linux/fs.h
--- linux/include/linux/fs.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/linux/fs.h	2002-08-31 14:12:05.000000000 -0400
@@ -1060,7 +1060,7 @@
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, struct vfsmount *);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
diff -urN linux/include/linux/gracl.h linux/include/linux/gracl.h
--- linux/include/linux/gracl.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/gracl.h	2002-08-31 14:13:33.000000000 -0400
@@ -0,0 +1,249 @@
+#ifndef GR_ACL_H
+#define GR_ACL_H
+#endif
+#include <linux/grsecurity.h>
+#include <linux/grdefs.h>
+#include <asm/resource.h>
+#include <linux/resource.h>
+
+/* * * * * * * * * * * * * * * * * * * * *
+ * GrSecurity ACL System
+ * Main header file
+ * Purpose: define most gracl data structures 
+ * * * * * * * * * * * * * * * * * * * * */
+
+/* Major status information */
+
+#define GR_VERSION  "grsecurity 1.9.7"
+
+#ifndef CONFIG_GR_MAXTRIES
+#define CONFIG_GR_MAXTRIES 3
+#endif
+
+#ifndef CONFIG_GR_TIMEOUT
+#define CONFIG_GR_TIMEOUT 30
+#endif
+
+enum {
+
+	SHUTDOWN = 0,
+	ENABLE = 1,
+	GOD = 2,
+	RELOAD = 3,
+	SEGVMOD = 4
+};
+
+/* Internal status definitions
+ * gr_set_label() in kernel/gracl.c
+ * */
+enum {
+	GR_SET_INHERIT,
+	GR_SET_PROC
+};
+
+/* Password setup definitions
+ * kernel/grhash.c */
+enum {
+	GR_PW_LEN = 128,
+	GR_SALT_LEN = 16,
+	GR_SHA_LEN = 20,
+};
+
+/* Begin Data Structures */
+
+struct admin_pw {
+	unsigned char salt[GR_SALT_LEN];
+	unsigned char sum[GR_SHA_LEN];	/* 160-bit SHA hash of the password */
+};
+
+struct acl_subject_label {
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	kernel_cap_t cap_lower;
+	kernel_cap_t cap_raise_inherit;
+	kernel_cap_t cap_lower_inherit;
+	/* Keeps track of the capabilities to raise and lower. 
+	 * Have to store it this way because users my change the default
+	 * capabilities, and we want to change with them(but still
+	 * keep our custom raised/lowered caps) */
+	unsigned long pos;
+	/* .. used for process object
+	   hashing. Position (i.e.
+	   subject acl number 1..n)
+	   The reason positition is part of the hash is that multiple
+	   processes may have acls for the same file, and we need some way
+	   to prevent a collision from occurring in that case,
+	   BUT subject inodes/devices may change because of create/delete
+	   operations, so position is the only thing that won't change but
+	   will still identify the acl subject
+	 */
+	struct rlimit res[RLIM_NLIMITS + 1];
+	unsigned int resmask;
+
+	unsigned long expires;
+	unsigned long crashes;
+
+	__u32 ip_type;
+	__u32 ip_proto[8];
+	struct acl_ip_label ** ips;
+	unsigned long ip_num;
+};
+
+struct acl_object_label {
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	unsigned long parent_pos;
+};
+
+struct name_entry {
+	ino_t inode;
+	kdev_t device;
+	__u8 mode;
+	char *name;
+};
+
+struct acl_subject_db {
+	struct acl_subject_label *s_hash;
+	unsigned long s_size;
+	unsigned long s_used;
+};
+
+struct acl_object_db {
+	struct acl_object_label *o_hash;
+	unsigned long o_size;
+	unsigned long o_used;
+};
+
+struct name_db {
+	struct name_entry *n_hash;
+	unsigned long n_size;
+	unsigned long n_used;
+};
+
+struct crash_uid {
+	uid_t uid;
+	unsigned long expires;
+};
+
+struct temp_file_label {
+	ino_t inode;
+	kdev_t device;
+	unsigned long mode;
+};
+
+struct acl_info {
+	ino_t inode;
+	kdev_t device;
+	unsigned long pos;
+};
+
+struct label_info {
+	ino_t inode;
+	kdev_t device;
+};
+
+/* Userspace Grsecurity ACL data structures */
+struct user_acl_subject_label {
+	char * filename;
+	unsigned short filename_len;
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	__u32 cap_raise;
+	__u32 cap_lower;
+	__u32 cap_raise_inherit;
+	__u32 cap_lower_inherit;
+	unsigned long pos;
+	
+	struct rlimit res[RLIM_NLIMITS + 1];
+	unsigned int resmask;
+
+	__u32 ip_proto[8];
+	__u32 ip_type;
+	struct acl_ip_label ** ips;
+	unsigned long ip_num;
+
+	/* next 4 structures not used */
+
+        struct user_acl_object_label *proc_object;
+        struct acl_ip_label *ip_object;
+        struct user_acl_subject_label *prev;
+        struct user_acl_subject_label *next;
+};
+
+struct user_acl_subject_db {
+	struct user_acl_subject_label **s_table;
+	unsigned long s_entries;	/* Number of entries in table */
+};
+
+struct user_acl_object_label {
+	char * filename;
+	unsigned short filename_len;
+	ino_t inode;
+	kdev_t device;
+	__u16 mode;
+	unsigned long parent_pos;
+	
+	/* next two structures not used */
+
+ 	struct user_acl_object_label *prev;
+        struct user_acl_object_label *next;
+};
+
+struct user_acl_object_db {
+	struct user_acl_object_label **o_table;
+	unsigned long o_entries;
+};
+
+struct acl_ip_label {
+	unsigned long addr;
+	unsigned long netmask;
+	__u16 low, high;
+	__u8 mode;
+	__u32 type;
+	__u32 proto[8];
+	unsigned long parent_pos;
+
+	/* next two structures not used */
+
+ 	struct acl_ip_label *prev;
+        struct acl_ip_label *next;
+};
+
+struct gr_arg {
+	struct user_acl_object_db obj_db;
+	struct user_acl_subject_db subj_db;
+	unsigned char pw[GR_PW_LEN];
+	kdev_t segv_device;
+	ino_t segv_inode;	
+	uid_t segv_uid;
+	__u16 mode;
+
+};
+
+/* End Data Structures Section */
+
+static __inline__ unsigned long
+fhash(const ino_t ino, const kdev_t dev, const unsigned long sz)
+{
+	return (ino ^ (dev * 797)) % sz;
+}
+
+static __inline__ unsigned long
+phash(const ino_t ino, const kdev_t dev,
+      const unsigned long parent_pos, const unsigned long sz)
+{
+	/* Okay...parent_pos is the subject acl # (0..n-1 for n subject acls)
+	 * We reuse fhash here for the parent_pos portion of phash() for
+	 * simplicity's sake */
+	return (fhash(ino, dev, ~0UL) ^ fhash((ino_t) (parent_pos), 0, ~0UL))
+	    % sz;
+}
+
+static __inline__ unsigned long
+nhash(const char *name, const unsigned long sz)
+{
+	return full_name_hash(name, strlen(name)) % sz;
+}
diff -urN linux/include/linux/grdefs.h linux/include/linux/grdefs.h
--- linux/include/linux/grdefs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/grdefs.h	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,114 @@
+#ifndef GRDEFS_H
+#define GRDEFS_H
+
+/* Begin Status/Return value declarations */
+
+enum {
+	GR_ALLOW = 0x01,
+	GR_NOTFOUND = 0x1000
+};
+
+/* Begin GrSecurity status declarations */
+
+enum {
+	GR_READY = 0x01,
+	GR_STATUS_INIT = 0x00 // disabled state
+};
+
+/* Table Size Defaults (in the form of 2^GR_TABLE_SIZE). Since
+ * our tables are dynamic, this is just the starting point, set to
+ * a reasonable value for the predicted number of MAC labels */
+enum {
+	GR_TABLE_SIZE = PAGE_SIZE	/* One page by default */
+};
+
+/* Begin  ACL declarations */
+
+/* ACL Subject and Object mode flags */
+enum {
+	GR_FIND = 0x10,
+	GR_EXISTS = 0x20,	/* ACL exists....since our hash table 
+				   will have blank entries */
+	GR_INHERIT = 0x40,
+	GR_DELETED = 0x80
+};
+
+/* ACL Object-only mode flags */
+enum {
+	GR_READ = 0x01,
+	GR_APPEND = 0x02,
+	GR_WRITE = 0x04,
+	GR_EXEC = 0x08
+};
+
+/* ACL subject-only mode flags */
+enum {
+	GR_KILL = 0x01,
+	GR_VIEW = 0x02,
+	GR_PROTECTED = 0x100,
+	GR_LEARN = 0x200
+};
+
+/* Name hash table declarations. Used when mapping filename->inode/dev
+ * and to tell whether a particular inode/dev/filename triplet has 
+ * a process subject, process label, and/or file label assigned to it */
+enum {
+	GR_NAME_ACL_SUBJECT = 0x01,
+	GR_NAME_ACL_OBJECT = 0x02,
+};
+
+#define PW_CONF		"/etc/grsec/pw"
+
+#define GR_CRASH_RES	11
+#define GR_UIDTABLE_MAX 1000
+enum {
+	SET_INHERIT = 1,
+	SET_PROC = 2
+};
+
+/* Begin hash section */
+
+struct gr_SHA1_CTX {
+	unsigned long state[5];
+	unsigned long count[2];
+	unsigned char buffer[64];
+};
+
+/* begin resource learning section */
+enum {
+	GR_RLIM_CPU_BUMP = 60,
+	GR_RLIM_FSIZE_BUMP = 50000,
+	GR_RLIM_DATA_BUMP = 10000,
+	GR_RLIM_STACK_BUMP = 1000,
+	GR_RLIM_CORE_BUMP = 10000,
+	GR_RLIM_RSS_BUMP = 500000,
+	GR_RLIM_NPROC_BUMP = 1,
+	GR_RLIM_NOFILE_BUMP = 5,
+	GR_RLIM_MEMLOCK_BUMP = 50000,
+	GR_RLIM_AS_BUMP = 500000,
+	GR_RLIM_LOCKS_BUMP = 2
+};
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+#ifdef __LITTLE_ENDIAN
+#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
+		|(rol(block->l[i],8)&0x00FF00FF))
+#else
+#define blk0(i) block->l[i]
+#endif				/* __LITTLE_ENDIAN */
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+			^block->l[(i+2)&15]^block->l[i&15],1))
+
+	/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+/* End hash section */
+
+#endif
diff -urN linux/include/linux/grmsg.h linux/include/linux/grmsg.h
--- linux/include/linux/grmsg.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/grmsg.h	2002-08-31 11:33:54.000000000 -0400
@@ -0,0 +1,190 @@
+#define DEFAULTSECMSG "(%.16s:%d) UID(%d) EUID(%d), parent (%.16s:%d) UID(%d) EUID(%d)"
+#define GR_PTRACE_ACL_MSG "denied ptrace of (%.16s:%d) by " DEFAULTSECMSG
+#define GR_PTRACE_ACL_FLD "denied ptraces"
+#define GR_STACK_MSG "return onto stack by " DEFAULTSECMSG
+#define GR_STACK_FLD "returns onto stack"
+#define GR_KMEM_MSG "attempted open of /dev/kmem by " DEFAULTSECMSG
+#define GR_KMEM_FLD "attempted kernel opens"
+#define GR_SYMLINK_MSG "not following symlink (%.30s/%.30s) of [%.32s]:%lu owned by %d.%d by " DEFAULTSECMSG
+#define GR_SYMLINK_FLD "symlinks not followed"
+#define GR_LEARN_AUDIT_MSG "LEARN:%d:%lu:%lu:%lu:%.950s:%d"
+#define GR_HIDDEN_ACL_MSG "attempt to access hidden file [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_HIDDEN_ACL_FLD "hidden file access attempts"
+#define GR_OPEN_ACL_MSG "attempt to open %.1024s for%s%s by " DEFAULTSECMSG
+#define GR_OPEN_ACL_FLD "file open attempts"
+#define GR_FIFO_MSG "denied writing FIFO (%.32s/%.32s) of %d.%d by " DEFAULTSECMSG
+#define GR_FIFO_FLD "writes into a FIFO denied"
+#define GR_MKNOD_CHROOT_MSG "refused attempt to mknod(%c:%.32s) (%.30s) from chroot jail [%.32s:%lu] owned by %d %d by " DEFAULTSECMSG
+#define GR_MKNOD_CHROOT_FLD "mknods in chroot denied"
+#define GR_MKNOD_ACL_MSG "attempt to mknod %.950s by " DEFAULTSECMSG
+#define GR_MKNOD_ACL_FLD "mknod attempts"
+#define GR_MKDIR_ACL_MSG "attempt to mkdir %.950s by " DEFAULTSECMSG
+#define GR_MKDIR_ACL_FLD "mkdir attempts"
+#define GR_RMDIR_ACL_MSG "attempt to rmdir %.950s by " DEFAULTSECMSG
+#define GR_RMDIR_ACL_FLD "rmdir attempts"
+#define GR_UNLINK_ACL_MSG "attempt to unlink %.950s by " DEFAULTSECMSG
+#define GR_UNLINK_ACL_FLD "unlink attempts"
+#define GR_SYMLINK_ACL_MSG "attempt to symlink %.950s to %.950s by " DEFAULTSECMSG
+#define GR_SYMLINK_ACL_FLD "symlink attempts"
+#define GR_HARDLINK_MSG "denied hardlink of %.30s (owned by %d.%d) to %.30s for " DEFAULTSECMSG
+#define GR_HARDLINK_FLD "denied hardlinks"
+#define GR_LINK_ACL_MSG "attempt to link %.950s to %.950s by " DEFAULTSECMSG
+#define GR_LINK_ACL_FLD "attempted links"
+#define GR_RENAME_ACL_MSG "attempt to rename %.950s to %.950s by " DEFAULTSECMSG
+#define GR_RENAME_ACL_FLD "rename attempts"
+#define GR_PTRACE_EXEC_ACL_MSG "denied ptrace of [%.32s:%lu] (%.16s) by " DEFAULTSECMSG
+#define GR_PTRACE_EXEC_ACL_FLD "denied ptraces"
+#define GR_NPROC_MSG "Attempt to overstep process limit by " DEFAULTSECMSG
+#define GR_NPROC_FLD "proc limit overstep"
+#define GR_EXEC_ACL_MSG "denying execution of %.950s by " DEFAULTSECMSG
+#define GR_EXEC_ACL_FLD "file exec attempts"
+#define GR_EXEC_TPE_MSG "denied exec of %.32s by " DEFAULTSECMSG " reason: untrusted"
+#define GR_EXEC_TPE_FLD "denied execs"
+#define GR_SEGVSTART_ACL_MSG "Possible exploit bruteforcing on " DEFAULTSECMSG " Banning uid %u from login for %lu seconds"
+#define GR_SEGVSTART_ACL_FLD "possible exploit bruteforcing"
+#define GR_SEGVNOSUID_ACL_MSG "Possible exploit bruteforcing on " DEFAULTSECMSG " Banning execution of [%.16s:%lu] for %lu seconds"
+#define GR_SEGVNOSUID_ACL_FLD "possible exploit bruteforcing"
+#define GR_SEGVIP_ACL_MSG "Possible exploit bruteforcing by %u.%u.%u.%u on " DEFAULTSECMSG " Banning execution of [%.16s:%lu] for %lu seconds"
+#define GR_SEGVIP_ACL_FLD "possible exploit bruteforcing"
+#define GR_MOUNT_CHROOT_MSG "denied attempt to mount (%.30s) as %.64s from chroot jail (%.32s:%lu) of %d.%d by " DEFAULTSECMSG
+#define GR_MOUNT_CHROOT_FLD "denied mounts in chroot"
+#define GR_PIVOT_CHROOT_MSG "denied attempt to pivot_root(%.30s,%.30s) from chroot jail [%.32s:%lu] of %d.%d by " DEFAULTSECMSG
+#define GR_PIVOT_CHROOT_FLD "denied pivot_roots in chroot"
+#define GR_TRUNCATE_ACL_MSG "attempted to truncate file [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_TRUNCATE_ACL_FLD "file truncate attempts"
+#define GR_ATIME_ACL_MSG "attempted to change access time for file [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_ATIME_ACL_FLD "file access time change attempts"
+#define GR_ACCESS_ACL_MSG "attempted to access file [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_ACCESS_ACL_FLD "file access attempts"
+#define GR_CHDIR_ACL_MSG "Attempted to chdir to directory [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_CHDIR_ACL_FLD "chdir attempts"
+#define GR_FCHDIR_CHROOT_MSG "Attempted fchdir outside of chroot to %.16s by " DEFAULTSECMSG
+#define GR_FCHDIR_CHROOT_FLD "attempted fchdirs"
+#define GR_FCHDIR_ACL_MSG "attempted to fchdir to directory [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_FCHDIR_ACL_FLD "fchdir attempts"
+#define GR_FCHDIR_AUDIT_MSG "fchdir(%d) to %.64s by " DEFAULTSECMSG
+#define GR_CHROOT_CHROOT_MSG "denied attempt to chroot() from (%.32s:%lu) to (%.30s) by " DEFAULTSECMSG
+#define GR_CHROOT_CHROOT_FLD "double chroot denied"
+#define GR_FCHMOD_ACL_MSG "Attempt to fchmod file [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_FCHMOD_ACL_FLD "fchmod attempts"
+#define GR_FCHMOD_CHROOT_MSG "denied attempt to fchmod +s (%.32s:%lu) owned by %d.%d to mode 0%07o from chroot jail (%.32s:%lu) of %d.%d by " DEFAULTSECMSG
+#define GR_FCHMOD_CHROOT_FLD "denied fchmod +s in chroot"
+#define GR_CHMOD_ACL_MSG "Attempt to chmod file [%.32s:%lu] %.950s by " DEFAULTSECMSG
+#define GR_CHMOD_ACL_FLD "chmod attempts"
+#define GR_CHMOD_CHROOT_MSG "denied attempt to chmod +s (%.32s:%lu) (%.30s) owned by %d.%d to mode 0%07o from chroot jail (%.32s:%lu) of %d.%d by " DEFAULTSECMSG
+#define GR_CHMOD_CHROOT_FLD "denied chmod +s in chroot"
+#define GR_CHOWN_ACL_MSG "Attempt to chown file [%.32s:%lu] to %d.%d by " DEFAULTSECMSG
+#define GR_CHOWN_ACL_FLD "chown attempts"
+#define GR_WRITLIB_ACL_MSG "attempt to load writable library [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_WRITLIB_ACL_FLD "writable library loads"
+#define GR_PWCONF_ACL_MSG "Could not open config file %.950s"
+#define GR_PWCONF_ACL_FLD "config file open errors"
+#define GR_INVPW_ACL_MSG "Invalid pw entry detected, got %d wanted %d"
+#define GR_INVPW_ACL_FLD "password file errors"
+#define GR_INITF_ACL_MSG "init_variables() failed %s"
+#define GR_INITF_ACL_FLD "init_variables() failures"
+#define GR_PWF_ACL_MSG "chk_pw_conf() failed %s"
+#define GR_PWF_ACL_FLD "chk_pw_conf() failures"
+#define GR_PARSEF_ACL_MSG "parse_args() failed %s"
+#define GR_PARSEF_ACL_FLD "parse_args() failures" 
+#define GR_DISABLED_ACL_MSG "Error loading %s, trying to run kernel with acls disabled. To disable acls at startup use <kernel image name> gracl=off from your boot loader"
+#define GR_DISABLED_ACL_FLD "error loading acls"
+#define GR_PROC_ACL_MSG "Proc handler: being fed garbage %d bytes sent %d required"
+#define GR_PROC_ACL_FLD "proc garbage"
+#define GR_SHUTS_ACL_MSG "shutdown auth success for " DEFAULTSECMSG
+#define GR_SHUTS_ACL_FLD "shutdown successes"
+#define GR_SHUTF_ACL_MSG "shutdown auth failure for " DEFAULTSECMSG
+#define GR_SHUTF_ACL_FLD "shutdown failures"
+#define GR_SHUTI_ACL_MSG "ignoring shutdown for disabled acl for " DEFAULTSECMSG
+#define GR_SHUTI_ACL_FLD "ignored shutdowns"
+#define GR_SEGVMODS_ACL_MSG "segvmod auth success for " DEFAULTSECMSG
+#define GR_SEGVMODS_ACL_FLD "segvmod successes"
+#define GR_SEGVMODF_ACL_MSG "segvmod auth failure for " DEFAULTSECMSG
+#define GR_SEGVMODF_ACL_FLD "segvmod failures"
+#define GR_SEGVMODI_ACL_MSG "ignoring segvmod for disabled acl for " DEFAULTSECMSG
+#define GR_SEGVMODI_ACL_FLD "ignored segvmods"
+#define GR_ENABLEI_ACL_MSG "%s at boot time, ignoring load request"
+#define GR_ENABLEI_ACL_FLD "attempts to load gracl when disabled on boot"
+#define GR_ENABLE_ACL_MSG "Loaded %s"
+#define GR_ENABLE_ACL_FLD "grsecurity loads"
+#define GR_ENABLEF_ACL_MSG "Unable to load %s for " DEFAULTSECMSG " ACL system may already be enabled."
+#define GR_ENABLEF_ACL_FLD "enable failures"
+#define GR_RELOADI_ACL_MSG "Ignoring reload request for disabled ACL"
+#define GR_RELOADI_ACL_FLD "attempts to reload gracl when disabled"
+#define GR_RELOAD_ACL_MSG "Reloaded %s"
+#define GR_RELOAD_ACL_FLD "grsecurity reloads"
+#define GR_RELOADF_ACL_MSG "Failed reload of %s for " DEFAULTSECMSG
+#define GR_RELOADF_ACL_FLD "reload failures"
+#define GR_ADMINI_ACL_MSG "Ignoring change to admin mode for disabled acl for " DEFAULTSECMSG
+#define GR_ADMINI_ACL_FLD "ignored admin"
+#define GR_ADMINS_ACL_MSG "successful change to admin mode by " DEFAULTSECMSG
+#define GR_ADMINS_ACL_FLD "changes to admin mode"
+#define GR_ADMINF_ACL_MSG "admin auth failure for " DEFAULTSECMSG
+#define GR_ADMINF_ACL_FLD "admin failures"
+#define GR_INVMODE_ACL_MSG "Invalid mode %d by " DEFAULTSECMSG
+#define GR_INVMODE_ACL_FLD "invalid modes"
+#define GR_MAXPW_ACL_MSG "Maximum pw attempts reached (%d), locking password authentication"
+#define GR_MAXPW_ACL_FLD "password attempts failed"
+#define GR_PRIORITY_CHROOT_MSG "attempted priority change of process (%.16s:%d) by " DEFAULTSECMSG
+#define GR_PRIORITY_CHROOT_FLD "attempted priority changes"
+#define GR_CAPSET_CHROOT_MSG "denied capset of (%.16s:%d) within chroot jail [%.32s:%lu] by " DEFAULTSECMSG
+#define GR_CAPSET_CHROOT_FLD "denied chroot capsets"
+#define GR_FAILFORK_MSG "failed fork with errno %d by " DEFAULTSECMSG
+#define GR_FAILFORK_FLD "failed forks"
+#define GR_NICE_CHROOT_MSG "attempted priority change by " DEFAULTSECMSG
+#define GR_NICE_CHROOT_FLD "attempted priority changes"
+#define GR_UNISIGLOG_MSG "signal %d sent to " DEFAULTSECMSG
+#define GR_UNISIGLOG_FLD "signal warnings"
+#define GR_DUALSIGLOG_MSG "signal %d sent to " DEFAULTSECMSG " by " DEFAULTSECMSG
+#define GR_DUALSIGLOG_FLD "signal warnings"
+#define GR_SIG_ACL_MSG "Attempted send of signal %d to protected task " DEFAULTSECMSG " by " DEFAULTSECMSG
+#define GR_SIG_ACL_FLD "signals to protected processes"
+#define GR_SYSCTL_MSG "attempt to modify grsecurity sysctl value : %.32s by " DEFAULTSECMSG
+#define GR_SYSCTL_FLD "attempted sysctl changes"
+#define GR_SYSCTL_ACL_MSG "attempt to sysctl() %.32s for%s%s by " DEFAULTSECMSG
+#define GR_SYSCTL_ACL_FLD "attempted sysctl accesses"
+#define GR_TIME_MSG "time set by " DEFAULTSECMSG
+#define GR_TIME_FLD "time sets"
+#define GR_DEFACL_MSG "Fatal: Unable to find ACL for (%.16s:%d)"
+#define GR_DEFACL_FLD "default acl errors"
+#define GR_MMAP_ACL_MSG "attempt to mmap [%.32s:%lu] %.30s executable by " DEFAULTSECMSG
+#define GR_MMAP_ACL_FLD "mmap exec attempts"
+#define GR_SOCK_MSG "attempted socket(%d,%d,%d) by " DEFAULTSECMSG
+#define GR_SOCK_FLD "attempted sockets"
+#define GR_BIND_MSG "attempted bind() by " DEFAULTSECMSG
+#define GR_BIND_FLD "attempted binds"
+#define GR_CONNECT_MSG "attempted conntect() to fd %d by " DEFAULTSECMSG
+#define GR_CONNECT_FLD "attempted connects"
+#define GR_BIND_ACL_MSG "attempted bind to %u.%u.%u.%u port %u sock type %u protocol %u by " DEFAULTSECMSG
+#define GR_BIND_ACL_FLD "attempted binds"
+#define GR_CONNECT_ACL_MSG "attempted connect to %u.%u.%u.%u port %u sock type %u protocol %u by " DEFAULTSECMSG
+#define GR_CONNECT_ACL_FLD "attempted connects"
+#define GR_IP_LEARN_MSG "LEARN:%d:%lu:%u.%u.%u.%u:%u:%u:%u:%u"
+#define GR_EXEC_CHROOT_MSG "exec of %.64s within chroot jail [%.32s:%lu] by process " DEFAULTSECMSG
+#define GR_CAP_AUDIT_MSG "%s not raised for " DEFAULTSECMSG
+#define GR_REMOUNT_AUDIT_MSG "remount of %.30s by " DEFAULTSECMSG
+#define GR_UNMOUNT_AUDIT_MSG "unmount of %.30s by " DEFAULTSECMSG
+#define GR_MOUNT_AUDIT_MSG "mount %.30s to %.64s by " DEFAULTSECMSG
+#define GR_CHDIR_AUDIT_MSG "chdir(\"%.64s\") by " DEFAULTSECMSG
+#define GR_EXEC_AUDIT_MSG "exec of [%.32s:%lu] (%.63s) by " DEFAULTSECMSG
+#define GR_MSGQ_AUDIT_MSG "message queue created by " DEFAULTSECMSG
+#define GR_MSGQR_AUDIT_MSG "message queue of uid:%d euid:%d removed by " DEFAULTSECMSG
+#define GR_SEM_AUDIT_MSG "semaphore created by " DEFAULTSECMSG
+#define GR_SEMR_AUDIT_MSG "semaphore of uid:%d euid:%d removed by " DEFAULTSECMSG
+#define GR_SHM_AUDIT_MSG "shared memory of size %d created by " DEFAULTSECMSG
+#define GR_SHMR_AUDIT_MSG "shared memory of uid:%d euid:%d removed by " DEFAULTSECMSG
+#define GR_ACLINIT_DEBUG_MSG "got %.3s at startup"
+#define GR_ACLNCOLL_DEBUG_MSG "Hey, I had a name entry collision(I am %.425s and I collided with %.425s)"
+#define GR_ACLOCOLL_DEBUG_MSG "Hey, I had an acl object label collision (I am %lu %d)"
+#define GR_ACLSCOLL_DEBUG_MSG "Hey, I had an acl subject label collision (I am %lu %d )"
+#define GR_LISTNAMES_DEBUG_MSG "Name Entry pos %lu has inode %lu dev %.32s mode %x name %.950s"
+#define GR_LISTPROCSS_DEBUG_MSG "MAC Subject pos %lu has inode %lu dev %.32s mode %x pos %lu"
+#define GR_LISTPROCSO_DEBUG_MSG "MAC Object pos %lu has inode %lu dev %.32s mode %x parent %lu"
+#define GR_LISTACLS1_DEBUG_MSG "Iterating through received table\n"
+#define GR_LISTACLS2_DEBUG_MSG "Note: there should be %lu acl subject entries and %lu acl object entries"
+#define GR_LISTACLSS_DEBUG_MSG "Subject label %.950s position %lu has inode %lu device %d"
+#define GR_LISTACLSO_DEBUG_MSG "Object label %.950s position %lu has inode %lu device %d"
+#define GR_OBJDEL_DEBUG_MSG "Acl Object [%.32s:%lu] pos %lu deleted"
+#define GR_SUBJDEL_DEBUG_MSG "ACL subject [%.32s:%lu] deleted"
+#define GR_SUBJREC_DEBUG_MSG "Process Subj ACL %.950s recreated"
+#define GR_OBJREC_DEBUG_MSG "Process Obj ACL %.950s pos %lu recreated"
diff -urN linux/include/linux/grsecurity.h linux/include/linux/grsecurity.h
--- linux/include/linux/grsecurity.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/grsecurity.h	2002-08-31 14:12:05.000000000 -0400
@@ -0,0 +1,170 @@
+/* * * * * * * * * * * * * * * * * * * *
+ * Main grsecurity header file
+ * * * * * * * * * * * * * * * * * * * */
+
+/* Because this header file is used by the other sections of the kernel
+ * it defines external functions. The actual code in kernel/gracl.c
+ * uses include/linux/gracl.h. We make sure that that code ignores our
+ * extern declarations to avoid conflicts */
+
+#ifndef GR_ACL_H
+#include <linux/dcache.h>
+#include <linux/grdefs.h>
+#include <linux/in.h>
+#include <linux/net.h>
+
+extern int gr_disable;
+extern int gr_acl_is_enabled(void);
+extern int gr_search_file(struct dentry *dentry, __u16 mode,
+			  struct vfsmount *mnt);
+extern int gr_check_root(struct dentry * dentry, struct vfsmount * mnt,
+			 __u16 mode);
+extern void gr_set_proc_label(struct dentry *dentry, struct vfsmount *mnt,
+			     const char *filename);
+extern int gr_check_hidden_task(struct task_struct *tsk);
+extern int gr_check_protected_task(struct task_struct *tsk);
+extern void gr_copy_label(struct task_struct *tsk);
+extern void gr_handle_delete(const ino_t ino, const kdev_t dev);
+extern inline int gr_handle_mmap(struct file * filp, unsigned long prot);
+extern inline int gr_handle_ptrace(struct task_struct * task);
+extern void gr_handle_create(struct dentry * dentry,
+			     struct vfsmount * mnt);
+extern void gr_handle_crash(struct task_struct * task, int sig);
+extern int gr_check_crash_exec(struct file * filp);
+extern int gr_check_crash_uid(uid_t uid);
+extern int gr_handle_rename(struct inode * old_dir, struct inode * new_dir,
+			     struct dentry * old_dentry, 
+			     struct dentry * new_dentry,
+			     struct vfsmount * mnt, const __u8 noreplace); 
+extern struct file * gr_find_proc_file(struct task_struct * task);
+extern int gr_search_socket(int family, int type, int protocol);
+extern int gr_search_connectbind(int mode, struct socket * sock,
+					struct sockaddr_in * addr);
+extern void gr_set_caps(void);
+extern void gr_set_proc_res(void);
+extern int gr_set_acls(void);
+extern int gr_check_create(struct dentry *new_dentry, struct dentry *parent,
+			   struct vfsmount *mnt, __u16 mode);
+extern inline int gr_is_capable(int cap);
+extern inline void gr_learn_resource(struct task_struct * task, int limit, 
+					unsigned long wanted);
+#endif
+
+#ifndef GR_SECURITY_H
+#define GR_SECURITY_H
+#include <linux/grmsg.h>
+#include <linux/binfmts.h>
+
+extern __u16 ip_randomid(void);
+
+extern int grsec_enable_link;
+extern int grsec_enable_fifo;
+extern int grsec_enable_execve;
+extern int grsec_enable_forkbomb;
+extern int grsec_forkbomb_gid;
+extern int grsec_forkbomb_sec;
+extern int grsec_forkbomb_max;
+extern int grsec_enable_execlog;
+extern int grsec_enable_signal;
+extern int grsec_enable_forkfail;
+extern int grsec_enable_time;
+extern int grsec_enable_dmesg;
+extern int grsec_enable_chroot_findtask;
+extern int grsec_enable_chroot_mount;
+extern int grsec_enable_chroot_double;
+extern int grsec_enable_chroot_pivot;
+extern int grsec_enable_chroot_chdir;
+extern int grsec_enable_chroot_chmod;
+extern int grsec_enable_chroot_mknod;
+extern int grsec_enable_chroot_fchdir;
+extern int grsec_enable_chroot_nice;
+extern int grsec_enable_chroot_execlog;
+extern int grsec_enable_chroot_caps;
+extern int grsec_enable_tpe;
+extern int grsec_tpe_gid;
+extern int grsec_enable_tpe_all;
+extern int grsec_enable_sidcaps;
+extern int grsec_enable_randpid;
+extern int grsec_enable_randid;
+extern int grsec_enable_randsrc;
+extern int grsec_enable_randrpc;
+extern int grsec_enable_randping;
+extern int grsec_enable_socket_all;
+extern int grsec_socket_all_gid;
+extern int grsec_enable_socket_client;
+extern int grsec_socket_client_gid;
+extern int grsec_enable_socket_server;
+extern int grsec_socket_server_gid;
+extern int grsec_audit_gid;
+extern int grsec_enable_group;
+extern int grsec_enable_audit_ipc;
+extern int grsec_enable_mount;
+extern int grsec_enable_chdir;
+extern int grsec_lock;
+
+extern struct task_struct *child_reaper;
+
+#define proc_is_chrooted(tsk_a)  ((tsk_a->fs->root->d_inode->i_dev != \
+			  child_reaper->fs->root->d_inode->i_dev) || \
+			  (tsk_a->fs->root->d_inode->i_ino != \
+			  child_reaper->fs->root->d_inode->i_ino))
+
+#define have_same_root(tsk_a,tsk_b) ((tsk_a->fs->root->d_inode->i_dev == \
+			  tsk_b->fs->root->d_inode->i_dev) && \
+			  (tsk_a->fs->root->d_inode->i_ino == \
+			  tsk_b->fs->root->d_inode->i_ino))
+
+#define DEFAULTSECARGS current->comm, current->pid, current->uid, \
+		       current->euid, current->p_pptr->comm, \
+		       current->p_pptr->pid, current->p_pptr->uid, \
+		       current->p_pptr->euid
+
+#define GR_CHROOT_CAPS ( \
+	CAP_TO_MASK(CAP_FOWNER) | CAP_TO_MASK(CAP_SYS_RESOURCE) | \
+	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG))
+
+#define GR_BIND 0x01
+#define GR_CONNECT 0x02
+
+void gr_handle_exec_args(struct linux_binprm * bprm, char ** argv);
+int gr_tpe_allow(struct file * file);
+int gr_tpe_all_allow(struct file * file);
+int gr_pid_is_chrooted(struct task_struct *p);
+
+#ifdef CONFIG_GRKERNSEC
+#define GR_FLOODTIME CONFIG_GRKERNSEC_FLOODTIME
+#define GR_FLOODBURST CONFIG_GRKERNSEC_FLOODBURST
+#else
+#define GR_FLOODTIME 30
+#define GR_FLOODBURST 4
+#endif
+
+#define security_alert(normal_msg,flood_msg,args...) \
+({ \
+	static unsigned long warning_time = 0, no_flood_yet = 0; \
+	static spinlock_t security_alert_lock = SPIN_LOCK_UNLOCKED; \
+	\
+	spin_lock(&security_alert_lock); \
+	if(!warning_time || jiffies - warning_time > GR_FLOODTIME * HZ) { \
+	    warning_time = jiffies; no_flood_yet++; \
+	    printk(KERN_ALERT "grsec: " normal_msg "\n", ## args); \
+	} else if (no_flood_yet >= GR_FLOODBURST) { \
+	    warning_time = jiffies; no_flood_yet = 0; \
+	    printk(KERN_ALERT "grsec: more " flood_msg \
+		    ", logging disabled for %d seconds\n",GR_FLOODTIME); \
+	} \
+	\
+	spin_unlock(&security_alert_lock); \
+})
+
+#define security_audit(normal_msg,args...) \
+	printk(KERN_INFO "grsec: " normal_msg "\n", ## args)
+
+#define security_debug(normal_msg,args...) \
+	printk(KERN_DEBUG "grsec: " normal_msg "\n", ## args)
+
+#endif
diff -urN linux/include/linux/grsum.h linux/include/linux/grsum.h
--- linux/include/linux/grsum.h	1969-12-31 19:00:00.000000000 -0500
+++ linux/include/linux/grsum.h	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,15 @@
+/* * * * * * * * * * * * * * * * * * * *
+ * SHA-1 hash used by grsecurity 
+ * See kernel/grhash.c 
+ * * * * * * * * * * * * * * * * * * * */
+
+extern void gr_SHA1Init(struct gr_SHA1_CTX *context);
+extern void gr_SHA1Update(struct gr_SHA1_CTX *context, unsigned char *data,
+			  unsigned int len);
+extern void gr_SHA1Final(unsigned char digest[20], struct gr_SHA1_CTX *context);
+
+extern int chkpw(struct gr_arg *entry, struct admin_pw * pwent);
+/* @entry - current password entry attempt
+ * returns a memcmp() of the current password vs. entry's password,
+ * therefore 0 is success and nonzero is failure
+ */
diff -urN linux/include/linux/kernel.h linux/include/linux/kernel.h
--- linux/include/linux/kernel.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/linux/kernel.h	2002-08-31 14:12:05.000000000 -0400
@@ -70,14 +70,17 @@
 extern long long simple_strtoll(const char *,char **,unsigned int);
 extern int sprintf(char * buf, const char * fmt, ...)
 	__attribute__ ((format (printf, 2, 3)));
-extern int vsprintf(char *buf, const char *, va_list);
+extern int vsprintf(char *buf, const char *, va_list)
+	__attribute__ ((format (printf, 2, 0)));
 extern int snprintf(char * buf, size_t size, const char * fmt, ...)
 	__attribute__ ((format (printf, 3, 4)));
-extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+	__attribute__ ((format (printf, 3, 0)));
 
 extern int sscanf(const char *, const char *, ...)
 	__attribute__ ((format (scanf,2,3)));
-extern int vsscanf(const char *, const char *, va_list);
+extern int vsscanf(const char *, const char *, va_list)
+	__attribute__ ((format (scanf, 2, 0)));
 
 extern int get_option(char **str, int *pint);
 extern char *get_options(char *str, int nints, int *ints);
diff -urN linux/include/linux/mm.h linux/include/linux/mm.h
--- linux/include/linux/mm.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/linux/mm.h	2002-08-31 14:12:05.000000000 -0400
@@ -25,6 +25,7 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/atomic.h>
+#include <asm/mman.h>
 
 /*
  * Linux kernel virtual memory manager primitives.
@@ -104,7 +105,16 @@
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
 
-#define VM_STACK_FLAGS	0x00000177
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define VM_MIRROR	0x00100000	/* vma is mirroring another */
+#define VM_MIRRORED	0x00200000	/* vma is mirrored by another */
+#endif
+
+#if defined(CONFIG_GRKERNSEC_PAX_PAGEEXEC) || defined(CONFIG_GRKERNSEC_PAX_SEGMEXEC)
+#define VM_STACK_FLAGS (0x00000133 | ((current->flags & (PF_PAX_PAGEEXEC|PF_PAX_SEGMEXEC))?0:VM_EXEC|VM_MAYEXEC))
+#else
+#define VM_STACK_FLAGS  0x00000177 
+#endif
 
 #define VM_READHINTMASK			(VM_SEQ_READ | VM_RAND_READ)
 #define VM_ClearReadHint(v)		(v)->vm_flags &= ~VM_READHINTMASK
@@ -543,21 +553,50 @@
 	unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long pgoff);
 
+extern int do_munmap(struct mm_struct *, unsigned long, size_t);
+
 static inline unsigned long do_mmap(struct file *file, unsigned long addr,
 	unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long offset)
 {
 	unsigned long ret = -EINVAL;
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((current->flags & PF_PAX_SEGMEXEC) &&
+	   (len > TASK_SIZE/2 || (addr && addr > TASK_SIZE/2-len)))
+		goto out;
+#endif
+
 	if ((offset + PAGE_ALIGN(len)) < offset)
 		goto out;
 	if (!(offset & ~PAGE_MASK))
 		ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> PAGE_SHIFT);
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+#define BAD_ADDR(x)	((unsigned long)(x) > TASK_SIZE)
+	if ((current->flags & PF_PAX_SEGMEXEC) &&
+	    !BAD_ADDR(ret) &&
+	    (prot & PROT_EXEC)
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	    && (current->flags & PF_PAX_MPROTECT) && file
+#endif
+	   )
+	{
+		unsigned long ret_m;
+		ret_m = do_mmap_pgoff(NULL, ret + TASK_SIZE/2, 0UL, prot, MAP_PRIVATE | MAP_MIRROR | MAP_FIXED, ret);
+		if (BAD_ADDR(ret_m)) {
+			do_munmap(current->mm, ret, len);
+			ret = ret_m;
+		}
+	}
+#undef BAD_ADDR
+#endif
+
 out:
 	return ret;
 }
 
-extern int do_munmap(struct mm_struct *, unsigned long, size_t);
-
 extern unsigned long do_brk(unsigned long, unsigned long);
 
 static inline void __vma_unlink(struct mm_struct * mm, struct vm_area_struct * vma, struct vm_area_struct * prev)
@@ -570,6 +609,13 @@
 
 static inline int can_vma_merge(struct vm_area_struct * vma, unsigned long vm_flags)
 {
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((vma->vm_flags | vm_flags) & VM_MIRROR)
+		return 0;
+	else
+#endif
+
 	if (!vma->vm_file && vma->vm_flags == vm_flags)
 		return 1;
 	else
@@ -638,6 +684,8 @@
 	address &= PAGE_MASK;
  	spin_lock(&vma->vm_mm->page_table_lock);
 	grow = (vma->vm_start - address) >> PAGE_SHIFT;
+	gr_learn_resource(current, RLIMIT_STACK, vma->vm_end - address);
+	gr_learn_resource(current, RLIMIT_AS, (vma->vm_mm->total_vm + grow) << PAGE_SHIFT);
 	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
 	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur) {
 		spin_unlock(&vma->vm_mm->page_table_lock);
diff -urN linux/include/linux/proc_fs.h linux/include/linux/proc_fs.h
--- linux/include/linux/proc_fs.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/linux/proc_fs.h	2002-08-31 14:12:06.000000000 -0400
@@ -143,6 +143,9 @@
 extern struct proc_dir_entry *proc_mknod(const char *,mode_t,
 		struct proc_dir_entry *,kdev_t);
 extern struct proc_dir_entry *proc_mkdir(const char *,struct proc_dir_entry *);
+#ifdef CONFIG_GRKERNSEC_PROC
+extern struct proc_dir_entry *proc_priv_mkdir(const char *, struct proc_dir_entry *);
+#endif
 
 static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
 	mode_t mode, struct proc_dir_entry *base, 
diff -urN linux/include/linux/sched.h linux/include/linux/sched.h
--- linux/include/linux/sched.h	2002-08-02 20:39:45.000000000 -0400
+++ linux/include/linux/sched.h	2002-08-31 14:12:05.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/signal.h>
 #include <linux/securebits.h>
 #include <linux/fs_struct.h>
+#include <linux/grsecurity.h>
 
 struct exec_domain;
 
@@ -231,6 +232,12 @@
 	unsigned long cpu_vm_mask;
 	unsigned long swap_address;
 
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	unsigned long delta_mmap;		/* PaX: randomized offset */
+	unsigned long delta_exec;		/* PaX: randomized offset */
+	unsigned long delta_stack;		/* PaX: randomized offset */
+#endif
+ 
 	unsigned dumpable:1;
 
 	/* Architecture-specific MM context */
@@ -410,6 +417,10 @@
 	void *notifier_data;
 	sigset_t *notifier_mask;
 	
+	volatile void * acl;
+	u8 acl_admin;	
+	rwlock_t acl_lock;
+	
 /* Thread group tracking */
    	u32 parent_exec_id;
    	u32 self_exec_id;
@@ -438,6 +449,12 @@
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
+#define PF_PAX_PAGEEXEC       0x01000000      /* Paging based non-executable pages */
+#define PF_PAX_EMUTRAMP       0x02000000      /* Emulate trampolines */
+#define PF_PAX_MPROTECT       0x04000000      /* Restrict mprotect() */
+#define PF_PAX_RANDMMAP       0x08000000      /* Randomize mmap() base */
+#define PF_PAX_SEGMEXEC	      0x20000000      /* Segmentation based non-executable pages */
+
 /*
  * Ptrace flags
  */
@@ -511,6 +528,8 @@
     blocked:		{{0}},						\
     alloc_lock:		SPIN_LOCK_UNLOCKED,				\
     journal_info:	NULL,						\
+    acl:		NULL,						\
+    acl_lock:		RW_LOCK_UNLOCKED,				\
 }
 
 
@@ -551,6 +570,8 @@
 	*p->pidhash_pprev = p->pidhash_next;
 }
 
+#include <asm/current.h>
+
 static inline struct task_struct *find_task_by_pid(int pid)
 {
 	struct task_struct *p, **htable = &pidhash[pid_hashfn(pid)];
@@ -558,6 +579,8 @@
 	for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
 		;
 
+	if(gr_pid_is_chrooted(p)) p = NULL;
+
 	return p;
 }
 
@@ -578,8 +601,6 @@
 extern struct user_struct * alloc_uid(uid_t);
 extern void free_uid(struct user_struct *);
 
-#include <asm/current.h>
-
 extern unsigned long volatile jiffies;
 extern unsigned long itimer_ticks;
 extern unsigned long itimer_next;
@@ -743,7 +764,7 @@
 static inline int capable(int cap)
 {
 #if 1 /* ok now */
-	if (cap_raised(current->cap_effective, cap))
+	if (cap_raised(current->cap_effective, cap) && gr_is_capable(cap))
 #else
 	if (cap_is_fs_cap(cap) ? current->fsuid == 0 : current->euid == 0)
 #endif
diff -urN linux/include/linux/sysctl.h linux/include/linux/sysctl.h
--- linux/include/linux/sysctl.h	2002-08-02 20:39:46.000000000 -0400
+++ linux/include/linux/sysctl.h	2002-08-31 14:12:05.000000000 -0400
@@ -124,6 +124,7 @@
 	KERN_CORE_USES_PID=52,		/* int: use core or core.%pid */
 	KERN_TAINTED=53,	/* int: various kernel tainted flags */
 	KERN_CADPID=54,		/* int: PID of the process to notify on CAD */
+        KERN_GRSECURITY=68,              /* grsecurity */
 };
 
 
diff -urN linux/include/net/inetpeer.h linux/include/net/inetpeer.h
--- linux/include/net/inetpeer.h	2002-02-25 14:38:13.000000000 -0500
+++ linux/include/net/inetpeer.h	2002-08-31 14:12:26.000000000 -0400
@@ -13,6 +13,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
+#include <linux/grsecurity.h>
 #include <asm/atomic.h>
 
 struct inet_peer
@@ -58,7 +59,12 @@
 	__u16 id;
 
 	spin_lock_bh(&inet_peer_idlock);
-	id = p->ip_id_count++;
+
+	if(grsec_enable_randid)
+		id = htons(ip_randomid());
+	else
+		id = p->ip_id_count++;
+
 	spin_unlock_bh(&inet_peer_idlock);
 	return id;
 }
diff -urN linux/include/net/ip.h linux/include/net/ip.h
--- linux/include/net/ip.h	2001-11-22 14:47:15.000000000 -0500
+++ linux/include/net/ip.h	2002-08-31 14:12:27.000000000 -0400
@@ -29,6 +29,7 @@
 #include <linux/netdevice.h>
 #include <linux/inetdevice.h>
 #include <linux/in_route.h>
+#include <linux/grsecurity.h>
 #include <net/route.h>
 #include <net/arp.h>
 
@@ -196,7 +197,11 @@
 		 * does not change, they drop every other packet in
 		 * a TCP stream using header compression.
 		 */
-		iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
+
+		if(grsec_enable_randid)
+			iph->id = htons(ip_randomid());
+		else
+			iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
 	} else
 		__ip_select_ident(iph, dst);
 }
diff -urN linux/init/main.c linux/init/main.c
--- linux/init/main.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/init/main.c	2002-08-31 11:24:08.000000000 -0400
@@ -27,6 +27,7 @@
 #include <linux/iobuf.h>
 #include <linux/bootmem.h>
 #include <linux/tty.h>
+#include <linux/grsecurity.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -107,6 +108,10 @@
 extern void ipc_init(void);
 #endif
 
+extern void grsecurity_init(void);
+
+static __init int gr_setup(char *line);
+
 /*
  * Boot command-line arguments
  */
@@ -132,6 +137,17 @@
 
 __setup("profile=", profile_setup);
 
+static int __init gr_setup(char *str) 
+{
+#ifdef CONFIG_GR_DEBUG
+	security_debug(GR_ACLINIT_DEBUG_MSG, str);
+#endif
+	if(  *str == '0' || ( !(strcmp(str,"off")) )  ) 
+		gr_disable = 1;
+	return 1;
+}
+__setup("gracl",gr_setup);
+
 static int __init checksetup(char *line)
 {
 	struct kernel_param *p;
@@ -546,6 +562,7 @@
 	do_basic_setup();
 
 	prepare_namespace();
+	grsecurity_init();
 
 	/*
 	 * Ok, we have completed the initial bootup, and
diff -urN linux/ipc/msg.c linux/ipc/msg.c
--- linux/ipc/msg.c	2001-09-14 17:17:00.000000000 -0400
+++ linux/ipc/msg.c	2002-08-31 11:24:08.000000000 -0400
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -326,6 +327,11 @@
 		msg_unlock(id);
 	}
 	up(&msg_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) && grsec_enable_audit_ipc) || 
+	   (grsec_enable_audit_ipc && !grsec_enable_group)) && (ret >= 0) && (msgflg & IPC_CREAT))
+		security_audit(GR_MSGQ_AUDIT_MSG, DEFAULTSECARGS);
+
 	return ret;
 }
 
@@ -560,6 +566,13 @@
 		break;
 	}
 	case IPC_RMID:
+
+		if((grsec_enable_group && in_group_p(grsec_audit_gid) 
+		   && grsec_enable_audit_ipc) || 
+		   (grsec_enable_audit_ipc && !grsec_enable_group))
+			security_audit(GR_MSGQR_AUDIT_MSG, ipcp->uid,
+					ipcp->cuid, DEFAULTSECARGS);
+
 		freeque (msqid); 
 		break;
 	}
diff -urN linux/ipc/sem.c linux/ipc/sem.c
--- linux/ipc/sem.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/ipc/sem.c	2002-08-31 11:24:08.000000000 -0400
@@ -62,6 +62,7 @@
 #include <linux/spinlock.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
+#include <linux/grsecurity.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -181,6 +182,13 @@
 	}
 
 	up(&sem_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) 
+	   && grsec_enable_audit_ipc) || 
+	   (grsec_enable_audit_ipc && !grsec_enable_group)) 
+	   && (err >= 0) && (semflg & IPC_CREAT))
+		security_audit(GR_SEM_AUDIT_MSG, DEFAULTSECARGS); 
+
 	return err;
 }
 
@@ -728,6 +736,12 @@
 
 	switch(cmd){
 	case IPC_RMID:
+		if((grsec_enable_group && in_group_p(grsec_audit_gid) 
+		   && grsec_enable_audit_ipc) || 
+		   (grsec_enable_audit_ipc && !grsec_enable_group))
+			security_audit(GR_SEMR_AUDIT_MSG, ipcp->uid,
+					ipcp->cuid, DEFAULTSECARGS);
+
 		freeary(semid);
 		err = 0;
 		break;
diff -urN linux/ipc/shm.c linux/ipc/shm.c
--- linux/ipc/shm.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/ipc/shm.c	2002-08-31 11:24:08.000000000 -0400
@@ -23,6 +23,7 @@
 #include <linux/mman.h>
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 #include "util.h"
 
@@ -254,6 +255,12 @@
 		shm_unlock(id);
 	}
 	up(&shm_ids.sem);
+
+	if(((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+	   grsec_enable_audit_ipc) || (grsec_enable_audit_ipc && 
+	   !grsec_enable_group)) && (err >= 0) && (shmflg & IPC_CREAT))
+		security_audit(GR_SHM_AUDIT_MSG, size, DEFAULTSECARGS);
+
 	return err;
 }
 
@@ -509,6 +516,13 @@
 			err=-EPERM;
 			goto out_unlock_up;
 		}
+
+		if(((grsec_enable_group && in_group_p(grsec_audit_gid) &&
+		   grsec_enable_audit_ipc) || (grsec_enable_audit_ipc && 
+		   !grsec_enable_group)) && !err)
+			 security_audit(GR_SHMR_AUDIT_MSG, shp->shm_perm.uid,
+					shp->shm_perm.cuid, DEFAULTSECARGS);
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
diff -urN linux/kernel/capability.c linux/kernel/capability.c
--- linux/kernel/capability.c	2000-06-24 00:06:37.000000000 -0400
+++ linux/kernel/capability.c	2002-08-31 11:24:08.000000000 -0400
@@ -7,6 +7,7 @@
 
 #include <linux/mm.h>
 #include <asm/uaccess.h>
+#include <linux/grsecurity.h>
 
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
 
@@ -188,6 +189,16 @@
              goto out;
      }
 
+     if(grsec_enable_chroot_caps && proc_is_chrooted(current) &&
+	!have_same_root(current,target)) {
+	     security_alert(GR_CAPSET_CHROOT_MSG, GR_CAPSET_CHROOT_FLD,
+			    target->comm, target->pid, 
+			    kdevname(current->fs->root->d_inode->i_dev), 
+			    current->fs->root->d_inode->i_ino,
+			    DEFAULTSECARGS);
+	     goto out;
+     }
+
      /* having verified that the proposed changes are legal,
            we now put them into effect. */
      error = 0;
diff -urN linux/kernel/exit.c linux/kernel/exit.c
--- linux/kernel/exit.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/exit.c	2002-08-31 11:24:08.000000000 -0400
@@ -16,6 +16,7 @@
 #ifdef CONFIG_BSD_PROCESS_ACCT
 #include <linux/acct.h>
 #endif
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -453,6 +454,9 @@
 #ifdef CONFIG_BSD_PROCESS_ACCT
 	acct_process(code);
 #endif
+	if (current->acl_admin && gr_acl_is_enabled()) 
+		gr_set_acls();
+
 	__exit_mm(tsk);
 
 	lock_kernel();
diff -urN linux/kernel/fork.c linux/kernel/fork.c
--- linux/kernel/fork.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/fork.c	2002-08-31 11:24:08.000000000 -0400
@@ -22,6 +22,7 @@
 #include <linux/namespace.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#include <linux/grsecurity.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -92,6 +93,25 @@
 	if (flags & CLONE_PID)
 		return current->pid;
 
+	if(grsec_enable_randpid && current->fs->root) {
+		spin_lock(&lastpid_lock);
+		pid = (ip_randomid() % PID_MAX) + 1;
+		read_lock(&tasklist_lock);
+		repeater:
+			for_each_task(p) {
+				if(p->pid == pid ||
+				   p->pgrp == pid ||
+				   p->tgid == pid ||
+				   p->session == pid) {
+					pid = (ip_randomid() % PID_MAX) + 1;
+					goto repeater;
+				}
+			}
+		read_unlock(&tasklist_lock);
+		spin_unlock(&lastpid_lock);
+		return pid;
+	}
+
 	spin_lock(&lastpid_lock);
 	beginpid = last_pid;
 	if((++last_pid) & 0xffff8000) {
@@ -609,6 +629,9 @@
 	 * friends to set the per-user process limit to something lower
 	 * than the amount of processes root is running. -- Rik
 	 */
+
+	gr_learn_resource(p, RLIMIT_NPROC, atomic_read(&p->user->processes));
+
 	if (atomic_read(&p->user->processes) >= p->rlim[RLIMIT_NPROC].rlim_cur
 	              && !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE))
 		goto bad_fork_free;
@@ -693,6 +716,7 @@
 	retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);
 	if (retval)
 		goto bad_fork_cleanup_namespace;
+	gr_copy_label(p);
 	p->semundo = NULL;
 	
 	/* Our parent execution domain becomes current domain
@@ -778,6 +802,10 @@
 	free_uid(p->user);
 bad_fork_free:
 	free_task_struct(p);
+
+	if(grsec_enable_forkfail)
+    		security_alert(GR_FAILFORK_MSG, GR_FAILFORK_FLD,
+                  	       retval, DEFAULTSECARGS);
 	goto fork_out;
 }
 
diff -urN linux/kernel/ksyms.c linux/kernel/ksyms.c
--- linux/kernel/ksyms.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/ksyms.c	2002-08-31 11:24:08.000000000 -0400
@@ -47,6 +47,7 @@
 #include <linux/in6.h>
 #include <linux/completion.h>
 #include <linux/seq_file.h>
+#include <linux/grsecurity.h>
 #include <asm/checksum.h>
 
 #if defined(CONFIG_PROC_FS)
@@ -570,3 +571,7 @@
 
 EXPORT_SYMBOL(tasklist_lock);
 EXPORT_SYMBOL(pidhash);
+
+EXPORT_SYMBOL(gr_is_capable);
+EXPORT_SYMBOL(gr_pid_is_chrooted);
+EXPORT_SYMBOL(gr_learn_resource);
diff -urN linux/kernel/printk.c linux/kernel/printk.c
--- linux/kernel/printk.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/printk.c	2002-08-31 11:24:08.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -294,7 +295,9 @@
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
-	if ((type != 3) && !capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) && grsec_enable_dmesg)
+		return -EPERM;
+	else if ((type != 3) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	return do_syslog(type, buf, len);
 }
diff -urN linux/kernel/sched.c linux/kernel/sched.c
--- linux/kernel/sched.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/sched.c	2002-08-31 11:24:08.000000000 -0400
@@ -29,6 +29,7 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -874,6 +875,12 @@
 			return -EPERM;
 		if (increment < -40)
 			increment = -40;
+
+		if(grsec_enable_chroot_nice && proc_is_chrooted(current)){
+			security_alert(GR_NICE_CHROOT_MSG, GR_NICE_CHROOT_FLD,
+				DEFAULTSECARGS);
+			return -EPERM;
+		}
 	}
 	if (increment > 40)
 		increment = 40;
diff -urN linux/kernel/signal.c linux/kernel/signal.c
--- linux/kernel/signal.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/signal.c	2002-08-31 11:24:08.000000000 -0400
@@ -13,6 +13,8 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -554,6 +556,20 @@
 	if (!sig || !t->sig)
 		goto out_nolock;
 
+	if(grsec_enable_signal && ((sig == SIGSEGV) || (sig == SIGILL) || 
+	   (sig == SIGABRT) || (sig == SIGBUS))) {
+		if(t->pid == current->pid) {
+			security_alert(GR_UNISIGLOG_MSG, GR_UNISIGLOG_FLD,
+					sig, DEFAULTSECARGS);
+		} else {
+			security_alert(GR_DUALSIGLOG_MSG, GR_DUALSIGLOG_FLD,
+			   		sig, t->comm, t->pid, t->uid, t->euid,
+					t->p_pptr->comm, t->p_pptr->pid,
+					t->p_pptr->uid, t->p_pptr->euid, 
+					DEFAULTSECARGS);
+		}
+	} 
+
 	spin_lock_irqsave(&t->sigmask_lock, flags);
 	handle_stop_signal(sig, t);
 
@@ -603,6 +619,8 @@
 	recalc_sigpending(t);
 	spin_unlock_irqrestore(&t->sigmask_lock, flags);
 
+	gr_handle_crash(t, sig);
+
 	return send_sig_info(sig, info, t);
 }
 
@@ -622,9 +640,19 @@
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
 			if (p->pgrp == pgrp && thread_group_leader(p)) {
-				int err = send_sig_info(sig, info, p);
-				if (retval)
-					retval = err;
+				if (current->pid > 1 && gr_check_protected_task(p)) {
+					security_alert(GR_SIG_ACL_MSG, GR_SIG_ACL_FLD,
+						sig, p->comm, p->pid, p->uid, p->euid,
+						p->p_pptr->comm, p->p_pptr->pid, p->p_pptr->uid,
+						p->p_pptr->euid, DEFAULTSECARGS);
+					retval = -EPERM;
+				} else if (gr_pid_is_chrooted(p)) {
+					retval = -EPERM;
+				} else {
+					int err = send_sig_info(sig, info, p);
+					if (retval)
+						retval = err;
+				}
 			}
 		}
 		read_unlock(&tasklist_lock);
@@ -675,7 +703,15 @@
                        if (tg)
                                p = tg;
                 }
-		error = send_sig_info(sig, info, p);
+		if (current->pid > 1 && gr_check_protected_task(p)) {
+			security_alert(GR_SIG_ACL_MSG, GR_SIG_ACL_FLD,
+				sig, p->comm, p->pid, p->uid, p->euid,
+				p->p_pptr->comm, p->p_pptr->pid, p->p_pptr->uid,
+				p->p_pptr->euid, DEFAULTSECARGS);
+			error = -EPERM;
+		} else {
+			error = send_sig_info(sig, info, p);
+		}
 	}
 	read_unlock(&tasklist_lock);
 	return error;
@@ -700,10 +736,20 @@
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
 			if (p->pid > 1 && p != current && thread_group_leader(p)) {
-				int err = send_sig_info(sig, info, p);
-				++count;
-				if (err != -EPERM)
-					retval = err;
+				if (current->pid > 1 && gr_check_protected_task(p)) {
+					security_alert(GR_SIG_ACL_MSG, GR_SIG_ACL_FLD,
+						sig, p->comm, p->pid, p->uid, p->euid,
+						p->p_pptr->comm, p->p_pptr->pid, p->p_pptr->uid,
+						p->p_pptr->euid, DEFAULTSECARGS);
+					retval = -EPERM;
+				} else if (gr_pid_is_chrooted(p)) {
+					retval = -EPERM;
+				} else {
+					int err = send_sig_info(sig, info, p);
+					++count;
+					if (err != -EPERM)
+						retval = err;
+				}
 			}
 		}
 		read_unlock(&tasklist_lock);
diff -urN linux/kernel/sys.c linux/kernel/sys.c
--- linux/kernel/sys.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/sys.c	2002-08-31 11:24:08.000000000 -0400
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/utsname.h>
@@ -14,6 +15,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -220,6 +222,14 @@
 		}
 		if (error == -ESRCH)
 			error = 0;
+
+		if(grsec_enable_chroot_nice && (!have_same_root(p,current)
+		   || (have_same_root(p,current) && (niceval < p->nice) && proc_is_chrooted(current)))) {
+			security_alert(GR_PRIORITY_CHROOT_MSG, GR_PRIORITY_CHROOT_FLD,
+					p->comm,p->pid,DEFAULTSECARGS);
+			return -ESRCH; /* be stealthy */
+		}
+
 		if (niceval < p->nice && !capable(CAP_SYS_NICE))
 			error = -EACCES;
 		else
@@ -607,6 +617,9 @@
 	} else if ((uid != current->uid) && (uid != new_suid))
 		return -EPERM;
 
+	if (gr_check_crash_uid(uid))
+		return -EPERM;
+
 	if (old_euid != uid)
 	{
 		current->mm->dumpable = 0;
diff -urN linux/kernel/sysctl.c linux/kernel/sysctl.c
--- linux/kernel/sysctl.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/sysctl.c	2002-08-31 13:10:58.000000000 -0400
@@ -38,6 +38,11 @@
 #endif
 
 #if defined(CONFIG_SYSCTL)
+#include <linux/grsecurity.h>
+
+extern int gr_proc_handler(ctl_table * table, int write, struct file * filp,
+				void * buffer, size_t * lenp);
+extern int gr_handle_sysctl(ctl_table * table, int mode);
 
 /* External variables not in a header file. */
 extern int panic_timeout;
@@ -118,6 +123,8 @@
 static ctl_table dev_table[];
 extern ctl_table random_table[];
 
+static ctl_table grsecurity_table[];
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_FS
@@ -256,8 +263,181 @@
 	{KERN_S390_USER_DEBUG_LOGGING,"userprocess_debug",
 	 &sysctl_userprocess_debug,sizeof(int),0644,NULL,&proc_dointvec},
 #endif
+#ifdef CONFIG_GRKERNSEC
+	{KERN_GRSECURITY, "grsecurity", NULL, 0, 0500, grsecurity_table},
+#endif
+	{0}
+};
+
+#ifdef CONFIG_GRKERNSEC
+enum {GS_ACL=1, GS_LINK, GS_FIFO, GS_EXECVE, GS_EXECLOG, GS_SIGNAL, 
+GS_FORKFAIL, GS_TIME, GS_CHROOT_MNT, GS_CHROOT_FCHDIR, 
+GS_CHROOT_DBL, GS_CHROOT_PVT, GS_CHROOT_CD, GS_CHROOT_CM, GS_CHROOT_MK, 
+GS_CHROOT_NI, GS_CHROOT_EXECLOG, GS_CHROOT_CAPS, GS_TPE, 
+GS_TPE_GID, GS_TPE_ALL, GS_SIDCAPS, GS_RANDPID, GS_RANDID, 
+GS_RANDSRC, GS_RANDPING, GS_SOCKET_ALL, GS_SOCKET_ALL_GID, GS_SOCKET_CLIENT, 
+GS_SOCKET_CLIENT_GID, GS_SOCKET_SERVER, GS_SOCKET_SERVER_GID, 
+GS_TTY, GS_TTYS, GS_PTY, GS_GROUP, GS_GID, GS_ACHDIR, GS_AMOUNT, GS_AIPC, 
+GS_DMSG, GS_RANDRPC, GS_FINDTASK, GS_LOCK};
+
+static ctl_table grsecurity_table[] = {
+	{GS_ACL,"acl", NULL, sizeof(int), 0600, NULL, &gr_proc_handler},
+#ifdef CONFIG_GRKERNSEC_SYSCTL
+#ifdef CONFIG_GRKERNSEC_LINK
+	{GS_LINK, "linking_restrictions", &grsec_enable_link, sizeof (int),
+	 0600, NULL, &proc_dointvec}, 
+#endif
+#ifdef CONFIG_GRKERNSEC_FIFO
+	{GS_FIFO, "fifo_restrictions", &grsec_enable_fifo, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECVE
+	{GS_EXECVE, "execve_limiting", &grsec_enable_execve, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_EXECLOG
+	{GS_EXECLOG, "exec_logging", &grsec_enable_execlog, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SIGNAL
+	{GS_SIGNAL, "signal_logging", &grsec_enable_signal, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_FORKFAIL
+	{GS_FORKFAIL, "forkfail_logging", &grsec_enable_forkfail, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TIME
+	{GS_TIME, "timechange_logging", &grsec_enable_time, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MOUNT
+	{GS_CHROOT_MNT, "chroot_deny_mount", &grsec_enable_chroot_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FCHDIR
+	{GS_CHROOT_FCHDIR, "chroot_deny_fchdir", &grsec_enable_chroot_fchdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_DOUBLE
+	{GS_CHROOT_DBL, "chroot_deny_chroot", &grsec_enable_chroot_double, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_PIVOT
+	{GS_CHROOT_PVT, "chroot_deny_pivot", &grsec_enable_chroot_pivot, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHDIR
+	{GS_CHROOT_CD, "chroot_deny_chdir", &grsec_enable_chroot_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CHMOD
+	{GS_CHROOT_CM, "chroot_deny_chmod", &grsec_enable_chroot_chmod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_MKNOD
+	{GS_CHROOT_MK, "chroot_deny_mknod", &grsec_enable_chroot_mknod, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_NICE
+	{GS_CHROOT_NI, "chroot_restrict_nice", &grsec_enable_chroot_nice, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_EXECLOG
+	{GS_CHROOT_EXECLOG, "chroot_execlog",
+	 &grsec_enable_chroot_execlog, sizeof (int),
+         0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
+	{GS_CHROOT_CAPS, "chroot_caps", &grsec_enable_chroot_caps, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE
+	{GS_TPE, "tpe", &grsec_enable_tpe, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_TPE_GID, "tpe_gid", &grsec_tpe_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_TPE_ALL
+	{GS_TPE_ALL, "tpe_restrict_all", &grsec_enable_tpe_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPID
+	{GS_RANDPID, "rand_pids", &grsec_enable_randpid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDID
+	{GS_RANDID, "rand_ip_ids", &grsec_enable_randid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDSRC
+	{GS_RANDSRC, "rand_tcp_src_ports", &grsec_enable_randsrc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDPING
+	{GS_RANDPING, "altered_pings", &grsec_enable_randping, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_ALL
+	{GS_SOCKET_ALL, "socket_all", &grsec_enable_socket_all, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_ALL_GID, "socket_all_gid",
+	 &grsec_socket_all_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_CLIENT
+	{GS_SOCKET_CLIENT, "socket_client", 
+	 &grsec_enable_socket_client, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_CLIENT_GID, "socket_client_gid", 
+	 &grsec_socket_client_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_SOCKET_SERVER
+	{GS_SOCKET_SERVER, "socket_server", 
+	 &grsec_enable_socket_server, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_SOCKET_SERVER_GID, "socket_server_gid",
+	 &grsec_socket_server_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_GROUP
+	{GS_GROUP, "audit_group", &grsec_enable_group, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+	{GS_GID, "audit_gid",
+	 &grsec_audit_gid, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_CHDIR
+	{GS_ACHDIR, "audit_chdir", &grsec_enable_chdir, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_MOUNT
+	{GS_AMOUNT, "audit_mount", &grsec_enable_mount, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_AUDIT_IPC
+	{GS_AIPC, "audit_ipc", &grsec_enable_audit_ipc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_DMESG
+	{GS_AIPC, "dmesg", &grsec_enable_dmesg, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_RANDRPC
+	{GS_RANDRPC, "rand_rpc", &grsec_enable_randrpc, sizeof (int),
+	 0600, NULL, &proc_dointvec},
+#endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_FINDTASK
+	{GS_FINDTASK, "chroot_findtask", &grsec_enable_chroot_findtask, 
+	 sizeof (int), 0600, NULL, &proc_dointvec},
+#endif
+	{GS_LOCK, "grsec_lock", &grsec_lock, sizeof (int), 0600, NULL,
+	 &proc_dointvec},
+#endif
 	{0}
 };
+#endif
 
 static ctl_table vm_table[] = {
 	{VM_BDFLUSH, "bdflush", &bdf_prm, 9*sizeof(int), 0644, NULL,
@@ -392,6 +572,15 @@
 
 static inline int ctl_perm(ctl_table *table, int op)
 {
+#ifdef CONFIG_GRKERNSEC
+	if(!strcmp(table->de->parent->name, "grsecurity") && grsec_lock 
+	   && (table->ctl_name != GS_ACL) && (op & 002)) {
+		security_alert(GR_SYSCTL_MSG, GR_SYSCTL_FLD,
+			       table->de->name, DEFAULTSECARGS);
+		return -EACCES;
+	}
+#endif
+
 	return test_perm(table->mode, op);
 }
 
@@ -409,6 +598,7 @@
 	for ( ; table->ctl_name; table++) {
 		if (n == table->ctl_name || table->ctl_name == CTL_ANY) {
 			int error;
+			int op = 0;
 			if (table->child) {
 				if (ctl_perm(table, 001))
 					return -EPERM;
@@ -425,6 +615,18 @@
 				table = table->child;
 				goto repeat;
 			}
+			if (oldval)
+				op |= GR_READ;
+			if (newval) 
+				op |= GR_WRITE;
+			if(!gr_handle_sysctl(table, op)) {
+				security_alert(GR_SYSCTL_ACL_MSG, GR_SYSCTL_ACL_FLD,
+						table->de->name, 
+						(op & GR_READ) ? " reading" : "",
+						(op & GR_WRITE) ? " writing" : "",
+						DEFAULTSECARGS);
+				return -EACCES;
+			}
 			error = do_sysctl_strategy(table, name, nlen,
 						   oldval, oldlenp,
 						   newval, newlen, context);
diff -urN linux/kernel/time.c linux/kernel/time.c
--- linux/kernel/time.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/time.c	2002-08-31 11:24:08.000000000 -0400
@@ -27,6 +27,7 @@
 #include <linux/mm.h>
 #include <linux/timex.h>
 #include <linux/smp_lock.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 
@@ -87,6 +88,10 @@
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
 	write_unlock_irq(&xtime_lock);
+
+	if(grsec_enable_time)
+		security_alert(GR_TIME_MSG, GR_TIME_FLD, DEFAULTSECARGS);
+
 	return 0;
 }
 
@@ -163,6 +168,9 @@
 		 * globally block out interrupts when it runs.
 		 */
 		do_settimeofday(tv);
+
+		if(grsec_enable_time)
+			security_alert(GR_TIME_MSG, GR_TIME_FLD, DEFAULTSECARGS);
 	}
 	return 0;
 }
diff -urN linux/kernel/timer.c linux/kernel/timer.c
--- linux/kernel/timer.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/kernel/timer.c	2002-08-31 11:24:08.000000000 -0400
@@ -541,6 +541,9 @@
 
 	psecs = (p->times.tms_utime += user);
 	psecs += (p->times.tms_stime += system);
+
+	gr_learn_resource(p, RLIMIT_CPU, psecs / HZ);
+
 	if (psecs / HZ > p->rlim[RLIMIT_CPU].rlim_cur) {
 		/* Send SIGXCPU every second.. */
 		if (!(psecs % HZ))
diff -urN linux/mm/filemap.c linux/mm/filemap.c
--- linux/mm/filemap.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/mm/filemap.c	2002-08-31 11:24:08.000000000 -0400
@@ -2456,6 +2456,7 @@
 	error = -EIO;
 	rlim_rss = current->rlim ?  current->rlim[RLIMIT_RSS].rlim_cur :
 				LONG_MAX; /* default: see resource.h */
+	gr_learn_resource(current, RLIMIT_RSS, vma->vm_mm->rss + (end - start));
 	if ((vma->vm_mm->rss + (end - start)) > rlim_rss)
 		return error;
 
@@ -2959,6 +2960,7 @@
 	err = -EFBIG;
 	
 	if (!S_ISBLK(inode->i_mode) && limit != RLIM_INFINITY) {
+		gr_learn_resource(current, RLIMIT_FSIZE, pos);
 		if (pos >= limit) {
 			send_sig(SIGXFSZ, current, 0);
 			goto out;
@@ -2994,6 +2996,7 @@
 	 */
 	 
 	if (!S_ISBLK(inode->i_mode)) {
+		gr_learn_resource(current, RLIMIT_FSIZE, count + (u32)pos);
 		if (pos >= inode->i_sb->s_maxbytes)
 		{
 			if (count || pos > inode->i_sb->s_maxbytes) {
diff -urN linux/mm/memory.c linux/mm/memory.c
--- linux/mm/memory.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/mm/memory.c	2002-08-31 11:24:08.000000000 -0400
@@ -1066,6 +1066,7 @@
 
 do_expand:
 	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	gr_learn_resource(current, RLIMIT_FSIZE, offset);
 	if (limit != RLIM_INFINITY && offset > limit)
 		goto out_sig;
 	if (offset > inode->i_sb->s_maxbytes)
@@ -1368,6 +1369,40 @@
 	pgd_t *pgd;
 	pmd_t *pmd;
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	unsigned long address_m = 0UL;
+	struct vm_area_struct * vma_m = NULL;
+
+	if (vma->vm_flags & VM_MIRRORED) {
+		address_m = vma->vm_start + TASK_SIZE/2;
+		vma_m = find_vma(mm, address_m);
+		if (!vma_m || !(vma_m->vm_flags & VM_MIRROR) ||
+		    vma_m->vm_start != address_m ||
+		    vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			printk(KERN_ERR "VMMIRROR: %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return 0;
+		}
+		vma = vma_m;
+		address += TASK_SIZE/2;
+	}
+
+	if (vma->vm_flags & VM_MIRROR) {
+		address_m = vma->vm_start - TASK_SIZE/2;
+		vma_m = find_vma(mm, address_m);
+		if (!vma_m || !(vma_m->vm_flags & VM_MIRRORED) ||
+		    vma_m->vm_start != address_m ||
+		    vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			printk(KERN_ERR "VMMIRROR: %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return 0;
+		}
+		address_m += address - vma->vm_start;
+	}			
+#endif
+
 	current->state = TASK_RUNNING;
 	pgd = pgd_offset(mm, address);
 
@@ -1380,6 +1415,59 @@
 
 	if (pmd) {
 		pte_t * pte = pte_alloc(mm, pmd, address);
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR && pte) {
+			pgd_t *pgd_m;
+			pmd_t *pmd_m;
+			pte_t *pte_m, entry = *pte;
+			int error;
+
+			pgd_m = pgd_offset(mm, address_m);
+			pmd_m = pmd_alloc(mm, pgd_m, address_m);
+
+			if (!pmd_m) {
+				spin_unlock(&mm->page_table_lock);
+				return -1;
+			}
+
+			pte_m = pte_alloc(mm, pmd_m, address_m);
+
+			if (!pte_m) {
+				spin_unlock(&mm->page_table_lock);
+				return -1;
+			}
+
+			error = handle_pte_fault(mm, vma_m, address_m, write_access, pte_m);
+
+			switch (error) {
+			case 1:
+			case 2:
+				spin_lock(&mm->page_table_lock);
+				if (pte_same(entry, *pte) && pte_present(*pte_m)) {
+					struct page * page_m = pte_page(*pte_m);
+
+					page_cache_get(page_m);
+					if (pte_none(entry)) {
+					} else if (pte_present(entry)) {
+						flush_cache_page(vma, address);
+						page_cache_release(pte_page(entry));
+					} else {
+						free_swap_and_cache(pte_to_swp_entry(entry));
+					}
+					entry = mk_pte(page_m, vma->vm_page_prot);
+					if (pte_write(*pte_m))
+						entry = pte_mkdirty(pte_mkwrite(entry));
+					else
+						entry = pte_wrprotect(entry);
+					establish_pte(vma, address, pte, entry);
+				}
+				spin_unlock(&mm->page_table_lock);
+			}
+			return error;
+		}
+#endif
+
 		if (pte)
 			return handle_pte_fault(mm, vma, address, write_access, pte);
 	}
diff -urN linux/mm/mlock.c linux/mm/mlock.c
--- linux/mm/mlock.c	2001-09-17 18:30:23.000000000 -0400
+++ linux/mm/mlock.c	2002-08-31 11:24:08.000000000 -0400
@@ -209,6 +209,7 @@
 	lock_limit >>= PAGE_SHIFT;
 
 	/* check against resource limits */
+	gr_learn_resource(current, RLIMIT_MEMLOCK, locked);
 	if (locked > lock_limit)
 		goto out;
 
@@ -276,6 +277,7 @@
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
+	gr_learn_resource(current, RLIMIT_MEMLOCK, current->mm->total_vm);
 	if (current->mm->total_vm > lock_limit)
 		goto out;
 
diff -urN linux/mm/mmap.c linux/mm/mmap.c
--- linux/mm/mmap.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/mm/mmap.c	2002-08-31 11:24:08.000000000 -0400
@@ -14,6 +14,8 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/personality.h>
+#include <linux/random.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -168,6 +170,7 @@
 
 	/* Check against rlimit.. */
 	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	gr_learn_resource(current, RLIMIT_DATA, brk - mm->start_data);
 	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
 		goto out;
 
@@ -205,6 +208,11 @@
 		_trans(prot, PROT_WRITE, VM_WRITE) |
 		_trans(prot, PROT_EXEC, VM_EXEC);
 	flag_bits =
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+		_trans(flags, MAP_MIRROR, VM_MIRROR) |
+#endif
+
 		_trans(flags, MAP_GROWSDOWN, VM_GROWSDOWN) |
 		_trans(flags, MAP_DENYWRITE, VM_DENYWRITE) |
 		_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE);
@@ -400,6 +408,26 @@
 	int error;
 	rb_node_t ** rb_link, * rb_parent;
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+	
+	if (flags & MAP_MIRROR) {
+		if (file || len || ((flags & MAP_TYPE) != MAP_PRIVATE))
+			return -EINVAL;
+
+		vma_m = find_vma(mm, pgoff);
+
+		if (!vma_m ||
+		    vma_m->vm_start != pgoff ||
+		    (vma_m->vm_flags & (VM_MIRROR | VM_MIRRORED)) ||
+		    (!(vma_m->vm_flags & VM_WRITE) && (prot & PROT_WRITE)))
+			return -EINVAL;
+
+		pgoff = 0UL;
+		len = vma_m->vm_end - vma_m->vm_start;
+	}
+#endif
+
 	if (file && (!file->f_op || !file->f_op->mmap))
 		return -ENODEV;
 
@@ -430,10 +458,43 @@
 	 */
 	vm_flags = calc_vm_flags(prot,flags) | mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (current->flags & PF_PAX_PAGEEXEC) {
+		if (!file)
+			vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+		if ((current->flags & PF_PAX_MPROTECT) && (!file || !(prot & PROT_EXEC)))
+			vm_flags &= ~VM_MAYEXEC;
+
+		if ((current->flags & PF_PAX_MPROTECT) && (flags & MAP_EXECUTABLE) && (prot & PROT_EXEC))
+			vm_flags &= ~VM_MAYWRITE;
+#endif
+
+	}
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if (current->flags & PF_PAX_SEGMEXEC) {
+		if (!file && !(flags & MAP_MIRROR))
+			vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	if ((current->flags & PF_PAX_MPROTECT) && ((!file && !(flags & MAP_MIRROR)) || !(prot & PROT_EXEC)))
+		vm_flags &= ~VM_MAYEXEC;
+
+	if ((current->flags & PF_PAX_MPROTECT) && (flags & MAP_EXECUTABLE) && (prot & PROT_EXEC))
+		vm_flags &= ~VM_MAYWRITE;
+#endif
+
+	}
+#endif
+
 	/* mlock MCL_FUTURE? */
 	if (vm_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
 		locked += len;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			return -EAGAIN;
 	}
@@ -477,6 +538,18 @@
 			break;
 		}
 	}
+	if(file && (!gr_tpe_allow(file) || !gr_tpe_all_allow(file) || 
+	  !gr_search_file(file->f_dentry,GR_EXEC,file->f_vfsmnt))) {
+		if(prot & PROT_EXEC) {
+			security_alert(GR_MMAP_ACL_MSG, GR_MMAP_ACL_FLD,
+					kdevname(file->f_dentry->d_inode->i_dev),
+					file->f_dentry->d_inode->i_ino,
+					file->f_dentry->d_name.name,
+					DEFAULTSECARGS);
+			return -EACCES;
+		} else
+			vm_flags &= ~VM_MAYEXEC;
+	}
 
 	/* Clear old maps */
 munmap_back:
@@ -488,6 +561,7 @@
 	}
 
 	/* Check against address space limit. */
+	gr_learn_resource(current, RLIMIT_AS, (mm->total_vm << PAGE_SHIFT) + len);
 	if ((mm->total_vm << PAGE_SHIFT) + len
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
@@ -515,6 +589,12 @@
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = vm_flags;
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (!(current->flags & PF_PAX_PAGEEXEC) && (vm_flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & 0x0f];
+	else
+#endif
 	vma->vm_page_prot = protection_map[vm_flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = pgoff;
@@ -543,6 +623,11 @@
 			goto free_vma;
 	}
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR)
+		vma_m->vm_flags |= VM_MIRRORED;
+#endif
+
 	/* Can addr have changed??
 	 *
 	 * Answer: Yes, several device drivers can do it in their
@@ -614,20 +699,45 @@
 {
 	struct vm_area_struct *vma;
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((current->flags & PF_PAX_SEGMEXEC) && len > TASK_SIZE/2)
+		return -ENOMEM;
+	else
+#endif
+
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current->mm, addr);
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+		if ((current->flags & PF_PAX_SEGMEXEC) && TASK_SIZE/2-len < addr)		
+			return -ENOMEM;
+#endif
+
 		if (TASK_SIZE - len >= addr &&
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
 	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE);
 
+#ifdef CONFIG_GRKERNSEC_PAX_RANDMMAP
+	/* PaX: randomize base address if requested */
+	if (current->flags & PF_PAX_RANDMMAP)
+		addr += current->mm->delta_mmap;
+#endif
+
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+		if ((current->flags & PF_PAX_SEGMEXEC) && TASK_SIZE/2-len < addr)
+			return -ENOMEM;
+		else
+#endif
+
 		if (TASK_SIZE - len < addr)
 			return -ENOMEM;
 		if (!vma || addr + len <= vma->vm_start)
@@ -1015,7 +1125,23 @@
 	struct mm_struct *mm = current->mm;
 
 	down_write(&mm->mmap_sem);
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((current->flags & PF_PAX_SEGMEXEC) &&
+	    (len > TASK_SIZE/2 || addr > TASK_SIZE/2-len))
+		return -EINVAL;
+
 	ret = do_munmap(mm, addr, len);
+
+	if ((current->flags & PF_PAX_SEGMEXEC) && !ret) {
+		int ret_m = do_munmap(mm, addr + TASK_SIZE/2, len);
+		if (ret_m)
+			ret = ret_m;
+	}
+#else
+	ret = do_munmap(mm, addr, len);
+#endif
+
 	up_write(&mm->mmap_sem);
 	return ret;
 }
@@ -1042,6 +1168,7 @@
 	if (mm->def_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
 		locked += len;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			return -EAGAIN;
 	}
@@ -1058,6 +1185,7 @@
 	}
 
 	/* Check against address space limits *after* clearing old maps... */
+	gr_learn_resource(current, RLIMIT_AS, (mm->total_vm << PAGE_SHIFT) + len);
 	if ((mm->total_vm << PAGE_SHIFT) + len
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
@@ -1070,6 +1198,16 @@
 
 	flags = VM_DATA_DEFAULT_FLAGS | mm->def_flags;
 
+#if defined(CONFIG_GRKERNSEC_PAX_PAGEEXEC) || defined(CONFIG_GRKERNSEC_PAX_SEGMEXEC)
+	if (current->flags & (PF_PAX_PAGEEXEC|PF_PAX_SEGMEXEC))
+		flags &= ~VM_EXEC;
+#endif
+
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+	if (current->flags & PF_PAX_MPROTECT)
+		flags &= ~VM_MAYEXEC;
+#endif
+
 	/* Can we just expand an old anonymous mapping? */
 	if (rb_parent && vma_merge(mm, prev, rb_parent, addr, addr + len, flags))
 		goto out;
@@ -1085,6 +1223,12 @@
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = flags;
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (!(current->flags & PF_PAX_PAGEEXEC) && (flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(flags | VM_EXEC) & 0x0f];
+	else
+#endif
 	vma->vm_page_prot = protection_map[flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = 0;
diff -urN linux/mm/mprotect.c linux/mm/mprotect.c
--- linux/mm/mprotect.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/mm/mprotect.c	2002-08-31 11:24:08.000000000 -0400
@@ -246,7 +246,14 @@
 		*pprev = vma;
 		return 0;
 	}
+
+#ifdef CONFIG_GRKERNSEC_PAX_PAGEEXEC
+	if (!(current->flags & PF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+		newprot = protection_map[(newflags | VM_EXEC) & 0xf];
+	else
+#else
 	newprot = protection_map[newflags & 0xf];
+#endif
 	if (start == vma->vm_start) {
 		if (end == vma->vm_end)
 			error = mprotect_fixup_all(vma, pprev, newflags, newprot);
@@ -264,7 +271,33 @@
 	return 0;
 }
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+static long __sys_mprotect(unsigned long start, size_t len, unsigned long prot);
+
+asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
+{
+	int error;
+
+	if ((current->flags & PF_PAX_SEGMEXEC) &&
+	    (len > TASK_SIZE/2 || start > TASK_SIZE/2-len))
+		return -EINVAL;
+
+	down_write(&current->mm->mmap_sem);
+	error = __sys_mprotect(start, len, prot);
+	if ((current->flags & PF_PAX_SEGMEXEC) && !error) {
+		if (prot & PROT_EXEC)
+			error = __sys_mprotect(start+TASK_SIZE/2, len, prot);
+		else
+			error = __sys_mprotect(start+TASK_SIZE/2, len, PROT_NONE);
+	}
+	up_write(&current->mm->mmap_sem);
+	return error;
+}
+
+static long __sys_mprotect(unsigned long start, size_t len, unsigned long prot)
+#else
 asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
+#endif
 {
 	unsigned long nstart, end, tmp;
 	struct vm_area_struct * vma, * next, * prev;
@@ -281,7 +314,9 @@
 	if (end == start)
 		return 0;
 
+#ifndef CONFIG_GRKERNSEC_PAX_SEGMEXEC
 	down_write(&current->mm->mmap_sem);
+#endif
 
 	vma = find_vma_prev(current->mm, start, &prev);
 	error = -ENOMEM;
@@ -300,6 +335,12 @@
 			goto out;
 		}
 
+#ifdef CONFIG_GRKERNSEC_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((current->flags & PF_PAX_MPROTECT) && (prot & PROT_WRITE) && (vma->vm_flags & VM_MAYEXEC)) {
+			newflags &= ~VM_MAYWRITE;
+		}
+#endif
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
@@ -332,6 +373,10 @@
 		prev->vm_mm->map_count--;
 	}
 out:
+
+#ifndef CONFIG_GRKERNSEC_PAX_SEGMEXEC
 	up_write(&current->mm->mmap_sem);
+#endif
+
 	return error;
 }
diff -urN linux/mm/mremap.c linux/mm/mremap.c
--- linux/mm/mremap.c	2001-09-20 23:31:26.000000000 -0400
+++ linux/mm/mremap.c	2002-08-31 11:24:08.000000000 -0400
@@ -227,6 +227,12 @@
 	old_len = PAGE_ALIGN(old_len);
 	new_len = PAGE_ALIGN(new_len);
 
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((current->flags & PF_PAX_SEGMEXEC) && (flags & MREMAP_FIXED) &&
+	    (new_len > TASK_SIZE/2 || new_addr > TASK_SIZE/2-new_len))
+		goto out;
+#endif
+
 	/* new_addr is only valid if MREMAP_FIXED is specified */
 	if (flags & MREMAP_FIXED) {
 		if (new_addr & ~PAGE_MASK)
@@ -267,6 +273,12 @@
 	vma = find_vma(current->mm, addr);
 	if (!vma || vma->vm_start > addr)
 		goto out;
+
+#ifdef CONFIG_GRKERNSEC_PAX_SEGMEXEC
+	if ((current->flags & PF_PAX_SEGMEXEC) && (vma->vm_flags & VM_MIRRORED))
+		return -EINVAL;
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
@@ -278,10 +290,12 @@
 		unsigned long locked = current->mm->locked_vm << PAGE_SHIFT;
 		locked += new_len - old_len;
 		ret = -EAGAIN;
+		gr_learn_resource(current, RLIMIT_MEMLOCK, locked);
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			goto out;
 	}
 	ret = -ENOMEM;
+	gr_learn_resource(current, RLIMIT_AS, (current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len));
 	if ((current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len)
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		goto out;
diff -urN linux/mm/shmem.c linux/mm/shmem.c
--- linux/mm/shmem.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/mm/shmem.c	2002-08-31 11:24:08.000000000 -0400
@@ -816,6 +816,8 @@
 	 */
 	err = -EFBIG;
 	if (limit != RLIM_INFINITY) {
+		gr_learn_resource(current, RLIMIT_FSIZE, pos);
+
 		if (pos >= limit) {
 			send_sig(SIGXFSZ, current, 0);
 			goto out;
diff -urN linux/net/ipv4/af_inet.c linux/net/ipv4/af_inet.c
--- linux/net/ipv4/af_inet.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/af_inet.c	2002-08-31 11:24:08.000000000 -0400
@@ -83,6 +83,7 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/grsecurity.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -374,7 +375,10 @@
 	else
 		sk->protinfo.af_inet.pmtudisc = IP_PMTUDISC_WANT;
 
-	sk->protinfo.af_inet.id = 0;
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = 0;
 
 	sock_init_data(sock,sk);
 
diff -urN linux/net/ipv4/icmp.c linux/net/ipv4/icmp.c
--- linux/net/ipv4/icmp.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/icmp.c	2002-08-31 11:24:08.000000000 -0400
@@ -87,6 +87,7 @@
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/grsecurity.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <net/checksum.h>
@@ -742,6 +743,10 @@
 
 		icmp_param.data.icmph=*skb->h.icmph;
 		icmp_param.data.icmph.type=ICMP_ECHOREPLY;
+
+		if(grsec_enable_randping)
+			icmp_param.data.icmph.un.echo.id = skb->h.icmph->un.echo.id;
+
 		icmp_param.skb=skb;
 		icmp_param.offset=0;
 		icmp_param.data_len=skb->len;
diff -urN linux/net/ipv4/ip_output.c linux/net/ipv4/ip_output.c
--- linux/net/ipv4/ip_output.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/ip_output.c	2002-08-31 11:24:08.000000000 -0400
@@ -77,6 +77,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/mroute.h>
 #include <linux/netlink.h>
+#include <linux/grsecurity.h>
 
 /*
  *      Shall we try to damage output packets if routing dev changes?
@@ -511,7 +512,11 @@
 	 *	Begin outputting the bytes.
 	 */
 
-	id = sk->protinfo.af_inet.id++;
+	if(grsec_enable_randid) { 
+		id = htons(ip_randomid());	
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	} else
+		id = sk->protinfo.af_inet.id++;
 
 	do {
 		char *data;
diff -urN linux/net/ipv4/netfilter/Config.in linux/net/ipv4/netfilter/Config.in
--- linux/net/ipv4/netfilter/Config.in	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/netfilter/Config.in	2002-08-31 11:24:08.000000000 -0400
@@ -25,6 +25,7 @@
   dep_tristate '  LENGTH match support' CONFIG_IP_NF_MATCH_LENGTH $CONFIG_IP_NF_IPTABLES
   dep_tristate '  TTL match support' CONFIG_IP_NF_MATCH_TTL $CONFIG_IP_NF_IPTABLES
   dep_tristate '  tcpmss match support' CONFIG_IP_NF_MATCH_TCPMSS $CONFIG_IP_NF_IPTABLES
+  dep_tristate '  stealth match support' CONFIG_IP_NF_MATCH_STEALTH $CONFIG_IP_NF_IPTABLES
   if [ "$CONFIG_IP_NF_CONNTRACK" != "n" ]; then
     dep_tristate '  Connection state match support' CONFIG_IP_NF_MATCH_STATE $CONFIG_IP_NF_CONNTRACK $CONFIG_IP_NF_IPTABLES 
   fi
diff -urN linux/net/ipv4/netfilter/Makefile linux/net/ipv4/netfilter/Makefile
--- linux/net/ipv4/netfilter/Makefile	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/netfilter/Makefile	2002-08-31 11:24:08.000000000 -0400
@@ -62,6 +62,7 @@
 obj-$(CONFIG_IP_NF_MATCH_STATE) += ipt_state.o
 obj-$(CONFIG_IP_NF_MATCH_UNCLEAN) += ipt_unclean.o
 obj-$(CONFIG_IP_NF_MATCH_TCPMSS) += ipt_tcpmss.o
+obj-$(CONFIG_IP_NF_MATCH_STEALTH) += ipt_stealth.o
 
 # targets
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
diff -urN linux/net/ipv4/netfilter/ipt_stealth.c linux/net/ipv4/netfilter/ipt_stealth.c
--- linux/net/ipv4/netfilter/ipt_stealth.c	1969-12-31 19:00:00.000000000 -0500
+++ linux/net/ipv4/netfilter/ipt_stealth.c	2002-08-31 11:24:08.000000000 -0400
@@ -0,0 +1,107 @@
+/* Kernel module to add stealth support.
+ *
+ * Copyright (C) 2002 Brad Spengler  <spender@grsecurity.net>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/inet.h>
+#include <linux/stddef.h>
+
+#include <net/ip.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+MODULE_LICENSE("GPL");
+
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const void *matchinfo,
+      int offset,
+      const void *hdr,
+      u_int16_t datalen,
+      int *hotdrop)
+{
+	struct iphdr *ip = skb->nh.iph;
+	struct tcphdr *th = (struct tcphdr *) hdr;
+	struct udphdr *uh = (struct udphdr *) hdr;
+	struct sock *sk = NULL;
+
+	if (!ip || !hdr || offset) return 0;
+
+	switch(ip->protocol) {
+	case IPPROTO_TCP:
+		if (datalen < sizeof(struct tcphdr)) {
+			*hotdrop = 1;
+			return 0;
+		}
+		if (!(th->syn && !th->ack)) return 0;
+		sk = tcp_v4_lookup_listener(ip->daddr, ntohs(th->dest), ((struct rtable*)skb->dst)->rt_iif);	
+		break;
+	case IPPROTO_UDP:
+		if (datalen < sizeof(struct udphdr)) {
+			*hotdrop = 1;
+			return 0;
+		}
+		sk = udp_v4_lookup(ip->saddr, uh->source, ip->daddr, uh->dest, skb->dev->ifindex);
+		break;
+	default:
+		return 0;
+	}
+
+	if(!sk) // port is being listened on, match this
+		return 1;
+	else
+		return 0;
+}
+
+/* Called when user tries to insert an entry of this type. */
+static int
+checkentry(const char *tablename,
+           const struct ipt_ip *ip,
+           void *matchinfo,
+           unsigned int matchsize,
+           unsigned int hook_mask)
+{
+        if (matchsize != IPT_ALIGN(0))
+                return 0;
+
+	if(((ip->proto == IPPROTO_TCP && !(ip->invflags & IPT_INV_PROTO)) ||
+		((ip->proto == IPPROTO_UDP) && !(ip->invflags & IPT_INV_PROTO)))
+		&& (hook_mask & (1 << NF_IP_LOCAL_IN)))
+			return 1;
+
+	printk("stealth: Only works on TCP and UDP for the INPUT chain.\n");
+
+        return 0;
+}
+
+
+static struct ipt_match stealth_match
+= { { NULL, NULL }, "stealth", &match, &checkentry, NULL, THIS_MODULE };
+
+static int __init init(void)
+{
+	return ipt_register_match(&stealth_match);
+}
+
+static void __exit fini(void)
+{
+	ipt_unregister_match(&stealth_match);
+}
+
+module_init(init);
+module_exit(fini);
diff -urN linux/net/ipv4/tcp_ipv4.c linux/net/ipv4/tcp_ipv4.c
--- linux/net/ipv4/tcp_ipv4.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/tcp_ipv4.c	2002-08-31 11:24:08.000000000 -0400
@@ -62,6 +62,7 @@
 #include <linux/inet.h>
 #include <linux/stddef.h>
 #include <linux/ipsec.h>
+#include <linux/grsecurity.h>
 
 extern int sysctl_ip_dynaddr;
 extern int sysctl_ip_default_ttl;
@@ -214,9 +215,15 @@
 
 		spin_lock(&tcp_portalloc_lock);
 		rover = tcp_port_rover;
-		do {	rover++;
-			if ((rover < low) || (rover > high))
-				rover = low;
+                do {
+			if(grsec_enable_randsrc && (high > low)) {
+				rover = low + (ip_randomid() % (high - low));
+			} else {
+				rover++;
+				if ((rover < low) || (rover > high))
+					rover = low;
+			}
+
 			head = &tcp_bhash[tcp_bhashfn(rover)];
 			spin_lock(&head->lock);
 			for (tb = head->chain; tb; tb = tb->next)
@@ -836,7 +843,10 @@
 		tp->write_seq = secure_tcp_sequence_number(sk->saddr, sk->daddr,
 							   sk->sport, usin->sin_port);
 
-	sk->protinfo.af_inet.id = tp->write_seq^jiffies;
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = tp->write_seq^jiffies;
 
 	err = tcp_connect(sk);
 	if (err)
@@ -1561,7 +1571,11 @@
 	newtp->ext_header_len = 0;
 	if (newsk->protinfo.af_inet.opt)
 		newtp->ext_header_len = newsk->protinfo.af_inet.opt->optlen;
-	newsk->protinfo.af_inet.id = newtp->write_seq^jiffies;
+
+	if(grsec_enable_randid)
+		newsk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		newsk->protinfo.af_inet.id = newtp->write_seq^jiffies;
 
 	tcp_sync_mss(newsk, dst->pmtu);
 	newtp->advmss = dst->advmss;
diff -urN linux/net/ipv4/udp.c linux/net/ipv4/udp.c
--- linux/net/ipv4/udp.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/ipv4/udp.c	2002-08-31 11:24:08.000000000 -0400
@@ -87,6 +87,7 @@
 #include <net/ip.h>
 #include <net/protocol.h>
 #include <linux/skbuff.h>
+#include <linux/grsecurity.h>
 #include <net/sock.h>
 #include <net/udp.h>
 #include <net/icmp.h>
@@ -748,7 +749,11 @@
 	sk->daddr = rt->rt_dst;
 	sk->dport = usin->sin_port;
 	sk->state = TCP_ESTABLISHED;
-	sk->protinfo.af_inet.id = jiffies;
+
+	if(grsec_enable_randid)
+		sk->protinfo.af_inet.id = htons(ip_randomid());
+	else
+		sk->protinfo.af_inet.id = jiffies;
 
 	sk_dst_set(sk, &rt->u.dst);
 	return(0);
diff -urN linux/net/netsyms.c linux/net/netsyms.c
--- linux/net/netsyms.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/netsyms.c	2002-08-31 11:24:08.000000000 -0400
@@ -24,6 +24,7 @@
 #include <net/checksum.h>
 #include <linux/etherdevice.h>
 #include <net/route.h>
+#include <linux/grsecurity.h>
 #ifdef CONFIG_HIPPI
 #include <linux/hippidevice.h>
 #endif
@@ -588,4 +589,17 @@
 EXPORT_SYMBOL(net_call_rx_atomic);
 EXPORT_SYMBOL(softnet_data);
 
+#if defined(CONFIG_IP_NF_MATCH_STEALTH_MODULE)
+#if !defined (CONFIG_IPV6_MODULE) && !defined (CONFIG_KHTTPD) && !defined (CONFIG_KHTTPD_MODULE)
+EXPORT_SYMBOL(tcp_v4_lookup_listener);
+#endif
+extern struct sock *udp_v4_lookup(u32 saddr, u16 sport, u32 daddr, u16 dport, int dif);
+EXPORT_SYMBOL(udp_v4_lookup);
+#endif
+
+EXPORT_SYMBOL(ip_randomid);
+EXPORT_SYMBOL(grsec_enable_randid);
+EXPORT_SYMBOL(grsec_enable_randsrc);
+EXPORT_SYMBOL(grsec_enable_randrpc);
+
 #endif  /* CONFIG_NET */
diff -urN linux/net/socket.c linux/net/socket.c
--- linux/net/socket.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/socket.c	2002-08-31 11:24:08.000000000 -0400
@@ -84,6 +84,8 @@
 #include <net/sock.h>
 #include <net/scm.h>
 #include <linux/netfilter.h>
+#include <linux/grsecurity.h>
+
 
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_read(struct file *file, char *buf,
@@ -902,6 +904,21 @@
 	int retval;
 	struct socket *sock;
 
+	if(!gr_search_socket(family, type, protocol)) {
+		security_alert(GR_SOCK_MSG, GR_SOCK_FLD,
+				family, type, protocol, DEFAULTSECARGS);
+		retval = -EACCES;
+		goto out;
+	}
+
+	if(grsec_enable_socket_all && (in_group_p(grsec_socket_all_gid)) 
+	   && (family != AF_UNIX) && (family != AF_LOCAL)) {
+		security_alert(GR_SOCK_MSG, GR_SOCK_FLD,
+				family, type, protocol, DEFAULTSECARGS);
+		retval = -EACCES;
+		goto out;
+	}
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
@@ -997,12 +1014,28 @@
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr * sck;
 	int err;
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
-		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
+		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+			sck = (struct sockaddr *) address;
+
+			if(!gr_search_connectbind(GR_BIND, sock, (struct sockaddr_in *) sck)) {
+				sockfd_put(sock);
+				return -EACCES;
+			}
+
+			if(grsec_enable_socket_server && (in_group_p(grsec_socket_server_gid))
+	   		   && sck && (sck->sa_family != AF_UNIX) && (sck->sa_family != AF_LOCAL)){
+				security_alert(GR_BIND_MSG, GR_BIND_FLD, DEFAULTSECARGS);
+				sockfd_put(sock);
+				return -EACCES;
+			}
+
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
+		}
 		sockfd_put(sock);
 	}			
 	return err;
@@ -1105,6 +1138,7 @@
 {
 	struct socket *sock;
 	char address[MAX_SOCK_ADDR];
+	struct sockaddr * sck;
 	int err;
 
 	sock = sockfd_lookup(fd, &err);
@@ -1113,6 +1147,22 @@
 	err = move_addr_to_kernel(uservaddr, addrlen, address);
 	if (err < 0)
 		goto out_put;
+
+	sck = (struct sockaddr *) address;
+
+	if(!gr_search_connectbind(GR_CONNECT, sock, (struct sockaddr_in *) sck)) {
+		err = -EACCES;
+		goto out_put;
+	}
+		
+	if(grsec_enable_socket_client && (in_group_p(grsec_socket_client_gid))
+	   && sck && (sck->sa_family != AF_UNIX) 
+	   && (sck->sa_family != AF_LOCAL)){
+		security_alert(GR_CONNECT_MSG, GR_CONNECT_FLD, fd, DEFAULTSECARGS);
+		err = -EACCES;
+		goto out_put;
+	}
+
 	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
 				 sock->file->f_flags);
 out_put:
diff -urN linux/net/sunrpc/xprt.c linux/net/sunrpc/xprt.c
--- linux/net/sunrpc/xprt.c	2002-08-02 20:39:46.000000000 -0400
+++ linux/net/sunrpc/xprt.c	2002-08-31 11:24:08.000000000 -0400
@@ -59,6 +59,7 @@
 #include <linux/unistd.h>
 #include <linux/sunrpc/clnt.h>
 #include <linux/file.h>
+#include <linux/grsecurity.h>
 
 #include <net/sock.h>
 #include <net/checksum.h>
@@ -1241,7 +1242,13 @@
 	req->rq_timeout = xprt->timeout;
 	req->rq_task	= task;
 	req->rq_xprt    = xprt;
-	req->rq_xid     = xid++;
+
+	if(grsec_enable_randrpc) {
+		req->rq_xid = ip_randomid();
+		req->rq_xid = (req->rq_xid << 16) | ip_randomid();
+	} else
+		req->rq_xid = xid++;
+
 	if (!xid)
 		xid++;
 }
